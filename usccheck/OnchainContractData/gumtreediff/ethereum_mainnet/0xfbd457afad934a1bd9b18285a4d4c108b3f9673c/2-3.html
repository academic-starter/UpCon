<html lang="en"><head><meta charset="utf8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>GumTree</title><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css"><style type="text/css">/*
 * This file is part of GumTree.
 *
 * GumTree is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * GumTree is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with GumTree.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Copyright 2011-2015 Jean-Rémy Falleri <jr.falleri@gmail.com>
 * Copyright 2011-2015 Floréal Morandat <florealm@gmail.com>
 */

.add {
	border: 1px solid black;
	background-color: MediumSeaGreen;
}

.del {
	border: 1px solid black;
	background-color: IndianRed;
}

.mv {
	border: 1px solid black;
	background-color: Plum;
}

.upd {
	border: 1px solid black;
	background-color: DarkOrange;
	font-weight: bold;
}

.cupd {
	font-weight: normal;
	color: DimGray;
}

.selected {
	background-color: Gold;
}

.marker {
	margin: 0;
	padding: 0;
}

div {
	margin: 0px;
	padding: 0px;
}

.pre-scrollable {
	margin: 0px;
	padding: 0px;
	font-size: 10pt;
	color: black;
	max-height: 90vh;
	background-color: white;
	border: 1px solid black;
	font-family: "Hack, Inconsolata", "Consolas", "Liberation Sans Regular", "DejaVu Sans Mono", monospace;
}

.tooltip-inner {
    max-width: none;
}
</style><script type="text/javascript" src="https://code.jquery.com/jquery-3.4.1.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/js/bootstrap.bundle.min.js"></script><script type="text/javascript">/*
 * This file is part of GumTree.
 *
 * GumTree is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * GumTree is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with GumTree.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Copyright 2011-2015 Jean-Rémy Falleri <jr.falleri@gmail.com>
 * Copyright 2011-2015 Floréal Morandat <florealm@gmail.com>
 */

$(function(){
    let popoverTriggerList = [].slice.call(document.querySelectorAll('[data-bs-toggle="popover"]'))
    let popoverList = popoverTriggerList.map(function (popoverTriggerEl) {
      return new bootstrap.Popover(popoverTriggerEl)
    })

    $("body").keypress(function (event) {
        switch (event.which) {
            case 116:
                $('html, body').animate({scrollTop: 0}, 100);
                break;
            case 98:
                $("html, body").animate({ scrollTop: $(document).height() }, 100);
                break;
            case 113:
                window.location = "/quit";
                break;
            case 108:
                window.location = "/list";
                break;
        }
    });
});
</script><script type="text/javascript">/*
 * This file is part of GumTree.
 *
 * GumTree is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * GumTree is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with GumTree.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Copyright 2011-2015 Jean-Rémy Falleri <jr.falleri@gmail.com>
 * Copyright 2011-2015 Floréal Morandat <florealm@gmail.com>
 */

currentMapping = 0;

if (typeof String.prototype.startsWith != 'function') {
  String.prototype.startsWith = function (str){
    return this.slice(0, str.length) == str;
  };
}

function getMappedElement(eltId) {
	if (eltId.startsWith("move-src")) {
		return eltId.replace("src","dst");  	 	
  	}
  	else {
  		return eltId.replace("dst","src");
  	}
}

function nextMapping() {
	if (currentMapping == 0) {
		currentMapping = 1;
		return "#mapping-" + currentMapping.toString();
	} else {
		currentMapping++;
		
		if ($("#mapping-" + currentMapping.toString()).length > 0) {
			return "#mapping-" + currentMapping.toString();
		} else {
			currentMapping = 1;
			return "#mapping-" + currentMapping.toString();		
		}		
	}
}

function isSrc(eltId) {
	return eltId.startsWith("move-src");
}

$(function() {
    $("body").keypress(function (event) {
        switch(event.which) {
            case 110:
                const mapping = $(nextMapping());
                const pre = mapping.closest("pre");
                pre.animate({scrollTop: pre.scrollTop() + mapping.position().top - 200}, 100);
                break;
        }
    });

    // highlight
    $("span.mv.token, span.token.upd").click(function(event) {
        if ($(this).hasClass("selected")) {
            $("span.mv.token, span.token.upd").removeClass("selected");
        } else {
            $("span.mv.token, span.token.upd").removeClass("selected");
            const refElt = $("#" + getMappedElement($(this).attr("id")));
            $(this).addClass("selected");
            refElt.addClass("selected");
            const pre = refElt.closest("pre");
            console.log(pre);
            pre.animate({scrollTop: pre.scrollTop() + refElt.position().top - 200}, 100);
        }
        event.stopPropagation();
    });
    
    $("span.add.token, span.token.del").click(function(event) {
        $("span.mv.token, span.token.upd").removeClass("selected");
        event.stopPropagation();
    });

    // tooltip
    $("span.token").hover(
    	function (event) {
    		$(this).tooltip('show');
    		event.stopPropagation();
    	},
    	function (event) {
    		$(this).tooltip('hide');
    		event.stopPropagation();
    	}
    );
});
</script></head><body><div class="container-fluid"><div class="row"><div class="col"><div class="btn-toolbar justify-content-end"><div class="btn-group mr-2"><button class="btn btn-primary btn-sm" id="legend" data-bs-toggle="popover" data-bs-placement="bottom" data-bs-html="true" data-bs-content="<span class='del'>&nbsp;&nbsp;</span> deleted<br><span class='add'>&nbsp;&nbsp;</span> added<br><span class='mv'>&nbsp;&nbsp;</span> moved<br><span class='upd';>&nbsp;&nbsp;</span> updated<br>">Legend</button><button class="btn btn-primary btn-sm" id="shortcuts" data-bs-toggle="popover" data-bs-placement="bottom" data-bs-html="true" data-bs-content="<b>q</b> quit<br><b>l</b> list<br><b>n</b> next<br><b>t</b> top<br><b>b</b> bottom">Shortcuts</button></div><div class="btn-group"><a href="/list" class="btn btn-default btn-sm btn-primary">Back</a><a href="/quit" class="btn btn-default btn-sm btn-danger">Quit</a></div></div></div></div><div class="row"><div class="col-6"><h5>0x185486869e615f5a5644991a491212582caa08fb.etherscan.io-ValidatorShare.sol</h5><pre class="pre-scrollable"><span class="marker" id="mapping-1"></span><span class="token upd" id="move-src-1" data-title="source_file/comment"><span class="cupd">/</span>**<span class="cupd"></span>
 *Sub<span class="cupd">m</span>it<span class="cupd">t</span>e<span class="cupd">d</span> <span class="cupd">f</span><span class="cupd">o</span>r<span class="cupd"> ve</span>rifi<span class="cupd">c</span>ati<span class="cupd">o</span>n at Et<span class="cupd">h</span><span class="cupd">e</span>rs<span class="cupd">ca</span><span class="cupd">n</span>.io on 2020-10-27
*/</span>

<span class="marker" id="mapping-2"></span><span class="token mv" id="move-src-2" data-title="source_file/comment">// File: openzeppelin-solidity/contracts/token/ERC20/IERC20.sol</span>

pragma solidity ^0.5.2;

/**
 * @title ERC20 interface
 * @dev see https://eips.ethereum.org/EIPS/eip-20
 */
interface IERC20 {
    function transfer(address to, uint256 value) external returns (bool);

    function approve(address spender, uint256 value) external returns (bool);

    function transferFrom(address from, address to, uint256 value) external returns (bool);

    function totalSupply() external view returns (uint256);

    function balanceOf(address who) external view returns (uint256);

    function allowance(address owner, address spender) external view returns (uint256);

    event Transfer(address indexed from, address indexed to, uint256 value);

    event Approval(address indexed owner, address indexed spender, uint256 value);
}

// File: openzeppelin-solidity/contracts/math/SafeMath.sol

<span class="marker" id="mapping-3"></span><span class="token mv" id="move-src-3" data-title="source_file/pragma_directive">pragma solidity ^0.5.2;</span>

/**
 * @title SafeMath
 * @dev Unsigned math operations with safety checks that revert on error
 */
library SafeMath {
    /**
     * @dev Multiplies two unsigned integers, reverts on overflow.
     */
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the
        // benefit is lost if 'b' is also tested.
        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522
        if (a == 0) {
            return 0;
        }

        uint256 c = a * b;
        require(c / a == b);

        return c;
    }

    /**
     * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.
     */
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        // Solidity only automatically asserts when dividing by 0
        require(b &gt; 0);
        uint256 c = a / b;
        // assert(a == b * c + a % b); // There is no case in which this doesn't hold

        return c;
    }

    /**
     * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).
     */
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b &lt;= a);
        uint256 c = a - b;

        return c;
    }

    /**
     * @dev Adds two unsigned integers, reverts on overflow.
     */
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c &gt;= a);

        return c;
    }

    /**
     * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),
     * reverts when dividing by zero.
     */
    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b != 0);
        return a % b;
    }
}

// File: openzeppelin-solidity/contracts/token/ERC20/ERC20.sol

<span class="marker" id="mapping-4"></span><span class="token mv" id="move-src-4" data-title="source_file/pragma_directive">pragma solidity ^0.5.2;</span>



/**
 * @title Standard ERC20 token
 *
 * @dev Implementation of the basic standard token.
 * https://eips.ethereum.org/EIPS/eip-20
 * Originally based on code by FirstBlood:
 * https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol
 *
 * This implementation emits additional Approval events, allowing applications to reconstruct the allowance status for
 * all accounts just by listening to said events. Note that this isn't required by the specification, and other
 * compliant implementations may not do it.
 */
contract ERC20 is IERC20 {
    using SafeMath for uint256;

    mapping (address =&gt; uint256) private _balances;

    mapping (address =&gt; mapping (address =&gt; uint256)) private _allowed;

    uint256 private _totalSupply;

    /**
     * @dev Total number of tokens in existence
     */
    function totalSupply() public view returns (uint256) {
        return _totalSupply;
    }

    /**
     * @dev Gets the balance of the specified address.
     * @param owner The address to query the balance of.
     * @return A uint256 representing the amount owned by the passed address.
     */
    function balanceOf(address owner) public view returns (uint256) {
        return _balances[owner];
    }

    /**
     * @dev Function to check the amount of tokens that an owner allowed to a spender.
     * @param owner address The address which owns the funds.
     * @param spender address The address which will spend the funds.
     * @return A uint256 specifying the amount of tokens still available for the spender.
     */
    function allowance(address owner, address spender) public view returns (uint256) {
        return _allowed[owner][spender];
    }

    /**
     * @dev Transfer token to a specified address
     * @param to The address to transfer to.
     * @param value The amount to be transferred.
     */
    function transfer(address to, uint256 value) public returns (bool) {
        _transfer(msg.sender, to, value);
        return true;
    }

    /**
     * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.
     * Beware that changing an allowance with this method brings the risk that someone may use both the old
     * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this
     * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:
     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
     * @param spender The address which will spend the funds.
     * @param value The amount of tokens to be spent.
     */
    function approve(address spender, uint256 value) public returns (bool) {
        _approve(msg.sender, spender, value);
        return true;
    }

    <span class="marker" id="mapping-5"></span><span class="token upd" id="move-src-5" data-title="contract_body/comment"><span class="cupd">/**
     * @dev Transfer tokens from one address to another.
     * Note that while this function emits an Approval event, this is not required as per the specification,
     * and other compliant implementations may not emit the event.
     * @param from address The address which you want to send tokens from
     * @param to address The address which you want </span><span class="cupd">to transfer to
     * @param value uint256 the amount of tokens to be transferred
</span>     */</span>
    function transferFrom(address from, address to, uint256 value) public returns (bool) {
        _transfer(from, to, value);
        _approve(from, msg.sender, _allowed[from][msg.sender].sub(value));
        return true;
    }

    /**
     * @dev Increase the amount of tokens that an owner allowed to a spender.
     * approve should be called when _allowed[msg.sender][spender] == 0. To increment
     * allowed value is better to use this function to avoid 2 calls (and wait until
     * the first transaction is mined)
     * From MonolithDAO Token.sol
     * Emits an Approval event.
     * @param spender The address which will spend the funds.
     * @param addedValue The amount of tokens to increase the allowance by.
     */
    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {
        _approve(msg.sender, spender, _allowed[msg.sender][spender].add(addedValue));
        return true;
    }

    /**
     * @dev Decrease the amount of tokens that an owner allowed to a spender.
     * approve should be called when _allowed[msg.sender][spender] == 0. To decrement
     * allowed value is better to use this function to avoid 2 calls (and wait until
     * the first transaction is mined)
     * From MonolithDAO Token.sol
     * Emits an Approval event.
     * @param spender The address which will spend the funds.
     * @param subtractedValue The amount of tokens to decrease the allowance by.
     */
    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {
        _approve(msg.sender, spender, _allowed[msg.sender][spender].sub(subtractedValue));
        return true;
    }

    /**
     * @dev Transfer token for a specified addresses
     * @param from The address to transfer from.
     * @param to The address to transfer to.
     * @param value The amount to be transferred.
     */
    function _transfer(address from, address to, uint256 value) internal {
        require(to != address(0));

        _balances[from] = _balances[from].sub(value);
        _balances[to] = _balances[to].add(value);
        emit Transfer(from, to, value);
    }

    /**
     * @dev Internal function that mints an amount of the token and assigns it to
     * an account. This encapsulates the modification of balances such that the
     * proper events are emitted.
     * @param account The account that will receive the created tokens.
     * @param value The amount that will be created.
     */
    function _mint(address account, uint256 value) internal {
        require(account != address(0));

        _totalSupply = _totalSupply.add(value);
        _balances[account] = _balances[account].add(value);
        emit Transfer(address(0), account, value);
    }

    /**
     * @dev Internal function that burns an amount of the token of a given
     * account.
     * @param account The account whose tokens will be burnt.
     * @param value The amount that will be burnt.
     */
    function _burn(address account, uint256 value) internal {
        require(account != address(0));

        _totalSupply = _totalSupply.sub(value);
        _balances[account] = _balances[account].sub(value);
        emit Transfer(account, address(0), value);
    }

    /**
     * @dev Approve an address to spend another addresses' tokens.
     * @param owner The address that owns the tokens.
     * @param spender The address that will spend the tokens.
     * @param value The number of tokens that can be spent.
     */
    function _approve(address owner, address spender, uint256 value) internal {
        require(spender != address(0));
        require(owner != address(0));

        _allowed[owner][spender] = value;
        emit Approval(owner, spender, value);
    }

    /**
     * @dev Internal function that burns an amount of the token of a given
     * account, deducting from the sender's allowance for said account. Uses the
     * internal burn function.
     * Emits an Approval event (reflecting the reduced allowance).
     * @param account The account whose tokens will be burnt.
     * @param value The amount that will be burnt.
     */
    function _burnFrom(address account, uint256 value) internal {
        _burn(account, value);
        _approve(account, msg.sender, _allowed[account][msg.sender].sub(value));
    }
}

<span class="marker" id="mapping-6"></span><span class="token mv" id="move-src-6" data-title="source_file/comment"><span class="marker" id="mapping-7"></span><span class="token upd" id="move-src-7" data-title="source_file/comment"><span class="cupd">// File: contracts/common/</span>t<span class="cupd">o</span>k<span class="cupd">e</span><span class="cupd">n</span>s<span class="cupd">/</span>ERC20N<span class="cupd">o</span>nT<span class="cupd">r</span>a<span class="cupd">n</span>sfer<span class="cupd">able.sol</span></span></span>

<span class="marker" id="mapping-8"></span><span class="token mv" id="move-src-8" data-title="source_file/pragma_directive">pragma solidity ^0.5.2;</span>


<span class="marker" id="mapping-9"></span><span class="token mv" id="move-src-9" data-title="source_file/contract_declaration">contract <span class="marker" id="mapping-10"></span><span class="token upd" id="move-src-10" data-title="contract_declaration/identifier"><span class="cupd">ERC20NonTra</span>nsfer<span class="cupd">able</span></span> is ERC20 {
    function <span class="marker" id="mapping-11"></span><span class="token upd" id="move-src-11" data-title="function_definition/identifier"><span class="cupd">_</span>t<span class="cupd">r</span>ansfer</span>(
        <span class="marker" id="mapping-12"></span><span class="token mv" id="move-src-12" data-title="function_definition/parameter">address from</span>,
        <span class="marker" id="mapping-13"></span><span class="token mv" id="move-src-13" data-title="function_definition/parameter">address to</span>,
        uint256 value
    ) internal {
        revert("Disabled");
    }
}</span>

<span class="marker" id="mapping-14"></span><span class="token mv" id="move-src-14" data-title="source_file/comment"><span class="marker" id="mapping-15"></span><span class="token upd" id="move-src-15" data-title="source_file/comment"><span class="cupd">// File: contracts/</span>c<span class="cupd">o</span>mm<span class="cupd">o</span>n<span class="cupd">/</span>gove<span class="cupd">r</span><span class="cupd">na</span>nc<span class="cupd">e</span><span class="cupd">/I</span>Gove<span class="cupd">r</span><span class="cupd">na</span>nc<span class="cupd">e</span><span class="cupd">.sol</span></span></span>

<span class="marker" id="mapping-16"></span><span class="token mv" id="move-src-16" data-title="source_file/pragma_directive">pragma solidity ^0.5.2;</span>

<span class="marker" id="mapping-17"></span><span class="token mv" id="move-src-17" data-title="source_file/interface_declaration">interface IGovernance {
    function update(address target, bytes calldata data) external;
}</span>

<span class="marker" id="mapping-18"></span><span class="token mv" id="move-src-18" data-title="source_file/comment"><span class="marker" id="mapping-19"></span><span class="token upd" id="move-src-19" data-title="source_file/comment"><span class="cupd">// File: contracts/common/</span><span class="cupd">g</span>ove<span class="cupd">r</span>nance/Governable<span class="cupd">.sol</span></span></span>

<span class="marker" id="mapping-20"></span><span class="token mv" id="move-src-20" data-title="source_file/pragma_directive">pragma solidity ^0.5.2;</span>


<span class="marker" id="mapping-21"></span><span class="token mv" id="move-src-21" data-title="source_file/contract_declaration">contract Governable {
    IGovernance public governance;

    constructor(address _governance) public {
        governance = IGovernance(_governance);
    }

    modifier onlyGovernance() <span class="marker" id="mapping-22"></span><span class="token mv" id="move-src-22" data-title="modifier_definition/function_body">{
        require(
            msg.sender == address(governance),
            "Only governance contract is authorized"
        );
        <span class="marker" id="mapping-23"></span><span class="token mv" id="move-src-23" data-title="function_body/expression_statement">_;</span>
    }</span>
}</span>

<span class="marker" id="mapping-24"></span><span class="token upd" id="move-src-24" data-title="source_file/comment"><span class="cupd">// File: contracts/</span>r<span class="cupd">o</span><span class="cupd">o</span>t<span class="cupd">/</span>wi<span class="cupd">t</span>hdrawMa<span class="cupd">n</span>ager<span class="cupd">/</span>IWithd<span class="cupd">ra</span>wM<span class="cupd">a</span>nag<span class="cupd">e</span>r<span class="cupd">.sol</span></span>

<span class="marker" id="mapping-25"></span><span class="token mv" id="move-src-25" data-title="source_file/pragma_directive">pragma solidity ^0.5.2;</span>

<span class="marker" id="mapping-26"></span><span class="token mv" id="move-src-26" data-title="source_file/contract_declaration">contract IWithdrawManager {
    function createExitQueue(address token) external;

    function verifyInclusion(
        bytes calldata data,
        uint8 offset,
        bool verifyTxInclusion
    ) external view returns (uint256 age);

    function addExitToQueue(
        address exitor,
        address childToken,
        address rootToken,
        uint256 exitAmountOrTokenId,
        bytes32 txHash,
        bool isRegularExit,
        uint256 priority
    ) external;

    function addInput(
        uint256 exitId,
        uint256 age,
        address utxoOwner,
        address token
    ) external;

    function challengeExit(
        uint256 exitId,
        uint256 inputId,
        bytes calldata challengeData,
        address adjudicatorPredicate
    ) external;
}</span>

<span class="marker" id="mapping-27"></span><span class="token mv" id="move-src-27" data-title="source_file/comment"><span class="marker" id="mapping-28"></span><span class="token upd" id="move-src-28" data-title="source_file/comment"><span class="cupd">// File: contracts/common/</span>Reg<span class="cupd">i</span>s<span class="cupd">t</span>ry<span class="cupd">.sol</span></span></span>

pragma solidity ^0.5.2;




<span class="marker" id="mapping-29"></span><span class="token mv" id="move-src-29" data-title="source_file/contract_declaration">contract Registry is Governable {
    // @todo hardcode constants
    bytes32 private constant WETH_TOKEN = keccak256("wethToken");
    bytes32 private constant DEPOSIT_MANAGER = keccak256("depositManager");
    bytes32 private constant STAKE_MANAGER = keccak256("stakeManager");
    bytes32 private constant VALIDATOR_SHARE = keccak256("validatorShare");
    bytes32 private constant WITHDRAW_MANAGER = keccak256("withdrawManager");
    bytes32 private constant CHILD_CHAIN = keccak256("childChain");
    bytes32 private constant STATE_SENDER = keccak256("stateSender");
    bytes32 private constant SLASHING_MANAGER = keccak256("slashingManager");

    address public erc20Predicate;
    address public erc721Predicate;

    mapping(bytes32 =&gt; address) public contractMap;
    mapping(address =&gt; address) public rootToChildToken;
    mapping(address =&gt; address) public childToRootToken;
    mapping(address =&gt; bool) public proofValidatorContracts;
    mapping(address =&gt; bool) public isERC721;

    enum Type {Invalid, ERC20, ERC721, Custom}
    struct Predicate {
        Type _type;
    }
    mapping(address =&gt; Predicate) public predicates;

    event TokenMapped(address indexed rootToken, address indexed childToken);
    event ProofValidatorAdded(address indexed validator, address indexed from);
    event ProofValidatorRemoved(address indexed validator, address indexed from);
    event PredicateAdded(address indexed predicate, address indexed from);
    event PredicateRemoved(address indexed predicate, address indexed from);
    event ContractMapUpdated(bytes32 indexed key, address indexed previousContract, address indexed newContract);

    constructor(address _governance) public Governable(_governance) {}

    function updateContractMap(bytes32 _key, address _address) external onlyGovernance {
        emit ContractMapUpdated(_key, contractMap[_key], _address);
        contractMap[_key] = _address;
    }

    /**
     * @dev Map root token to child token
     * @param _rootToken Token address on the root chain
     * @param _childToken Token address on the child chain
     * @param _isERC721 Is the token being mapped ERC721
     */
    function mapToken(
        address _rootToken,
        address _childToken,
        bool _isERC721
    ) external onlyGovernance {
        require(_rootToken != address(0x0) &amp;&amp; _childToken != address(0x0), "INVALID_TOKEN_ADDRESS");
        rootToChildToken[_rootToken] = _childToken;
        childToRootToken[_childToken] = _rootToken;
        isERC721[_rootToken] = _isERC721;
        IWithdrawManager(contractMap[WITHDRAW_MANAGER]).createExitQueue(_rootToken);
        emit TokenMapped(_rootToken, _childToken);
    }

    function addErc20Predicate(address predicate) public onlyGovernance {
        require(predicate != address(0x0), "Can not add null address as predicate");
        erc20Predicate = predicate;
        addPredicate(predicate, Type.ERC20);
    }

    function addErc721Predicate(address predicate) public onlyGovernance {
        erc721Predicate = predicate;
        addPredicate(predicate, Type.ERC721);
    }

    function addPredicate(address predicate, Type _type) public onlyGovernance {
        require(predicates[predicate]._type == Type.Invalid, "Predicate already added");
        predicates[predicate]._type = _type;
        emit PredicateAdded(predicate, msg.sender);
    }

    function removePredicate(address predicate) public onlyGovernance {
        require(predicates[predicate]._type != Type.Invalid, "Predicate does not exist");
        delete predicates[predicate];
        emit PredicateRemoved(predicate, msg.sender);
    }

    function getValidatorShareAddress() public view returns (address) {
        return contractMap[VALIDATOR_SHARE];
    }

    function getWethTokenAddress() public view returns (address) {
        return contractMap[WETH_TOKEN];
    }

    function getDepositManagerAddress() public view returns (address) {
        return contractMap[DEPOSIT_MANAGER];
    }

    function getStakeManagerAddress() public view returns (address) {
        return contractMap[STAKE_MANAGER];
    }

    function getSlashingManagerAddress() public view returns (address) {
        return contractMap[SLASHING_MANAGER];
    }

    function getWithdrawManagerAddress() public view returns (address) {
        return contractMap[WITHDRAW_MANAGER];
    }

    function getChildChainAndStateSender() public view returns (address, address) {
        return (contractMap[CHILD_CHAIN], contractMap[STATE_SENDER]);
    }

    function isTokenMapped(address _token) public view returns (bool) {
        return rootToChildToken[_token] != address(0x0);
    }

    function isTokenMappedAndIsErc721(address _token) public view returns (bool) {
        require(isTokenMapped(_token), "TOKEN_NOT_MAPPED");
        return isERC721[_token];
    }

    function isTokenMappedAndGetPredicate(address _token) public view returns (address) {
        if (isTokenMappedAndIsErc721(_token)) {
            return erc721Predicate;
        }
        return erc20Predicate;
    }

    function isChildTokenErc721(address childToken) public view returns (bool) {
        address rootToken = childToRootToken[childToken];
        require(rootToken != address(0x0), "Child token is not mapped");
        return isERC721[rootToken];
    }
}</span>

// File: openzeppelin-solidity/contracts/ownership/Ownable.sol

pragma solidity ^0.5.2;

/**
 * @title Ownable
 * @dev The Ownable contract has an owner address, and provides basic authorization control
 * functions, this simplifies the implementation of "user permissions".
 */
contract Ownable {
    address private _owner;

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    /**
     * @dev The Ownable constructor sets the original `owner` of the contract to the sender
     * account.
     */
    constructor () internal {
        _owner = msg.sender;
        emit OwnershipTransferred(address(0), _owner);
    }

    /**
     * @return the address of the owner.
     */
    function owner() public view returns (address) {
        return _owner;
    }

    /**
     * @dev Throws if called by any account other than the owner.
     */
    modifier onlyOwner() {
        require(isOwner());
        _;
    }

    /**
     * @return true if `msg.sender` is the owner of the contract.
     */
    function isOwner() public view returns (bool) {
        return msg.sender == _owner;
    }

    /**
     * @dev Allows the current owner to relinquish control of the contract.
     * It will not be possible to call the functions with the `onlyOwner`
     * modifier anymore.
     * @notice Renouncing ownership will leave the contract without an owner,
     * thereby removing any functionality that is only available to the owner.
     */
    function renounceOwnership() public onlyOwner {
        emit OwnershipTransferred(_owner, address(0));
        _owner = address(0);
    }

    /**
     * @dev Allows the current owner to transfer control of the contract to a newOwner.
     * @param newOwner The address to transfer ownership to.
     */
    function transferOwnership(address newOwner) public onlyOwner {
        _transferOwnership(newOwner);
    }

    /**
     * @dev Transfers control of the contract to a newOwner.
     * @param newOwner The address to transfer ownership to.
     */
    function _transferOwnership(address newOwner) internal {
        require(newOwner != address(0));
        emit OwnershipTransferred(_owner, newOwner);
        _owner = newOwner;
    }
}

<span class="marker" id="mapping-30"></span><span class="token mv" id="move-src-30" data-title="source_file/comment"><span class="marker" id="mapping-31"></span><span class="token upd" id="move-src-31" data-title="source_file/comment"><span class="cupd">// File: contracts/</span>commo<span class="cupd">n</span><span class="cupd">/</span>lib/By<span class="cupd">t</span>e<span class="cupd">s</span>Li<span class="cupd">b.sol</span></span></span>

<span class="marker" id="mapping-32"></span><span class="token mv" id="move-src-32" data-title="source_file/pragma_directive">pragma solidity ^0.5.2;</span>


<span class="marker" id="mapping-33"></span><span class="token del" data-title="source_file/library_declaration">library BytesLib <span class="marker" id="mapping-34"></span><span class="token del" data-title="library_declaration/contract_body">{
    <span class="marker" id="mapping-35"></span><span class="token del" data-title="contract_body/function_definition">function concat(bytes memory _preBytes, bytes memory _postBytes)
        internal
        pure
        returns (bytes memory)
    {
        bytes memory tempBytes;
        assembly {
            // Get a location of some free memory and store it in tempBytes as
            // Solidity does for memory variables.
            tempBytes := mload(0x40)

            // Store the length of the first bytes array at the beginning of
            // the memory for tempBytes.
            let length := mload(_preBytes)
            mstore(tempBytes, length)

            // Maintain a memory counter for the current write location in the
            // temp bytes array by adding the 32 bytes for the array length to
            // the starting location.
            let mc := add(tempBytes, 0x20)
            // Stop copying when the memory counter reaches the length of the
            // first bytes array.
            let end := add(mc, length)

            for {
                // Initialize a copy counter to the start of the _preBytes data,
                // 32 bytes into its memory.
                let cc := add(_preBytes, 0x20)
            } lt(mc, end) {
                // Increase both counters by 32 bytes each iteration.
                mc := add(mc, 0x20)
                cc := add(cc, 0x20)
            } {
                // Write the _preBytes data into the tempBytes memory 32 bytes
                // at a time.
                mstore(mc, mload(cc))
            }

            // Add the length of _postBytes to the current length of tempBytes
            // and store it as the new length in the first 32 bytes of the
            // tempBytes memory.
            length := mload(_postBytes)
            mstore(tempBytes, add(length, mload(tempBytes)))

            // Move the memory counter back from a multiple of 0x20 to the
            // actual end of the _preBytes data.
            mc := end
            // Stop copying when the memory counter reaches the new combined
            // length of the arrays.
            end := add(mc, length)

            for {
                let cc := add(_postBytes, 0x20)
            } lt(mc, end) {
                mc := add(mc, 0x20)
                cc := add(cc, 0x20)
            } {
                mstore(mc, mload(cc))
            }

            // Update the free-memory pointer by padding our last write location
            // to 32 bytes: add 31 bytes to the end of tempBytes to move to the
            // next 32 byte block, then round down to the nearest multiple of
            // 32. If the sum of the length of the two arrays is zero then add
            // one before rounding down to leave a blank 32 bytes (the length block with 0).
            mstore(
                0x40,
                and(
                    add(add(end, iszero(add(length, mload(_preBytes)))), 31),
                    not(31) // Round down to the nearest 32 bytes.
                )
            )
        }
        return tempBytes;
    }</span>

    <span class="marker" id="mapping-36"></span><span class="token del" data-title="contract_body/function_definition">function slice(<span class="marker" id="mapping-37"></span><span class="token del" data-title="function_definition/parameter">bytes memory _bytes</span>, <span class="marker" id="mapping-38"></span><span class="token mv" id="move-src-33" data-title="function_definition/parameter">uint256 <span class="marker" id="mapping-39"></span><span class="token upd" id="move-src-34" data-title="parameter/identifier">_start</span></span>, <span class="marker" id="mapping-40"></span><span class="token mv" id="move-src-35" data-title="function_definition/parameter">uint256 <span class="marker" id="mapping-41"></span><span class="token upd" id="move-src-36" data-title="parameter/identifier">_length</span></span>)
        <span class="marker" id="mapping-42"></span><span class="token del" data-title="function_definition/visibility">internal</span>
        <span class="marker" id="mapping-43"></span><span class="token del" data-title="function_definition/state_mutability">pure</span>
        <span class="marker" id="mapping-44"></span><span class="token del" data-title="function_definition/return_type_definition">returns (bytes memory)</span>
    <span class="marker" id="mapping-45"></span><span class="token del" data-title="function_definition/function_body">{
        require(_bytes.length &gt;= (_start + _length));
        bytes memory tempBytes;
        assembly {
            switch iszero(_length)
                case 0 {
                    // Get a location of some free memory and store it in tempBytes as
                    // Solidity does for memory variables.
                    tempBytes := mload(0x40)

                    // The first word of the slice result is potentially a partial
                    // word read from the original array. To read it, we calculate
                    // the length of that partial word and start copying that many
                    // bytes into the array. The first word we copy will start with
                    // data we don't care about, but the last `lengthmod` bytes will
                    // land at the beginning of the contents of the new array. When
                    // we're done copying, we overwrite the full first word with
                    // the actual length of the slice.
                    let lengthmod := and(_length, 31)

                    // The multiplication in the next line is necessary
                    // because when slicing multiples of 32 bytes (lengthmod == 0)
                    // the following copy loop was copying the origin's length
                    // and then ending prematurely not copying everything it should.
                    let mc := add(
                        add(tempBytes, lengthmod),
                        mul(0x20, iszero(lengthmod))
                    )
                    let end := add(mc, _length)

                    for {
                        // The multiplication in the next line has the same exact purpose
                        // as the one above.
                        let cc := add(
                            add(
                                add(_bytes, lengthmod),
                                mul(0x20, iszero(lengthmod))
                            ),
                            _start
                        )
                    } lt(mc, end) {
                        mc := add(mc, 0x20)
                        cc := add(cc, 0x20)
                    } {
                        mstore(mc, mload(cc))
                    }

                    mstore(tempBytes, _length)

                    //update free-memory pointer
                    //allocating the array padded to 32 bytes like the compiler does now
                    mstore(0x40, and(add(mc, 31), not(31)))
                }
                //if we want a zero-length slice let's just return a zero-length array
                default {
                    tempBytes := mload(0x40)
                    mstore(0x40, add(tempBytes, 0x20))
                }
        }

        return tempBytes;
    }</span></span>

    // Pad a bytes array to 32 bytes
    <span class="marker" id="mapping-46"></span><span class="token del" data-title="contract_body/function_definition">function leftPad(bytes memory _bytes) internal pure returns (bytes memory) {
        // may underflow if bytes.length &lt; 32. Hence using SafeMath.sub
        bytes memory newBytes = new bytes(SafeMath.sub(32, _bytes.length));
        return concat(newBytes, _bytes);
    }</span>

    <span class="marker" id="mapping-47"></span><span class="token del" data-title="contract_body/function_definition">function toBytes32(<span class="marker" id="mapping-48"></span><span class="token del" data-title="function_definition/parameter">bytes memory b</span>) <span class="marker" id="mapping-49"></span><span class="token del" data-title="function_definition/visibility">internal</span> <span class="marker" id="mapping-50"></span><span class="token del" data-title="function_definition/state_mutability">pure</span> <span class="marker" id="mapping-51"></span><span class="token del" data-title="function_definition/return_type_definition">returns (bytes32)</span> <span class="marker" id="mapping-52"></span><span class="token del" data-title="function_definition/function_body">{
        <span class="marker" id="mapping-53"></span><span class="token del" data-title="function_body/expression_statement">require(b.length &gt;= 32, "Bytes array should atleast be 32 bytes");</span>
        <span class="marker" id="mapping-54"></span><span class="token del" data-title="function_body/variable_declaration_statement">bytes32 out;</span>
        <span class="marker" id="mapping-55"></span><span class="token del" data-title="function_body/for_statement">for (<span class="marker" id="mapping-56"></span><span class="token del" data-title="for_statement/variable_declaration_statement"><span class="marker" id="mapping-57"></span><span class="token del" data-title="variable_declaration_statement/variable_declaration"><span class="marker" id="mapping-58"></span><span class="token mv" id="move-src-37" data-title="variable_declaration/type_name">uint256</span> i</span> = 0;</span> <span class="marker" id="mapping-59"></span><span class="token del" data-title="for_statement/expression_statement">i &lt; 32;</span> <span class="marker" id="mapping-60"></span><span class="token del" data-title="for_statement/update_expression">i++</span>) <span class="marker" id="mapping-61"></span><span class="token del" data-title="for_statement/block_statement">{
            out |= bytes32(b[i] &amp; 0xFF) &gt;&gt; (i * 8);
        }</span></span>
        <span class="marker" id="mapping-62"></span><span class="token del" data-title="function_body/return_statement">return out;</span>
    }</span></span>

    <span class="marker" id="mapping-63"></span><span class="token del" data-title="contract_body/function_definition">function toBytes4(bytes memory b) internal pure returns (bytes4 result) {
        assembly {
            result := mload(add(b, 32))
        }
    }</span>

    <span class="marker" id="mapping-64"></span><span class="token del" data-title="contract_body/function_definition">function fromBytes32(<span class="marker" id="mapping-65"></span><span class="token del" data-title="function_definition/parameter">bytes32 x</span>) <span class="marker" id="mapping-66"></span><span class="token del" data-title="function_definition/visibility">internal</span> <span class="marker" id="mapping-67"></span><span class="token del" data-title="function_definition/state_mutability">pure</span> <span class="marker" id="mapping-68"></span><span class="token del" data-title="function_definition/return_type_definition">returns (bytes memory)</span> <span class="marker" id="mapping-69"></span><span class="token del" data-title="function_definition/function_body">{
        <span class="marker" id="mapping-70"></span><span class="token del" data-title="function_body/variable_declaration_statement">bytes memory b = new bytes(32);</span>
        <span class="marker" id="mapping-71"></span><span class="token del" data-title="function_body/for_statement">for (<span class="marker" id="mapping-72"></span><span class="token del" data-title="for_statement/variable_declaration_statement"><span class="marker" id="mapping-73"></span><span class="token mv" id="move-src-38" data-title="variable_declaration_statement/variable_declaration">uint256 <span class="marker" id="mapping-74"></span><span class="token upd" id="move-src-39" data-title="variable_declaration/identifier">i</span></span> = 0;</span> <span class="marker" id="mapping-75"></span><span class="token del" data-title="for_statement/expression_statement">i &lt; 32;</span> <span class="marker" id="mapping-76"></span><span class="token del" data-title="for_statement/update_expression">i++</span>) <span class="marker" id="mapping-77"></span><span class="token del" data-title="for_statement/block_statement">{
            <span class="marker" id="mapping-78"></span><span class="token del" data-title="block_statement/expression_statement"><span class="marker" id="mapping-79"></span><span class="token del" data-title="expression_statement/assignment_expression"><span class="marker" id="mapping-80"></span><span class="token del" data-title="assignment_expression/array_access">b[i]</span> = <span class="marker" id="mapping-81"></span><span class="token del" data-title="assignment_expression/type_cast_expression"><span class="marker" id="mapping-82"></span><span class="token del" data-title="type_cast_expression/primitive_type">bytes1</span>(<span class="marker" id="mapping-83"></span><span class="token del" data-title="type_cast_expression/call_argument"><span class="marker" id="mapping-84"></span><span class="token del" data-title="call_argument/type_cast_expression"><span class="marker" id="mapping-85"></span><span class="token del" data-title="type_cast_expression/primitive_type">uint8</span>(<span class="marker" id="mapping-86"></span><span class="token del" data-title="type_cast_expression/call_argument"><span class="marker" id="mapping-87"></span><span class="token del" data-title="call_argument/binary_expression"><span class="marker" id="mapping-88"></span><span class="token del" data-title="binary_expression/type_cast_expression"><span class="marker" id="mapping-89"></span><span class="token mv" id="move-src-40" data-title="type_cast_expression/primitive_type">uint256</span>(<span class="marker" id="mapping-90"></span><span class="token del" data-title="type_cast_expression/call_argument">x</span>)</span> / <span class="marker" id="mapping-91"></span><span class="token del" data-title="binary_expression/parenthesized_expression">(2**(8 * (31 - i)))</span></span></span>)</span></span>)</span></span>;</span>
        }</span></span>
        <span class="marker" id="mapping-92"></span><span class="token del" data-title="function_body/return_statement">return b;</span>
    }</span></span>

    <span class="marker" id="mapping-93"></span><span class="token del" data-title="contract_body/function_definition">function fromUint(<span class="marker" id="mapping-94"></span><span class="token mv" id="move-src-41" data-title="function_definition/parameter">uint256 <span class="marker" id="mapping-95"></span><span class="token upd" id="move-src-42" data-title="parameter/identifier">_num</span></span>) <span class="marker" id="mapping-96"></span><span class="token del" data-title="function_definition/visibility">internal</span> <span class="marker" id="mapping-97"></span><span class="token del" data-title="function_definition/state_mutability">pure</span> <span class="marker" id="mapping-98"></span><span class="token del" data-title="function_definition/return_type_definition">returns (bytes memory _ret)</span> <span class="marker" id="mapping-99"></span><span class="token del" data-title="function_definition/function_body">{
        _ret = new bytes(32);
        assembly {
            mstore(add(_ret, 32), _num)
        }
    }</span></span>

    <span class="marker" id="mapping-100"></span><span class="token del" data-title="contract_body/function_definition">function toUint(<span class="marker" id="mapping-101"></span><span class="token del" data-title="function_definition/parameter">bytes memory _bytes</span>, <span class="marker" id="mapping-102"></span><span class="token mv" id="move-src-43" data-title="function_definition/parameter">uint256 <span class="marker" id="mapping-103"></span><span class="token upd" id="move-src-44" data-title="parameter/identifier">_st<span class="cupd">ar</span>t</span></span>)
        <span class="marker" id="mapping-104"></span><span class="token del" data-title="function_definition/visibility">internal</span>
        <span class="marker" id="mapping-105"></span><span class="token del" data-title="function_definition/state_mutability">pure</span>
        <span class="marker" id="mapping-106"></span><span class="token del" data-title="function_definition/return_type_definition">returns (uint256)</span>
    <span class="marker" id="mapping-107"></span><span class="token del" data-title="function_definition/function_body">{
        <span class="marker" id="mapping-108"></span><span class="token del" data-title="function_body/expression_statement">require(_bytes.length &gt;= (_start + 32));</span>
        <span class="marker" id="mapping-109"></span><span class="token del" data-title="function_body/variable_declaration_statement"><span class="marker" id="mapping-110"></span><span class="token mv" id="move-src-45" data-title="variable_declaration_statement/variable_declaration">uint256 <span class="marker" id="mapping-111"></span><span class="token upd" id="move-src-46" data-title="variable_declaration/identifier">tempUint</span></span>;</span>
        <span class="marker" id="mapping-112"></span><span class="token del" data-title="function_body/assembly_statement">assembly {
            tempUint := mload(add(add(_bytes, 0x20), _start))
        }</span>
        <span class="marker" id="mapping-113"></span><span class="token del" data-title="function_body/return_statement">return tempUint;</span>
    }</span></span>

    <span class="marker" id="mapping-114"></span><span class="token del" data-title="contract_body/function_definition">function toAddress(<span class="marker" id="mapping-115"></span><span class="token del" data-title="function_definition/parameter">bytes memory _bytes</span>, <span class="marker" id="mapping-116"></span><span class="token mv" id="move-src-47" data-title="function_definition/parameter">uint256 <span class="marker" id="mapping-117"></span><span class="token upd" id="move-src-48" data-title="parameter/identifier">_st<span class="cupd">a</span><span class="cupd">r</span>t</span></span>)
        <span class="marker" id="mapping-118"></span><span class="token del" data-title="function_definition/visibility">internal</span>
        <span class="marker" id="mapping-119"></span><span class="token del" data-title="function_definition/state_mutability">pure</span>
        <span class="marker" id="mapping-120"></span><span class="token mv" id="move-src-49" data-title="function_definition/return_type_definition">returns (address)</span>
    <span class="marker" id="mapping-121"></span><span class="token del" data-title="function_definition/function_body">{
        <span class="marker" id="mapping-122"></span><span class="token del" data-title="function_body/expression_statement">require(_bytes.length &gt;= (_start + 20));</span>
        <span class="marker" id="mapping-123"></span><span class="token mv" id="move-src-50" data-title="function_body/variable_declaration_statement">address <span class="marker" id="mapping-124"></span><span class="token upd" id="move-src-51" data-title="variable_declaration/identifier">t<span class="cupd">e</span>mpAddress</span>;</span>
        <span class="marker" id="mapping-125"></span><span class="token del" data-title="function_body/assembly_statement">assembly {
            tempAddress := div(
                mload(add(add(_bytes, 0x20), _start)),
                0x1000000000000000000000000
            )
        }</span>

        <span class="marker" id="mapping-126"></span><span class="token del" data-title="function_body/return_statement">return tempAddress;</span>
    }</span></span>
}</span></span>

<span class="marker" id="mapping-127"></span><span class="token del" data-title="source_file/comment">// File: contracts/common/lib/ECVerify.sol</span>

<span class="marker" id="mapping-128"></span><span class="token mv" id="move-src-52" data-title="source_file/pragma_directive">pragma solidity ^0.5.2;</span>


<span class="marker" id="mapping-129"></span><span class="token del" data-title="source_file/library_declaration">library ECVerify <span class="marker" id="mapping-130"></span><span class="token del" data-title="library_declaration/contract_body">{
    <span class="marker" id="mapping-131"></span><span class="token del" data-title="contract_body/function_definition">function ecrecovery(<span class="marker" id="mapping-132"></span><span class="token del" data-title="function_definition/parameter">bytes32 hash</span>, <span class="marker" id="mapping-133"></span><span class="token del" data-title="function_definition/parameter">bytes memory sig</span>)
        <span class="marker" id="mapping-134"></span><span class="token mv" id="move-src-53" data-title="function_definition/visibility">public</span>
        <span class="marker" id="mapping-135"></span><span class="token del" data-title="function_definition/state_mutability">pure</span>
        <span class="marker" id="mapping-136"></span><span class="token del" data-title="function_definition/return_type_definition">returns (address)</span>
    <span class="marker" id="mapping-137"></span><span class="token del" data-title="function_definition/function_body">{
        <span class="marker" id="mapping-138"></span><span class="token del" data-title="function_body/variable_declaration_statement">bytes32 r;</span>
        <span class="marker" id="mapping-139"></span><span class="token del" data-title="function_body/variable_declaration_statement">bytes32 s;</span>
        <span class="marker" id="mapping-140"></span><span class="token del" data-title="function_body/variable_declaration_statement">uint8 v;</span>

        <span class="marker" id="mapping-141"></span><span class="token del" data-title="function_body/if_statement">if (sig.length != 65) {
            return address(0x0);
        }</span>

        <span class="marker" id="mapping-142"></span><span class="token del" data-title="function_body/assembly_statement">assembly {
            r := mload(add(sig, 32))
            s := mload(add(sig, 64))
            v := and(mload(add(sig, 65)), 255)
        }</span>

        // https://github.com/ethereum/go-ethereum/issues/2053
        <span class="marker" id="mapping-143"></span><span class="token del" data-title="function_body/if_statement">if (v &lt; 27) {
            v += 27;
        }</span>

        <span class="marker" id="mapping-144"></span><span class="token del" data-title="function_body/if_statement">if (<span class="marker" id="mapping-145"></span><span class="token del" data-title="if_statement/binary_expression">v != 27 &amp;&amp; v != 28</span>) <span class="marker" id="mapping-146"></span><span class="token del" data-title="if_statement/block_statement">{
            <span class="marker" id="mapping-147"></span><span class="token del" data-title="block_statement/return_statement">return <span class="marker" id="mapping-148"></span><span class="token del" data-title="return_statement/type_cast_expression"><span class="marker" id="mapping-149"></span><span class="token mv" id="move-src-54" data-title="type_cast_expression/primitive_type">address</span>(<span class="marker" id="mapping-150"></span><span class="token mv" id="move-src-55" data-title="type_cast_expression/call_argument">0x0</span>)</span>;</span>
        }</span></span>

        // get address out of hash and signature
        <span class="marker" id="mapping-151"></span><span class="token del" data-title="function_body/variable_declaration_statement"><span class="marker" id="mapping-152"></span><span class="token del" data-title="variable_declaration_statement/variable_declaration"><span class="marker" id="mapping-153"></span><span class="token mv" id="move-src-56" data-title="variable_declaration/type_name">address</span> result</span> = <span class="marker" id="mapping-154"></span><span class="token del" data-title="variable_declaration_statement/call_expression">ecrecover(hash, v, r, s)</span>;</span>

        // ecrecover returns zero on error
        <span class="marker" id="mapping-155"></span><span class="token del" data-title="function_body/expression_statement">require(result != address(0x0));</span>

        <span class="marker" id="mapping-156"></span><span class="token del" data-title="function_body/return_statement">return result;</span>
    }</span></span>

    <span class="marker" id="mapping-157"></span><span class="token del" data-title="contract_body/function_definition">function ecrecovery(<span class="marker" id="mapping-158"></span><span class="token del" data-title="function_definition/parameter">bytes32 hash</span>, <span class="marker" id="mapping-159"></span><span class="token del" data-title="function_definition/parameter">uint8 v</span>, <span class="marker" id="mapping-160"></span><span class="token del" data-title="function_definition/parameter">bytes32 r</span>, <span class="marker" id="mapping-161"></span><span class="token del" data-title="function_definition/parameter">bytes32 s</span>)
        <span class="marker" id="mapping-162"></span><span class="token mv" id="move-src-57" data-title="function_definition/visibility">public</span>
        <span class="marker" id="mapping-163"></span><span class="token del" data-title="function_definition/state_mutability">pure</span>
        <span class="marker" id="mapping-164"></span><span class="token del" data-title="function_definition/return_type_definition">returns (address)</span>
    <span class="marker" id="mapping-165"></span><span class="token del" data-title="function_definition/function_body">{
        // get address out of hash and signature
        <span class="marker" id="mapping-166"></span><span class="token mv" id="move-src-58" data-title="function_body/variable_declaration_statement">address <span class="marker" id="mapping-167"></span><span class="token upd" id="move-src-59" data-title="variable_declaration/identifier"><span class="cupd">r</span>esult</span> <span class="marker" id="mapping-168"></span><span class="token del" data-title="variable_declaration_statement/=">=</span> <span class="marker" id="mapping-169"></span><span class="token del" data-title="variable_declaration_statement/call_expression">ecrecover(hash, v, r, s)</span>;</span>

        // ecrecover returns zero on error
        <span class="marker" id="mapping-170"></span><span class="token del" data-title="function_body/expression_statement">require(result != address(0x0), "signature verification failed");</span>

        <span class="marker" id="mapping-171"></span><span class="token del" data-title="function_body/return_statement">return result;</span>
    }</span></span>

    <span class="marker" id="mapping-172"></span><span class="token del" data-title="contract_body/function_definition">function ecverify(<span class="marker" id="mapping-173"></span><span class="token del" data-title="function_definition/parameter">bytes32 hash</span>, <span class="marker" id="mapping-174"></span><span class="token del" data-title="function_definition/parameter">bytes memory sig</span>, <span class="marker" id="mapping-175"></span><span class="token mv" id="move-src-60" data-title="function_definition/parameter">address <span class="marker" id="mapping-176"></span><span class="token upd" id="move-src-61" data-title="parameter/identifier"><span class="cupd">s</span>ig<span class="cupd">n</span><span class="cupd">er</span></span></span>)
        <span class="marker" id="mapping-177"></span><span class="token mv" id="move-src-62" data-title="function_definition/visibility">public</span>
        <span class="marker" id="mapping-178"></span><span class="token del" data-title="function_definition/state_mutability">pure</span>
        <span class="marker" id="mapping-179"></span><span class="token del" data-title="function_definition/return_type_definition">returns (bool)</span>
    <span class="marker" id="mapping-180"></span><span class="token del" data-title="function_definition/function_body">{
        return signer == ecrecovery(hash, sig);
    }</span></span>
}</span></span>

// File: contracts/staking/StakingInfo.sol

<span class="marker" id="mapping-181"></span><span class="token mv" id="move-src-63" data-title="source_file/pragma_directive">pragma solidity ^0.5.2;</span>







// dummy interface to avoid cyclic dependency
contract IStakeManagerLocal {
    enum Status {Inactive, Active, Locked, Unstaked}

    struct Validator {
        uint256 amount;
        uint256 reward;
        uint256 activationEpoch;
        uint256 deactivationEpoch;
        uint256 jailTime;
        address signer;
        address contractAddress;
        Status status;
    }

    mapping(uint256 =&gt; Validator) public validators;
    bytes32 public accountStateRoot;
    uint256 public activeAmount; // delegation amount from validator contract
    uint256 public validatorRewards;

    function currentValidatorSetTotalStake() public view returns (uint256);

    // signer to Validator mapping
    function signerToValidator(address validatorAddress)
        public
        view
        returns (uint256);

    function isValidator(uint256 validatorId) public view returns (bool);
}


contract StakingInfo is Ownable {
    using SafeMath for uint256;
    mapping(uint256 =&gt; uint256) public validatorNonce;

    /// @dev Emitted when validator stakes in '_stakeFor()' in StakeManager.
    /// @param signer validator address.
    /// @param validatorId unique integer to identify a validator.
    /// @param nonce to synchronize the events in heimdal.
    /// @param activationEpoch validator's first epoch as proposer.
    /// @param amount staking amount.
    /// @param total total staking amount.
    /// @param signerPubkey public key of the validator
    event Staked(
        address indexed signer,
        uint256 indexed validatorId,
        uint256 nonce,
        uint256 indexed activationEpoch,
        uint256 amount,
        uint256 total,
        bytes signerPubkey
    );

    /// @dev Emitted when validator unstakes in 'unstakeClaim()'
    /// @param user address of the validator.
    /// @param validatorId unique integer to identify a validator.
    /// @param amount staking amount.
    /// @param total total staking amount.
    event Unstaked(
        address indexed user,
        uint256 indexed validatorId,
        uint256 amount,
        uint256 total
    );

    /// @dev Emitted when validator unstakes in '_unstake()'.
    /// @param user address of the validator.
    /// @param validatorId unique integer to identify a validator.
    /// @param nonce to synchronize the events in heimdal.
    /// @param deactivationEpoch last epoch for validator.
    /// @param amount staking amount.
    event UnstakeInit(
        address indexed user,
        uint256 indexed validatorId,
        uint256 nonce,
        uint256 deactivationEpoch,
        uint256 indexed amount
    );

    /// @dev Emitted when the validator public key is updated in 'updateSigner()'.
    /// @param validatorId unique integer to identify a validator.
    /// @param nonce to synchronize the events in heimdal.
    /// @param oldSigner old address of the validator.
    /// @param newSigner new address of the validator.
    /// @param signerPubkey public key of the validator.
    event SignerChange(
        uint256 indexed validatorId,
        uint256 nonce,
        address indexed oldSigner,
        address indexed newSigner,
        bytes signerPubkey
    );
    event Restaked(uint256 indexed validatorId, uint256 amount, uint256 total);
    event Jailed(
        uint256 indexed validatorId,
        uint256 indexed exitEpoch,
        address indexed signer
    );
    event UnJailed(uint256 indexed validatorId, address indexed signer);
    event Slashed(uint256 indexed nonce, uint256 indexed amount);
    event ThresholdChange(uint256 newThreshold, uint256 oldThreshold);
    event DynastyValueChange(uint256 newDynasty, uint256 oldDynasty);
    event ProposerBonusChange(
        uint256 newProposerBonus,
        uint256 oldProposerBonus
    );

    event RewardUpdate(uint256 newReward, uint256 oldReward);

    /// @dev Emitted when validator confirms the auction bid and at the time of restaking in confirmAuctionBid() and restake().
    /// @param validatorId unique integer to identify a validator.
    /// @param nonce to synchronize the events in heimdal.
    /// @param newAmount the updated stake amount.
    event StakeUpdate(
        uint256 indexed validatorId,
        uint256 indexed nonce,
        uint256 indexed newAmount
    );
    event ClaimRewards(
        uint256 indexed validatorId,
        uint256 indexed amount,
        uint256 indexed totalAmount
    );
    event StartAuction(
        uint256 indexed validatorId,
        uint256 indexed amount,
        uint256 indexed auctionAmount
    );
    event ConfirmAuction(
        uint256 indexed newValidatorId,
        uint256 indexed oldValidatorId,
        uint256 indexed amount
    );
    event TopUpFee(address indexed user, uint256 indexed fee);
    event ClaimFee(address indexed user, uint256 indexed fee);
    // Delegator events
    event ShareMinted(
        uint256 indexed validatorId,
        address indexed user,
        uint256 indexed amount,
        uint256 tokens
    );
    event ShareBurned(
        uint256 indexed validatorId,
        address indexed user,
        uint256 indexed amount,
        uint256 tokens
    );
    event DelegatorClaimedRewards(
        uint256 indexed validatorId,
        address indexed user,
        uint256 indexed rewards
    );
    event DelegatorRestaked(
        uint256 indexed validatorId,
        address indexed user,
        uint256 indexed totalStaked
    );
    event DelegatorUnstaked(
        uint256 indexed validatorId,
        address indexed user,
        uint256 amount
    );
    event UpdateCommissionRate(
        uint256 indexed validatorId,
        uint256 indexed newCommissionRate,
        uint256 indexed oldCommissionRate
    );

    Registry public registry;

    modifier onlyValidatorContract(uint256 validatorId) {
        address _contract;
        (, , , , , , _contract, ) = IStakeManagerLocal(
            registry.getStakeManagerAddress()
        )
            .validators(validatorId);
        require(_contract == msg.sender,
        "Invalid sender, not validator");
        _;
    }

    modifier StakeManagerOrValidatorContract(uint256 validatorId) {
        address _contract;
        address _stakeManager = registry.getStakeManagerAddress();
        (, , , , , , _contract, ) = IStakeManagerLocal(_stakeManager).validators(
            validatorId
        );
        require(_contract == msg.sender || _stakeManager == msg.sender,
        "Invalid sender, not stake manager or validator contract");
        _;
    }

    modifier onlyStakeManager() {
        require(registry.getStakeManagerAddress() == msg.sender,
        "Invalid sender, not stake manager");
        _;
    }
    modifier onlySlashingManager() {
        require(registry.getSlashingManagerAddress() == msg.sender,
        "Invalid sender, not slashing manager");
        _;
    }

    constructor(address _registry) public {
        registry = Registry(_registry);
    }

    function updateNonce(
        uint256[] calldata validatorIds,
        uint256[] calldata nonces
    ) external onlyOwner {
        require(validatorIds.length == nonces.length, "args length mismatch");

        for (uint256 i = 0; i &lt; validatorIds.length; ++i) {
            validatorNonce[validatorIds[i]] = nonces[i];
        }
    } 

    function logStaked(
        address signer,
        bytes memory signerPubkey,
        uint256 validatorId,
        uint256 activationEpoch,
        uint256 amount,
        uint256 total
    ) public onlyStakeManager {
        validatorNonce[validatorId] = validatorNonce[validatorId].add(1);
        emit Staked(
            signer,
            validatorId,
            validatorNonce[validatorId],
            activationEpoch,
            amount,
            total,
            signerPubkey
        );
    }

    function logUnstaked(
        address user,
        uint256 validatorId,
        uint256 amount,
        uint256 total
    ) public onlyStakeManager {
        emit Unstaked(user, validatorId, amount, total);
    }

    function logUnstakeInit(
        address user,
        uint256 validatorId,
        uint256 deactivationEpoch,
        uint256 amount
    ) public onlyStakeManager {
        validatorNonce[validatorId] = validatorNonce[validatorId].add(1);
        emit UnstakeInit(
            user,
            validatorId,
            validatorNonce[validatorId],
            deactivationEpoch,
            amount
        );
    }

    function logSignerChange(
        uint256 validatorId,
        address oldSigner,
        address newSigner,
        bytes memory signerPubkey
    ) public onlyStakeManager {
        validatorNonce[validatorId] = validatorNonce[validatorId].add(1);
        emit SignerChange(
            validatorId,
            validatorNonce[validatorId],
            oldSigner,
            newSigner,
            signerPubkey
        );
    }

    function logRestaked(uint256 validatorId, uint256 amount, uint256 total)
        public
        onlyStakeManager
    {
        emit Restaked(validatorId, amount, total);
    }

    function logJailed(uint256 validatorId, uint256 exitEpoch, address signer)
        public
        onlyStakeManager
    {
        emit Jailed(validatorId, exitEpoch, signer);
    }

    function logUnjailed(uint256 validatorId, address signer)
        public
        onlyStakeManager
    {
        emit UnJailed(validatorId, signer);
    }

    function logSlashed(uint256 nonce, uint256 amount)
        public
        onlySlashingManager
    {
        emit Slashed(nonce, amount);
    }

    function logThresholdChange(uint256 newThreshold, uint256 oldThreshold)
        public
        onlyStakeManager
    {
        emit ThresholdChange(newThreshold, oldThreshold);
    }

    function logDynastyValueChange(uint256 newDynasty, uint256 oldDynasty)
        public
        onlyStakeManager
    {
        emit DynastyValueChange(newDynasty, oldDynasty);
    }

    function logProposerBonusChange(
        uint256 newProposerBonus,
        uint256 oldProposerBonus
    ) public onlyStakeManager {
        emit ProposerBonusChange(newProposerBonus, oldProposerBonus);
    }

    function logRewardUpdate(uint256 newReward, uint256 oldReward)
        public
        onlyStakeManager
    {
        emit RewardUpdate(newReward, oldReward);
    }

    function logStakeUpdate(uint256 validatorId)
        public
        StakeManagerOrValidatorContract(validatorId)
    {
        validatorNonce[validatorId] = validatorNonce[validatorId].add(1);
        emit StakeUpdate(
            validatorId,
            validatorNonce[validatorId],
            totalValidatorStake(validatorId)
        );
    }

    function logClaimRewards(
        uint256 validatorId,
        uint256 amount,
        uint256 totalAmount
    ) public onlyStakeManager {
        emit ClaimRewards(validatorId, amount, totalAmount);
    }

    function logStartAuction(
        uint256 validatorId,
        uint256 amount,
        uint256 auctionAmount
    ) public onlyStakeManager {
        emit StartAuction(validatorId, amount, auctionAmount);
    }

    function logConfirmAuction(
        uint256 newValidatorId,
        uint256 oldValidatorId,
        uint256 amount
    ) public onlyStakeManager {
        emit ConfirmAuction(newValidatorId, oldValidatorId, amount);
    }

    function logTopUpFee(address user, uint256 fee) public onlyStakeManager {
        emit TopUpFee(user, fee);
    }

    function logClaimFee(address user, uint256 fee) public onlyStakeManager {
        emit ClaimFee(user, fee);
    }

    function getStakerDetails(uint256 validatorId)
        public
        view
        returns (
            uint256 amount,
            uint256 reward,
            uint256 activationEpoch,
            uint256 deactivationEpoch,
            address signer,
            uint256 _status
        )
    {
        IStakeManagerLocal stakeManager = IStakeManagerLocal(
            registry.getStakeManagerAddress()
        );
        address _contract;
        IStakeManagerLocal.Status status;
        (
            amount,
            reward,
            activationEpoch,
            deactivationEpoch,
            ,
            signer,
            _contract,
            status
        ) = stakeManager.validators(validatorId);
        _status = uint256(status);
        if (_contract != address(0x0)) {
            reward += IStakeManagerLocal(_contract).validatorRewards();
        }
    }

    function totalValidatorStake(uint256 validatorId)
        public
        view
        returns (uint256 validatorStake)
    {
        address contractAddress;
        (validatorStake, , , , , , contractAddress, ) = IStakeManagerLocal(
            registry.getStakeManagerAddress()
        )
            .validators(validatorId);
        if (contractAddress != address(0x0)) {
            validatorStake += IStakeManagerLocal(contractAddress).activeAmount();
        }
    }

    function getAccountStateRoot()
        public
        view
        returns (bytes32 accountStateRoot)
    {
        accountStateRoot = IStakeManagerLocal(registry.getStakeManagerAddress())
            .accountStateRoot();
    }

    function getValidatorContractAddress(uint256 validatorId)
        public
        view
        returns (address ValidatorContract)
    {
        (, , , , , , ValidatorContract, ) = IStakeManagerLocal(
            registry.getStakeManagerAddress()
        )
            .validators(validatorId);
    }

    // validator Share contract logging func
    function logShareMinted(
        uint256 validatorId,
        address user,
        uint256 amount,
        uint256 tokens
    ) public onlyValidatorContract(validatorId) {
        emit ShareMinted(validatorId, user, amount, tokens);
    }

    function logShareBurned(
        uint256 validatorId,
        address user,
        uint256 amount,
        uint256 tokens
    ) public onlyValidatorContract(validatorId) {
        emit ShareBurned(validatorId, user, amount, tokens);
    }

    function logDelegatorClaimRewards(
        uint256 validatorId,
        address user,
        uint256 rewards
    ) public onlyValidatorContract(validatorId) {
        emit DelegatorClaimedRewards(validatorId, user, rewards);
    }

    function logDelegatorRestaked(
        uint256 validatorId,
        address user,
        uint256 totalStaked
    ) public onlyValidatorContract(validatorId) {
        emit DelegatorRestaked(validatorId, user, totalStaked);
    }

    function logDelegatorUnstaked(uint256 validatorId, address user, uint256 amount)
        public
        onlyValidatorContract(validatorId)
    {
        emit DelegatorUnstaked(validatorId, user, amount);
    }

    function logUpdateCommissionRate(
        uint256 validatorId,
        uint256 newCommissionRate,
        uint256 oldCommissionRate
    ) public onlyValidatorContract(validatorId) {
        emit UpdateCommissionRate(
            validatorId,
            newCommissionRate,
            oldCommissionRate
        );
    }
}

// File: contracts/common/mixin/Lockable.sol

pragma solidity ^0.5.2;

contract Lockable {
    bool public locked;

    modifier onlyWhenUnlocked() {
        _assertUnlocked();
        _;
    }

    function _assertUnlocked() private view {
        require(!locked, "locked");
    }

    function lock() public {
        locked = true;
    }

    function unlock() public {
        locked = false;
    }
}

// File: contracts/common/mixin/OwnableLockable.sol

pragma solidity ^0.5.2;



contract OwnableLockable is Lockable, Ownable {
    function lock() public onlyOwner {
        super.lock();
    }

    function unlock() public onlyOwner {
        super.unlock();
    }
}

// File: contracts/staking/stakeManager/IStakeManager.sol

<span class="marker" id="mapping-182"></span><span class="token del" data-title="source_file/pragma_directive">pragma solidity ^0.5.2;</span>


contract IStakeManager {
    // validator replacement
    function startAuction(
        uint256 validatorId,
        uint256 amount,
        bool acceptDelegation,
        bytes calldata signerPubkey
    ) external;

    function confirmAuctionBid(uint256 validatorId, uint256 heimdallFee) external;

    function transferFunds(
        uint256 validatorId,
        uint256 amount,
        address delegator
    ) external returns (bool);

    function delegationDeposit(
        uint256 validatorId,
        uint256 amount,
        address delegator
    ) external returns (bool);

    <span class="marker" id="mapping-183"></span><span class="token mv" id="move-src-64" data-title="contract_body/function_definition">function <span class="marker" id="mapping-184"></span><span class="token upd" id="move-src-65" data-title="function_definition/identifier">s<span class="cupd">t</span><span class="cupd">ake</span></span>(
        <span class="marker" id="mapping-185"></span><span class="token mv" id="move-src-66" data-title="function_definition/parameter">uint256 amount</span>,
        uint256 heimdallFee,
        <span class="marker" id="mapping-186"></span><span class="token mv" id="move-src-67" data-title="function_definition/parameter">bool acceptDelegation</span>,
        bytes calldata signerPubkey
    ) external;</span>

    function unstake(uint256 validatorId) external;

    function totalStakedFor(address addr) external view returns (uint256);

    function stakeFor(
        address user,
        uint256 amount,
        uint256 heimdallFee,
        bool acceptDelegation,
        bytes memory signerPubkey
    ) public;

    function checkSignatures(
        uint256 blockInterval,
        bytes32 voteHash,
        bytes32 stateRoot,
        address proposer,
        <span class="marker" id="mapping-187"></span><span class="token del" data-title="type_name/primitive_type">bytes</span> <span class="marker" id="mapping-188"></span><span class="token del" data-title="parameter/memory">memory</span> sigs
    ) <span class="marker" id="mapping-189"></span><span class="token mv" id="move-src-68" data-title="function_definition/visibility">public</span> returns (uint256);

    function updateValidatorState(uint256 validatorId, int256 amount) public;

    function ownerOf(uint256 tokenId) public view returns (address);

    function slash(bytes <span class="marker" id="mapping-190"></span><span class="token del" data-title="parameter/memory">memory</span> slashingInfoList) <span class="marker" id="mapping-191"></span><span class="token mv" id="move-src-69" data-title="function_definition/visibility">public</span> returns (uint256);

    function validatorStake(uint256 validatorId) public view returns (uint256);

    function epoch() public view returns (uint256);

    function withdrawalDelay() public view returns (uint256);
}

// File: contracts/staking/validatorShare/IValidatorShare.sol

<span class="marker" id="mapping-192"></span><span class="token del" data-title="source_file/pragma_directive">pragma solidity ^0.5.2;</span>

// note this contract interface is only for stakeManager use
contract IValidatorShare {
    <span class="marker" id="mapping-193"></span><span class="token del" data-title="contract_body/function_definition">function withdrawRewardsValidator() <span class="marker" id="mapping-194"></span><span class="token mv" id="move-src-70" data-title="function_definition/visibility">external</span> <span class="marker" id="mapping-195"></span><span class="token del" data-title="function_definition/return_type_definition">returns (uint256)</span>;</span>

    <span class="marker" id="mapping-196"></span><span class="token mv" id="move-src-71" data-title="contract_body/function_definition">function <span class="marker" id="mapping-197"></span><span class="token upd" id="move-src-72" data-title="function_definition/identifier"><span class="cupd">a</span>ddP<span class="cupd">r</span>opos<span class="cupd">e</span><span class="cupd">r</span>Bonus</span>(uint256 <span class="marker" id="mapping-198"></span><span class="token upd" id="move-src-73" data-title="parameter/identifier">_rew<span class="cupd">a</span><span class="cupd">r</span>ds</span>, uint256 <span class="marker" id="mapping-199"></span><span class="token upd" id="move-src-74" data-title="parameter/identifier">valS<span class="cupd">t</span>a<span class="cupd">ke</span></span>) public;</span>

    function withdrawRewards() public;

    function unstakeClaimTokens() public;

    function getLiquidRewards(address user) public view returns (uint256);
    
    <span class="marker" id="mapping-200"></span><span class="token del" data-title="contract_body/function_definition">function getActiveAmount() <span class="marker" id="mapping-201"></span><span class="token mv" id="move-src-75" data-title="function_definition/visibility">external</span> <span class="marker" id="mapping-202"></span><span class="token mv" id="move-src-76" data-title="function_definition/state_mutability">view</span> <span class="marker" id="mapping-203"></span><span class="token del" data-title="function_definition/return_type_definition">returns (uint256)</span>;</span>

    function owner() public view returns (address);

    <span class="marker" id="mapping-204"></span><span class="token del" data-title="contract_body/function_definition">function restake() <span class="marker" id="mapping-205"></span><span class="token mv" id="move-src-77" data-title="function_definition/visibility">public</span>;</span>

    <span class="marker" id="mapping-206"></span><span class="token mv" id="move-src-78" data-title="contract_body/function_definition">function <span class="marker" id="mapping-207"></span><span class="token upd" id="move-src-79" data-title="function_definition/identifier">upd<span class="cupd">a</span>teRewards</span>(
        <span class="marker" id="mapping-208"></span><span class="token mv" id="move-src-80" data-title="function_definition/parameter">uint256 <span class="marker" id="mapping-209"></span><span class="token upd" id="move-src-81" data-title="parameter/identifier">_rew<span class="cupd">a</span><span class="cupd">r</span>d</span></span>,
        uint256 <span class="marker" id="mapping-210"></span><span class="token upd" id="move-src-82" data-title="parameter/identifier">_<span class="cupd">t</span><span class="cupd">o</span>talStake</span>,
        <span class="marker" id="mapping-211"></span><span class="token del" data-title="function_definition/parameter">uint256 validatorStake</span>
    ) <span class="marker" id="mapping-212"></span><span class="token mv" id="move-src-83" data-title="function_definition/visibility">external</span> returns (uint256);</span>

    <span class="marker" id="mapping-213"></span><span class="token mv" id="move-src-84" data-title="contract_body/function_definition">function <span class="marker" id="mapping-214"></span><span class="token upd" id="move-src-85" data-title="function_definition/identifier">un<span class="cupd">l</span><span class="cupd">o</span>ckCont<span class="cupd">r</span>act</span>() <span class="marker" id="mapping-215"></span><span class="token mv" id="move-src-86" data-title="function_definition/visibility">external</span> returns (uint256);</span>

    <span class="marker" id="mapping-216"></span><span class="token mv" id="move-src-87" data-title="contract_body/function_definition">function <span class="marker" id="mapping-217"></span><span class="token upd" id="move-src-88" data-title="function_definition/identifier"><span class="cupd">l</span><span class="cupd">o</span>ckCont<span class="cupd">r</span>act</span>() <span class="marker" id="mapping-218"></span><span class="token mv" id="move-src-89" data-title="function_definition/visibility">external</span> returns (uint256);</span>

    function drain(
        address token,
        address payable destination,
        uint256 amount
    ) external;

    <span class="marker" id="mapping-219"></span><span class="token mv" id="move-src-90" data-title="contract_body/function_definition">function <span class="marker" id="mapping-220"></span><span class="token upd" id="move-src-91" data-title="function_definition/identifier">s<span class="cupd">l</span>ash</span>(<span class="marker" id="mapping-221"></span><span class="token mv" id="move-src-92" data-title="function_definition/parameter">uint256 valPow</span><span class="marker" id="mapping-222"></span><span class="token del" data-title="function_definition/,">,</span> <span class="marker" id="mapping-223"></span><span class="token mv" id="move-src-93" data-title="function_definition/parameter">uint256 totalAmountToSlash</span>) <span class="marker" id="mapping-224"></span><span class="token mv" id="move-src-94" data-title="function_definition/visibility">external</span> returns (uint256);</span>

    function updateDelegation(bool delegation) external;

    function migrateOut(address user, uint256 amount) external;

    function migrateIn(address user, uint256 amount) external;
}

<span class="marker" id="mapping-225"></span><span class="token del" data-title="source_file/comment">// File: contracts/common/mixin/Initializable.sol</span>

<span class="marker" id="mapping-226"></span><span class="token del" data-title="source_file/pragma_directive">pragma solidity ^0.5.2;</span>

<span class="marker" id="mapping-227"></span><span class="token mv" id="move-src-95" data-title="source_file/contract_declaration">contract Initializable {
    bool inited = false;

    modifier initializer() {
        require(!inited, "already inited");
        inited = true;
        
        _;
    }
}</span>

// File: contracts/staking/validatorShare/ValidatorShare.sol

<span class="marker" id="mapping-228"></span><span class="token del" data-title="source_file/pragma_directive">pragma solidity ^0.5.2;</span>








contract ValidatorShare is IValidatorShare, <span class="marker" id="mapping-229"></span><span class="token upd" id="move-src-96" data-title="user_defined_type/identifier"><span class="cupd">ERC20NonTra</span>nsfer<span class="cupd">able</span></span>, OwnableLockable, Initializable {
    struct DelegatorUnbond {
        uint256 shares;
        uint256 withdrawEpoch;
    }

    uint256 constant EXCHANGE_RATE_PRECISION = 100;
    // maximum matic possible, even if rate will be 1 and all matic will be staken in one go, it will result in 10 ^ 58 shares
    uint256 constant EXCHANGE_RATE_HIGH_PRECISION = 10 ** 29; 
    uint256 constant MAX_COMMISION_RATE = 100;
    uint256 constant REWARD_PRECISION = 10**25;

    StakingInfo public stakingLogger;
    IStakeManager public stakeManager;
    uint256 public validatorId;
    uint256 public <span class="marker" id="mapping-230"></span><span class="token upd" id="move-src-97" data-title="state_variable_declaration/identifier"><span class="cupd">validatorRewards</span></span>;
    uint256 public <span class="marker" id="mapping-231"></span><span class="token upd" id="move-src-98" data-title="state_variable_declaration/identifier"><span class="cupd">commissionRate</span></span>;
    <span class="marker" id="mapping-232"></span><span class="token mv" id="move-src-99" data-title="contract_body/comment"><span class="marker" id="mapping-233"></span><span class="token upd" id="move-src-100" data-title="contract_body/comment"><span class="cupd">//</span>last<span class="cupd"> </span>ch<span class="cupd">e</span><span class="cupd">c</span>kpoin<span class="cupd">t</span><span class="cupd"> </span>wh<span class="cupd">e</span>r<span class="cupd">e</span><span class="cupd"> </span>validat<span class="cupd">or </span><span class="cupd">u</span>p<span class="cupd">dat</span>ed comm<span class="cupd">i</span>ssi<span class="cupd">on </span>r<span class="cupd">at</span>e</span></span>
    uint256 public <span class="marker" id="mapping-234"></span><span class="token upd" id="move-src-101" data-title="state_variable_declaration/identifier">lastCo<span class="cupd">m</span><span class="cupd">m</span>issi<span class="cupd">o</span><span class="cupd">n</span>Update</span>;
    uint256 public <span class="marker" id="mapping-235"></span><span class="token upd" id="move-src-102" data-title="state_variable_declaration/identifier">minAm<span class="cupd">o</span>unt</span> <span class="marker" id="mapping-236"></span><span class="token del" data-title="state_variable_declaration/=">=</span> <span class="marker" id="mapping-237"></span><span class="token del" data-title="state_variable_declaration/binary_expression">10**18</span>;

    <span class="marker" id="mapping-238"></span><span class="token mv" id="move-src-103" data-title="contract_body/comment"><span class="marker" id="mapping-239"></span><span class="token upd" id="move-src-104" data-title="contract_body/comment"><span class="cupd">/</span>/<span class="cupd"> </span>d<span class="cupd">e</span>pr<span class="cupd">e</span>ca<span class="cupd">t</span>ed</span></span>
    <span class="marker" id="mapping-240"></span><span class="token mv" id="move-src-105" data-title="contract_body/state_variable_declaration">uint256 public <span class="marker" id="mapping-241"></span><span class="token upd" id="move-src-106" data-title="state_variable_declaration/identifier">__<span class="cupd">t</span><span class="cupd">o</span><span class="cupd">t</span><span class="cupd">a</span>lS<span class="cupd">t</span>ake</span>;</span>
    uint256 public rewardPerShare;
    uint256 public activeAmount;
    bool public delegation <span class="marker" id="mapping-242"></span><span class="token del" data-title="state_variable_declaration/=">=</span> <span class="marker" id="mapping-243"></span><span class="token del" data-title="state_variable_declaration/boolean_literal">true</span>;

    uint256 public withdrawPool;
    uint256 public withdrawShares;

    <span class="marker" id="mapping-244"></span><span class="token mv" id="move-src-107" data-title="contract_body/comment"><span class="marker" id="mapping-245"></span><span class="token upd" id="move-src-108" data-title="contract_body/comment"><span class="cupd">/</span>/<span class="cupd"> </span>d<span class="cupd">e</span>preca<span class="cupd">t</span>ed</span></span>
    <span class="marker" id="mapping-246"></span><span class="token mv" id="move-src-109" data-title="contract_body/state_variable_declaration">mapping(address =&gt; uint256) <span class="marker" id="mapping-247"></span><span class="token upd" id="move-src-110" data-title="state_variable_declaration/identifier">__amo<span class="cupd">un</span>tStaked</span>;</span>
    mapping(address =&gt; DelegatorUnbond) public unbonds;
    mapping(address =&gt; uint256) public initalRewardPerShare;

    <span class="marker" id="mapping-248"></span><span class="token mv" id="move-src-111" data-title="contract_body/modifier_definition">modifier <span class="marker" id="mapping-249"></span><span class="token upd" id="move-src-112" data-title="modifier_definition/identifier"><span class="cupd">onlyValidator</span></span>() {
        require(<span class="marker" id="mapping-250"></span><span class="token del" data-title="binary_expression/call_expression"><span class="marker" id="mapping-251"></span><span class="token del" data-title="call_expression/member_expression">stakeManager.ownerOf</span>(<span class="marker" id="mapping-252"></span><span class="token mv" id="move-src-113" data-title="call_expression/call_argument">validatorId</span>)</span> == msg.sender, "not validator");
        _;
    }</span>

    // onlyOwner will prevent this contract from initializing, since it's owner is going to be 0x0 address
    function initialize(uint256 _validatorId, address _stakingLogger, address _stakeManager) external initializer  {
        validatorId = _validatorId;
        stakingLogger = StakingInfo(_stakingLogger);
        stakeManager = IStakeManager(_stakeManager);
        _transferOwnership(_stakeManager);

        minAmount = 10**18;
        delegation = true;
    }

    <span class="marker" id="mapping-253"></span><span class="token del" data-title="contract_body/function_definition">function updateCommissionRate(<span class="marker" id="mapping-254"></span><span class="token mv" id="move-src-114" data-title="function_definition/parameter">uint256 newCommissionRate</span>) <span class="marker" id="mapping-255"></span><span class="token del" data-title="function_definition/visibility">external</span> <span class="marker" id="mapping-256"></span><span class="token del" data-title="function_definition/modifier_invocation">onlyValidator</span> <span class="marker" id="mapping-257"></span><span class="token del" data-title="function_definition/function_body">{
        <span class="marker" id="mapping-258"></span><span class="token mv" id="move-src-115" data-title="function_body/variable_declaration_statement"><span class="marker" id="mapping-259"></span><span class="token mv" id="move-src-116" data-title="variable_declaration_statement/variable_declaration">uint256 <span class="marker" id="mapping-260"></span><span class="token upd" id="move-src-117" data-title="variable_declaration/identifier">epoch</span></span> = <span class="marker" id="mapping-261"></span><span class="token mv" id="move-src-118" data-title="variable_declaration_statement/call_expression">stakeManager.epoch()</span>;</span>
        <span class="marker" id="mapping-262"></span><span class="token del" data-title="function_body/variable_declaration_statement"><span class="marker" id="mapping-263"></span><span class="token mv" id="move-src-119" data-title="variable_declaration_statement/variable_declaration">uint256 <span class="marker" id="mapping-264"></span><span class="token upd" id="move-src-120" data-title="variable_declaration/identifier"><span class="cupd">_</span>l<span class="cupd">a</span>stC<span class="cupd">o</span>mmissi<span class="cupd">o</span>nUpd<span class="cupd">a</span>te</span></span> = lastCommissionUpdate;</span>

        <span class="marker" id="mapping-265"></span><span class="token del" data-title="function_body/expression_statement">require( // withdrawalDelay == dynasty
            (_lastCommissionUpdate.add(stakeManager.withdrawalDelay()) &lt;= epoch) || _lastCommissionUpdate == 0, // For initial setting of commission rate
            "Commission rate update cooldown period"
        );</span>

        <span class="marker" id="mapping-266"></span><span class="token mv" id="move-src-121" data-title="function_body/expression_statement"><span class="marker" id="mapping-267"></span><span class="token mv" id="move-src-122" data-title="expression_statement/call_expression"><span class="marker" id="mapping-268"></span><span class="token upd" id="move-src-123" data-title="call_expression/identifier">require</span>(<span class="marker" id="mapping-269"></span><span class="token del" data-title="call_expression/call_argument">newCommissionRate &lt;= MAX_COMMISION_RATE</span><span class="marker" id="mapping-270"></span><span class="token del" data-title="call_expression/,">,</span> "Commission rate should be in range of 0-100")</span>;</span>
        <span class="marker" id="mapping-271"></span><span class="token del" data-title="function_body/expression_statement"><span class="marker" id="mapping-272"></span><span class="token del" data-title="expression_statement/call_expression"><span class="marker" id="mapping-273"></span><span class="token del" data-title="call_expression/member_expression">stakingLogger.logUpdateCommissionRate</span>(<span class="marker" id="mapping-274"></span><span class="token mv" id="move-src-124" data-title="call_expression/call_argument">validatorId</span>, <span class="marker" id="mapping-275"></span><span class="token mv" id="move-src-125" data-title="call_expression/call_argument">newCommissionRate</span>, <span class="marker" id="mapping-276"></span><span class="token del" data-title="call_expression/call_argument">commissionRate</span>)</span>;</span>
        <span class="marker" id="mapping-277"></span><span class="token del" data-title="function_body/expression_statement">commissionRate = newCommissionRate;</span>
        <span class="marker" id="mapping-278"></span><span class="token del" data-title="function_body/expression_statement">lastCommissionUpdate = epoch;</span>
    }</span></span>

    <span class="marker" id="mapping-279"></span><span class="token del" data-title="contract_body/function_definition">function updateRewards(<span class="marker" id="mapping-280"></span><span class="token mv" id="move-src-126" data-title="function_definition/parameter">uint256 <span class="marker" id="mapping-281"></span><span class="token upd" id="move-src-127" data-title="parameter/identifier">rew<span class="cupd">a</span><span class="cupd">r</span>d</span></span>, <span class="marker" id="mapping-282"></span><span class="token mv" id="move-src-128" data-title="function_definition/parameter">uint256 <span class="marker" id="mapping-283"></span><span class="token upd" id="move-src-129" data-title="parameter/identifier">checkpo<span class="cupd">i</span>n<span class="cupd">t</span>StakeP<span class="cupd">o</span>wer</span></span>, <span class="marker" id="mapping-284"></span><span class="token del" data-title="function_definition/parameter">uint256 validatorStake</span>)
        <span class="marker" id="mapping-285"></span><span class="token del" data-title="function_definition/visibility">external</span>
        <span class="marker" id="mapping-286"></span><span class="token del" data-title="function_definition/modifier_invocation">onlyOwner</span>
        <span class="marker" id="mapping-287"></span><span class="token mv" id="move-src-130" data-title="function_definition/return_type_definition">returns (uint256)</span>
    <span class="marker" id="mapping-288"></span><span class="token del" data-title="function_definition/function_body">{
        <span class="marker" id="mapping-289"></span><span class="token mv" id="move-src-131" data-title="function_body/variable_declaration_statement">uint256 <span class="marker" id="mapping-290"></span><span class="token upd" id="move-src-132" data-title="variable_declaration/identifier">combin<span class="cupd">e</span><span class="cupd">d</span><span class="cupd">S</span>t<span class="cupd">a</span>kePower</span> = <span class="marker" id="mapping-291"></span><span class="token mv" id="move-src-133" data-title="variable_declaration_statement/call_expression">validatorStake.add(<span class="marker" id="mapping-292"></span><span class="token del" data-title="call_expression/call_argument">activeAmount</span>)</span>;</span> // validator + delegation stake power
        <span class="marker" id="mapping-293"></span><span class="token del" data-title="function_body/variable_declaration_statement"><span class="marker" id="mapping-294"></span><span class="token mv" id="move-src-134" data-title="variable_declaration_statement/variable_declaration">uint256 <span class="marker" id="mapping-295"></span><span class="token upd" id="move-src-135" data-title="variable_declaration/identifier">r<span class="cupd">eward</span>s</span></span> = <span class="marker" id="mapping-296"></span><span class="token del" data-title="variable_declaration_statement/call_expression">combinedStakePower.mul(reward).div(checkpointStakePower)</span>;</span>

        <span class="marker" id="mapping-297"></span><span class="token del" data-title="function_body/expression_statement">_updateRewards(rewards, validatorStake, combinedStakePower);</span>
        <span class="marker" id="mapping-298"></span><span class="token del" data-title="function_body/return_statement">return combinedStakePower;</span>
    }</span></span>

    <span class="marker" id="mapping-299"></span><span class="token del" data-title="contract_body/function_definition">function addProposerBonus(<span class="marker" id="mapping-300"></span><span class="token mv" id="move-src-136" data-title="function_definition/parameter">uint256 <span class="marker" id="mapping-301"></span><span class="token upd" id="move-src-137" data-title="parameter/identifier">rew<span class="cupd">a</span><span class="cupd">r</span>ds</span></span>, <span class="marker" id="mapping-302"></span><span class="token del" data-title="function_definition/parameter">uint256 validatorStake</span>) <span class="marker" id="mapping-303"></span><span class="token mv" id="move-src-138" data-title="function_definition/visibility">public</span> <span class="marker" id="mapping-304"></span><span class="token del" data-title="function_definition/modifier_invocation">onlyOwner</span> <span class="marker" id="mapping-305"></span><span class="token del" data-title="function_definition/function_body">{
        <span class="marker" id="mapping-306"></span><span class="token mv" id="move-src-139" data-title="function_body/variable_declaration_statement">uint256 <span class="marker" id="mapping-307"></span><span class="token upd" id="move-src-140" data-title="variable_declaration/identifier">combin<span class="cupd">e</span><span class="cupd">d</span><span class="cupd">S</span>t<span class="cupd">a</span>kePower</span> = <span class="marker" id="mapping-308"></span><span class="token del" data-title="variable_declaration_statement/call_expression">validatorStake.add(activeAmount)</span>;</span>
        <span class="marker" id="mapping-309"></span><span class="token del" data-title="function_body/expression_statement">_updateRewards(rewards, validatorStake, combinedStakePower);</span>
    }</span></span>

    <span class="marker" id="mapping-310"></span><span class="token mv" id="move-src-141" data-title="contract_body/function_definition">function <span class="marker" id="mapping-311"></span><span class="token upd" id="move-src-142" data-title="function_definition/identifier"><span class="cupd">_</span><span class="cupd">u</span>pd<span class="cupd">ateReward</span>s</span>(<span class="marker" id="mapping-312"></span><span class="token mv" id="move-src-143" data-title="function_definition/parameter">uint256 <span class="marker" id="mapping-313"></span><span class="token upd" id="move-src-144" data-title="parameter/identifier">rew<span class="cupd">a</span><span class="cupd">r</span>ds</span></span><span class="marker" id="mapping-314"></span><span class="token del" data-title="function_definition/,">,</span> <span class="marker" id="mapping-315"></span><span class="token mv" id="move-src-145" data-title="function_definition/parameter">uint256 validatorStake</span><span class="marker" id="mapping-316"></span><span class="token del" data-title="function_definition/,">,</span> <span class="marker" id="mapping-317"></span><span class="token mv" id="move-src-146" data-title="function_definition/parameter">uint256 <span class="marker" id="mapping-318"></span><span class="token upd" id="move-src-147" data-title="parameter/identifier"><span class="cupd">c</span><span class="cupd">o</span><span class="cupd">m</span>bi<span class="cupd">n</span>edStakePower</span></span>) <span class="marker" id="mapping-319"></span><span class="token del" data-title="visibility/internal">internal</span> {
        <span class="marker" id="mapping-320"></span><span class="token del" data-title="function_body/variable_declaration_statement"><span class="marker" id="mapping-321"></span><span class="token mv" id="move-src-148" data-title="variable_declaration_statement/variable_declaration">uint256 <span class="marker" id="mapping-322"></span><span class="token upd" id="move-src-149" data-title="variable_declaration/identifier">_v<span class="cupd">a</span>lidatorRewards</span></span> = <span class="marker" id="mapping-323"></span><span class="token del" data-title="variable_declaration_statement/call_expression">validatorStake.mul(rewards).div(combinedStakePower)</span>;</span>

        <span class="marker" id="mapping-324"></span><span class="token del" data-title="function_body/comment">// add validator commission from delegation rewards</span>
        if (<span class="marker" id="mapping-325"></span><span class="token upd" id="move-src-150" data-title="binary_expression/identifier"><span class="cupd">c</span>o<span class="cupd">m</span>missionR<span class="cupd">ate</span></span> <span class="marker" id="mapping-326"></span><span class="token del" data-title="binary_expression/>">&gt;</span> 0) {
            <span class="marker" id="mapping-327"></span><span class="token del" data-title="block_statement/expression_statement">_validatorRewards = _validatorRewards.add(
                rewards.sub(_validatorRewards).mul(commissionRate).div(MAX_COMMISION_RATE)
            );</span>
        }

        <span class="marker" id="mapping-328"></span><span class="token del" data-title="function_body/expression_statement">validatorRewards = validatorRewards.add(_validatorRewards);</span>

        <span class="marker" id="mapping-329"></span><span class="token mv" id="move-src-151" data-title="function_body/variable_declaration_statement">uint256 <span class="marker" id="mapping-330"></span><span class="token upd" id="move-src-152" data-title="variable_declaration/identifier">d<span class="cupd">e</span><span class="cupd">l</span>eg<span class="cupd">a</span>tor<span class="cupd">s</span>R<span class="cupd">e</span>wards</span> = <span class="marker" id="mapping-331"></span><span class="token del" data-title="variable_declaration_statement/call_expression">rewards.sub(_validatorRewards)</span>;</span>
        <span class="marker" id="mapping-332"></span><span class="token mv" id="move-src-153" data-title="function_body/variable_declaration_statement">uint256 totalShares = totalSupply();</span>
        <span class="marker" id="mapping-333"></span><span class="token mv" id="move-src-154" data-title="function_body/if_statement">if (totalShares <span class="marker" id="mapping-334"></span><span class="token del" data-title="binary_expression/>">&gt;</span> 0) {
            <span class="marker" id="mapping-335"></span><span class="token upd" id="move-src-155" data-title="assignment_expression/identifier"><span class="cupd">rewardPerShare</span></span> = <span class="marker" id="mapping-336"></span><span class="token upd" id="move-src-156" data-title="member_expression/identifier"><span class="cupd">rewardPerShare</span></span>.add(
                <span class="marker" id="mapping-337"></span><span class="token upd" id="move-src-157" data-title="member_expression/identifier">de<span class="cupd">l</span>eg<span class="cupd">at</span>ors<span class="cupd">Reward</span>s</span>.mul(REWARD_PRECISION).div(totalShares)
            );
        }</span>
    }</span>

    <span class="marker" id="mapping-338"></span><span class="token mv" id="move-src-158" data-title="contract_body/function_definition">function <span class="marker" id="mapping-339"></span><span class="token upd" id="move-src-159" data-title="function_definition/identifier">wi<span class="cupd">t</span>hdraw<span class="cupd">Reward</span>sV<span class="cupd">a</span>lidator</span>() <span class="marker" id="mapping-340"></span><span class="token del" data-title="visibility/external">external</span> <span class="marker" id="mapping-341"></span><span class="token del" data-title="function_definition/modifier_invocation">onlyOwner</span> returns (uint256) {
        <span class="marker" id="mapping-342"></span><span class="token del" data-title="function_body/variable_declaration_statement"><span class="marker" id="mapping-343"></span><span class="token mv" id="move-src-160" data-title="variable_declaration_statement/variable_declaration">uint256 <span class="marker" id="mapping-344"></span><span class="token upd" id="move-src-161" data-title="variable_declaration/identifier">_vali<span class="cupd">d</span>at<span class="cupd">o</span>rRewards</span></span> = validatorRewards;</span>
        <span class="marker" id="mapping-345"></span><span class="token del" data-title="function_body/expression_statement">validatorRewards = 0;</span>
        return <span class="marker" id="mapping-346"></span><span class="token del" data-title="return_statement/identifier">_validatorRewards</span>;
    }</span>

    <span class="marker" id="mapping-347"></span><span class="token mv" id="move-src-162" data-title="contract_body/function_definition">function _getRatePrecision() private view returns(uint256) {
        // if foundation validator, use old precision
        if (validatorId &lt; 8) {
            return EXCHANGE_RATE_PRECISION;
        } 

        return EXCHANGE_RATE_HIGH_PRECISION;
    }</span>

    function exchangeRate() public view returns (uint256) {
        uint256 totalShares = totalSupply();
        uint256 precision = _getRatePrecision();
        return
            <span class="marker" id="mapping-348"></span><span class="token mv" id="move-src-163" data-title="return_statement/call_expression">totalShares == 0
                ? precision
                : <span class="marker" id="mapping-349"></span><span class="token upd" id="move-src-164" data-title="member_expression/identifier"><span class="cupd">a</span>ctiv<span class="cupd">e</span>Amount</span>.<span class="marker" id="mapping-350"></span><span class="token upd" id="move-src-165" data-title="member_expression/identifier"><span class="cupd">m</span>ul</span>(<span class="marker" id="mapping-351"></span><span class="token mv" id="move-src-166" data-title="call_expression/call_argument">precision</span>).<span class="marker" id="mapping-352"></span><span class="token upd" id="move-src-167" data-title="member_expression/identifier">div</span>(<span class="marker" id="mapping-353"></span><span class="token mv" id="move-src-168" data-title="call_expression/call_argument">totalShares</span>)</span>;
    }

    function withdrawExchangeRate() public view returns (uint256) {
        uint256 precision = _getRatePrecision();
        if (validatorId &lt; 8) {
            // fix of potentially broken withdrawals for future unbonding
            // foundation validators have no slashing enabled and thus we can return default exchange rate
            // because without slashing rate will stay constant
            return precision;
        }

        uint256 _withdrawShares = withdrawShares;
        return
            _withdrawShares == 0
                ? precision
                : withdrawPool.mul(precision).div(_withdrawShares);
    }

    <span class="marker" id="mapping-354"></span><span class="token del" data-title="contract_body/function_definition">function buyVoucher(<span class="marker" id="mapping-355"></span><span class="token del" data-title="function_definition/parameter">uint256 _amount</span>, <span class="marker" id="mapping-356"></span><span class="token del" data-title="function_definition/parameter">uint256 _minSharesToMint</span>) <span class="marker" id="mapping-357"></span><span class="token mv" id="move-src-169" data-title="function_definition/visibility">public</span> <span class="marker" id="mapping-358"></span><span class="token del" data-title="function_definition/function_body">{
        _buyVoucher(_amount, _minSharesToMint);
    }</span></span>

    function <span class="marker" id="mapping-359"></span><span class="token upd" id="move-src-170" data-title="function_definition/identifier">_<span class="cupd">buyVoucher</span></span>(uint256 _amount, uint256 _minSharesToMint) <span class="marker" id="mapping-360"></span><span class="token del" data-title="function_definition/visibility">internal</span> returns(uint256) {
        _withdrawAndTransferReward(msg.sender);
        <span class="marker" id="mapping-361"></span><span class="token mv" id="move-src-171" data-title="function_body/variable_declaration_statement">uint256 <span class="marker" id="mapping-362"></span><span class="token upd" id="move-src-172" data-title="variable_declaration/identifier"><span class="cupd">amount</span>ToDeposit</span> = <span class="marker" id="mapping-363"></span><span class="token mv" id="move-src-173" data-title="variable_declaration_statement/call_expression">_buyShares(_amount, _minSharesToMint, msg.sender)</span>;</span>
        require(stakeManager.delegationDeposit(validatorId, amountToDeposit, msg.sender), "deposit failed");
        return amountToDeposit;
    }

    <span class="marker" id="mapping-364"></span><span class="token mv" id="move-src-174" data-title="contract_body/function_definition">function <span class="marker" id="mapping-365"></span><span class="token upd" id="move-src-175" data-title="function_definition/identifier">_<span class="cupd">getTotalStake</span></span>(address user) <span class="marker" id="mapping-366"></span><span class="token del" data-title="visibility/internal">internal</span> view returns(uint256, uint256) {
        uint256 shares = balanceOf(user);
        uint256 rate = exchangeRate();
        if (shares == 0) {
            return (0, rate);
        }

        return (rate.mul(shares).div(_getRatePrecision()), rate);
    }</span>

    <span class="marker" id="mapping-367"></span><span class="token del" data-title="contract_body/function_definition">function restake() <span class="marker" id="mapping-368"></span><span class="token mv" id="move-src-176" data-title="function_definition/visibility">public</span> <span class="marker" id="mapping-369"></span><span class="token del" data-title="function_definition/function_body">{
        _restake();
    }</span></span>

    function <span class="marker" id="mapping-370"></span><span class="token upd" id="move-src-177" data-title="function_definition/identifier">_<span class="cupd">restake</span></span>() <span class="marker" id="mapping-371"></span><span class="token del" data-title="visibility/internal">internal</span> returns(uint256) {
        uint256 liquidReward = _withdrawReward(<span class="marker" id="mapping-372"></span><span class="token del" data-title="call_argument/member_expression">msg.sender</span>);
        <span class="marker" id="mapping-373"></span><span class="token mv" id="move-src-178" data-title="function_body/expression_statement">require(liquidReward &gt;= minAmount, "Too small rewards to restake");</span>

        uint256 amountRestaked <span class="marker" id="mapping-374"></span><span class="token del" data-title="variable_declaration_statement/=">=</span> <span class="marker" id="mapping-375"></span><span class="token mv" id="move-src-179" data-title="variable_declaration_statement/call_expression">_buyShares(liquidReward, 0, <span class="marker" id="mapping-376"></span><span class="token del" data-title="call_argument/member_expression">msg.sender</span>)</span>;
        <span class="marker" id="mapping-377"></span><span class="token mv" id="move-src-180" data-title="function_body/if_statement">if (liquidReward &gt; amountRestaked) {
            // return change to the user
            require(stakeManager.transferFunds(validatorId, liquidReward - amountRestaked, <span class="marker" id="mapping-378"></span><span class="token del" data-title="call_argument/member_expression">msg.sender</span>), "Insufficent rewards");
            stakingLogger.logDelegatorClaimRewards(validatorId, <span class="marker" id="mapping-379"></span><span class="token mv" id="move-src-181" data-title="call_expression/call_argument">msg.sender</span>, liquidReward - amountRestaked);
        }</span>

        <span class="marker" id="mapping-380"></span><span class="token mv" id="move-src-182" data-title="function_body/variable_declaration_statement">(uint256 totalStaked, ) = <span class="marker" id="mapping-381"></span><span class="token upd" id="move-src-183" data-title="call_expression/identifier">_<span class="cupd">getTotalStake</span></span>(<span class="marker" id="mapping-382"></span><span class="token del" data-title="call_argument/member_expression">msg.sender</span>);</span>
        <span class="marker" id="mapping-383"></span><span class="token mv" id="move-src-184" data-title="function_body/expression_statement">stakingLogger.logDelegatorRestaked(validatorId, <span class="marker" id="mapping-384"></span><span class="token mv" id="move-src-185" data-title="call_expression/call_argument">msg.sender</span>, totalStaked);</span>

        return <span class="marker" id="mapping-385"></span><span class="token del" data-title="return_statement/identifier">amountRestaked</span>;
    }

    <span class="marker" id="mapping-386"></span><span class="token mv" id="move-src-186" data-title="contract_body/function_definition">function _buyShares(uint256 _amount, uint256 _minSharesToMint, address user) private onlyWhenUnlocked returns(uint256) {
        require(delegation, "Delegation is disabled");

        uint256 rate = exchangeRate();
        uint256 precision = _getRatePrecision();
        uint256 shares = _amount.mul(precision).div(rate);
        require(shares &gt;= _minSharesToMint, "Too much slippage");
        require(unbonds[user].shares == 0, "Ongoing exit");

        _mint(user, shares);

        // clamp amount of tokens in case resulted shares requires less tokens than anticipated
        _amount = <span class="marker" id="mapping-387"></span><span class="token del" data-title="assignment_expression/call_expression"><span class="marker" id="mapping-388"></span><span class="token del" data-title="call_expression/member_expression">_amount.sub</span>(<span class="marker" id="mapping-389"></span><span class="token del" data-title="call_expression/call_argument"><span class="marker" id="mapping-390"></span><span class="token mv" id="move-src-187" data-title="call_argument/call_expression"><span class="marker" id="mapping-391"></span><span class="token del" data-title="member_expression/binary_expression">_amount % <span class="marker" id="mapping-392"></span><span class="token mv" id="move-src-188" data-title="binary_expression/call_expression">rate.mul(shares)</span></span>.div(precision)</span></span>)</span>;

        <span class="marker" id="mapping-393"></span><span class="token mv" id="move-src-189" data-title="function_body/expression_statement">activeAmount = activeAmount.add(_amount);</span>
        stakeManager.updateValidatorState(validatorId, int256(_amount));

        StakingInfo logger = stakingLogger;
        logger.logShareMinted(validatorId, user, _amount, shares);
        logger.logStakeUpdate(validatorId);

        return _amount;
    }</span>

    <span class="marker" id="mapping-394"></span><span class="token del" data-title="contract_body/function_definition">function _reduceActiveStake(<span class="marker" id="mapping-395"></span><span class="token mv" id="move-src-190" data-title="function_definition/parameter">uint256 <span class="marker" id="mapping-396"></span><span class="token upd" id="move-src-191" data-title="parameter/identifier"><span class="cupd">a</span>c<span class="cupd">t</span>iv<span class="cupd">e</span>StakeRe<span class="cupd">d</span>uce</span></span>) <span class="marker" id="mapping-397"></span><span class="token mv" id="move-src-192" data-title="function_definition/visibility">private</span> <span class="marker" id="mapping-398"></span><span class="token del" data-title="function_definition/function_body">{
        <span class="marker" id="mapping-399"></span><span class="token mv" id="move-src-193" data-title="function_body/expression_statement">activeAmount = activeAmount.sub(<span class="marker" id="mapping-400"></span><span class="token upd" id="move-src-194" data-title="call_argument/identifier"><span class="cupd">a</span>ctiveStakeReduce</span>);</span>
    }</span></span>

    <span class="marker" id="mapping-401"></span><span class="token del" data-title="contract_body/function_definition">function _reduceWithdrawPool(<span class="marker" id="mapping-402"></span><span class="token mv" id="move-src-195" data-title="function_definition/parameter">uint256 <span class="marker" id="mapping-403"></span><span class="token upd" id="move-src-196" data-title="parameter/identifier">with<span class="cupd">d</span>rawP<span class="cupd">o</span>olRedu<span class="cupd">ce</span></span></span>) <span class="marker" id="mapping-404"></span><span class="token mv" id="move-src-197" data-title="function_definition/visibility">private</span> <span class="marker" id="mapping-405"></span><span class="token del" data-title="function_definition/function_body">{
        <span class="marker" id="mapping-406"></span><span class="token mv" id="move-src-198" data-title="function_body/expression_statement">withdrawPool = withdrawPool.sub(<span class="marker" id="mapping-407"></span><span class="token del" data-title="call_expression/call_argument">withdrawPoolReduce</span>);</span>
    }</span></span>

    <span class="marker" id="mapping-408"></span><span class="token mv" id="move-src-199" data-title="contract_body/function_definition">function <span class="marker" id="mapping-409"></span><span class="token upd" id="move-src-200" data-title="function_definition/identifier"><span class="cupd">sellVoucher</span></span>(uint256 claimAmount, uint256 maximumSharesToBurn) <span class="marker" id="mapping-410"></span><span class="token mv" id="move-src-201" data-title="function_definition/visibility">public</span> {
        // first get how much staked in total and compare to target unstake amount
        <span class="marker" id="mapping-411"></span><span class="token mv" id="move-src-202" data-title="function_body/variable_declaration_statement">(uint256 totalStaked, uint256 rate) = <span class="marker" id="mapping-412"></span><span class="token mv" id="move-src-203" data-title="variable_declaration_statement/call_expression"><span class="marker" id="mapping-413"></span><span class="token upd" id="move-src-204" data-title="call_expression/identifier">_<span class="cupd">getTotalStake</span></span>(msg.sender)</span>;</span>
        require(totalStaked <span class="marker" id="mapping-414"></span><span class="token del" data-title="binary_expression/>">&gt;</span> 0 &amp;&amp; totalStaked &gt;= claimAmount, "Too much requested");

        // convert requested amount back to shares
        uint256 precision = _getRatePrecision();
        uint256 shares = claimAmount.mul(precision).div(rate);
        require(shares &lt;= maximumSharesToBurn, "too much slippage");

        _withdrawAndTransferReward(msg.sender);
        
        _burn(msg.sender, shares);
        stakeManager.updateValidatorState(validatorId, -int256(claimAmount));

        <span class="marker" id="mapping-415"></span><span class="token del" data-title="expression_statement/call_expression">_reduceActiveStake(<span class="marker" id="mapping-416"></span><span class="token mv" id="move-src-205" data-title="call_expression/call_argument">claimAmount</span>)</span>;

        uint256 _withdrawPoolShare = claimAmount.mul(precision).div(withdrawExchangeRate());
        withdrawPool = withdrawPool.add(claimAmount);
        withdrawShares = withdrawShares.add(_withdrawPoolShare);
        
        <span class="marker" id="mapping-417"></span><span class="token mv" id="move-src-206" data-title="function_body/variable_declaration_statement">DelegatorUnbond memory unbond = unbonds[msg.sender];</span>
        <span class="marker" id="mapping-418"></span><span class="token mv" id="move-src-207" data-title="function_body/expression_statement">unbond.shares = unbond.shares.add(_withdrawPoolShare);</span>
        <span class="marker" id="mapping-419"></span><span class="token del" data-title="function_body/comment">// refresh undond period</span>
        <span class="marker" id="mapping-420"></span><span class="token mv" id="move-src-208" data-title="function_body/expression_statement">unbond.withdrawEpoch = stakeManager.epoch();</span>
        <span class="marker" id="mapping-421"></span><span class="token mv" id="move-src-209" data-title="function_body/expression_statement">unbonds[msg.sender] = unbond;</span>

        <span class="marker" id="mapping-422"></span><span class="token mv" id="move-src-210" data-title="function_body/variable_declaration_statement">StakingInfo logger = stakingLogger;</span>
        <span class="marker" id="mapping-423"></span><span class="token mv" id="move-src-211" data-title="function_body/expression_statement">logger.logShareBurned(validatorId, msg.sender, claimAmount, shares);</span>
        <span class="marker" id="mapping-424"></span><span class="token mv" id="move-src-212" data-title="function_body/expression_statement">logger.logStakeUpdate(validatorId);</span>
    }</span>

    <span class="marker" id="mapping-425"></span><span class="token mv" id="move-src-213" data-title="contract_body/function_definition">function _withdrawReward(address user) private returns(uint256) {
        uint256 liquidRewards = <span class="marker" id="mapping-426"></span><span class="token mv" id="move-src-214" data-title="variable_declaration_statement/call_expression"><span class="marker" id="mapping-427"></span><span class="token upd" id="move-src-215" data-title="call_expression/identifier"><span class="cupd">get</span>LiquidRewards</span>(user)</span>;
        initalRewardPerShare[user] = <span class="marker" id="mapping-428"></span><span class="token upd" id="move-src-216" data-title="assignment_expression/identifier"><span class="cupd">rewardPerShare</span></span>;
        return liquidRewards;
    }</span>

    <span class="marker" id="mapping-429"></span><span class="token mv" id="move-src-217" data-title="contract_body/function_definition">function _withdrawAndTransferReward(address user) private returns(uint256) {
        uint256 liquidRewards = _withdrawReward(user);
        if (liquidRewards <span class="marker" id="mapping-430"></span><span class="token del" data-title="binary_expression/>">&gt;</span> 0) {
            require(stakeManager.transferFunds(validatorId, liquidRewards, user), "Insufficent rewards");
            stakingLogger.logDelegatorClaimRewards(validatorId, user, liquidRewards);
        }
        
        return liquidRewards;
    }</span>

    function withdrawRewards() public {
        uint256 rewards = _withdrawAndTransferReward(msg.sender);
        require(rewards &gt;= minAmount, "Too small rewards amount");
    }

    function migrateOut(address user, uint256 amount) external onlyOwner {
        _withdrawAndTransferReward(user);
        <span class="marker" id="mapping-431"></span><span class="token mv" id="move-src-218" data-title="function_body/variable_declaration_statement">(uint256 totalStaked, uint256 rate) = <span class="marker" id="mapping-432"></span><span class="token del" data-title="variable_declaration_statement/call_expression">_getTotalStake(<span class="marker" id="mapping-433"></span><span class="token mv" id="move-src-219" data-title="call_expression/call_argument">user</span>)</span>;</span>
        require(totalStaked &gt;= amount, "Migrating too much");

        uint256 precision = _getRatePrecision();
        uint256 shares = amount.mul(precision).div(rate);
        _burn(user, shares);

        stakeManager.updateValidatorState(validatorId, -int256(amount));
        <span class="marker" id="mapping-434"></span><span class="token del" data-title="function_body/expression_statement"><span class="marker" id="mapping-435"></span><span class="token del" data-title="expression_statement/call_expression">_reduceActiveStake(<span class="marker" id="mapping-436"></span><span class="token mv" id="move-src-220" data-title="call_expression/call_argument">amount</span>)</span>;</span>

        stakingLogger.logShareBurned(validatorId, user, amount, shares);
        stakingLogger.logStakeUpdate(validatorId);
        stakingLogger.logDelegatorUnstaked(validatorId, user, amount);
    }

    function migrateIn(address user, uint256 amount) external onlyOwner {
        _withdrawAndTransferReward(user);
        _buyShares(amount, 0, user);
    }

    <span class="marker" id="mapping-437"></span><span class="token mv" id="move-src-221" data-title="contract_body/function_definition">function <span class="marker" id="mapping-438"></span><span class="token upd" id="move-src-222" data-title="function_definition/identifier">g<span class="cupd">e</span>tLiquid<span class="cupd">Reward</span>s</span>(address user) <span class="marker" id="mapping-439"></span><span class="token mv" id="move-src-223" data-title="function_definition/visibility">public</span> view returns (uint256) {
        uint256 shares = balanceOf(user);
        if (shares == 0) {
            return 0;
        }

        return <span class="marker" id="mapping-440"></span><span class="token upd" id="move-src-224" data-title="member_expression/identifier"><span class="cupd">rewardPerShare</span></span>.sub(<span class="marker" id="mapping-441"></span><span class="token mv" id="move-src-225" data-title="call_argument/array_access">initalRewardPerShare[user]</span>).mul(shares).div(REWARD_PRECISION);
    }</span>

    <span class="marker" id="mapping-442"></span><span class="token del" data-title="contract_body/function_definition">function unstakeClaimTokens() <span class="marker" id="mapping-443"></span><span class="token mv" id="move-src-226" data-title="function_definition/visibility">public</span> <span class="marker" id="mapping-444"></span><span class="token del" data-title="function_definition/function_body">{
        _claimUnstakedTokens();
    }</span></span>

    <span class="marker" id="mapping-445"></span><span class="token mv" id="move-src-227" data-title="contract_body/function_definition">function <span class="marker" id="mapping-446"></span><span class="token upd" id="move-src-228" data-title="function_definition/identifier"><span class="cupd">_</span>claimU<span class="cupd">nstake</span>d<span class="cupd">Tokens</span></span>() <span class="marker" id="mapping-447"></span><span class="token mv" id="move-src-229" data-title="function_definition/visibility">internal</span> returns(uint256) {
        <span class="marker" id="mapping-448"></span><span class="token mv" id="move-src-230" data-title="function_body/variable_declaration_statement">DelegatorUnbond memory unbond = unbonds[msg.sender];</span>

        uint256 shares = unbond.shares;
        require(
            unbond.withdrawEpoch.add(stakeManager.withdrawalDelay()) &lt;= stakeManager.epoch() &amp;&amp; shares &gt; 0,
            "Incomplete withdrawal period"
        );

        uint256 _amount = withdrawExchangeRate().mul(shares).div(_getRatePrecision());
        withdrawShares = withdrawShares.sub(shares);
        withdrawPool = withdrawPool.sub(_amount);

        require(stakeManager.transferFunds(validatorId, _amount, msg.sender), "Insufficent rewards");
        <span class="marker" id="mapping-449"></span><span class="token mv" id="move-src-231" data-title="function_body/expression_statement">stakingLogger.logDelegatorUnstaked(validatorId, msg.sender, <span class="marker" id="mapping-450"></span><span class="token upd" id="move-src-232" data-title="call_argument/identifier">_<span class="cupd">amount</span></span>);</span>
        <span class="marker" id="mapping-451"></span><span class="token mv" id="move-src-233" data-title="function_body/expression_statement">delete unbonds[msg.sender];</span>

        return _amount;
    }</span>

    function slash(<span class="marker" id="mapping-452"></span><span class="token del" data-title="function_definition/parameter">uint256 valPow</span>, uint256 totalAmountToSlash) external onlyOwner returns (uint256) {
        uint256 _withdrawPool = withdrawPool;
        uint256 delegationAmount = <span class="marker" id="mapping-453"></span><span class="token upd" id="move-src-234" data-title="member_expression/identifier"><span class="cupd">a</span>c<span class="cupd">t</span>iv<span class="cupd">e</span><span class="cupd">Amount</span></span>.add(_withdrawPool);
        if (delegationAmount == 0) {
            return 0;
        }
        // total amount to be slashed from delegation pool (active + inactive)
        uint256 _amountToSlash = delegationAmount.mul(totalAmountToSlash).div(<span class="marker" id="mapping-454"></span><span class="token del" data-title="call_argument/call_expression"><span class="marker" id="mapping-455"></span><span class="token del" data-title="call_expression/member_expression">valPow.add</span>(<span class="marker" id="mapping-456"></span><span class="token mv" id="move-src-235" data-title="call_expression/call_argument">delegationAmount</span>)</span>);
        uint256 _amountToSlashWithdrawalPool = _withdrawPool.mul(_amountToSlash).div(delegationAmount);

        // slash inactive pool
        <span class="marker" id="mapping-457"></span><span class="token del" data-title="function_body/expression_statement"><span class="marker" id="mapping-458"></span><span class="token del" data-title="expression_statement/call_expression">_reduceActiveStake(<span class="marker" id="mapping-459"></span><span class="token del" data-title="call_expression/call_argument"><span class="marker" id="mapping-460"></span><span class="token mv" id="move-src-236" data-title="call_argument/call_expression">_amountToSlash.sub(_amountToSlashWithdrawalPool)</span></span>)</span>;</span>
        <span class="marker" id="mapping-461"></span><span class="token del" data-title="function_body/expression_statement"><span class="marker" id="mapping-462"></span><span class="token del" data-title="expression_statement/call_expression">_reduceWithdrawPool(<span class="marker" id="mapping-463"></span><span class="token mv" id="move-src-237" data-title="call_expression/call_argument">_amountToSlashWithdrawalPool</span>)</span>;</span>
        return _amountToSlash;
    }

    function updateDelegation(bool _delegation) external onlyOwner {
        delegation = _delegation;
    }

    function drain(
        address token,
        address payable destination,
        uint256 amount
    ) external onlyOwner {
        if (token == address(0x0)) {
            destination.transfer(amount);
        } else {
            require(ERC20(token).transfer(destination, amount), "Drain failed");
        }
    }

    <span class="marker" id="mapping-464"></span><span class="token del" data-title="contract_body/function_definition">function getActiveAmount() <span class="marker" id="mapping-465"></span><span class="token del" data-title="function_definition/visibility">external</span> <span class="marker" id="mapping-466"></span><span class="token mv" id="move-src-238" data-title="function_definition/state_mutability">view</span> <span class="marker" id="mapping-467"></span><span class="token mv" id="move-src-239" data-title="function_definition/return_type_definition">returns(uint256)</span> <span class="marker" id="mapping-468"></span><span class="token del" data-title="function_definition/function_body">{
        return activeAmount;
    }</span></span>

    <span class="marker" id="mapping-469"></span><span class="token del" data-title="contract_body/function_definition">function unlockContract() external onlyOwner returns (uint256) {
        unlock();
        return activeAmount;
    }</span>

    <span class="marker" id="mapping-470"></span><span class="token del" data-title="contract_body/function_definition">function lockContract() external onlyOwner returns (uint256) {
        lock();
        return activeAmount;
    }</span>
}</pre></div><div class="col-6"><h5>0x01d5dc56ad4206bb0c132d834644d57f51fed5ec.etherscan.io-ValidatorShare.sol</h5><pre class="pre-scrollable"><span class="marker" id="mapping-471"></span><span class="token upd" id="move-dst-1" data-title="source_file/comment"><span class="cupd">/</span>/<span class="cupd"> </span>F<span class="cupd">i</span>l<span class="cupd">e</span>:<span class="cupd"> </span>c<span class="cupd">o</span>nt<span class="cupd">r</span>acts/common/go<span class="cupd">ver</span>n<span class="cupd">a</span><span class="cupd">n</span>c<span class="cupd">e</span>/IGove<span class="cupd">r</span>n<span class="cupd">an</span>ce<span class="cupd">.</span>sol</span>

pragma solidity ^0.5.2;

<span class="marker" id="mapping-472"></span><span class="token mv" id="move-dst-17" data-title="source_file/interface_declaration">interface IGovernance {
    function update(address target, bytes calldata data) external;
}</span>

<span class="marker" id="mapping-473"></span><span class="token mv" id="move-dst-7" data-title="source_file/comment"><span class="marker" id="mapping-474"></span><span class="token upd" id="move-dst-7" data-title="source_file/comment"><span class="cupd">// File: contracts/common/</span>g<span class="cupd">o</span>v<span class="cupd">e</span>r<span class="cupd">n</span>ance<span class="cupd">/</span>G<span class="cupd">o</span>ve<span class="cupd">r</span><span class="cupd">n</span><span class="cupd">able.sol</span></span></span>

<span class="marker" id="mapping-475"></span><span class="token mv" id="move-dst-25" data-title="source_file/pragma_directive">pragma solidity ^0.5.2;</span>


<span class="marker" id="mapping-476"></span><span class="token mv" id="move-dst-21" data-title="source_file/contract_declaration">contract Governable {
    IGovernance public governance;

    constructor(address _governance) public {
        governance = IGovernance(_governance);
    }

    modifier onlyGovernance() <span class="marker" id="mapping-477"></span><span class="token add" data-title="modifier_definition/function_body">{
        <span class="marker" id="mapping-478"></span><span class="token add" data-title="function_body/expression_statement">_assertGovernance();</span>
        <span class="marker" id="mapping-479"></span><span class="token mv" id="move-dst-23" data-title="function_body/expression_statement">_;</span>
    }</span>

    <span class="marker" id="mapping-480"></span><span class="token add" data-title="contract_body/function_definition">function _assertGovernance() <span class="marker" id="mapping-481"></span><span class="token add" data-title="function_definition/visibility">private</span> <span class="marker" id="mapping-482"></span><span class="token add" data-title="function_definition/state_mutability">view</span> <span class="marker" id="mapping-483"></span><span class="token mv" id="move-dst-22" data-title="function_definition/function_body">{
        require(
            msg.sender == address(governance),
            "Only governance contract is authorized"
        );
    }</span></span>
}</span>

<span class="marker" id="mapping-484"></span><span class="token mv" id="move-dst-15" data-title="source_file/comment"><span class="marker" id="mapping-485"></span><span class="token upd" id="move-dst-15" data-title="source_file/comment"><span class="cupd">// File: contracts/</span>r<span class="cupd">o</span><span class="cupd">o</span>t<span class="cupd">/</span>withd<span class="cupd">r</span>awMa<span class="cupd">na</span>g<span class="cupd">e</span>r<span class="cupd">/I</span>Withd<span class="cupd">r</span>awMa<span class="cupd">na</span>g<span class="cupd">e</span>r<span class="cupd">.sol</span></span></span>

<span class="marker" id="mapping-486"></span><span class="token mv" id="move-dst-3" data-title="source_file/pragma_directive">pragma solidity ^0.5.2;</span>

<span class="marker" id="mapping-487"></span><span class="token mv" id="move-dst-26" data-title="source_file/contract_declaration">contract IWithdrawManager {
    function createExitQueue(address token) external;

    function verifyInclusion(
        bytes calldata data,
        uint8 offset,
        bool verifyTxInclusion
    ) external view returns (uint256 age);

    function addExitToQueue(
        address exitor,
        address childToken,
        address rootToken,
        uint256 exitAmountOrTokenId,
        bytes32 txHash,
        bool isRegularExit,
        uint256 priority
    ) external;

    function addInput(
        uint256 exitId,
        uint256 age,
        address utxoOwner,
        address token
    ) external;

    function challengeExit(
        uint256 exitId,
        uint256 inputId,
        bytes calldata challengeData,
        address adjudicatorPredicate
    ) external;
}</span>

<span class="marker" id="mapping-488"></span><span class="token mv" id="move-dst-19" data-title="source_file/comment"><span class="marker" id="mapping-489"></span><span class="token upd" id="move-dst-19" data-title="source_file/comment"><span class="cupd">// File: contracts/common/</span>Re<span class="cupd">g</span>ist<span class="cupd">r</span>y<span class="cupd">.sol</span></span></span>

<span class="marker" id="mapping-490"></span><span class="token mv" id="move-dst-4" data-title="source_file/pragma_directive">pragma solidity ^0.5.2;</span>




<span class="marker" id="mapping-491"></span><span class="token mv" id="move-dst-29" data-title="source_file/contract_declaration">contract Registry is Governable {
    // @todo hardcode constants
    bytes32 private constant WETH_TOKEN = keccak256("wethToken");
    bytes32 private constant DEPOSIT_MANAGER = keccak256("depositManager");
    bytes32 private constant STAKE_MANAGER = keccak256("stakeManager");
    bytes32 private constant VALIDATOR_SHARE = keccak256("validatorShare");
    bytes32 private constant WITHDRAW_MANAGER = keccak256("withdrawManager");
    bytes32 private constant CHILD_CHAIN = keccak256("childChain");
    bytes32 private constant STATE_SENDER = keccak256("stateSender");
    bytes32 private constant SLASHING_MANAGER = keccak256("slashingManager");

    address public erc20Predicate;
    address public erc721Predicate;

    mapping(bytes32 =&gt; address) public contractMap;
    mapping(address =&gt; address) public rootToChildToken;
    mapping(address =&gt; address) public childToRootToken;
    mapping(address =&gt; bool) public proofValidatorContracts;
    mapping(address =&gt; bool) public isERC721;

    enum Type {Invalid, ERC20, ERC721, Custom}
    struct Predicate {
        Type _type;
    }
    mapping(address =&gt; Predicate) public predicates;

    event TokenMapped(address indexed rootToken, address indexed childToken);
    event ProofValidatorAdded(address indexed validator, address indexed from);
    event ProofValidatorRemoved(address indexed validator, address indexed from);
    event PredicateAdded(address indexed predicate, address indexed from);
    event PredicateRemoved(address indexed predicate, address indexed from);
    event ContractMapUpdated(bytes32 indexed key, address indexed previousContract, address indexed newContract);

    constructor(address _governance) public Governable(_governance) {}

    function updateContractMap(bytes32 _key, address _address) external onlyGovernance {
        emit ContractMapUpdated(_key, contractMap[_key], _address);
        contractMap[_key] = _address;
    }

    /**
     * @dev Map root token to child token
     * @param _rootToken Token address on the root chain
     * @param _childToken Token address on the child chain
     * @param _isERC721 Is the token being mapped ERC721
     */
    function mapToken(
        address _rootToken,
        address _childToken,
        bool _isERC721
    ) external onlyGovernance {
        require(_rootToken != address(0x0) &amp;&amp; _childToken != address(0x0), "INVALID_TOKEN_ADDRESS");
        rootToChildToken[_rootToken] = _childToken;
        childToRootToken[_childToken] = _rootToken;
        isERC721[_rootToken] = _isERC721;
        IWithdrawManager(contractMap[WITHDRAW_MANAGER]).createExitQueue(_rootToken);
        emit TokenMapped(_rootToken, _childToken);
    }

    function addErc20Predicate(address predicate) public onlyGovernance {
        require(predicate != address(0x0), "Can not add null address as predicate");
        erc20Predicate = predicate;
        addPredicate(predicate, Type.ERC20);
    }

    function addErc721Predicate(address predicate) public onlyGovernance {
        erc721Predicate = predicate;
        addPredicate(predicate, Type.ERC721);
    }

    function addPredicate(address predicate, Type _type) public onlyGovernance {
        require(predicates[predicate]._type == Type.Invalid, "Predicate already added");
        predicates[predicate]._type = _type;
        emit PredicateAdded(predicate, msg.sender);
    }

    function removePredicate(address predicate) public onlyGovernance {
        require(predicates[predicate]._type != Type.Invalid, "Predicate does not exist");
        delete predicates[predicate];
        emit PredicateRemoved(predicate, msg.sender);
    }

    function getValidatorShareAddress() public view returns (address) {
        return contractMap[VALIDATOR_SHARE];
    }

    function getWethTokenAddress() public view returns (address) {
        return contractMap[WETH_TOKEN];
    }

    function getDepositManagerAddress() public view returns (address) {
        return contractMap[DEPOSIT_MANAGER];
    }

    function getStakeManagerAddress() public view returns (address) {
        return contractMap[STAKE_MANAGER];
    }

    function getSlashingManagerAddress() public view returns (address) {
        return contractMap[SLASHING_MANAGER];
    }

    function getWithdrawManagerAddress() public view returns (address) {
        return contractMap[WITHDRAW_MANAGER];
    }

    function getChildChainAndStateSender() public view returns (address, address) {
        return (contractMap[CHILD_CHAIN], contractMap[STATE_SENDER]);
    }

    function isTokenMapped(address _token) public view returns (bool) {
        return rootToChildToken[_token] != address(0x0);
    }

    function isTokenMappedAndIsErc721(address _token) public view returns (bool) {
        require(isTokenMapped(_token), "TOKEN_NOT_MAPPED");
        return isERC721[_token];
    }

    function isTokenMappedAndGetPredicate(address _token) public view returns (address) {
        if (isTokenMappedAndIsErc721(_token)) {
            return erc721Predicate;
        }
        return erc20Predicate;
    }

    function isChildTokenErc721(address childToken) public view returns (bool) {
        address rootToken = childToRootToken[childToken];
        require(rootToken != address(0x0), "Child token is not mapped");
        return isERC721[rootToken];
    }
}</span>

<span class="marker" id="mapping-492"></span><span class="token mv" id="move-dst-2" data-title="source_file/comment">// File: openzeppelin-solidity/contracts/token/ERC20/IERC20.sol</span>

<span class="marker" id="mapping-493"></span><span class="token mv" id="move-dst-8" data-title="source_file/pragma_directive">pragma solidity ^0.5.2;</span>

/**
 * @title ERC20 interface
 * @dev see https://eips.ethereum.org/EIPS/eip-20
 */
interface IERC20 {
    function transfer(address to, uint256 value) external returns (bool);

    function approve(address spender, uint256 value) external returns (bool);

    function transferFrom(address from, address to, uint256 value) external returns (bool);

    function totalSupply() external view returns (uint256);

    function balanceOf(address who) external view returns (uint256);

    function allowance(address owner, address spender) external view returns (uint256);

    event Transfer(address indexed from, address indexed to, uint256 value);

    event Approval(address indexed owner, address indexed spender, uint256 value);
}

// File: openzeppelin-solidity/contracts/math/SafeMath.sol

<span class="marker" id="mapping-494"></span><span class="token mv" id="move-dst-16" data-title="source_file/pragma_directive">pragma solidity ^0.5.2;</span>

/**
 * @title SafeMath
 * @dev Unsigned math operations with safety checks that revert on error
 */
library SafeMath {
    /**
     * @dev Multiplies two unsigned integers, reverts on overflow.
     */
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the
        // benefit is lost if 'b' is also tested.
        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522
        if (a == 0) {
            return 0;
        }

        uint256 c = a * b;
        require(c / a == b);

        return c;
    }

    /**
     * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.
     */
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        // Solidity only automatically asserts when dividing by 0
        require(b &gt; 0);
        uint256 c = a / b;
        // assert(a == b * c + a % b); // There is no case in which this doesn't hold

        return c;
    }

    /**
     * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).
     */
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b &lt;= a);
        uint256 c = a - b;

        return c;
    }

    /**
     * @dev Adds two unsigned integers, reverts on overflow.
     */
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c &gt;= a);

        return c;
    }

    /**
     * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),
     * reverts when dividing by zero.
     */
    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b != 0);
        return a % b;
    }
}

// File: openzeppelin-solidity/contracts/token/ERC20/ERC20.sol

<span class="marker" id="mapping-495"></span><span class="token mv" id="move-dst-20" data-title="source_file/pragma_directive">pragma solidity ^0.5.2;</span>



/**
 * @title Standard ERC20 token
 *
 * @dev Implementation of the basic standard token.
 * https://eips.ethereum.org/EIPS/eip-20
 * Originally based on code by FirstBlood:
 * https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol
 *
 * This implementation emits additional Approval events, allowing applications to reconstruct the allowance status for
 * all accounts just by listening to said events. Note that this isn't required by the specification, and other
 * compliant implementations may not do it.
 */
contract ERC20 is IERC20 {
    using SafeMath for uint256;

    mapping (address =&gt; uint256) private _balances;

    mapping (address =&gt; mapping (address =&gt; uint256)) private _allowed;

    uint256 private _totalSupply;

    /**
     * @dev Total number of tokens in existence
     */
    function totalSupply() public view returns (uint256) {
        return _totalSupply;
    }

    /**
     * @dev Gets the balance of the specified address.
     * @param owner The address to query the balance of.
     * @return A uint256 representing the amount owned by the passed address.
     */
    function balanceOf(address owner) public view returns (uint256) {
        return _balances[owner];
    }

    /**
     * @dev Function to check the amount of tokens that an owner allowed to a spender.
     * @param owner address The address which owns the funds.
     * @param spender address The address which will spend the funds.
     * @return A uint256 specifying the amount of tokens still available for the spender.
     */
    function allowance(address owner, address spender) public view returns (uint256) {
        return _allowed[owner][spender];
    }

    /**
     * @dev Transfer token to a specified address
     * @param to The address to transfer to.
     * @param value The amount to be transferred.
     */
    function transfer(address to, uint256 value) public returns (bool) {
        _transfer(msg.sender, to, value);
        return true;
    }

    /**
     * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.
     * Beware that changing an allowance with this method brings the risk that someone may use both the old
     * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this
     * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:
     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
     * @param spender The address which will spend the funds.
     * @param value The amount of tokens to be spent.
     */
    function approve(address spender, uint256 value) public returns (bool) {
        _approve(msg.sender, spender, value);
        return true;
    }

    <span class="marker" id="mapping-496"></span><span class="token upd" id="move-dst-5" data-title="contract_body/comment"><span class="cupd">/**
     * @dev Transfer tokens from one address to another.
     * Note that while this function emits an Approval event, this is not required as per the specification,
     * and other compliant implementations may not emit the event.
     * @param from address The address which you want to send tokens from
     * @param to address The address which you want </span>to t<span class="cupd">r vbmansfer to
     * @param value uint256 the amount of tokens to be transferred
</span>     */</span>
    function transferFrom(address from, address to, uint256 value) public returns (bool) {
        _transfer(from, to, value);
        _approve(from, msg.sender, _allowed[from][msg.sender].sub(value));
        return true;
    }

    /**
     * @dev Increase the amount of tokens that an owner allowed to a spender.
     * approve should be called when _allowed[msg.sender][spender] == 0. To increment
     * allowed value is better to use this function to avoid 2 calls (and wait until
     * the first transaction is mined)
     * From MonolithDAO Token.sol
     * Emits an Approval event.
     * @param spender The address which will spend the funds.
     * @param addedValue The amount of tokens to increase the allowance by.
     */
    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {
        _approve(msg.sender, spender, _allowed[msg.sender][spender].add(addedValue));
        return true;
    }

    /**
     * @dev Decrease the amount of tokens that an owner allowed to a spender.
     * approve should be called when _allowed[msg.sender][spender] == 0. To decrement
     * allowed value is better to use this function to avoid 2 calls (and wait until
     * the first transaction is mined)
     * From MonolithDAO Token.sol
     * Emits an Approval event.
     * @param spender The address which will spend the funds.
     * @param subtractedValue The amount of tokens to decrease the allowance by.
     */
    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {
        _approve(msg.sender, spender, _allowed[msg.sender][spender].sub(subtractedValue));
        return true;
    }

    /**
     * @dev Transfer token for a specified addresses
     * @param from The address to transfer from.
     * @param to The address to transfer to.
     * @param value The amount to be transferred.
     */
    function _transfer(address from, address to, uint256 value) internal {
        require(to != address(0));

        _balances[from] = _balances[from].sub(value);
        _balances[to] = _balances[to].add(value);
        emit Transfer(from, to, value);
    }

    /**
     * @dev Internal function that mints an amount of the token and assigns it to
     * an account. This encapsulates the modification of balances such that the
     * proper events are emitted.
     * @param account The account that will receive the created tokens.
     * @param value The amount that will be created.
     */
    function _mint(address account, uint256 value) internal {
        require(account != address(0));

        _totalSupply = _totalSupply.add(value);
        _balances[account] = _balances[account].add(value);
        emit Transfer(address(0), account, value);
    }

    /**
     * @dev Internal function that burns an amount of the token of a given
     * account.
     * @param account The account whose tokens will be burnt.
     * @param value The amount that will be burnt.
     */
    function _burn(address account, uint256 value) internal {
        require(account != address(0));

        _totalSupply = _totalSupply.sub(value);
        _balances[account] = _balances[account].sub(value);
        emit Transfer(account, address(0), value);
    }

    /**
     * @dev Approve an address to spend another addresses' tokens.
     * @param owner The address that owns the tokens.
     * @param spender The address that will spend the tokens.
     * @param value The number of tokens that can be spent.
     */
    function _approve(address owner, address spender, uint256 value) internal {
        require(spender != address(0));
        require(owner != address(0));

        _allowed[owner][spender] = value;
        emit Approval(owner, spender, value);
    }

    /**
     * @dev Internal function that burns an amount of the token of a given
     * account, deducting from the sender's allowance for said account. Uses the
     * internal burn function.
     * Emits an Approval event (reflecting the reduced allowance).
     * @param account The account whose tokens will be burnt.
     * @param value The amount that will be burnt.
     */
    function _burnFrom(address account, uint256 value) internal {
        _burn(account, value);
        _approve(account, msg.sender, _allowed[account][msg.sender].sub(value));
    }
}

<span class="marker" id="mapping-497"></span><span class="token upd" id="move-dst-24" data-title="source_file/comment"><span class="cupd">// File: contracts/</span>c<span class="cupd">o</span>mm<span class="cupd">o</span>n<span class="cupd">/</span><span class="cupd">t</span>oke<span class="cupd">n</span>s<span class="cupd">/</span>ERC20NonT<span class="cupd">ra</span>d<span class="cupd">a</span>bl<span class="cupd">e</span><span class="cupd">.sol</span></span>

pragma solidity ^0.5.2;


<span class="marker" id="mapping-498"></span><span class="token mv" id="move-dst-9" data-title="source_file/contract_declaration">contract <span class="marker" id="mapping-499"></span><span class="token upd" id="move-dst-10" data-title="contract_declaration/identifier"><span class="cupd">ERC20NonTra</span>d<span class="cupd">able</span></span> is ERC20 {
    function <span class="marker" id="mapping-500"></span><span class="token upd" id="move-dst-11" data-title="function_definition/identifier"><span class="cupd">_</span>app<span class="cupd">r</span>ove</span>(
        <span class="marker" id="mapping-501"></span><span class="token add" data-title="function_definition/parameter"><span class="marker" id="mapping-502"></span><span class="token mv" id="move-dst-56" data-title="parameter/type_name">address</span> owner</span>,
        <span class="marker" id="mapping-503"></span><span class="token mv" id="move-dst-60" data-title="function_definition/parameter">address <span class="marker" id="mapping-504"></span><span class="token upd" id="move-dst-61" data-title="parameter/identifier"><span class="cupd">s</span>pe<span class="cupd">n</span>d<span class="cupd">er</span></span></span>,
        uint256 value
    ) internal {
        revert("disabled");
    }
}</span>

// File: openzeppelin-solidity/contracts/ownership/Ownable.sol

pragma solidity ^0.5.2;

/**
 * @title Ownable
 * @dev The Ownable contract has an owner address, and provides basic authorization control
 * functions, this simplifies the implementation of "user permissions".
 */
contract Ownable {
    address private _owner;

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    /**
     * @dev The Ownable constructor sets the original `owner` of the contract to the sender
     * account.
     */
    constructor () internal {
        _owner = msg.sender;
        emit OwnershipTransferred(address(0), _owner);
    }

    /**
     * @return the address of the owner.
     */
    function owner() public view returns (address) {
        return _owner;
    }

    /**
     * @dev Throws if called by any account other than the owner.
     */
    modifier onlyOwner() {
        require(isOwner());
        _;
    }

    /**
     * @return true if `msg.sender` is the owner of the contract.
     */
    function isOwner() public view returns (bool) {
        return msg.sender == _owner;
    }

    /**
     * @dev Allows the current owner to relinquish control of the contract.
     * It will not be possible to call the functions with the `onlyOwner`
     * modifier anymore.
     * @notice Renouncing ownership will leave the contract without an owner,
     * thereby removing any functionality that is only available to the owner.
     */
    function renounceOwnership() public onlyOwner {
        emit OwnershipTransferred(_owner, address(0));
        _owner = address(0);
    }

    /**
     * @dev Allows the current owner to transfer control of the contract to a newOwner.
     * @param newOwner The address to transfer ownership to.
     */
    function transferOwnership(address newOwner) public onlyOwner {
        _transferOwnership(newOwner);
    }

    /**
     * @dev Transfers control of the contract to a newOwner.
     * @param newOwner The address to transfer ownership to.
     */
    function _transferOwnership(address newOwner) internal {
        require(newOwner != address(0));
        emit OwnershipTransferred(_owner, newOwner);
        _owner = newOwner;
    }
}

// File: contracts/staking/StakingInfo.sol

<span class="marker" id="mapping-505"></span><span class="token mv" id="move-dst-32" data-title="source_file/pragma_directive">pragma solidity ^0.5.2;</span>





// dummy interface to avoid cyclic dependency
contract IStakeManagerLocal {
    enum Status {Inactive, Active, Locked, Unstaked}

    struct Validator {
        uint256 amount;
        uint256 reward;
        uint256 activationEpoch;
        uint256 deactivationEpoch;
        uint256 jailTime;
        address signer;
        address contractAddress;
        Status status;
    }

    mapping(uint256 =&gt; Validator) public validators;
    bytes32 public accountStateRoot;
    uint256 public activeAmount; // delegation amount from validator contract
    uint256 public validatorRewards;

    function currentValidatorSetTotalStake() public view returns (uint256);

    // signer to Validator mapping
    function signerToValidator(address validatorAddress)
        public
        view
        returns (uint256);

    function isValidator(uint256 validatorId) public view returns (bool);
}

contract StakingInfo is Ownable {
    using SafeMath for uint256;
    mapping(uint256 =&gt; uint256) public validatorNonce;

    /// @dev Emitted when validator stakes in '_stakeFor()' in StakeManager.
    /// @param signer validator address.
    /// @param validatorId unique integer to identify a validator.
    /// @param nonce to synchronize the events in heimdal.
    /// @param activationEpoch validator's first epoch as proposer.
    /// @param amount staking amount.
    /// @param total total staking amount.
    /// @param signerPubkey public key of the validator
    event Staked(
        address indexed signer,
        uint256 indexed validatorId,
        uint256 nonce,
        uint256 indexed activationEpoch,
        uint256 amount,
        uint256 total,
        bytes signerPubkey
    );

    /// @dev Emitted when validator unstakes in 'unstakeClaim()'
    /// @param user address of the validator.
    /// @param validatorId unique integer to identify a validator.
    /// @param amount staking amount.
    /// @param total total staking amount.
    event Unstaked(
        address indexed user,
        uint256 indexed validatorId,
        uint256 amount,
        uint256 total
    );

    /// @dev Emitted when validator unstakes in '_unstake()'.
    /// @param user address of the validator.
    /// @param validatorId unique integer to identify a validator.
    /// @param nonce to synchronize the events in heimdal.
    /// @param deactivationEpoch last epoch for validator.
    /// @param amount staking amount.
    event UnstakeInit(
        address indexed user,
        uint256 indexed validatorId,
        uint256 nonce,
        uint256 deactivationEpoch,
        uint256 indexed amount
    );

    /// @dev Emitted when the validator public key is updated in 'updateSigner()'.
    /// @param validatorId unique integer to identify a validator.
    /// @param nonce to synchronize the events in heimdal.
    /// @param oldSigner old address of the validator.
    /// @param newSigner new address of the validator.
    /// @param signerPubkey public key of the validator.
    event SignerChange(
        uint256 indexed validatorId,
        uint256 nonce,
        address indexed oldSigner,
        address indexed newSigner,
        bytes signerPubkey
    );
    event Restaked(uint256 indexed validatorId, uint256 amount, uint256 total);
    event Jailed(
        uint256 indexed validatorId,
        uint256 indexed exitEpoch,
        address indexed signer
    );
    event UnJailed(uint256 indexed validatorId, address indexed signer);
    event Slashed(uint256 indexed nonce, uint256 indexed amount);
    event ThresholdChange(uint256 newThreshold, uint256 oldThreshold);
    event DynastyValueChange(uint256 newDynasty, uint256 oldDynasty);
    event ProposerBonusChange(
        uint256 newProposerBonus,
        uint256 oldProposerBonus
    );

    event RewardUpdate(uint256 newReward, uint256 oldReward);

    /// @dev Emitted when validator confirms the auction bid and at the time of restaking in confirmAuctionBid() and restake().
    /// @param validatorId unique integer to identify a validator.
    /// @param nonce to synchronize the events in heimdal.
    /// @param newAmount the updated stake amount.
    event StakeUpdate(
        uint256 indexed validatorId,
        uint256 indexed nonce,
        uint256 indexed newAmount
    );
    event ClaimRewards(
        uint256 indexed validatorId,
        uint256 indexed amount,
        uint256 indexed totalAmount
    );
    event StartAuction(
        uint256 indexed validatorId,
        uint256 indexed amount,
        uint256 indexed auctionAmount
    );
    event ConfirmAuction(
        uint256 indexed newValidatorId,
        uint256 indexed oldValidatorId,
        uint256 indexed amount
    );
    event TopUpFee(address indexed user, uint256 indexed fee);
    event ClaimFee(address indexed user, uint256 indexed fee);
    // Delegator events
    event ShareMinted(
        uint256 indexed validatorId,
        address indexed user,
        uint256 indexed amount,
        uint256 tokens
    );
    event ShareBurned(
        uint256 indexed validatorId,
        address indexed user,
        uint256 indexed amount,
        uint256 tokens
    );
    event DelegatorClaimedRewards(
        uint256 indexed validatorId,
        address indexed user,
        uint256 indexed rewards
    );
    event DelegatorRestaked(
        uint256 indexed validatorId,
        address indexed user,
        uint256 indexed totalStaked
    );
    event DelegatorUnstaked(
        uint256 indexed validatorId,
        address indexed user,
        uint256 amount
    );
    event UpdateCommissionRate(
        uint256 indexed validatorId,
        uint256 indexed newCommissionRate,
        uint256 indexed oldCommissionRate
    );

    Registry public registry;

    modifier onlyValidatorContract(uint256 validatorId) {
        address _contract;
        (, , , , , , _contract, ) = IStakeManagerLocal(
            registry.getStakeManagerAddress()
        )
            .validators(validatorId);
        require(_contract == msg.sender,
        "Invalid sender, not validator");
        _;
    }

    modifier StakeManagerOrValidatorContract(uint256 validatorId) {
        address _contract;
        address _stakeManager = registry.getStakeManagerAddress();
        (, , , , , , _contract, ) = IStakeManagerLocal(_stakeManager).validators(
            validatorId
        );
        require(_contract == msg.sender || _stakeManager == msg.sender,
        "Invalid sender, not stake manager or validator contract");
        _;
    }

    modifier onlyStakeManager() {
        require(registry.getStakeManagerAddress() == msg.sender,
        "Invalid sender, not stake manager");
        _;
    }
    modifier onlySlashingManager() {
        require(registry.getSlashingManagerAddress() == msg.sender,
        "Invalid sender, not slashing manager");
        _;
    }

    constructor(address _registry) public {
        registry = Registry(_registry);
    }

    function updateNonce(
        uint256[] calldata validatorIds,
        uint256[] calldata nonces
    ) external onlyOwner {
        require(validatorIds.length == nonces.length, "args length mismatch");

        for (uint256 i = 0; i &lt; validatorIds.length; ++i) {
            validatorNonce[validatorIds[i]] = nonces[i];
        }
    } 

    function logStaked(
        address signer,
        bytes memory signerPubkey,
        uint256 validatorId,
        uint256 activationEpoch,
        uint256 amount,
        uint256 total
    ) public onlyStakeManager {
        validatorNonce[validatorId] = validatorNonce[validatorId].add(1);
        emit Staked(
            signer,
            validatorId,
            validatorNonce[validatorId],
            activationEpoch,
            amount,
            total,
            signerPubkey
        );
    }

    function logUnstaked(
        address user,
        uint256 validatorId,
        uint256 amount,
        uint256 total
    ) public onlyStakeManager {
        emit Unstaked(user, validatorId, amount, total);
    }

    function logUnstakeInit(
        address user,
        uint256 validatorId,
        uint256 deactivationEpoch,
        uint256 amount
    ) public onlyStakeManager {
        validatorNonce[validatorId] = validatorNonce[validatorId].add(1);
        emit UnstakeInit(
            user,
            validatorId,
            validatorNonce[validatorId],
            deactivationEpoch,
            amount
        );
    }

    function logSignerChange(
        uint256 validatorId,
        address oldSigner,
        address newSigner,
        bytes memory signerPubkey
    ) public onlyStakeManager {
        validatorNonce[validatorId] = validatorNonce[validatorId].add(1);
        emit SignerChange(
            validatorId,
            validatorNonce[validatorId],
            oldSigner,
            newSigner,
            signerPubkey
        );
    }

    function logRestaked(uint256 validatorId, uint256 amount, uint256 total)
        public
        onlyStakeManager
    {
        emit Restaked(validatorId, amount, total);
    }

    function logJailed(uint256 validatorId, uint256 exitEpoch, address signer)
        public
        onlyStakeManager
    {
        emit Jailed(validatorId, exitEpoch, signer);
    }

    function logUnjailed(uint256 validatorId, address signer)
        public
        onlyStakeManager
    {
        emit UnJailed(validatorId, signer);
    }

    function logSlashed(uint256 nonce, uint256 amount)
        public
        onlySlashingManager
    {
        emit Slashed(nonce, amount);
    }

    function logThresholdChange(uint256 newThreshold, uint256 oldThreshold)
        public
        onlyStakeManager
    {
        emit ThresholdChange(newThreshold, oldThreshold);
    }

    function logDynastyValueChange(uint256 newDynasty, uint256 oldDynasty)
        public
        onlyStakeManager
    {
        emit DynastyValueChange(newDynasty, oldDynasty);
    }

    function logProposerBonusChange(
        uint256 newProposerBonus,
        uint256 oldProposerBonus
    ) public onlyStakeManager {
        emit ProposerBonusChange(newProposerBonus, oldProposerBonus);
    }

    function logRewardUpdate(uint256 newReward, uint256 oldReward)
        public
        onlyStakeManager
    {
        emit RewardUpdate(newReward, oldReward);
    }

    function logStakeUpdate(uint256 validatorId)
        public
        StakeManagerOrValidatorContract(validatorId)
    {
        validatorNonce[validatorId] = validatorNonce[validatorId].add(1);
        emit StakeUpdate(
            validatorId,
            validatorNonce[validatorId],
            totalValidatorStake(validatorId)
        );
    }

    function logClaimRewards(
        uint256 validatorId,
        uint256 amount,
        uint256 totalAmount
    ) public onlyStakeManager {
        emit ClaimRewards(validatorId, amount, totalAmount);
    }

    function logStartAuction(
        uint256 validatorId,
        uint256 amount,
        uint256 auctionAmount
    ) public onlyStakeManager {
        emit StartAuction(validatorId, amount, auctionAmount);
    }

    function logConfirmAuction(
        uint256 newValidatorId,
        uint256 oldValidatorId,
        uint256 amount
    ) public onlyStakeManager {
        emit ConfirmAuction(newValidatorId, oldValidatorId, amount);
    }

    function logTopUpFee(address user, uint256 fee) public onlyStakeManager {
        emit TopUpFee(user, fee);
    }

    function logClaimFee(address user, uint256 fee) public onlyStakeManager {
        emit ClaimFee(user, fee);
    }

    function getStakerDetails(uint256 validatorId)
        public
        view
        returns (
            uint256 amount,
            uint256 reward,
            uint256 activationEpoch,
            uint256 deactivationEpoch,
            address signer,
            uint256 _status
        )
    {
        IStakeManagerLocal stakeManager = IStakeManagerLocal(
            registry.getStakeManagerAddress()
        );
        address _contract;
        IStakeManagerLocal.Status status;
        (
            amount,
            reward,
            activationEpoch,
            deactivationEpoch,
            ,
            signer,
            _contract,
            status
        ) = stakeManager.validators(validatorId);
        _status = uint256(status);
        if (_contract != address(0x0)) {
            reward += IStakeManagerLocal(_contract).validatorRewards();
        }
    }

    function totalValidatorStake(uint256 validatorId)
        public
        view
        returns (uint256 validatorStake)
    {
        address contractAddress;
        (validatorStake, , , , , , contractAddress, ) = IStakeManagerLocal(
            registry.getStakeManagerAddress()
        )
            .validators(validatorId);
        if (contractAddress != address(0x0)) {
            validatorStake += IStakeManagerLocal(contractAddress).activeAmount();
        }
    }

    function getAccountStateRoot()
        public
        view
        returns (bytes32 accountStateRoot)
    {
        accountStateRoot = IStakeManagerLocal(registry.getStakeManagerAddress())
            .accountStateRoot();
    }

    function getValidatorContractAddress(uint256 validatorId)
        public
        view
        returns (address ValidatorContract)
    {
        (, , , , , , ValidatorContract, ) = IStakeManagerLocal(
            registry.getStakeManagerAddress()
        )
            .validators(validatorId);
    }

    // validator Share contract logging func
    function logShareMinted(
        uint256 validatorId,
        address user,
        uint256 amount,
        uint256 tokens
    ) public onlyValidatorContract(validatorId) {
        emit ShareMinted(validatorId, user, amount, tokens);
    }

    function logShareBurned(
        uint256 validatorId,
        address user,
        uint256 amount,
        uint256 tokens
    ) public onlyValidatorContract(validatorId) {
        emit ShareBurned(validatorId, user, amount, tokens);
    }

    function logDelegatorClaimRewards(
        uint256 validatorId,
        address user,
        uint256 rewards
    ) public onlyValidatorContract(validatorId) {
        emit DelegatorClaimedRewards(validatorId, user, rewards);
    }

    function logDelegatorRestaked(
        uint256 validatorId,
        address user,
        uint256 totalStaked
    ) public onlyValidatorContract(validatorId) {
        emit DelegatorRestaked(validatorId, user, totalStaked);
    }

    function logDelegatorUnstaked(uint256 validatorId, address user, uint256 amount)
        public
        onlyValidatorContract(validatorId)
    {
        emit DelegatorUnstaked(validatorId, user, amount);
    }

    <span class="marker" id="mapping-506"></span><span class="token add" data-title="contract_body/comment">// deprecated</span>
    function logUpdateCommissionRate(
        uint256 validatorId,
        uint256 newCommissionRate,
        uint256 oldCommissionRate
    ) public onlyValidatorContract(validatorId) {
        emit UpdateCommissionRate(
            validatorId,
            newCommissionRate,
            oldCommissionRate
        );
    }
}

<span class="marker" id="mapping-507"></span><span class="token mv" id="move-dst-28" data-title="source_file/comment"><span class="marker" id="mapping-508"></span><span class="token upd" id="move-dst-28" data-title="source_file/comment"><span class="cupd">// File: contracts/common/</span>m<span class="cupd">i</span>xin/Ini<span class="cupd">t</span>ializable<span class="cupd">.sol</span></span></span>

<span class="marker" id="mapping-509"></span><span class="token mv" id="move-dst-52" data-title="source_file/pragma_directive">pragma solidity ^0.5.2;</span>

<span class="marker" id="mapping-510"></span><span class="token mv" id="move-dst-95" data-title="source_file/contract_declaration">contract Initializable {
    bool inited = false;

    modifier initializer() {
        require(!inited, "already inited");
        inited = true;
        
        _;
    }
}</span>

<span class="marker" id="mapping-511"></span><span class="token mv" id="move-dst-31" data-title="source_file/comment"><span class="marker" id="mapping-512"></span><span class="token upd" id="move-dst-31" data-title="source_file/comment"><span class="cupd">// File: contracts/</span>staki<span class="cupd">n</span>g<span class="cupd">/</span>Even<span class="cupd">t</span><span class="cupd">s</span>Hu<span class="cupd">b.sol</span></span></span>

<span class="marker" id="mapping-513"></span><span class="token mv" id="move-dst-63" data-title="source_file/pragma_directive">pragma solidity ^0.5.2;</span>



<span class="marker" id="mapping-514"></span><span class="token add" data-title="source_file/contract_declaration">contract IStakeManagerEventsHub <span class="marker" id="mapping-515"></span><span class="token add" data-title="contract_declaration/contract_body">{
    <span class="marker" id="mapping-516"></span><span class="token add" data-title="contract_body/struct_declaration">struct Validator {
        uint256 amount;
        uint256 reward;
        uint256 activationEpoch;
        uint256 deactivationEpoch;
        uint256 jailTime;
        address signer;
        address contractAddress;
    }</span>

    <span class="marker" id="mapping-517"></span><span class="token add" data-title="contract_body/state_variable_declaration"><span class="marker" id="mapping-518"></span><span class="token add" data-title="state_variable_declaration/type_name">mapping(<span class="marker" id="mapping-519"></span><span class="token mv" id="move-dst-40" data-title="type_name/primitive_type">uint256</span> =&gt; <span class="marker" id="mapping-520"></span><span class="token add" data-title="type_name/type_name">Validator</span>)</span> <span class="marker" id="mapping-521"></span><span class="token add" data-title="state_variable_declaration/visibility">public</span> validators;</span>
}</span></span>

<span class="marker" id="mapping-522"></span><span class="token add" data-title="source_file/contract_declaration">contract EventsHub is <span class="marker" id="mapping-523"></span><span class="token add" data-title="contract_declaration/inheritance_specifier">Initializable</span> <span class="marker" id="mapping-524"></span><span class="token add" data-title="contract_declaration/contract_body">{
    <span class="marker" id="mapping-525"></span><span class="token add" data-title="contract_body/state_variable_declaration">Registry public registry;</span>

    <span class="marker" id="mapping-526"></span><span class="token mv" id="move-dst-111" data-title="contract_body/modifier_definition">modifier <span class="marker" id="mapping-527"></span><span class="token upd" id="move-dst-112" data-title="modifier_definition/identifier"><span class="cupd">onlyValidator</span>Contract</span>(<span class="marker" id="mapping-528"></span><span class="token add" data-title="modifier_definition/parameter">uint256 validatorId</span>) {
        <span class="marker" id="mapping-529"></span><span class="token mv" id="move-dst-58" data-title="function_body/variable_declaration_statement">address <span class="marker" id="mapping-530"></span><span class="token upd" id="move-dst-59" data-title="variable_declaration/identifier">_cont<span class="cupd">r</span>act</span>;</span>
        <span class="marker" id="mapping-531"></span><span class="token add" data-title="function_body/expression_statement"><span class="marker" id="mapping-532"></span><span class="token add" data-title="expression_statement/assignment_expression"><span class="marker" id="mapping-533"></span><span class="token add" data-title="assignment_expression/tuple_expression">(, , , , , , _contract)</span> = <span class="marker" id="mapping-534"></span><span class="token add" data-title="assignment_expression/call_expression"><span class="marker" id="mapping-535"></span><span class="token add" data-title="call_expression/member_expression">IStakeManagerEventsHub(registry.getStakeManagerAddress()).validators</span>(<span class="marker" id="mapping-536"></span><span class="token mv" id="move-dst-113" data-title="call_expression/call_argument">validatorId</span>)</span></span>;</span>
        require(<span class="marker" id="mapping-537"></span><span class="token add" data-title="binary_expression/identifier">_contract</span> == msg.sender, "not validator");
        _;
    }</span>

    <span class="marker" id="mapping-538"></span><span class="token add" data-title="contract_body/modifier_definition">modifier onlyStakeManager() {
        require(registry.getStakeManagerAddress() == msg.sender,
        "Invalid sender, not stake manager");
        _;
    }</span>

    <span class="marker" id="mapping-539"></span><span class="token add" data-title="contract_body/function_definition">function initialize(<span class="marker" id="mapping-540"></span><span class="token add" data-title="function_definition/parameter">Registry _registry</span>) <span class="marker" id="mapping-541"></span><span class="token mv" id="move-dst-70" data-title="function_definition/visibility">external</span> <span class="marker" id="mapping-542"></span><span class="token add" data-title="function_definition/modifier_invocation">initializer</span> <span class="marker" id="mapping-543"></span><span class="token add" data-title="function_definition/function_body">{
        registry = _registry;
    }</span></span>

    <span class="marker" id="mapping-544"></span><span class="token add" data-title="contract_body/event_definition">event ShareBurnedWithId(
        uint256 indexed validatorId,
        address indexed user,
        uint256 indexed amount,
        uint256 tokens,
        uint256 nonce
    );</span>

    <span class="marker" id="mapping-545"></span><span class="token mv" id="move-dst-71" data-title="contract_body/function_definition">function <span class="marker" id="mapping-546"></span><span class="token upd" id="move-dst-72" data-title="function_definition/identifier">logSh<span class="cupd">a</span><span class="cupd">r</span><span class="cupd">e</span>Bu<span class="cupd">r</span>nedWithId</span>(
        uint256 <span class="marker" id="mapping-547"></span><span class="token upd" id="move-dst-73" data-title="parameter/identifier">v<span class="cupd">a</span>lidato<span class="cupd">r</span>Id</span>,
        <span class="marker" id="mapping-548"></span><span class="token add" data-title="function_definition/parameter">address user</span><span class="marker" id="mapping-549"></span><span class="token add" data-title="function_definition/,">,</span>
        <span class="marker" id="mapping-550"></span><span class="token mv" id="move-dst-66" data-title="function_definition/parameter">uint256 amount</span><span class="marker" id="mapping-551"></span><span class="token add" data-title="function_definition/,">,</span>
        uint256 <span class="marker" id="mapping-552"></span><span class="token upd" id="move-dst-74" data-title="parameter/identifier"><span class="cupd">t</span>o<span class="cupd">ke</span>ns</span><span class="marker" id="mapping-553"></span><span class="token add" data-title="function_definition/,">,</span>
        <span class="marker" id="mapping-554"></span><span class="token mv" id="move-dst-35" data-title="function_definition/parameter">uint256 <span class="marker" id="mapping-555"></span><span class="token upd" id="move-dst-36" data-title="parameter/identifier">nonce</span></span>
    ) public <span class="marker" id="mapping-556"></span><span class="token add" data-title="function_definition/modifier_invocation">onlyValidatorContract(validatorId)</span> <span class="marker" id="mapping-557"></span><span class="token add" data-title="function_definition/function_body">{
        emit ShareBurnedWithId(validatorId, user, amount, tokens, nonce);
    }</span></span>

    <span class="marker" id="mapping-558"></span><span class="token add" data-title="contract_body/event_definition">event DelegatorUnstakeWithId(
        uint256 indexed validatorId,
        address indexed user,
        uint256 amount,
        uint256 nonce
    );</span>

    <span class="marker" id="mapping-559"></span><span class="token add" data-title="contract_body/function_definition">function logDelegatorUnstakedWithId(
        <span class="marker" id="mapping-560"></span><span class="token mv" id="move-dst-41" data-title="function_definition/parameter">uint256 <span class="marker" id="mapping-561"></span><span class="token upd" id="move-dst-42" data-title="parameter/identifier">validatorId</span></span>,
        <span class="marker" id="mapping-562"></span><span class="token add" data-title="function_definition/parameter">address user</span>,
        <span class="marker" id="mapping-563"></span><span class="token add" data-title="function_definition/parameter">uint256 amount</span>,
        <span class="marker" id="mapping-564"></span><span class="token mv" id="move-dst-33" data-title="function_definition/parameter">uint256 <span class="marker" id="mapping-565"></span><span class="token upd" id="move-dst-34" data-title="parameter/identifier">nonce</span></span>
    ) <span class="marker" id="mapping-566"></span><span class="token mv" id="move-dst-68" data-title="function_definition/visibility">public</span> <span class="marker" id="mapping-567"></span><span class="token add" data-title="function_definition/modifier_invocation">onlyValidatorContract(validatorId)</span> <span class="marker" id="mapping-568"></span><span class="token add" data-title="function_definition/function_body">{
        emit DelegatorUnstakeWithId(validatorId, user, amount, nonce);
    }</span></span>

    <span class="marker" id="mapping-569"></span><span class="token add" data-title="contract_body/event_definition">event RewardParams(
        uint256 rewardDecreasePerCheckpoint,
        uint256 maxRewardedCheckpoints,
        uint256 checkpointRewardDelta
    );</span>

    <span class="marker" id="mapping-570"></span><span class="token add" data-title="contract_body/function_definition">function logRewardParams(
        <span class="marker" id="mapping-571"></span><span class="token mv" id="move-dst-43" data-title="function_definition/parameter">uint256 <span class="marker" id="mapping-572"></span><span class="token upd" id="move-dst-44" data-title="parameter/identifier">rew<span class="cupd">ar</span>dDecreasePerCheckpoint</span></span>,
        <span class="marker" id="mapping-573"></span><span class="token mv" id="move-dst-47" data-title="function_definition/parameter">uint256 <span class="marker" id="mapping-574"></span><span class="token upd" id="move-dst-48" data-title="parameter/identifier">m<span class="cupd">a</span>xRewa<span class="cupd">r</span>dedCheckpoints</span></span>,
        <span class="marker" id="mapping-575"></span><span class="token add" data-title="function_definition/parameter">uint256 checkpointRewardDelta</span>
    ) <span class="marker" id="mapping-576"></span><span class="token mv" id="move-dst-62" data-title="function_definition/visibility">public</span> <span class="marker" id="mapping-577"></span><span class="token add" data-title="function_definition/modifier_invocation">onlyStakeManager</span> <span class="marker" id="mapping-578"></span><span class="token add" data-title="function_definition/function_body">{
        emit RewardParams(rewardDecreasePerCheckpoint, maxRewardedCheckpoints, checkpointRewardDelta);
    }</span></span>

    <span class="marker" id="mapping-579"></span><span class="token add" data-title="contract_body/event_definition">event UpdateCommissionRate(
        uint256 indexed validatorId,
        uint256 indexed newCommissionRate,
        uint256 indexed oldCommissionRate
    );</span>

    <span class="marker" id="mapping-580"></span><span class="token add" data-title="contract_body/function_definition">function logUpdateCommissionRate(
        <span class="marker" id="mapping-581"></span><span class="token add" data-title="function_definition/parameter"><span class="marker" id="mapping-582"></span><span class="token mv" id="move-dst-37" data-title="parameter/type_name">uint256</span> validatorId</span>,
        <span class="marker" id="mapping-583"></span><span class="token mv" id="move-dst-114" data-title="function_definition/parameter">uint256 newCommissionRate</span>,
        <span class="marker" id="mapping-584"></span><span class="token add" data-title="function_definition/parameter">uint256 oldCommissionRate</span>
    ) <span class="marker" id="mapping-585"></span><span class="token mv" id="move-dst-57" data-title="function_definition/visibility">public</span> <span class="marker" id="mapping-586"></span><span class="token add" data-title="function_definition/modifier_invocation">onlyStakeManager</span> <span class="marker" id="mapping-587"></span><span class="token add" data-title="function_definition/function_body">{
        <span class="marker" id="mapping-588"></span><span class="token add" data-title="function_body/emit_statement">emit UpdateCommissionRate(
            <span class="marker" id="mapping-589"></span><span class="token mv" id="move-dst-124" data-title="emit_statement/call_argument">validatorId</span>,
            <span class="marker" id="mapping-590"></span><span class="token mv" id="move-dst-125" data-title="emit_statement/call_argument">newCommissionRate</span>,
            <span class="marker" id="mapping-591"></span><span class="token add" data-title="emit_statement/call_argument">oldCommissionRate</span>
        );</span>
    }</span></span>
}</span></span>

// File: contracts/common/mixin/Lockable.sol

pragma solidity ^0.5.2;

contract Lockable {
    bool public locked;

    modifier onlyWhenUnlocked() {
        _assertUnlocked();
        _;
    }

    function _assertUnlocked() private view {
        require(!locked, "locked");
    }

    function lock() public {
        locked = true;
    }

    function unlock() public {
        locked = false;
    }
}

// File: contracts/common/mixin/OwnableLockable.sol

pragma solidity ^0.5.2;



contract OwnableLockable is Lockable, Ownable {
    function lock() public onlyOwner {
        super.lock();
    }

    function unlock() public onlyOwner {
        super.unlock();
    }
}

// File: contracts/staking/stakeManager/IStakeManager.sol

<span class="marker" id="mapping-592"></span><span class="token add" data-title="source_file/pragma_directive">pragma solidity 0.5.17;</span>

contract IStakeManager {
    // validator replacement
    function startAuction(
        uint256 validatorId,
        uint256 amount,
        bool acceptDelegation,
        bytes calldata signerPubkey
    ) external;

    function confirmAuctionBid(uint256 validatorId, uint256 heimdallFee) external;

    function transferFunds(
        uint256 validatorId,
        uint256 amount,
        address delegator
    ) external returns (bool);

    function delegationDeposit(
        uint256 validatorId,
        uint256 amount,
        address delegator
    ) external returns (bool);

    function unstake(uint256 validatorId) external;

    function totalStakedFor(address addr) external view returns (uint256);

    function stakeFor(
        address user,
        uint256 amount,
        uint256 heimdallFee,
        bool acceptDelegation,
        bytes memory signerPubkey
    ) public;

    function checkSignatures(
        uint256 blockInterval,
        bytes32 voteHash,
        bytes32 stateRoot,
        address proposer,
        <span class="marker" id="mapping-593"></span><span class="token add" data-title="type_name/type_name">uint[3]</span><span class="marker" id="mapping-594"></span><span class="token add" data-title="type_name/[">[</span><span class="marker" id="mapping-595"></span><span class="token add" data-title="type_name/]">]</span> <span class="marker" id="mapping-596"></span><span class="token add" data-title="parameter/calldata">calldata</span> sigs
    ) <span class="marker" id="mapping-597"></span><span class="token mv" id="move-dst-83" data-title="function_definition/visibility">external</span> returns (uint256);

    function updateValidatorState(uint256 validatorId, int256 amount) public;

    function ownerOf(uint256 tokenId) public view returns (address);

    function slash(bytes <span class="marker" id="mapping-598"></span><span class="token add" data-title="parameter/calldata">calldata</span> slashingInfoList) <span class="marker" id="mapping-599"></span><span class="token mv" id="move-dst-89" data-title="function_definition/visibility">external</span> returns (uint256);

    function validatorStake(uint256 validatorId) public view returns (uint256);

    function epoch() public view returns (uint256);

    <span class="marker" id="mapping-600"></span><span class="token add" data-title="contract_body/function_definition">function getRegistry() <span class="marker" id="mapping-601"></span><span class="token mv" id="move-dst-69" data-title="function_definition/visibility">public</span> <span class="marker" id="mapping-602"></span><span class="token mv" id="move-dst-76" data-title="function_definition/state_mutability">view</span> <span class="marker" id="mapping-603"></span><span class="token mv" id="move-dst-49" data-title="function_definition/return_type_definition">returns (address)</span>;</span>

    function withdrawalDelay() public view returns (uint256);

    <span class="marker" id="mapping-604"></span><span class="token mv" id="move-dst-90" data-title="contract_body/function_definition">function <span class="marker" id="mapping-605"></span><span class="token upd" id="move-dst-91" data-title="function_definition/identifier">de<span class="cupd">l</span>egatedAmount</span>(<span class="marker" id="mapping-606"></span><span class="token mv" id="move-dst-80" data-title="function_definition/parameter">uint256 <span class="marker" id="mapping-607"></span><span class="token upd" id="move-dst-81" data-title="parameter/identifier">v<span class="cupd">a</span>lidato<span class="cupd">r</span>Id</span></span>) <span class="marker" id="mapping-608"></span><span class="token add" data-title="function_definition/visibility">public</span> <span class="marker" id="mapping-609"></span><span class="token add" data-title="function_definition/state_mutability">view</span> returns(uint256);</span>

    <span class="marker" id="mapping-610"></span><span class="token add" data-title="contract_body/function_definition">function decreaseValidatorDelegatedAmount(<span class="marker" id="mapping-611"></span><span class="token mv" id="move-dst-143" data-title="function_definition/parameter">uint256 <span class="marker" id="mapping-612"></span><span class="token upd" id="move-dst-144" data-title="parameter/identifier">v<span class="cupd">a</span>lidato<span class="cupd">r</span>Id</span></span>, <span class="marker" id="mapping-613"></span><span class="token add" data-title="function_definition/parameter">uint256 amount</span>) <span class="marker" id="mapping-614"></span><span class="token add" data-title="function_definition/visibility">public</span>;</span>

    <span class="marker" id="mapping-615"></span><span class="token mv" id="move-dst-87" data-title="contract_body/function_definition">function <span class="marker" id="mapping-616"></span><span class="token upd" id="move-dst-88" data-title="function_definition/identifier">withdrawDe<span class="cupd">l</span>egat<span class="cupd">o</span><span class="cupd">r</span>sReward</span>(<span class="marker" id="mapping-617"></span><span class="token mv" id="move-dst-136" data-title="function_definition/parameter">uint256 <span class="marker" id="mapping-618"></span><span class="token upd" id="move-dst-137" data-title="parameter/identifier">v<span class="cupd">a</span>lidato<span class="cupd">r</span>Id</span></span>) <span class="marker" id="mapping-619"></span><span class="token mv" id="move-dst-138" data-title="function_definition/visibility">public</span> returns(uint256);</span>

    <span class="marker" id="mapping-620"></span><span class="token mv" id="move-dst-84" data-title="contract_body/function_definition">function <span class="marker" id="mapping-621"></span><span class="token upd" id="move-dst-85" data-title="function_definition/identifier">de<span class="cupd">l</span>egat<span class="cupd">o</span><span class="cupd">r</span>sReward</span>(<span class="marker" id="mapping-622"></span><span class="token mv" id="move-dst-126" data-title="function_definition/parameter">uint256 <span class="marker" id="mapping-623"></span><span class="token upd" id="move-dst-127" data-title="parameter/identifier">v<span class="cupd">a</span>lidato<span class="cupd">r</span>Id</span></span>) <span class="marker" id="mapping-624"></span><span class="token add" data-title="function_definition/visibility">public</span> <span class="marker" id="mapping-625"></span><span class="token add" data-title="function_definition/state_mutability">view</span> returns(uint256);</span>

    <span class="marker" id="mapping-626"></span><span class="token mv" id="move-dst-64" data-title="contract_body/function_definition">function <span class="marker" id="mapping-627"></span><span class="token upd" id="move-dst-65" data-title="function_definition/identifier">de<span class="cupd">t</span>hroneAndSt<span class="cupd">ake</span></span>(
        <span class="marker" id="mapping-628"></span><span class="token add" data-title="function_definition/parameter">address auctionUser</span>,
        uint256 heimdallFee,
        <span class="marker" id="mapping-629"></span><span class="token mv" id="move-dst-128" data-title="function_definition/parameter">uint256 <span class="marker" id="mapping-630"></span><span class="token upd" id="move-dst-129" data-title="parameter/identifier">val<span class="cupd">i</span>da<span class="cupd">t</span><span class="cupd">o</span>rId</span></span>,
        <span class="marker" id="mapping-631"></span><span class="token mv" id="move-dst-146" data-title="function_definition/parameter">uint256 <span class="marker" id="mapping-632"></span><span class="token upd" id="move-dst-147" data-title="parameter/identifier">au<span class="cupd">c</span>ti<span class="cupd">o</span>nA<span class="cupd">m</span>ou<span class="cupd">n</span>t</span></span><span class="marker" id="mapping-633"></span><span class="token add" data-title="function_definition/,">,</span>
        <span class="marker" id="mapping-634"></span><span class="token mv" id="move-dst-67" data-title="function_definition/parameter">bool acceptDelegation</span><span class="marker" id="mapping-635"></span><span class="token add" data-title="function_definition/,">,</span>
        bytes calldata signerPubkey
    ) external;</span>
}

// File: contracts/staking/validatorShare/IValidatorShare.sol

<span class="marker" id="mapping-636"></span><span class="token add" data-title="source_file/pragma_directive">pragma solidity 0.5.17;</span>

// note this contract interface is only for stakeManager use
contract IValidatorShare {
    function withdrawRewards() public;

    function unstakeClaimTokens() public;

    function getLiquidRewards(address user) public view returns (uint256);
    
    function owner() public view returns (address);

    <span class="marker" id="mapping-637"></span><span class="token add" data-title="contract_body/function_definition">function restake() <span class="marker" id="mapping-638"></span><span class="token mv" id="move-dst-77" data-title="function_definition/visibility">public</span> <span class="marker" id="mapping-639"></span><span class="token add" data-title="function_definition/return_type_definition">returns(uint256, uint256)</span>;</span>

    <span class="marker" id="mapping-640"></span><span class="token add" data-title="contract_body/function_definition">function unlock() <span class="marker" id="mapping-641"></span><span class="token mv" id="move-dst-75" data-title="function_definition/visibility">external</span>;</span>

    <span class="marker" id="mapping-642"></span><span class="token add" data-title="contract_body/function_definition">function lock() <span class="marker" id="mapping-643"></span><span class="token mv" id="move-dst-86" data-title="function_definition/visibility">external</span>;</span>

    function drain(
        address token,
        address payable destination,
        uint256 amount
    ) external;

    <span class="marker" id="mapping-644"></span><span class="token mv" id="move-dst-78" data-title="contract_body/function_definition">function <span class="marker" id="mapping-645"></span><span class="token upd" id="move-dst-79" data-title="function_definition/identifier">sl<span class="cupd">a</span>sh</span>(<span class="marker" id="mapping-646"></span><span class="token mv" id="move-dst-92" data-title="function_definition/parameter">uint256 valPow</span>, uint256 <span class="marker" id="mapping-647"></span><span class="token upd" id="move-dst-82" data-title="parameter/identifier">delega<span class="cupd">t</span>edAm<span class="cupd">o</span>unt</span>, <span class="marker" id="mapping-648"></span><span class="token mv" id="move-dst-93" data-title="function_definition/parameter">uint256 totalAmountToSlash</span>) <span class="marker" id="mapping-649"></span><span class="token mv" id="move-dst-94" data-title="function_definition/visibility">external</span> returns (uint256);</span>

    function updateDelegation(bool delegation) external;

    function migrateOut(address user, uint256 amount) external;

    function migrateIn(address user, uint256 amount) external;
}

// File: contracts/staking/validatorShare/ValidatorShare.sol

<span class="marker" id="mapping-650"></span><span class="token add" data-title="source_file/pragma_directive">pragma solidity 0.5.17;</span>










contract ValidatorShare is IValidatorShare, <span class="marker" id="mapping-651"></span><span class="token upd" id="move-dst-96" data-title="user_defined_type/identifier"><span class="cupd">ERC20NonTra</span>d<span class="cupd">able</span></span>, OwnableLockable, Initializable {
    struct DelegatorUnbond {
        uint256 shares;
        uint256 withdrawEpoch;
    }

    uint256 constant EXCHANGE_RATE_PRECISION = 100;
    // maximum matic possible, even if rate will be 1 and all matic will be staken in one go, it will result in 10 ^ 58 shares
    uint256 constant EXCHANGE_RATE_HIGH_PRECISION = 10**29;
    uint256 constant MAX_COMMISION_RATE = 100;
    uint256 constant REWARD_PRECISION = 10**25;

    StakingInfo public stakingLogger;
    IStakeManager public stakeManager;
    uint256 public validatorId;
    uint256 public <span class="marker" id="mapping-652"></span><span class="token upd" id="move-dst-97" data-title="state_variable_declaration/identifier"><span class="cupd">validatorRewards</span>_deprecated</span>;
    uint256 public <span class="marker" id="mapping-653"></span><span class="token upd" id="move-dst-98" data-title="state_variable_declaration/identifier"><span class="cupd">commissionRate</span>_deprecated</span>;
    <span class="marker" id="mapping-654"></span><span class="token mv" id="move-dst-105" data-title="contract_body/state_variable_declaration">uint256 public <span class="marker" id="mapping-655"></span><span class="token upd" id="move-dst-106" data-title="state_variable_declaration/identifier">las<span class="cupd">t</span>C<span class="cupd">o</span>mmissionUpda<span class="cupd">t</span>e_deprec<span class="cupd">a</span><span class="cupd">t</span>ed</span>;</span>
    uint256 public <span class="marker" id="mapping-656"></span><span class="token upd" id="move-dst-101" data-title="state_variable_declaration/identifier"><span class="cupd">m</span>inA<span class="cupd">m</span><span class="cupd">o</span>u<span class="cupd">n</span>t</span>;

    uint256 public <span class="marker" id="mapping-657"></span><span class="token upd" id="move-dst-102" data-title="state_variable_declaration/identifier">t<span class="cupd">o</span>talStake_deprecated</span>;
    uint256 public rewardPerShare;
    uint256 public activeAmount;

    bool public delegation;

    uint256 public withdrawPool;
    uint256 public withdrawShares;

    <span class="marker" id="mapping-658"></span><span class="token add" data-title="contract_body/state_variable_declaration">mapping(address =&gt; uint256) amountStaked_deprecated;</span> <span class="marker" id="mapping-659"></span><span class="token mv" id="move-dst-100" data-title="contract_body/comment"><span class="marker" id="mapping-660"></span><span class="token upd" id="move-dst-100" data-title="contract_body/comment"><span class="cupd">//</span><span class="cupd"> </span>d<span class="cupd">e</span>pre<span class="cupd">c</span>a<span class="cupd">t</span>ed,<span class="cupd"> </span>k<span class="cupd">e</span><span class="cupd">e</span>p<span class="cupd"> </span>f<span class="cupd">or </span>fo<span class="cupd">u</span>n<span class="cupd">dat</span><span class="cupd">i</span><span class="cupd">on </span>deleg<span class="cupd">at</span>ors</span></span>
    mapping(address =&gt; DelegatorUnbond) public unbonds;
    mapping(address =&gt; uint256) public initalRewardPerShare;

    <span class="marker" id="mapping-661"></span><span class="token mv" id="move-dst-109" data-title="contract_body/state_variable_declaration">mapping(address =&gt; uint256) <span class="marker" id="mapping-662"></span><span class="token add" data-title="state_variable_declaration/visibility">public</span> <span class="marker" id="mapping-663"></span><span class="token upd" id="move-dst-110" data-title="state_variable_declaration/identifier"><span class="cupd">un</span>bondNonces</span>;</span>
    <span class="marker" id="mapping-664"></span><span class="token add" data-title="contract_body/state_variable_declaration"><span class="marker" id="mapping-665"></span><span class="token add" data-title="state_variable_declaration/type_name">mapping(<span class="marker" id="mapping-666"></span><span class="token mv" id="move-dst-54" data-title="type_name/primitive_type">address</span> =&gt; <span class="marker" id="mapping-667"></span><span class="token add" data-title="type_name/type_name">mapping(uint256 =&gt; DelegatorUnbond)</span>)</span> <span class="marker" id="mapping-668"></span><span class="token mv" id="move-dst-53" data-title="state_variable_declaration/visibility">public</span> unbonds_new;</span>

    <span class="marker" id="mapping-669"></span><span class="token add" data-title="contract_body/state_variable_declaration">EventsHub public eventsHub;</span>

    // onlyOwner will prevent this contract from initializing, since it's owner is going to be 0x0 address
    function initialize(
        uint256 _validatorId,
        address _stakingLogger,
        address _stakeManager
    ) external initializer {
        validatorId = _validatorId;
        stakingLogger = StakingInfo(_stakingLogger);
        stakeManager = IStakeManager(_stakeManager);
        _transferOwnership(_stakeManager);
        <span class="marker" id="mapping-670"></span><span class="token add" data-title="function_body/expression_statement">_getOrCacheEventsHub();</span>

        minAmount = 10**18;
        delegation = true;
    }

    <span class="marker" id="mapping-671"></span><span class="token mv" id="move-dst-104" data-title="contract_body/comment"><span class="marker" id="mapping-672"></span><span class="token upd" id="move-dst-104" data-title="contract_body/comment"><span class="cupd">/</span>**<span class="cupd"></span>
        Public V<span class="cupd">i</span>ew <span class="cupd">M</span><span class="cupd">e</span>thods
    */</span></span>

    function exchangeRate() public view returns (uint256) {
        uint256 totalShares = totalSupply();
        uint256 precision = _getRatePrecision();
        return <span class="marker" id="mapping-673"></span><span class="token add" data-title="return_statement/call_expression"><span class="marker" id="mapping-674"></span><span class="token add" data-title="call_expression/member_expression"><span class="marker" id="mapping-675"></span><span class="token mv" id="move-dst-163" data-title="member_expression/call_expression">totalShares == 0 ? precision : <span class="marker" id="mapping-676"></span><span class="token upd" id="move-dst-164" data-title="member_expression/identifier">st<span class="cupd">a</span>k<span class="cupd">e</span>Manager</span>.<span class="marker" id="mapping-677"></span><span class="token upd" id="move-dst-165" data-title="member_expression/identifier">delegatedA<span class="cupd">m</span>ount</span>(<span class="marker" id="mapping-678"></span><span class="token add" data-title="call_expression/call_argument">validatorId</span>).<span class="marker" id="mapping-679"></span><span class="token upd" id="move-dst-167" data-title="member_expression/identifier">mul</span>(<span class="marker" id="mapping-680"></span><span class="token mv" id="move-dst-166" data-title="call_expression/call_argument">precision</span>)</span>.div</span>(<span class="marker" id="mapping-681"></span><span class="token mv" id="move-dst-168" data-title="call_expression/call_argument">totalShares</span>)</span>;
    }

    <span class="marker" id="mapping-682"></span><span class="token mv" id="move-dst-174" data-title="contract_body/function_definition">function <span class="marker" id="mapping-683"></span><span class="token upd" id="move-dst-175" data-title="function_definition/identifier"><span class="cupd">getTotalStake</span></span>(address user) <span class="marker" id="mapping-684"></span><span class="token add" data-title="visibility/public">public</span> view returns (uint256, uint256) {
        uint256 shares = balanceOf(user);
        uint256 rate = exchangeRate();
        if (shares == 0) {
            return (0, rate);
        }

        return (rate.mul(shares).div(_getRatePrecision()), rate);
    }</span>

    function withdrawExchangeRate() public view returns (uint256) {
        uint256 precision = _getRatePrecision();
        if (validatorId &lt; 8) {
            // fix of potentially broken withdrawals for future unbonding
            // foundation validators have no slashing enabled and thus we can return default exchange rate
            // because without slashing rate will stay constant
            return precision;
        }

        uint256 _withdrawShares = withdrawShares;
        return _withdrawShares == 0 ? precision : withdrawPool.mul(precision).div(_withdrawShares);
    }

    <span class="marker" id="mapping-685"></span><span class="token add" data-title="contract_body/function_definition">function getLiquidRewards(<span class="marker" id="mapping-686"></span><span class="token add" data-title="function_definition/parameter">address user</span>) <span class="marker" id="mapping-687"></span><span class="token add" data-title="function_definition/visibility">public</span> <span class="marker" id="mapping-688"></span><span class="token add" data-title="function_definition/state_mutability">view</span> <span class="marker" id="mapping-689"></span><span class="token mv" id="move-dst-130" data-title="function_definition/return_type_definition">returns (uint256)</span> <span class="marker" id="mapping-690"></span><span class="token add" data-title="function_definition/function_body">{
        return _calculateReward(user, getRewardPerShare());
    }</span></span>

    <span class="marker" id="mapping-691"></span><span class="token mv" id="move-dst-158" data-title="contract_body/function_definition">function <span class="marker" id="mapping-692"></span><span class="token upd" id="move-dst-159" data-title="function_definition/identifier">ge<span class="cupd">t</span><span class="cupd">Reward</span>PerSh<span class="cupd">a</span>re</span>() <span class="marker" id="mapping-693"></span><span class="token add" data-title="visibility/public">public</span> <span class="marker" id="mapping-694"></span><span class="token add" data-title="function_definition/state_mutability">view</span> returns (uint256) {
        return <span class="marker" id="mapping-695"></span><span class="token add" data-title="return_statement/call_expression">_calculateRewardPerShareWithRewards(stakeManager.delegatorsReward(validatorId))</span>;
    }</span>

    <span class="marker" id="mapping-696"></span><span class="token mv" id="move-dst-108" data-title="contract_body/comment"><span class="marker" id="mapping-697"></span><span class="token upd" id="move-dst-108" data-title="contract_body/comment"><span class="cupd">/</span>**<span class="cupd"></span>
        Public <span class="cupd">M</span><span class="cupd">e</span>thods
     */</span></span>

    function <span class="marker" id="mapping-698"></span><span class="token upd" id="move-dst-170" data-title="function_definition/identifier"><span class="cupd">buyVoucher</span></span>(uint256 _amount, uint256 _minSharesToMint) <span class="marker" id="mapping-699"></span><span class="token mv" id="move-dst-169" data-title="function_definition/visibility">public</span> returns(uint256 <span class="marker" id="mapping-700"></span><span class="token add" data-title="parameter/identifier">amountToDeposit</span>) {
        _withdrawAndTransferReward(msg.sender);
        
        <span class="marker" id="mapping-701"></span><span class="token add" data-title="function_body/expression_statement"><span class="marker" id="mapping-702"></span><span class="token add" data-title="expression_statement/assignment_expression">amountToDeposit = <span class="marker" id="mapping-703"></span><span class="token mv" id="move-dst-173" data-title="assignment_expression/call_expression">_buyShares(_amount, _minSharesToMint, msg.sender)</span></span>;</span>
        require(stakeManager.delegationDeposit(validatorId, amountToDeposit, msg.sender), "deposit failed");
        
        return amountToDeposit;
    }

    function <span class="marker" id="mapping-704"></span><span class="token upd" id="move-dst-177" data-title="function_definition/identifier"><span class="cupd">restake</span></span>() <span class="marker" id="mapping-705"></span><span class="token add" data-title="visibility/public">public</span> returns(uint256<span class="marker" id="mapping-706"></span><span class="token add" data-title="return_type_definition/,">,</span> <span class="marker" id="mapping-707"></span><span class="token add" data-title="return_type_definition/parameter">uint256</span>) {
        <span class="marker" id="mapping-708"></span><span class="token mv" id="move-dst-50" data-title="function_body/variable_declaration_statement">address <span class="marker" id="mapping-709"></span><span class="token upd" id="move-dst-51" data-title="variable_declaration/identifier">us<span class="cupd">e</span>r</span> <span class="marker" id="mapping-710"></span><span class="token add" data-title="variable_declaration_statement/=">=</span> <span class="marker" id="mapping-711"></span><span class="token add" data-title="variable_declaration_statement/member_expression">msg.sender</span>;</span>
        uint256 liquidReward = _withdrawReward(<span class="marker" id="mapping-712"></span><span class="token add" data-title="call_argument/identifier">user</span>);
        uint256 amountRestaked;

        <span class="marker" id="mapping-713"></span><span class="token mv" id="move-dst-178" data-title="function_body/expression_statement">require(liquidReward &gt;= minAmount, "Too small rewards to restake");</span>

        <span class="marker" id="mapping-714"></span><span class="token add" data-title="function_body/if_statement">if (<span class="marker" id="mapping-715"></span><span class="token add" data-title="if_statement/binary_expression">liquidReward != 0</span>) <span class="marker" id="mapping-716"></span><span class="token add" data-title="if_statement/block_statement">{
            <span class="marker" id="mapping-717"></span><span class="token add" data-title="block_statement/expression_statement"><span class="marker" id="mapping-718"></span><span class="token add" data-title="expression_statement/assignment_expression">amountRestaked = <span class="marker" id="mapping-719"></span><span class="token mv" id="move-dst-179" data-title="assignment_expression/call_expression">_buyShares(liquidReward, 0, <span class="marker" id="mapping-720"></span><span class="token add" data-title="call_argument/identifier">user</span>)</span></span>;</span>

            <span class="marker" id="mapping-721"></span><span class="token mv" id="move-dst-180" data-title="block_statement/if_statement">if (liquidReward &gt; amountRestaked) {
                // return change to the user
                require(
                    stakeManager.transferFunds(validatorId, liquidReward - amountRestaked, <span class="marker" id="mapping-722"></span><span class="token add" data-title="call_argument/identifier">user</span>),
                    "Insufficent rewards"
                );
                stakingLogger.logDelegatorClaimRewards(validatorId, <span class="marker" id="mapping-723"></span><span class="token add" data-title="call_expression/call_argument">user</span>, liquidReward - amountRestaked);
            }</span>

            <span class="marker" id="mapping-724"></span><span class="token mv" id="move-dst-182" data-title="block_statement/variable_declaration_statement">(uint256 totalStaked, ) = <span class="marker" id="mapping-725"></span><span class="token upd" id="move-dst-183" data-title="call_expression/identifier"><span class="cupd">getTotalStake</span></span>(<span class="marker" id="mapping-726"></span><span class="token add" data-title="call_argument/identifier">user</span>);</span>
            <span class="marker" id="mapping-727"></span><span class="token mv" id="move-dst-184" data-title="block_statement/expression_statement">stakingLogger.logDelegatorRestaked(validatorId, <span class="marker" id="mapping-728"></span><span class="token add" data-title="call_expression/call_argument">user</span>, totalStaked);</span>
        }</span></span>
        
        return <span class="marker" id="mapping-729"></span><span class="token add" data-title="return_statement/tuple_expression">(amountRestaked, liquidReward)</span>;
    }

    <span class="marker" id="mapping-730"></span><span class="token add" data-title="contract_body/function_definition">function sellVoucher(<span class="marker" id="mapping-731"></span><span class="token add" data-title="function_definition/parameter">uint256 claimAmount</span>, <span class="marker" id="mapping-732"></span><span class="token add" data-title="function_definition/parameter">uint256 maximumSharesToBurn</span>) <span class="marker" id="mapping-733"></span><span class="token mv" id="move-dst-201" data-title="function_definition/visibility">public</span> <span class="marker" id="mapping-734"></span><span class="token add" data-title="function_definition/function_body">{
        <span class="marker" id="mapping-735"></span><span class="token add" data-title="function_body/variable_declaration_statement"><span class="marker" id="mapping-736"></span><span class="token add" data-title="variable_declaration_statement/variable_declaration_tuple">(<span class="marker" id="mapping-737"></span><span class="token mv" id="move-dst-116" data-title="variable_declaration_tuple/variable_declaration">uint256 <span class="marker" id="mapping-738"></span><span class="token upd" id="move-dst-117" data-title="variable_declaration/identifier">shares</span></span>, <span class="marker" id="mapping-739"></span><span class="token mv" id="move-dst-119" data-title="variable_declaration_tuple/variable_declaration">uint256 <span class="marker" id="mapping-740"></span><span class="token upd" id="move-dst-120" data-title="variable_declaration/identifier"><span class="cupd">_</span>withdr<span class="cupd">a</span>wP<span class="cupd">o</span><span class="cupd">o</span>lSh<span class="cupd">a</span>re</span></span>)</span> = <span class="marker" id="mapping-741"></span><span class="token add" data-title="variable_declaration_statement/call_expression">_sellVoucher(claimAmount, maximumSharesToBurn)</span>;</span>

        <span class="marker" id="mapping-742"></span><span class="token mv" id="move-dst-206" data-title="function_body/variable_declaration_statement">DelegatorUnbond memory unbond = unbonds[msg.sender];</span>
        <span class="marker" id="mapping-743"></span><span class="token mv" id="move-dst-207" data-title="function_body/expression_statement">unbond.shares = unbond.shares.add(_withdrawPoolShare);</span>
        // refresh undond period
        <span class="marker" id="mapping-744"></span><span class="token mv" id="move-dst-208" data-title="function_body/expression_statement">unbond.withdrawEpoch = stakeManager.epoch();</span>
        <span class="marker" id="mapping-745"></span><span class="token mv" id="move-dst-209" data-title="function_body/expression_statement">unbonds[msg.sender] = unbond;</span>

        <span class="marker" id="mapping-746"></span><span class="token mv" id="move-dst-210" data-title="function_body/variable_declaration_statement">StakingInfo logger = stakingLogger;</span>
        <span class="marker" id="mapping-747"></span><span class="token mv" id="move-dst-211" data-title="function_body/expression_statement">logger.logShareBurned(validatorId, msg.sender, claimAmount, shares);</span>
        <span class="marker" id="mapping-748"></span><span class="token mv" id="move-dst-212" data-title="function_body/expression_statement">logger.logStakeUpdate(validatorId);</span>
    }</span></span>

    function withdrawRewards() public {
        uint256 rewards = _withdrawAndTransferReward(msg.sender);
        require(rewards &gt;= minAmount, "Too small rewards amount");
    }

    function migrateOut(address user, uint256 amount) external onlyOwner {
        _withdrawAndTransferReward(user);
        <span class="marker" id="mapping-749"></span><span class="token mv" id="move-dst-202" data-title="function_body/variable_declaration_statement">(uint256 totalStaked, uint256 rate) = <span class="marker" id="mapping-750"></span><span class="token mv" id="move-dst-214" data-title="variable_declaration_statement/call_expression"><span class="marker" id="mapping-751"></span><span class="token upd" id="move-dst-215" data-title="call_expression/identifier"><span class="cupd">get</span>TotalStake</span>(user)</span>;</span>
        require(totalStaked &gt;= amount, "Migrating too much");

        uint256 precision = _getRatePrecision();
        uint256 shares = amount.mul(precision).div(rate);
        _burn(user, shares);

        stakeManager.updateValidatorState(validatorId, -int256(amount));
        <span class="marker" id="mapping-752"></span><span class="token mv" id="move-dst-193" data-title="function_body/expression_statement">activeAmount = activeAmount.sub(<span class="marker" id="mapping-753"></span><span class="token upd" id="move-dst-194" data-title="call_argument/identifier"><span class="cupd">a</span>mount</span>);</span>

        stakingLogger.logShareBurned(validatorId, user, amount, shares);
        stakingLogger.logStakeUpdate(validatorId);
        stakingLogger.logDelegatorUnstaked(validatorId, user, amount);
    }

    function migrateIn(address user, uint256 amount) external onlyOwner {
        _withdrawAndTransferReward(user);
        _buyShares(amount, 0, user);
    }

    <span class="marker" id="mapping-754"></span><span class="token add" data-title="contract_body/function_definition">function unstakeClaimTokens() <span class="marker" id="mapping-755"></span><span class="token mv" id="move-dst-176" data-title="function_definition/visibility">public</span> <span class="marker" id="mapping-756"></span><span class="token add" data-title="function_definition/function_body">{
        <span class="marker" id="mapping-757"></span><span class="token mv" id="move-dst-230" data-title="function_body/variable_declaration_statement">DelegatorUnbond memory unbond = unbonds[msg.sender];</span>
        <span class="marker" id="mapping-758"></span><span class="token mv" id="move-dst-171" data-title="function_body/variable_declaration_statement">uint256 <span class="marker" id="mapping-759"></span><span class="token upd" id="move-dst-172" data-title="variable_declaration/identifier"><span class="cupd">amount</span></span> = <span class="marker" id="mapping-760"></span><span class="token add" data-title="variable_declaration_statement/call_expression">_unstakeClaimTokens(unbond)</span>;</span>
        <span class="marker" id="mapping-761"></span><span class="token mv" id="move-dst-233" data-title="function_body/expression_statement">delete unbonds[msg.sender];</span>
        <span class="marker" id="mapping-762"></span><span class="token mv" id="move-dst-231" data-title="function_body/expression_statement">stakingLogger.logDelegatorUnstaked(validatorId, msg.sender, <span class="marker" id="mapping-763"></span><span class="token upd" id="move-dst-232" data-title="call_argument/identifier"><span class="cupd">amount</span></span>);</span>
    }</span></span>

    function slash(
        <span class="marker" id="mapping-764"></span><span class="token mv" id="move-dst-145" data-title="function_definition/parameter">uint256 validatorStake</span>,
        <span class="marker" id="mapping-765"></span><span class="token mv" id="move-dst-190" data-title="function_definition/parameter">uint256 <span class="marker" id="mapping-766"></span><span class="token upd" id="move-dst-191" data-title="parameter/identifier">deleg<span class="cupd">a</span><span class="cupd">t</span><span class="cupd">e</span><span class="cupd">d</span>Amount</span></span><span class="marker" id="mapping-767"></span><span class="token add" data-title="function_definition/,">,</span>
        uint256 totalAmountToSlash
    ) external onlyOwner returns (uint256) {
        uint256 _withdrawPool = withdrawPool;
        uint256 delegationAmount = <span class="marker" id="mapping-768"></span><span class="token upd" id="move-dst-234" data-title="member_expression/identifier">deleg<span class="cupd">a</span><span class="cupd">t</span><span class="cupd">e</span>d<span class="cupd">Amount</span></span>.add(_withdrawPool);
        if (delegationAmount == 0) {
            return 0;
        }
        // total amount to be slashed from delegation pool (active + inactive)
        uint256 _amountToSlash = delegationAmount.mul(totalAmountToSlash).div(<span class="marker" id="mapping-769"></span><span class="token mv" id="move-dst-133" data-title="call_argument/call_expression">validatorStake.add(<span class="marker" id="mapping-770"></span><span class="token mv" id="move-dst-235" data-title="call_expression/call_argument">delegationAmount</span>)</span>);
        uint256 _amountToSlashWithdrawalPool = _withdrawPool.mul(_amountToSlash).div(delegationAmount);

        // slash inactive pool
        <span class="marker" id="mapping-771"></span><span class="token mv" id="move-dst-151" data-title="function_body/variable_declaration_statement">uint256 <span class="marker" id="mapping-772"></span><span class="token upd" id="move-dst-152" data-title="variable_declaration/identifier">stak<span class="cupd">e</span>S<span class="cupd">l</span><span class="cupd">a</span><span class="cupd">s</span>h<span class="cupd">e</span>d</span> = <span class="marker" id="mapping-773"></span><span class="token mv" id="move-dst-236" data-title="variable_declaration_statement/call_expression">_amountToSlash.sub(_amountToSlashWithdrawalPool)</span>;</span>
        <span class="marker" id="mapping-774"></span><span class="token add" data-title="function_body/expression_statement">stakeManager.decreaseValidatorDelegatedAmount(validatorId, stakeSlashed);</span>
        <span class="marker" id="mapping-775"></span><span class="token add" data-title="function_body/expression_statement">activeAmount = activeAmount.sub(stakeSlashed);</span>

        <span class="marker" id="mapping-776"></span><span class="token mv" id="move-dst-198" data-title="function_body/expression_statement">withdrawPool = withdrawPool.sub(<span class="marker" id="mapping-777"></span><span class="token mv" id="move-dst-237" data-title="call_expression/call_argument">_amountToSlashWithdrawalPool</span>);</span>
        return _amountToSlash;
    }

    function updateDelegation(bool _delegation) external onlyOwner {
        delegation = _delegation;
    }

    function drain(
        address token,
        address payable destination,
        uint256 amount
    ) external onlyOwner {
        if (token == address(0x0)) {
            destination.transfer(amount);
        } else {
            require(ERC20(token).transfer(destination, amount), "Drain failed");
        }
    }

    <span class="marker" id="mapping-778"></span><span class="token add" data-title="contract_body/comment">/**
        New shares exit API
     */</span>

    <span class="marker" id="mapping-779"></span><span class="token add" data-title="contract_body/function_definition">function sellVoucher_new(<span class="marker" id="mapping-780"></span><span class="token add" data-title="function_definition/parameter">uint256 claimAmount</span>, <span class="marker" id="mapping-781"></span><span class="token add" data-title="function_definition/parameter">uint256 maximumSharesToBurn</span>) <span class="marker" id="mapping-782"></span><span class="token mv" id="move-dst-226" data-title="function_definition/visibility">public</span> <span class="marker" id="mapping-783"></span><span class="token add" data-title="function_definition/function_body">{
        <span class="marker" id="mapping-784"></span><span class="token add" data-title="function_body/variable_declaration_statement"><span class="marker" id="mapping-785"></span><span class="token add" data-title="variable_declaration_statement/variable_declaration_tuple">(<span class="marker" id="mapping-786"></span><span class="token mv" id="move-dst-45" data-title="variable_declaration_tuple/variable_declaration">uint256 <span class="marker" id="mapping-787"></span><span class="token upd" id="move-dst-46" data-title="variable_declaration/identifier">shares</span></span>, <span class="marker" id="mapping-788"></span><span class="token mv" id="move-dst-38" data-title="variable_declaration_tuple/variable_declaration">uint256 <span class="marker" id="mapping-789"></span><span class="token upd" id="move-dst-39" data-title="variable_declaration/identifier">_withdrawPoolShare</span></span>)</span> = <span class="marker" id="mapping-790"></span><span class="token add" data-title="variable_declaration_statement/call_expression">_sellVoucher(claimAmount, maximumSharesToBurn)</span>;</span>

        <span class="marker" id="mapping-791"></span><span class="token add" data-title="function_body/variable_declaration_statement"><span class="marker" id="mapping-792"></span><span class="token mv" id="move-dst-160" data-title="variable_declaration_statement/variable_declaration">uint256 <span class="marker" id="mapping-793"></span><span class="token upd" id="move-dst-161" data-title="variable_declaration/identifier">unbon<span class="cupd">d</span>N<span class="cupd">o</span>nce</span></span> = <span class="marker" id="mapping-794"></span><span class="token add" data-title="variable_declaration_statement/call_expression">unbondNonces[msg.sender].add(1)</span>;</span>

        <span class="marker" id="mapping-795"></span><span class="token mv" id="move-dst-115" data-title="function_body/variable_declaration_statement"><span class="marker" id="mapping-796"></span><span class="token add" data-title="variable_declaration_statement/variable_declaration">DelegatorUnbond memory unbond</span> = <span class="marker" id="mapping-797"></span><span class="token add" data-title="variable_declaration_statement/call_expression">DelegatorUnbond(<span class="marker" id="mapping-798"></span><span class="token add" data-title="call_expression/call_argument">{
            <span class="marker" id="mapping-799"></span><span class="token add" data-title="call_argument/call_struct_argument">shares: _withdrawPoolShare</span>,
            <span class="marker" id="mapping-800"></span><span class="token add" data-title="call_argument/call_struct_argument">withdrawEpoch: <span class="marker" id="mapping-801"></span><span class="token mv" id="move-dst-118" data-title="call_struct_argument/call_expression">stakeManager.epoch()</span></span>
        }</span>)</span>;</span>
        <span class="marker" id="mapping-802"></span><span class="token add" data-title="function_body/expression_statement">unbonds_new[msg.sender][unbondNonce] = unbond;</span>
        <span class="marker" id="mapping-803"></span><span class="token add" data-title="function_body/expression_statement">unbondNonces[msg.sender] = unbondNonce;</span>

        <span class="marker" id="mapping-804"></span><span class="token add" data-title="function_body/expression_statement"><span class="marker" id="mapping-805"></span><span class="token add" data-title="expression_statement/call_expression"><span class="marker" id="mapping-806"></span><span class="token add" data-title="call_expression/member_expression">_getOrCacheEventsHub().logShareBurnedWithId</span>(<span class="marker" id="mapping-807"></span><span class="token add" data-title="call_expression/call_argument">validatorId</span>, <span class="marker" id="mapping-808"></span><span class="token mv" id="move-dst-185" data-title="call_expression/call_argument">msg.sender</span>, <span class="marker" id="mapping-809"></span><span class="token mv" id="move-dst-205" data-title="call_expression/call_argument">claimAmount</span>, <span class="marker" id="mapping-810"></span><span class="token add" data-title="call_expression/call_argument">shares</span>, <span class="marker" id="mapping-811"></span><span class="token add" data-title="call_expression/call_argument">unbondNonce</span>)</span>;</span>
        <span class="marker" id="mapping-812"></span><span class="token add" data-title="function_body/expression_statement">stakingLogger.logStakeUpdate(validatorId);</span>
    }</span></span>

    <span class="marker" id="mapping-813"></span><span class="token add" data-title="contract_body/function_definition">function unstakeClaimTokens_new(<span class="marker" id="mapping-814"></span><span class="token mv" id="move-dst-195" data-title="function_definition/parameter">uint256 <span class="marker" id="mapping-815"></span><span class="token upd" id="move-dst-196" data-title="parameter/identifier">unbon<span class="cupd">d</span>N<span class="cupd">o</span>n<span class="cupd">ce</span></span></span>) <span class="marker" id="mapping-816"></span><span class="token mv" id="move-dst-223" data-title="function_definition/visibility">public</span> <span class="marker" id="mapping-817"></span><span class="token add" data-title="function_definition/function_body">{
        <span class="marker" id="mapping-818"></span><span class="token add" data-title="function_body/variable_declaration_statement">DelegatorUnbond memory unbond = unbonds_new[msg.sender][unbondNonce];</span>
        <span class="marker" id="mapping-819"></span><span class="token add" data-title="function_body/variable_declaration_statement"><span class="marker" id="mapping-820"></span><span class="token mv" id="move-dst-148" data-title="variable_declaration_statement/variable_declaration">uint256 <span class="marker" id="mapping-821"></span><span class="token upd" id="move-dst-149" data-title="variable_declaration/identifier"><span class="cupd">a</span>mount</span></span> = <span class="marker" id="mapping-822"></span><span class="token add" data-title="variable_declaration_statement/call_expression">_unstakeClaimTokens(unbond)</span>;</span>
        <span class="marker" id="mapping-823"></span><span class="token add" data-title="function_body/expression_statement">delete unbonds_new[msg.sender][unbondNonce];</span>
        <span class="marker" id="mapping-824"></span><span class="token add" data-title="function_body/expression_statement"><span class="marker" id="mapping-825"></span><span class="token add" data-title="expression_statement/call_expression"><span class="marker" id="mapping-826"></span><span class="token add" data-title="call_expression/member_expression">_getOrCacheEventsHub().logDelegatorUnstakedWithId</span>(<span class="marker" id="mapping-827"></span><span class="token add" data-title="call_expression/call_argument">validatorId</span>, <span class="marker" id="mapping-828"></span><span class="token mv" id="move-dst-181" data-title="call_expression/call_argument">msg.sender</span>, <span class="marker" id="mapping-829"></span><span class="token mv" id="move-dst-220" data-title="call_expression/call_argument">amount</span>, <span class="marker" id="mapping-830"></span><span class="token add" data-title="call_expression/call_argument">unbondNonce</span>)</span>;</span>
    }</span></span>

    <span class="marker" id="mapping-831"></span><span class="token add" data-title="contract_body/comment">/**
        Private Methods
     */</span>

    <span class="marker" id="mapping-832"></span><span class="token add" data-title="contract_body/function_definition">function _getOrCacheEventsHub() <span class="marker" id="mapping-833"></span><span class="token mv" id="move-dst-197" data-title="function_definition/visibility">private</span> <span class="marker" id="mapping-834"></span><span class="token add" data-title="function_definition/return_type_definition">returns(EventsHub)</span> <span class="marker" id="mapping-835"></span><span class="token add" data-title="function_definition/function_body">{
        <span class="marker" id="mapping-836"></span><span class="token add" data-title="function_body/variable_declaration_statement">EventsHub _eventsHub = eventsHub;</span>
        <span class="marker" id="mapping-837"></span><span class="token add" data-title="function_body/if_statement">if (<span class="marker" id="mapping-838"></span><span class="token add" data-title="if_statement/binary_expression">_eventsHub == <span class="marker" id="mapping-839"></span><span class="token add" data-title="binary_expression/call_expression">EventsHub(<span class="marker" id="mapping-840"></span><span class="token mv" id="move-dst-55" data-title="call_expression/call_argument">0x0</span>)</span></span>) <span class="marker" id="mapping-841"></span><span class="token add" data-title="if_statement/block_statement">{
            <span class="marker" id="mapping-842"></span><span class="token mv" id="move-dst-121" data-title="block_statement/expression_statement"><span class="marker" id="mapping-843"></span><span class="token add" data-title="expression_statement/assignment_expression">_eventsHub = <span class="marker" id="mapping-844"></span><span class="token add" data-title="assignment_expression/call_expression">EventsHub(<span class="marker" id="mapping-845"></span><span class="token add" data-title="call_expression/call_argument"><span class="marker" id="mapping-846"></span><span class="token add" data-title="call_argument/call_expression"><span class="marker" id="mapping-847"></span><span class="token add" data-title="call_expression/member_expression">Registry(stakeManager.getRegistry()).contractMap</span>(<span class="marker" id="mapping-848"></span><span class="token add" data-title="call_expression/call_argument"><span class="marker" id="mapping-849"></span><span class="token mv" id="move-dst-122" data-title="call_argument/call_expression"><span class="marker" id="mapping-850"></span><span class="token upd" id="move-dst-123" data-title="call_expression/identifier">keccak256</span>("eventsHub")</span></span>)</span></span>)</span></span>;</span>
            <span class="marker" id="mapping-851"></span><span class="token add" data-title="block_statement/expression_statement">eventsHub = _eventsHub;</span>
        }</span></span>
        <span class="marker" id="mapping-852"></span><span class="token add" data-title="function_body/return_statement">return _eventsHub;</span>
    }</span></span>

    <span class="marker" id="mapping-853"></span><span class="token mv" id="move-dst-199" data-title="contract_body/function_definition">function <span class="marker" id="mapping-854"></span><span class="token upd" id="move-dst-200" data-title="function_definition/identifier">_<span class="cupd">sellVoucher</span></span>(uint256 claimAmount, uint256 maximumSharesToBurn) <span class="marker" id="mapping-855"></span><span class="token mv" id="move-dst-192" data-title="function_definition/visibility">private</span> <span class="marker" id="mapping-856"></span><span class="token add" data-title="function_definition/return_type_definition">returns(uint256, uint256)</span> {
        // first get how much staked in total and compare to target unstake amount
        <span class="marker" id="mapping-857"></span><span class="token mv" id="move-dst-218" data-title="function_body/variable_declaration_statement">(uint256 totalStaked, uint256 rate) = <span class="marker" id="mapping-858"></span><span class="token mv" id="move-dst-203" data-title="variable_declaration_statement/call_expression"><span class="marker" id="mapping-859"></span><span class="token upd" id="move-dst-204" data-title="call_expression/identifier"><span class="cupd">getTotalStake</span></span>(msg.sender)</span>;</span>
        require(totalStaked <span class="marker" id="mapping-860"></span><span class="token add" data-title="binary_expression/!=">!=</span> 0 &amp;&amp; totalStaked &gt;= claimAmount, "Too much requested");

        // convert requested amount back to shares
        uint256 precision = _getRatePrecision();
        uint256 shares = claimAmount.mul(precision).div(rate);
        require(shares &lt;= maximumSharesToBurn, "too much slippage");

        _withdrawAndTransferReward(msg.sender);

        _burn(msg.sender, shares);
        stakeManager.updateValidatorState(validatorId, -int256(claimAmount));
        <span class="marker" id="mapping-861"></span><span class="token add" data-title="expression_statement/assignment_expression">activeAmount = activeAmount.sub(claimAmount)</span>;

        uint256 _withdrawPoolShare = claimAmount.mul(precision).div(withdrawExchangeRate());
        withdrawPool = withdrawPool.add(claimAmount);
        withdrawShares = withdrawShares.add(_withdrawPoolShare);

        <span class="marker" id="mapping-862"></span><span class="token add" data-title="function_body/return_statement">return (shares, _withdrawPoolShare);</span>
    }</span>

    <span class="marker" id="mapping-863"></span><span class="token mv" id="move-dst-227" data-title="contract_body/function_definition">function <span class="marker" id="mapping-864"></span><span class="token upd" id="move-dst-228" data-title="function_definition/identifier"><span class="cupd">_</span>u<span class="cupd">nstake</span>Claim<span class="cupd">Tokens</span></span>(<span class="marker" id="mapping-865"></span><span class="token add" data-title="function_definition/parameter">DelegatorUnbond memory unbond</span>) <span class="marker" id="mapping-866"></span><span class="token add" data-title="function_definition/visibility">private</span> returns(uint256) {
        uint256 shares = unbond.shares;
        require(
            unbond.withdrawEpoch.add(stakeManager.withdrawalDelay()) &lt;= stakeManager.epoch() &amp;&amp; shares &gt; 0,
            "Incomplete withdrawal period"
        );

        uint256 _amount = withdrawExchangeRate().mul(shares).div(_getRatePrecision());
        withdrawShares = withdrawShares.sub(shares);
        withdrawPool = withdrawPool.sub(_amount);

        require(stakeManager.transferFunds(validatorId, _amount, msg.sender), "Insufficent rewards");

        return _amount;
    }</span>

    <span class="marker" id="mapping-867"></span><span class="token mv" id="move-dst-162" data-title="contract_body/function_definition">function _getRatePrecision() private view returns (uint256) {
        // if foundation validator, use old precision
        if (validatorId &lt; 8) {
            return EXCHANGE_RATE_PRECISION;
        }

        return EXCHANGE_RATE_HIGH_PRECISION;
    }</span>

    <span class="marker" id="mapping-868"></span><span class="token mv" id="move-dst-141" data-title="contract_body/function_definition">function <span class="marker" id="mapping-869"></span><span class="token upd" id="move-dst-142" data-title="function_definition/identifier"><span class="cupd">_</span>calc<span class="cupd">u</span>l<span class="cupd">ateReward</span>PerShareWithRewards</span>(<span class="marker" id="mapping-870"></span><span class="token add" data-title="function_definition/parameter">uint256 accumulatedReward</span>) <span class="marker" id="mapping-871"></span><span class="token add" data-title="visibility/private">private</span> <span class="marker" id="mapping-872"></span><span class="token mv" id="move-dst-238" data-title="function_definition/state_mutability">view</span> <span class="marker" id="mapping-873"></span><span class="token mv" id="move-dst-239" data-title="function_definition/return_type_definition">returns (uint256)</span> {
        <span class="marker" id="mapping-874"></span><span class="token mv" id="move-dst-139" data-title="function_body/variable_declaration_statement">uint256 <span class="marker" id="mapping-875"></span><span class="token upd" id="move-dst-140" data-title="variable_declaration/identifier">_r<span class="cupd">e</span>war<span class="cupd">d</span>Per<span class="cupd">S</span>h<span class="cupd">a</span>re</span> = <span class="marker" id="mapping-876"></span><span class="token add" data-title="variable_declaration_statement/identifier">rewardPerShare</span>;</span>
        if (<span class="marker" id="mapping-877"></span><span class="token upd" id="move-dst-150" data-title="binary_expression/identifier">a<span class="cupd">c</span>cu<span class="cupd">m</span>ul<span class="cupd">ate</span>dReward</span> <span class="marker" id="mapping-878"></span><span class="token add" data-title="binary_expression/!=">!=</span> 0) {
            <span class="marker" id="mapping-879"></span><span class="token mv" id="move-dst-153" data-title="block_statement/variable_declaration_statement">uint256 totalShares = totalSupply();</span>
            
            <span class="marker" id="mapping-880"></span><span class="token mv" id="move-dst-154" data-title="block_statement/if_statement">if (totalShares <span class="marker" id="mapping-881"></span><span class="token add" data-title="binary_expression/!=">!=</span> 0) {
                <span class="marker" id="mapping-882"></span><span class="token upd" id="move-dst-155" data-title="assignment_expression/identifier">_<span class="cupd">rewardPerShare</span></span> = <span class="marker" id="mapping-883"></span><span class="token upd" id="move-dst-156" data-title="member_expression/identifier">_<span class="cupd">rewardPerShare</span></span>.add(<span class="marker" id="mapping-884"></span><span class="token upd" id="move-dst-157" data-title="member_expression/identifier">accumu<span class="cupd">l</span><span class="cupd">at</span>ed<span class="cupd">Reward</span></span>.mul(REWARD_PRECISION).div(totalShares));
            }</span>
        }

        <span class="marker" id="mapping-885"></span><span class="token add" data-title="function_body/return_statement">return _rewardPerShare;</span>
    }</span>

    <span class="marker" id="mapping-886"></span><span class="token mv" id="move-dst-221" data-title="contract_body/function_definition">function <span class="marker" id="mapping-887"></span><span class="token upd" id="move-dst-222" data-title="function_definition/identifier">_calculat<span class="cupd">e</span><span class="cupd">Reward</span></span>(address user<span class="marker" id="mapping-888"></span><span class="token add" data-title="function_definition/,">,</span> <span class="marker" id="mapping-889"></span><span class="token add" data-title="function_definition/parameter">uint256 _rewardPerShare</span>) <span class="marker" id="mapping-890"></span><span class="token add" data-title="function_definition/visibility">private</span> view returns (uint256) {
        uint256 shares = balanceOf(user);
        if (shares == 0) {
            return 0;
        }

        <span class="marker" id="mapping-891"></span><span class="token add" data-title="function_body/variable_declaration_statement"><span class="marker" id="mapping-892"></span><span class="token mv" id="move-dst-134" data-title="variable_declaration_statement/variable_declaration">uint256 <span class="marker" id="mapping-893"></span><span class="token upd" id="move-dst-135" data-title="variable_declaration/identifier">_initialR<span class="cupd">eward</span>PerShare</span></span> = <span class="marker" id="mapping-894"></span><span class="token mv" id="move-dst-225" data-title="variable_declaration_statement/array_access">initalRewardPerShare[user]</span>;</span>

        <span class="marker" id="mapping-895"></span><span class="token add" data-title="function_body/if_statement">if (_initialRewardPerShare == _rewardPerShare) {
            return 0;
        }</span>

        return <span class="marker" id="mapping-896"></span><span class="token upd" id="move-dst-224" data-title="member_expression/identifier">_<span class="cupd">rewardPerShare</span></span>.sub(<span class="marker" id="mapping-897"></span><span class="token add" data-title="call_argument/identifier">_initialRewardPerShare</span>).mul(shares).div(REWARD_PRECISION);
    }</span>

    <span class="marker" id="mapping-898"></span><span class="token mv" id="move-dst-213" data-title="contract_body/function_definition">function _withdrawReward(address user) private returns (uint256) {
        <span class="marker" id="mapping-899"></span><span class="token mv" id="move-dst-131" data-title="function_body/variable_declaration_statement">uint256 <span class="marker" id="mapping-900"></span><span class="token upd" id="move-dst-132" data-title="variable_declaration/identifier">_r<span class="cupd">e</span>war<span class="cupd">d</span>Per<span class="cupd">S</span>h<span class="cupd">a</span>re</span> = <span class="marker" id="mapping-901"></span><span class="token add" data-title="variable_declaration_statement/call_expression">_calculateRewardPerShareWithRewards(
            stakeManager.withdrawDelegatorsReward(validatorId)
        )</span>;</span>
        uint256 liquidRewards = <span class="marker" id="mapping-902"></span><span class="token add" data-title="variable_declaration_statement/call_expression">_calculateReward(<span class="marker" id="mapping-903"></span><span class="token mv" id="move-dst-219" data-title="call_expression/call_argument">user</span>, <span class="marker" id="mapping-904"></span><span class="token add" data-title="call_expression/call_argument">_rewardPerShare</span>)</span>;
        
        <span class="marker" id="mapping-905"></span><span class="token add" data-title="function_body/expression_statement">rewardPerShare = _rewardPerShare;</span>
        initalRewardPerShare[user] = <span class="marker" id="mapping-906"></span><span class="token upd" id="move-dst-216" data-title="assignment_expression/identifier">_<span class="cupd">rewardPerShare</span></span>;
        return liquidRewards;
    }</span>

    <span class="marker" id="mapping-907"></span><span class="token mv" id="move-dst-217" data-title="contract_body/function_definition">function _withdrawAndTransferReward(address user) private returns (uint256) {
        uint256 liquidRewards = _withdrawReward(user);
        if (liquidRewards <span class="marker" id="mapping-908"></span><span class="token add" data-title="binary_expression/!=">!=</span> 0) {
            require(stakeManager.transferFunds(validatorId, liquidRewards, user), "Insufficent rewards");
            stakingLogger.logDelegatorClaimRewards(validatorId, user, liquidRewards);
        }
        return liquidRewards;
    }</span>

    <span class="marker" id="mapping-909"></span><span class="token mv" id="move-dst-186" data-title="contract_body/function_definition">function _buyShares(
        uint256 _amount,
        uint256 _minSharesToMint,
        address user
    ) private onlyWhenUnlocked returns (uint256) {
        require(delegation, "Delegation is disabled");

        uint256 rate = exchangeRate();
        uint256 precision = _getRatePrecision();
        uint256 shares = _amount.mul(precision).div(rate);
        require(shares &gt;= _minSharesToMint, "Too much slippage");
        require(unbonds[user].shares == 0, "Ongoing exit");

        _mint(user, shares);

        // clamp amount of tokens in case resulted shares requires less tokens than anticipated
        _amount = <span class="marker" id="mapping-910"></span><span class="token mv" id="move-dst-187" data-title="assignment_expression/call_expression"><span class="marker" id="mapping-911"></span><span class="token mv" id="move-dst-188" data-title="member_expression/call_expression">rate.mul(shares)</span>.div(precision)</span>;

        stakeManager.updateValidatorState(validatorId, int256(_amount));
        <span class="marker" id="mapping-912"></span><span class="token mv" id="move-dst-189" data-title="function_body/expression_statement">activeAmount = activeAmount.add(_amount);</span>

        StakingInfo logger = stakingLogger;
        logger.logShareMinted(validatorId, user, _amount, shares);
        logger.logStakeUpdate(validatorId);

        return _amount;
    }</span>

    <span class="marker" id="mapping-913"></span><span class="token add" data-title="contract_body/function_definition">function _transfer(
        <span class="marker" id="mapping-914"></span><span class="token mv" id="move-dst-12" data-title="function_definition/parameter">address from</span>,
        <span class="marker" id="mapping-915"></span><span class="token mv" id="move-dst-13" data-title="function_definition/parameter">address to</span>,
        <span class="marker" id="mapping-916"></span><span class="token add" data-title="function_definition/parameter">uint256 value</span>
    ) <span class="marker" id="mapping-917"></span><span class="token mv" id="move-dst-229" data-title="function_definition/visibility">internal</span> <span class="marker" id="mapping-918"></span><span class="token add" data-title="function_definition/function_body">{
        // get rewards for recipient 
        _withdrawAndTransferReward(to);
        // convert rewards to shares
        _withdrawAndTransferReward(from);
        // move shares to recipient
        super._transfer(from, to, value);
    }</span></span>
}</pre></div></div></div></body></html>