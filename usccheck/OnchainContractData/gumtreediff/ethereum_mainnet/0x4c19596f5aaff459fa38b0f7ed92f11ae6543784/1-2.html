<html lang="en"><head><meta charset="utf8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>GumTree</title><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css"><style type="text/css">/*
 * This file is part of GumTree.
 *
 * GumTree is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * GumTree is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with GumTree.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Copyright 2011-2015 Jean-Rémy Falleri <jr.falleri@gmail.com>
 * Copyright 2011-2015 Floréal Morandat <florealm@gmail.com>
 */

.add {
	border: 1px solid black;
	background-color: MediumSeaGreen;
}

.del {
	border: 1px solid black;
	background-color: IndianRed;
}

.mv {
	border: 1px solid black;
	background-color: Plum;
}

.upd {
	border: 1px solid black;
	background-color: DarkOrange;
	font-weight: bold;
}

.cupd {
	font-weight: normal;
	color: DimGray;
}

.selected {
	background-color: Gold;
}

.marker {
	margin: 0;
	padding: 0;
}

div {
	margin: 0px;
	padding: 0px;
}

.pre-scrollable {
	margin: 0px;
	padding: 0px;
	font-size: 10pt;
	color: black;
	max-height: 90vh;
	background-color: white;
	border: 1px solid black;
	font-family: "Hack, Inconsolata", "Consolas", "Liberation Sans Regular", "DejaVu Sans Mono", monospace;
}

.tooltip-inner {
    max-width: none;
}
</style><script type="text/javascript" src="https://code.jquery.com/jquery-3.4.1.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/js/bootstrap.bundle.min.js"></script><script type="text/javascript">/*
 * This file is part of GumTree.
 *
 * GumTree is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * GumTree is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with GumTree.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Copyright 2011-2015 Jean-Rémy Falleri <jr.falleri@gmail.com>
 * Copyright 2011-2015 Floréal Morandat <florealm@gmail.com>
 */

$(function(){
    let popoverTriggerList = [].slice.call(document.querySelectorAll('[data-bs-toggle="popover"]'))
    let popoverList = popoverTriggerList.map(function (popoverTriggerEl) {
      return new bootstrap.Popover(popoverTriggerEl)
    })

    $("body").keypress(function (event) {
        switch (event.which) {
            case 116:
                $('html, body').animate({scrollTop: 0}, 100);
                break;
            case 98:
                $("html, body").animate({ scrollTop: $(document).height() }, 100);
                break;
            case 113:
                window.location = "/quit";
                break;
            case 108:
                window.location = "/list";
                break;
        }
    });
});
</script><script type="text/javascript">/*
 * This file is part of GumTree.
 *
 * GumTree is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * GumTree is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with GumTree.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Copyright 2011-2015 Jean-Rémy Falleri <jr.falleri@gmail.com>
 * Copyright 2011-2015 Floréal Morandat <florealm@gmail.com>
 */

currentMapping = 0;

if (typeof String.prototype.startsWith != 'function') {
  String.prototype.startsWith = function (str){
    return this.slice(0, str.length) == str;
  };
}

function getMappedElement(eltId) {
	if (eltId.startsWith("move-src")) {
		return eltId.replace("src","dst");  	 	
  	}
  	else {
  		return eltId.replace("dst","src");
  	}
}

function nextMapping() {
	if (currentMapping == 0) {
		currentMapping = 1;
		return "#mapping-" + currentMapping.toString();
	} else {
		currentMapping++;
		
		if ($("#mapping-" + currentMapping.toString()).length > 0) {
			return "#mapping-" + currentMapping.toString();
		} else {
			currentMapping = 1;
			return "#mapping-" + currentMapping.toString();		
		}		
	}
}

function isSrc(eltId) {
	return eltId.startsWith("move-src");
}

$(function() {
    $("body").keypress(function (event) {
        switch(event.which) {
            case 110:
                const mapping = $(nextMapping());
                const pre = mapping.closest("pre");
                pre.animate({scrollTop: pre.scrollTop() + mapping.position().top - 200}, 100);
                break;
        }
    });

    // highlight
    $("span.mv.token, span.token.upd").click(function(event) {
        if ($(this).hasClass("selected")) {
            $("span.mv.token, span.token.upd").removeClass("selected");
        } else {
            $("span.mv.token, span.token.upd").removeClass("selected");
            const refElt = $("#" + getMappedElement($(this).attr("id")));
            $(this).addClass("selected");
            refElt.addClass("selected");
            const pre = refElt.closest("pre");
            console.log(pre);
            pre.animate({scrollTop: pre.scrollTop() + refElt.position().top - 200}, 100);
        }
        event.stopPropagation();
    });
    
    $("span.add.token, span.token.del").click(function(event) {
        $("span.mv.token, span.token.upd").removeClass("selected");
        event.stopPropagation();
    });

    // tooltip
    $("span.token").hover(
    	function (event) {
    		$(this).tooltip('show');
    		event.stopPropagation();
    	},
    	function (event) {
    		$(this).tooltip('hide');
    		event.stopPropagation();
    	}
    );
});
</script></head><body><div class="container-fluid"><div class="row"><div class="col"><div class="btn-toolbar justify-content-end"><div class="btn-group mr-2"><button class="btn btn-primary btn-sm" id="legend" data-bs-toggle="popover" data-bs-placement="bottom" data-bs-html="true" data-bs-content="<span class='del'>&nbsp;&nbsp;</span> deleted<br><span class='add'>&nbsp;&nbsp;</span> added<br><span class='mv'>&nbsp;&nbsp;</span> moved<br><span class='upd';>&nbsp;&nbsp;</span> updated<br>">Legend</button><button class="btn btn-primary btn-sm" id="shortcuts" data-bs-toggle="popover" data-bs-placement="bottom" data-bs-html="true" data-bs-content="<b>q</b> quit<br><b>l</b> list<br><b>n</b> next<br><b>t</b> top<br><b>b</b> bottom">Shortcuts</button></div><div class="btn-group"><a href="/list" class="btn btn-default btn-sm btn-primary">Back</a><a href="/quit" class="btn btn-default btn-sm btn-danger">Quit</a></div></div></div></div><div class="row"><div class="col-6"><h5>0xacedb4eb28eedc7fc05583abe829b7e19a17e50d.etherscan.io-TrustToken.sol</h5><pre class="pre-scrollable"><span class="marker" id="mapping-1"></span><span class="token mv" id="move-src-1" data-title="source_file/comment">// SPDX-License-Identifier: MIT</span>

<span class="marker" id="mapping-2"></span><span class="token upd" id="move-src-2" data-title="source_file/comment"><span class="cupd">// </span>File: @openzeppelin/contracts/math/SafeMath.sol</span>


<span class="marker" id="mapping-3"></span><span class="token mv" id="move-src-3" data-title="source_file/pragma_directive">pragma solidity ^0.6.0;</span>

<span class="marker" id="mapping-4"></span><span class="token mv" id="move-src-4" data-title="source_file/comment">/**
 * @dev Wrappers over Solidity's arithmetic operations with added overflow
 * checks.
 *
 * Arithmetic operations in Solidity wrap on overflow. This can easily result
 * in bugs, because programmers usually assume that an overflow raises an
 * error, which is the standard behavior in high level programming languages.
 * `SafeMath` restores this intuition by reverting the transaction when an
 * operation overflows.
 *
 * Using this library instead of the unchecked operations eliminates an entire
 * class of bugs, so it's recommended to use it always.
 */</span>
<span class="marker" id="mapping-5"></span><span class="token mv" id="move-src-5" data-title="source_file/library_declaration">library SafeMath {
    /**
     * @dev Returns the addition of two unsigned integers, reverting on
     * overflow.
     *
     * Counterpart to Solidity's `+` operator.
     *
     * Requirements:
     *
     * - Addition cannot overflow.
     */
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c &gt;= a, "SafeMath: addition overflow");

        return c;
    }

    /**
     * @dev Returns the subtraction of two unsigned integers, reverting on
     * overflow (when the result is negative).
     *
     * Counterpart to Solidity's `-` operator.
     *
     * Requirements:
     *
     * - Subtraction cannot overflow.
     */
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        return sub(a, b, "SafeMath: subtraction overflow");
    }

    /**
     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on
     * overflow (when the result is negative).
     *
     * Counterpart to Solidity's `-` operator.
     *
     * Requirements:
     *
     * - Subtraction cannot overflow.
     */
    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
        require(b &lt;= a, errorMessage);
        uint256 c = a - b;

        return c;
    }

    /**
     * @dev Returns the multiplication of two unsigned integers, reverting on
     * overflow.
     *
     * Counterpart to Solidity's `*` operator.
     *
     * Requirements:
     *
     * - Multiplication cannot overflow.
     */
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the
        // benefit is lost if 'b' is also tested.
        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522
        if (a == 0) {
            return 0;
        }

        uint256 c = a * b;
        require(c / a == b, "SafeMath: multiplication overflow");

        return c;
    }

    /**
     * @dev Returns the integer division of two unsigned integers. Reverts on
     * division by zero. The result is rounded towards zero.
     *
     * Counterpart to Solidity's `/` operator. Note: this function uses a
     * `revert` opcode (which leaves remaining gas untouched) while Solidity
     * uses an invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     *
     * - The divisor cannot be zero.
     */
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        return div(a, b, "SafeMath: division by zero");
    }

    /**
     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on
     * division by zero. The result is rounded towards zero.
     *
     * Counterpart to Solidity's `/` operator. Note: this function uses a
     * `revert` opcode (which leaves remaining gas untouched) while Solidity
     * uses an invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     *
     * - The divisor cannot be zero.
     */
    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
        require(b &gt; 0, errorMessage);
        uint256 c = a / b;
        // assert(a == b * c + a % b); // There is no case in which this doesn't hold

        return c;
    }

    /**
     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),
     * Reverts when dividing by zero.
     *
     * Counterpart to Solidity's `%` operator. This function uses a `revert`
     * opcode (which leaves remaining gas untouched) while Solidity uses an
     * invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     *
     * - The divisor cannot be zero.
     */
    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
        return mod(a, b, "SafeMath: modulo by zero");
    }

    /**
     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),
     * Reverts with custom message when dividing by zero.
     *
     * Counterpart to Solidity's `%` operator. This function uses a `revert`
     * opcode (which leaves remaining gas untouched) while Solidity uses an
     * invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     *
     * - The divisor cannot be zero.
     */
    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
        require(b != 0, errorMessage);
        return a % b;
    }
}</span>

<span class="marker" id="mapping-6"></span><span class="token upd" id="move-src-6" data-title="source_file/comment"><span class="cupd">// </span>File: @openzeppelin/contracts/token/ERC20/IERC20.sol</span>


<span class="marker" id="mapping-7"></span><span class="token mv" id="move-src-7" data-title="source_file/pragma_directive">pragma solidity ^0.6.0;</span>

<span class="marker" id="mapping-8"></span><span class="token mv" id="move-src-8" data-title="source_file/comment">/**
 * @dev Interface of the ERC20 standard as defined in the EIP.
 */</span>
<span class="marker" id="mapping-9"></span><span class="token mv" id="move-src-9" data-title="source_file/interface_declaration">interface IERC20 {
    /**
     * @dev Returns the amount of tokens in existence.
     */
    function totalSupply() external view returns (uint256);

    /**
     * @dev Returns the amount of tokens owned by `account`.
     */
    function balanceOf(address account) external view returns (uint256);

    /**
     * @dev Moves `amount` tokens from the caller's account to `recipient`.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * Emits a {Transfer} event.
     */
    function transfer(address recipient, uint256 amount) external returns (bool);

    /**
     * @dev Returns the remaining number of tokens that `spender` will be
     * allowed to spend on behalf of `owner` through {transferFrom}. This is
     * zero by default.
     *
     * This value changes when {approve} or {transferFrom} are called.
     */
    function allowance(address owner, address spender) external view returns (uint256);

    /**
     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * IMPORTANT: Beware that changing an allowance with this method brings the risk
     * that someone may use both the old and the new allowance by unfortunate
     * transaction ordering. One possible solution to mitigate this race
     * condition is to first reduce the spender's allowance to 0 and set the
     * desired value afterwards:
     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
     *
     * Emits an {Approval} event.
     */
    function approve(address spender, uint256 amount) external returns (bool);

    /**
     * @dev Moves `amount` tokens from `sender` to `recipient` using the
     * allowance mechanism. `amount` is then deducted from the caller's
     * allowance.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * Emits a {Transfer} event.
     */
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);

    /**
     * @dev Emitted when `value` tokens are moved from one account (`from`) to
     * another (`to`).
     *
     * Note that `value` may be zero.
     */
    event Transfer(address indexed from, address indexed to, uint256 value);

    /**
     * @dev Emitted when the allowance of a `spender` for an `owner` is set by
     * a call to {approve}. `value` is the new allowance.
     */
    event Approval(address indexed owner, address indexed spender, uint256 value);
}</span>

<span class="marker" id="mapping-10"></span><span class="token upd" id="move-src-10" data-title="source_file/comment"><span class="cupd">// </span>File: contracts/registry/Registry.sol</span>

<span class="marker" id="mapping-11"></span><span class="token del" data-title="source_file/pragma_directive">pragma solidity 0.6.10;</span>


<span class="marker" id="mapping-12"></span><span class="token mv" id="move-src-11" data-title="source_file/interface_declaration">interface RegistryClone {
    function syncAttributeValue(
        address _who,
        bytes32 _attribute,
        uint256 _value
    ) external;
}</span>

<span class="marker" id="mapping-13"></span><span class="token mv" id="move-src-12" data-title="source_file/contract_declaration">contract Registry {
    struct AttributeData {
        uint256 value;
        bytes32 notes;
        address adminAddr;
        uint256 timestamp;
    }

    // never remove any storage variables
    address public owner;
    address public pendingOwner;
    bool initialized;

    // Stores arbitrary attributes for users. An example use case is an IERC20
    // token that requires its users to go through a KYC/AML check - in this case
    // a validator can set an account's "hasPassedKYC/AML" attribute to 1 to indicate
    // that account can use the token. This mapping stores that value (1, in the
    // example) as well as which validator last set the value and at what time,
    // so that e.g. the check can be renewed at appropriate intervals.
    mapping(address =&gt; mapping(bytes32 =&gt; AttributeData)) attributes;
    // The logic governing who is allowed to set what attributes is abstracted as
    // this accessManager, so that it may be replaced by the owner as needed
    bytes32 constant WRITE_PERMISSION = keccak256("canWriteTo-");
    mapping(bytes32 =&gt; RegistryClone[]) subscribers;

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);
    event SetAttribute(address indexed who, bytes32 attribute, uint256 value, bytes32 notes, address indexed adminAddr);
    event SetManager(address indexed oldManager, address indexed newManager);
    event StartSubscription(bytes32 indexed attribute, RegistryClone indexed subscriber);
    event StopSubscription(bytes32 indexed attribute, RegistryClone indexed subscriber);

    // Allows a write if either a) the writer is that Registry's owner, or
    // b) the writer is writing to attribute foo and that writer already has
    // the canWriteTo-foo attribute set (in that same Registry)
    function confirmWrite(bytes32 _attribute, address _admin) internal view returns (bool) {
        return (_admin == owner || hasAttribute(_admin, keccak256(abi.encodePacked(WRITE_PERMISSION ^ _attribute))));
    }

    // Writes are allowed only if the accessManager approves
    function setAttribute(
        address _who,
        bytes32 _attribute,
        uint256 _value,
        bytes32 _notes
    ) public {
        require(confirmWrite(_attribute, msg.sender));
        attributes[_who][_attribute] = AttributeData(_value, _notes, msg.sender, block.timestamp);
        emit SetAttribute(_who, _attribute, _value, _notes, msg.sender);

        RegistryClone[] storage targets = subscribers[_attribute];
        uint256 index = targets.length;
        while (index-- &gt; 0) {
            targets[index].syncAttributeValue(_who, _attribute, _value);
        }
    }

    function subscribe(bytes32 _attribute, RegistryClone _syncer) external onlyOwner {
        subscribers[_attribute].push(_syncer);
        emit StartSubscription(_attribute, _syncer);
    }

    function unsubscribe(bytes32 _attribute, uint256 _index) external onlyOwner {
        uint256 length = subscribers[_attribute].length;
        require(_index &lt; length);
        emit StopSubscription(_attribute, subscribers[_attribute][_index]);
        subscribers[_attribute][_index] = subscribers[_attribute][length - 1];
        subscribers[_attribute].pop();
    }

    function subscriberCount(bytes32 _attribute) public view returns (uint256) {
        return subscribers[_attribute].length;
    }

    function setAttributeValue(
        address _who,
        bytes32 _attribute,
        uint256 _value
    ) public {
        require(confirmWrite(_attribute, msg.sender));
        attributes[_who][_attribute] = AttributeData(_value, "", msg.sender, block.timestamp);
        emit SetAttribute(_who, _attribute, _value, "", msg.sender);
        RegistryClone[] storage targets = subscribers[_attribute];
        uint256 index = targets.length;
        while (index-- &gt; 0) {
            targets[index].syncAttributeValue(_who, _attribute, _value);
        }
    }

    // Returns true if the uint256 value stored for this attribute is non-zero
    function hasAttribute(address _who, bytes32 _attribute) public view returns (bool) {
        return attributes[_who][_attribute].value != 0;
    }

    // Returns the exact value of the attribute, as well as its metadata
    function getAttribute(address _who, bytes32 _attribute)
        public
        view
        returns (
            uint256,
            bytes32,
            address,
            uint256
        )
    {
        AttributeData memory data = attributes[_who][_attribute];
        return (data.value, data.notes, data.adminAddr, data.timestamp);
    }

    function getAttributeValue(address _who, bytes32 _attribute) public view returns (uint256) {
        return attributes[_who][_attribute].value;
    }

    function getAttributeAdminAddr(address _who, bytes32 _attribute) public view returns (address) {
        return attributes[_who][_attribute].adminAddr;
    }

    function getAttributeTimestamp(address _who, bytes32 _attribute) public view returns (uint256) {
        return attributes[_who][_attribute].timestamp;
    }

    function syncAttribute(
        bytes32 _attribute,
        uint256 _startIndex,
        address[] calldata _addresses
    ) external {
        RegistryClone[] storage targets = subscribers[_attribute];
        uint256 index = targets.length;
        while (index-- &gt; _startIndex) {
            RegistryClone target = targets[index];
            for (uint256 i = _addresses.length; i-- &gt; 0; ) {
                address who = _addresses[i];
                target.syncAttributeValue(who, _attribute, attributes[who][_attribute].value);
            }
        }
    }

    function reclaimEther(address payable _to) external onlyOwner {
        _to.transfer(address(this).balance);
    }

    function reclaimToken(IERC20 token, address _to) external onlyOwner {
        uint256 balance = token.balanceOf(address(this));
        token.transfer(_to, balance);
    }

    /**
     * @dev Throws if called by any account other than the owner.
     */
    modifier onlyOwner() {
        require(msg.sender == owner, "only Owner");
        _;
    }

    /**
     * @dev Modifier throws if called by any account other than the pendingOwner.
     */
    modifier onlyPendingOwner() {
        require(msg.sender == pendingOwner);
        _;
    }

    /**
     * @dev Allows the current owner to set the pendingOwner address.
     * @param newOwner The address to transfer ownership to.
     */
    function transferOwnership(address newOwner) public onlyOwner {
        pendingOwner = newOwner;
    }

    /**
     * @dev Allows the pendingOwner address to finalize the transfer.
     */
    function claimOwnership() public onlyPendingOwner {
        emit OwnershipTransferred(owner, pendingOwner);
        owner = pendingOwner;
        pendingOwner = address(0);
    }
}</span>

<span class="marker" id="mapping-14"></span><span class="token upd" id="move-src-13" data-title="source_file/comment"><span class="cupd">// </span>File:<span class="cupd"> </span>contracts/trusttokens/ProxyStorage.sol</span>

<span class="marker" id="mapping-15"></span><span class="token del" data-title="source_file/pragma_directive">pragma solidity 0.6.10;</span>


<span class="marker" id="mapping-16"></span><span class="token mv" id="move-src-14" data-title="source_file/comment">/**
 * All storage must be declared here
 * New storage must be appended to the end
 * Never remove items from this list
 */</span>
<span class="marker" id="mapping-17"></span><span class="token mv" id="move-src-15" data-title="source_file/contract_declaration">contract ProxyStorage {
    bool initalized;
    uint256 public totalSupply;

    mapping(address =&gt; uint256) public balanceOf;
    mapping(address =&gt; mapping(address =&gt; uint256)) public allowance;
    mapping(uint144 =&gt; uint256) attributes; // see RegistrySubscriber

    address owner_;
    address pendingOwner_;

    /* Additionally, we have several keccak-based storage locations.
     * If you add more keccak-based storage mappings, such as mappings, you must document them here.
     * If the length of the keccak input is the same as an existing mapping, it is possible there could be a preimage collision.
     * A preimage collision can be used to attack the contract by treating one storage location as another,
     * which would always be a critical issue.
     * Carefully examine future keccak-based storage to ensure there can be no preimage collisions.
     *******************************************************************************************************
     ** length     input                                                         usage
     *******************************************************************************************************
     ** 19         "trueXXX.proxy.owner"                                         Proxy Owner
     ** 27         "trueXXX.pending.proxy.owner"                                 Pending Proxy Owner
     ** 28         "trueXXX.proxy.implementation"                                Proxy Implementation
     ** 64         uint256(address),uint256(1)                                   balanceOf
     ** 64         uint256(address),keccak256(uint256(address),uint256(2))       allowance
     ** 64         uint256(address),keccak256(bytes32,uint256(3))                attributes
     **/
}</span>

<span class="marker" id="mapping-18"></span><span class="token upd" id="move-src-16" data-title="source_file/comment"><span class="cupd">// </span>File:<span class="cupd"> </span>contracts<span class="cupd">/</span>trusttokens/ValSafeMath.sol</span>

<span class="marker" id="mapping-19"></span><span class="token del" data-title="source_file/pragma_directive">pragma solidity 0.6.10;</span>

<span class="marker" id="mapping-20"></span><span class="token upd" id="move-src-17" data-title="source_file/comment"><span class="cupd">/</span>**<span class="cupd"></span><span class="cupd">
</span> <span class="cupd">*</span> Forke<span class="cupd">d</span> subse<span class="cupd">t</span> o<span class="cupd">f</span> Openzeppeli<span class="cupd">n</span> SafeMath allowing custom underflo<span class="cupd">w</span>/overflow messages<span class="cupd">
 </span>* Usef<span class="cupd">u</span>l f<span class="cupd">o</span>r debugging, replaceable with standard SafeMath
 */</span>
<span class="marker" id="mapping-21"></span><span class="token mv" id="move-src-18" data-title="source_file/library_declaration">library <span class="marker" id="mapping-22"></span><span class="token upd" id="move-src-19" data-title="library_declaration/identifier">ValSafeMath</span> {
    <span class="marker" id="mapping-23"></span><span class="token del" data-title="contract_body/function_definition">function add(
        uint256 a,
        uint256 b,
        string memory overflowMessage
    ) internal pure returns (uint256 result) {
        result = a + b;
        require(result &gt;= a, overflowMessage);
    }</span>

    <span class="marker" id="mapping-24"></span><span class="token del" data-title="contract_body/function_definition">function sub(
        <span class="marker" id="mapping-25"></span><span class="token del" data-title="function_definition/parameter">uint256 a</span>,
        <span class="marker" id="mapping-26"></span><span class="token del" data-title="function_definition/parameter">uint256 b</span>,
        <span class="marker" id="mapping-27"></span><span class="token mv" id="move-src-20" data-title="function_definition/parameter">string memory <span class="marker" id="mapping-28"></span><span class="token upd" id="move-src-21" data-title="parameter/identifier">und<span class="cupd">er</span>fl<span class="cupd">o</span>w<span class="cupd">Message</span></span></span>
    ) <span class="marker" id="mapping-29"></span><span class="token mv" id="move-src-22" data-title="function_definition/visibility">internal</span> <span class="marker" id="mapping-30"></span><span class="token mv" id="move-src-23" data-title="function_definition/state_mutability">pure</span> <span class="marker" id="mapping-31"></span><span class="token del" data-title="function_definition/return_type_definition">returns (uint256 result)</span> <span class="marker" id="mapping-32"></span><span class="token del" data-title="function_definition/function_body">{
        require(b &lt;= a, underflowMessage);
        result = a - b;
    }</span></span>

    <span class="marker" id="mapping-33"></span><span class="token del" data-title="contract_body/function_definition">function mul(
        <span class="marker" id="mapping-34"></span><span class="token del" data-title="function_definition/parameter">uint256 a</span>,
        <span class="marker" id="mapping-35"></span><span class="token del" data-title="function_definition/parameter">uint256 b</span>,
        <span class="marker" id="mapping-36"></span><span class="token mv" id="move-src-24" data-title="function_definition/parameter">string memory <span class="marker" id="mapping-37"></span><span class="token upd" id="move-src-25" data-title="parameter/identifier">ov<span class="cupd">er</span>fl<span class="cupd">o</span>w<span class="cupd">Message</span></span></span>
    ) <span class="marker" id="mapping-38"></span><span class="token mv" id="move-src-26" data-title="function_definition/visibility">internal</span> <span class="marker" id="mapping-39"></span><span class="token mv" id="move-src-27" data-title="function_definition/state_mutability">pure</span> <span class="marker" id="mapping-40"></span><span class="token del" data-title="function_definition/return_type_definition">returns (uint256 result)</span> <span class="marker" id="mapping-41"></span><span class="token del" data-title="function_definition/function_body">{
        if (a == 0) {
            return 0;
        }
        result = a * b;
        require(result / a == b, overflowMessage);
    }</span></span>

    <span class="marker" id="mapping-42"></span><span class="token del" data-title="contract_body/function_definition">function div(
        <span class="marker" id="mapping-43"></span><span class="token del" data-title="function_definition/parameter">uint256 a</span>,
        <span class="marker" id="mapping-44"></span><span class="token mv" id="move-src-28" data-title="function_definition/parameter">uint256 <span class="marker" id="mapping-45"></span><span class="token upd" id="move-src-29" data-title="parameter/identifier">b</span></span>,
        <span class="marker" id="mapping-46"></span><span class="token mv" id="move-src-30" data-title="function_definition/parameter">string memory <span class="marker" id="mapping-47"></span><span class="token upd" id="move-src-31" data-title="parameter/identifier">divid<span class="cupd">e</span>ByZe<span class="cupd">r</span><span class="cupd">o</span><span class="cupd">Message</span></span></span>
    ) <span class="marker" id="mapping-48"></span><span class="token mv" id="move-src-32" data-title="function_definition/visibility">internal</span> <span class="marker" id="mapping-49"></span><span class="token mv" id="move-src-33" data-title="function_definition/state_mutability">pure</span> <span class="marker" id="mapping-50"></span><span class="token del" data-title="function_definition/return_type_definition">returns (uint256 result)</span> <span class="marker" id="mapping-51"></span><span class="token del" data-title="function_definition/function_body">{
        require(b &gt; 0, divideByZeroMessage);
        result = a / b;
    }</span></span>
}</span>

<span class="marker" id="mapping-52"></span><span class="token upd" id="move-src-34" data-title="source_file/comment"><span class="cupd">// </span>File: contracts/trusttokens/ERC20.sol</span>

<span class="marker" id="mapping-53"></span><span class="token del" data-title="source_file/pragma_directive">pragma solidity 0.6.10;</span>



<span class="marker" id="mapping-54"></span><span class="token upd" id="move-src-35" data-title="source_file/comment"><span class="cupd">// </span>Fork<span class="cupd"> </span>of<span class="cupd"> </span>OpenZeppelin's BasicToken</span>
<span class="marker" id="mapping-55"></span><span class="token upd" id="move-src-36" data-title="source_file/comment"><span class="cupd">/</span>**<span class="cupd"></span><span class="cupd">
</span> <span class="cupd">*</span> @titl<span class="cupd">e</span> Basi<span class="cupd">c</span> toke<span class="cupd">n</span>
<span class="cupd"> </span>* @d<span class="cupd">e</span>v Bas<span class="cupd">i</span>c versi<span class="cupd">o</span>n <span class="cupd">o</span>f StandardToke<span class="cupd">n</span>, wi<span class="cupd">t</span>h <span class="cupd">n</span>o allowance<span class="cupd">s.</span><span class="cupd">
</span> */</span>
<span class="marker" id="mapping-56"></span><span class="token del" data-title="source_file/contract_declaration">contract ModularBasicToken is <span class="marker" id="mapping-57"></span><span class="token mv" id="move-src-37" data-title="contract_declaration/inheritance_specifier">ProxyStorage</span> <span class="marker" id="mapping-58"></span><span class="token del" data-title="contract_declaration/contract_body">{
    <span class="marker" id="mapping-59"></span><span class="token del" data-title="contract_body/using_directive">using ValSafeMath for uint256;</span>

    <span class="marker" id="mapping-60"></span><span class="token mv" id="move-src-38" data-title="contract_body/event_definition">event Transfer(address indexed from, address indexed to, uint256 value);</span>

    <span class="marker" id="mapping-61"></span><span class="token del" data-title="contract_body/function_definition">function _addBalance(<span class="marker" id="mapping-62"></span><span class="token del" data-title="function_definition/parameter">address _who</span>, <span class="marker" id="mapping-63"></span><span class="token del" data-title="function_definition/parameter">uint256 _value</span>) <span class="marker" id="mapping-64"></span><span class="token mv" id="move-src-39" data-title="function_definition/visibility">internal</span> <span class="marker" id="mapping-65"></span><span class="token del" data-title="function_definition/return_type_definition">returns (uint256 priorBalance)</span> <span class="marker" id="mapping-66"></span><span class="token del" data-title="function_definition/function_body">{
        <span class="marker" id="mapping-67"></span><span class="token del" data-title="function_body/expression_statement">priorBalance = balanceOf[_who];</span>
        <span class="marker" id="mapping-68"></span><span class="token mv" id="move-src-40" data-title="function_body/expression_statement"><span class="marker" id="mapping-69"></span><span class="token del" data-title="expression_statement/assignment_expression"><span class="marker" id="mapping-70"></span><span class="token del" data-title="assignment_expression/array_access">balanceOf[_who]</span> = <span class="marker" id="mapping-71"></span><span class="token mv" id="move-src-41" data-title="assignment_expression/call_expression"><span class="marker" id="mapping-72"></span><span class="token del" data-title="call_expression/member_expression">priorBalance.add</span>(<span class="marker" id="mapping-73"></span><span class="token del" data-title="call_argument/identifier">_value</span>, "balance overflow")</span></span>;</span>
    }</span></span>

    <span class="marker" id="mapping-74"></span><span class="token del" data-title="contract_body/function_definition">function _subBalance(<span class="marker" id="mapping-75"></span><span class="token del" data-title="function_definition/parameter">address _who</span>, <span class="marker" id="mapping-76"></span><span class="token del" data-title="function_definition/parameter">uint256 _value</span>) <span class="marker" id="mapping-77"></span><span class="token mv" id="move-src-42" data-title="function_definition/visibility">internal</span> <span class="marker" id="mapping-78"></span><span class="token del" data-title="function_definition/return_type_definition">returns (uint256 result)</span> <span class="marker" id="mapping-79"></span><span class="token del" data-title="function_definition/function_body">{
        <span class="marker" id="mapping-80"></span><span class="token mv" id="move-src-43" data-title="function_body/expression_statement"><span class="marker" id="mapping-81"></span><span class="token del" data-title="expression_statement/assignment_expression">result = <span class="marker" id="mapping-82"></span><span class="token mv" id="move-src-44" data-title="assignment_expression/call_expression"><span class="marker" id="mapping-83"></span><span class="token del" data-title="call_expression/member_expression">balanceOf[_who].sub</span>(<span class="marker" id="mapping-84"></span><span class="token del" data-title="call_argument/identifier">_value</span>, "insufficient balance")</span></span>;</span>
        <span class="marker" id="mapping-85"></span><span class="token del" data-title="function_body/expression_statement">balanceOf[_who] = result;</span>
    }</span></span>

    <span class="marker" id="mapping-86"></span><span class="token del" data-title="contract_body/function_definition">function _setBalance(<span class="marker" id="mapping-87"></span><span class="token del" data-title="function_definition/parameter">address _who</span>, <span class="marker" id="mapping-88"></span><span class="token del" data-title="function_definition/parameter">uint256 _value</span>) <span class="marker" id="mapping-89"></span><span class="token mv" id="move-src-45" data-title="function_definition/visibility">internal</span> <span class="marker" id="mapping-90"></span><span class="token del" data-title="function_definition/function_body">{
        balanceOf[_who] = _value;
    }</span></span>
}</span></span>

<span class="marker" id="mapping-91"></span><span class="token upd" id="move-src-46" data-title="source_file/comment"><span class="cupd">/</span>**<span class="cupd"></span><span class="cupd">
</span> <span class="cupd">*</span> @titl<span class="cupd">e</span> Standar<span class="cupd">d</span> ERC2<span class="cupd">0</span> toke<span class="cupd">n</span>
<span class="cupd"> </span>*
 * @dev Implementation of the basic standard token.
 * @dev ht<span class="cupd">t</span>ps://github.com/ethereum/EIPs/issue<span class="cupd">s/</span>2<span class="cupd">0</span>
 *<span class="cupd"> </span>@dev <span class="cupd">B</span>ased on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol
 */</span>
<span class="marker" id="mapping-92"></span><span class="token mv" id="move-src-47" data-title="source_file/contract_declaration">contract <span class="marker" id="mapping-93"></span><span class="token upd" id="move-src-48" data-title="contract_declaration/identifier">ModularStandardToken</span> is <span class="marker" id="mapping-94"></span><span class="token upd" id="move-src-49" data-title="user_defined_type/identifier">M<span class="cupd">o</span>dularBasicToken</span> {
    using <span class="marker" id="mapping-95"></span><span class="token upd" id="move-src-50" data-title="type_alias/identifier">Val<span class="cupd">SafeMath</span></span> for uint256;
    <span class="marker" id="mapping-96"></span><span class="token del" data-title="contract_body/state_variable_declaration">uint256 constant INFINITE_ALLOWANCE = 0xfe00000000000000000000000000000000000000000000000000000000000000;</span>

    <span class="marker" id="mapping-97"></span><span class="token mv" id="move-src-51" data-title="contract_body/event_definition">event Approval(address indexed owner, address indexed spender, uint256 value);</span>

    <span class="marker" id="mapping-98"></span><span class="token upd" id="move-src-52" data-title="contract_body/comment"><span class="cupd">/**
     * @dev</span> Approve<span class="cupd"> </span>the passed address<span class="cupd"> </span>to s<span class="cupd">p</span>e<span class="cupd">nd</span> <span class="cupd">th</span><span class="cupd">e</span> specified<span class="cupd"> </span>am<span class="cupd">o</span>un<span class="cupd">t</span> of<span class="cupd"> tokens</span> on be<span class="cupd">h</span>alf of msg.send<span class="cupd">e</span>r.
     *
     <span class="cupd">*</span> Bew<span class="cupd">a</span>re that changing an <span class="cupd">a</span>llow<span class="cupd">a</span>nce with this me<span class="cupd">th</span>o<span class="cupd">d</span> brings the risk tha<span class="cupd">t </span>some<span class="cupd">o</span>ne may us<span class="cupd">e</span> both the old
    <span class="cupd"> </span>* an<span class="cupd">d </span>the <span class="cupd">n</span>ew all<span class="cupd">o</span>wance by<span class="cupd"> </span>un<span class="cupd">fo</span>r<span class="cupd">t</span>u<span class="cupd">n</span>a<span class="cupd">t</span>e trans<span class="cupd">a</span>c<span class="cupd">t</span>ion ordering. One possible <span class="cupd">s</span>o<span class="cupd">l</span>u<span class="cupd">t</span>io<span class="cupd">n</span> to miti<span class="cupd">g</span>ate <span class="cupd">thi</span>s
<span class="cupd">  </span> <span class="cupd"> </span> * ra<span class="cupd">c</span>e co<span class="cupd">n</span>ditio<span class="cupd">n</span> is to first red<span class="cupd">uc</span>e the s<span class="cupd">p</span>en<span class="cupd">d</span>er's allow<span class="cupd">an</span><span class="cupd">c</span>e<span class="cupd"> </span>to <span class="cupd">0</span> an<span class="cupd">d</span> se<span class="cupd">t</span> the de<span class="cupd">s</span>ired <span class="cupd">v</span>alue afterw<span class="cupd">ards:</span><span class="cupd">
 </span>    * https://gi<span class="cupd">t</span>hub<span class="cupd">.</span>c<span class="cupd">o</span>m/ethereum/EIPs/issues/20#issue<span class="cupd">c</span>omment-263524729
     * @param _sp<span class="cupd">e</span>nd<span class="cupd">e</span>r The address which will<span class="cupd"> </span>sp<span class="cupd">e</span>nd the funds.
     * <span class="cupd">@para</span><span class="cupd">m</span> _va<span class="cupd">l</span>ue Th<span class="cupd">e</span> amount of to<span class="cupd">ken</span>s <span class="cupd">t</span>o <span class="cupd">be spent.</span>
     */</span>
    <span class="marker" id="mapping-99"></span><span class="token mv" id="move-src-53" data-title="contract_body/function_definition">function <span class="marker" id="mapping-100"></span><span class="token upd" id="move-src-54" data-title="function_definition/identifier"><span class="cupd">a</span>ppr<span class="cupd">o</span>ve</span>(<span class="marker" id="mapping-101"></span><span class="token del" data-title="function_definition/parameter">address _spender</span>, <span class="marker" id="mapping-102"></span><span class="token del" data-title="function_definition/parameter">uint256 _value</span>) public returns (bool) {
        <span class="marker" id="mapping-103"></span><span class="token upd" id="move-src-55" data-title="call_expression/identifier"><span class="cupd">_approve</span>AllArgs</span>(<span class="marker" id="mapping-104"></span><span class="token mv" id="move-src-56" data-title="call_expression/call_argument"><span class="marker" id="mapping-105"></span><span class="token upd" id="move-src-57" data-title="call_argument/identifier">_<span class="cupd">spender</span></span></span>, <span class="marker" id="mapping-106"></span><span class="token del" data-title="call_expression/call_argument">_value</span>, <span class="marker" id="mapping-107"></span><span class="token del" data-title="call_expression/call_argument">msg.sender</span>);
        return true;
    }</span>

    <span class="marker" id="mapping-108"></span><span class="token del" data-title="contract_body/function_definition">function _approveAllArgs(
        <span class="marker" id="mapping-109"></span><span class="token mv" id="move-src-58" data-title="function_definition/parameter">address <span class="marker" id="mapping-110"></span><span class="token upd" id="move-src-59" data-title="parameter/identifier">_spender</span></span>,
        <span class="marker" id="mapping-111"></span><span class="token del" data-title="function_definition/parameter">uint256 _value</span>,
        <span class="marker" id="mapping-112"></span><span class="token del" data-title="function_definition/parameter">address _tokenHolder</span>
    ) <span class="marker" id="mapping-113"></span><span class="token mv" id="move-src-60" data-title="function_definition/visibility">internal</span> <span class="marker" id="mapping-114"></span><span class="token del" data-title="function_definition/function_body">{
        _setAllowance(_tokenHolder, _spender, _value);
        emit Approval(_tokenHolder, _spender, _value);
    }</span></span>

    <span class="marker" id="mapping-115"></span><span class="token upd" id="move-src-61" data-title="contract_body/comment"><span class="cupd">/**
     * @dev</span> Inc<span class="cupd">r</span>eas<span class="cupd">e</span> <span class="cupd">th</span>e amo<span class="cupd">u</span>n<span class="cupd">t</span> of<span class="cupd"> </span>tokens <span class="cupd">t</span>hat an ow<span class="cupd">n</span>e<span class="cupd">r allo</span>wed to<span class="cupd"> </span>a sp<span class="cupd">e</span>n<span class="cupd">d</span>er<span class="cupd">.</span>
     *
     * a<span class="cupd">p</span>pr<span class="cupd">o</span>ve should b<span class="cupd">e</span> cal<span class="cupd">l</span>ed when allowe<span class="cupd">d[_spen</span>d<span class="cupd">e</span>r] == 0<span class="cupd">.</span> To <span class="cupd">i</span>ncrem<span class="cupd">e</span>nt
   <span class="cupd"> </span> * allowed value is better to use thi<span class="cupd">s</span> func<span class="cupd">t</span>i<span class="cupd">o</span>n to avoid 2 calls (<span class="cupd">a</span>nd wa<span class="cupd">i</span>t until
    <span class="cupd"> </span><span class="cupd">*</span> <span class="cupd">t</span>h<span class="cupd">e</span> <span class="cupd">f</span>irst<span class="cupd"> </span>transaction i<span class="cupd">s</span> mined)
     * From <span class="cupd">M</span>onol<span class="cupd">i</span>thDAO Tok<span class="cupd">en.sol
</span>  <span class="cupd"> </span>  *<span class="cupd"> </span>@param _spend<span class="cupd">e</span>r The address w<span class="cupd">hic</span>h will<span class="cupd"> </span>sp<span class="cupd">e</span>nd the funds.
<span class="cupd"> </span> <span class="cupd"> </span>  <span class="cupd">*</span> <span class="cupd">@</span>param <span class="cupd">_ad</span><span class="cupd">d</span>edV<span class="cupd">a</span>lue T<span class="cupd">h</span>e amoun<span class="cupd">t</span> o<span class="cupd">f</span> tok<span class="cupd">e</span>ns<span class="cupd"> </span>to <span class="cupd">i</span>ncre<span class="cupd">ase the a</span>llo<span class="cupd">wance by.</span>
     */</span>
    <span class="marker" id="mapping-116"></span><span class="token mv" id="move-src-62" data-title="contract_body/function_definition">function <span class="marker" id="mapping-117"></span><span class="token upd" id="move-src-63" data-title="function_definition/identifier"><span class="cupd">increaseA</span>ppr<span class="cupd">o</span>val</span>(<span class="marker" id="mapping-118"></span><span class="token mv" id="move-src-64" data-title="function_definition/parameter">address <span class="marker" id="mapping-119"></span><span class="token upd" id="move-src-65" data-title="parameter/identifier">_spender</span></span>, <span class="marker" id="mapping-120"></span><span class="token del" data-title="function_definition/parameter">uint256 _addedValue</span>) public returns (bool) {
        <span class="marker" id="mapping-121"></span><span class="token upd" id="move-src-66" data-title="call_expression/identifier"><span class="cupd">_</span>incre<span class="cupd">a</span>seA<span class="cupd">pprov</span>alAllArgs</span>(<span class="marker" id="mapping-122"></span><span class="token mv" id="move-src-67" data-title="call_expression/call_argument"><span class="marker" id="mapping-123"></span><span class="token upd" id="move-src-68" data-title="call_argument/identifier">_<span class="cupd">spender</span></span></span>, <span class="marker" id="mapping-124"></span><span class="token del" data-title="call_expression/call_argument">_addedValue</span>, <span class="marker" id="mapping-125"></span><span class="token del" data-title="call_expression/call_argument">msg.sender</span>);
        return true;
    }</span>

    <span class="marker" id="mapping-126"></span><span class="token del" data-title="contract_body/function_definition">function _increaseApprovalAllArgs(
        <span class="marker" id="mapping-127"></span><span class="token mv" id="move-src-69" data-title="function_definition/parameter">address <span class="marker" id="mapping-128"></span><span class="token upd" id="move-src-70" data-title="parameter/identifier">_spender</span></span>,
        <span class="marker" id="mapping-129"></span><span class="token del" data-title="function_definition/parameter">uint256 _addedValue</span>,
        <span class="marker" id="mapping-130"></span><span class="token del" data-title="function_definition/parameter">address _tokenHolder</span>
    ) <span class="marker" id="mapping-131"></span><span class="token mv" id="move-src-71" data-title="function_definition/visibility">internal</span> <span class="marker" id="mapping-132"></span><span class="token del" data-title="function_definition/function_body">{
        _addAllowance(_tokenHolder, _spender, _addedValue);
        emit Approval(_tokenHolder, _spender, allowance[_tokenHolder][_spender]);
    }</span></span>

    <span class="marker" id="mapping-133"></span><span class="token upd" id="move-src-72" data-title="contract_body/comment"><span class="cupd">/**
     * @dev</span> <span class="cupd">D</span>ecrease<span class="cupd"> </span>the am<span class="cupd">o</span>unt of tokens that an own<span class="cupd">e</span>r allowed to a sp<span class="cupd">e</span>nder.
     *
     * appro<span class="cupd">v</span>e sho<span class="cupd">u</span>ld be called when allowed[_spender] == 0. To decre<span class="cupd">m</span>ent
     * allowed value is better to u<span class="cupd">s</span>e this function to avoid 2 calls (and wait until
    <span class="cupd"> *</span> the firs<span class="cupd">t</span> <span class="cupd">t</span>ransactio<span class="cupd">n</span> i<span class="cupd">s</span> m<span class="cupd">i</span>ned)
   <span class="cupd"> </span> * From MonolithDAO Token.sol
     * @param _spender The address which will spe<span class="cupd">n</span>d the<span class="cupd"> </span>funds.
     * @pa<span class="cupd">r</span>am _subtracte<span class="cupd">dVa</span>lue T<span class="cupd">h</span>e<span class="cupd"> </span>amou<span class="cupd">nt </span>of tokens to decrease the allo<span class="cupd">wance by.</span>
     */</span>
    <span class="marker" id="mapping-134"></span><span class="token del" data-title="contract_body/function_definition">function decreaseApproval(<span class="marker" id="mapping-135"></span><span class="token mv" id="move-src-73" data-title="function_definition/parameter">address <span class="marker" id="mapping-136"></span><span class="token upd" id="move-src-74" data-title="parameter/identifier">_spender</span></span>, <span class="marker" id="mapping-137"></span><span class="token mv" id="move-src-75" data-title="function_definition/parameter">uint256 <span class="marker" id="mapping-138"></span><span class="token upd" id="move-src-76" data-title="parameter/identifier">_<span class="cupd">subtractedValue</span></span></span>) <span class="marker" id="mapping-139"></span><span class="token mv" id="move-src-77" data-title="function_definition/visibility">public</span> <span class="marker" id="mapping-140"></span><span class="token mv" id="move-src-78" data-title="function_definition/return_type_definition">returns (bool)</span> <span class="marker" id="mapping-141"></span><span class="token del" data-title="function_definition/function_body">{
        <span class="marker" id="mapping-142"></span><span class="token del" data-title="function_body/expression_statement">_decreaseApprovalAllArgs(_spender, _subtractedValue, msg.sender);</span>
        <span class="marker" id="mapping-143"></span><span class="token mv" id="move-src-79" data-title="function_body/return_statement">return true;</span>
    }</span></span>

    <span class="marker" id="mapping-144"></span><span class="token del" data-title="contract_body/function_definition">function _decreaseApprovalAllArgs(
        <span class="marker" id="mapping-145"></span><span class="token mv" id="move-src-80" data-title="function_definition/parameter">address <span class="marker" id="mapping-146"></span><span class="token upd" id="move-src-81" data-title="parameter/identifier">_spe<span class="cupd">n</span>d<span class="cupd">er</span></span></span>,
        <span class="marker" id="mapping-147"></span><span class="token mv" id="move-src-82" data-title="function_definition/parameter">uint256 <span class="marker" id="mapping-148"></span><span class="token upd" id="move-src-83" data-title="parameter/identifier">_subtr<span class="cupd">a</span>ct<span class="cupd">edValue</span></span></span>,
        <span class="marker" id="mapping-149"></span><span class="token mv" id="move-src-84" data-title="function_definition/parameter">address <span class="marker" id="mapping-150"></span><span class="token upd" id="move-src-85" data-title="parameter/identifier">_<span class="cupd">t</span>okenHolder</span></span>
    ) <span class="marker" id="mapping-151"></span><span class="token del" data-title="function_definition/visibility">internal</span> <span class="marker" id="mapping-152"></span><span class="token del" data-title="function_definition/function_body">{
        uint256 oldValue = allowance[_tokenHolder][_spender];
        uint256 newValue;
        if (_subtractedValue &gt; oldValue) {
            newValue = 0;
        } else {
            newValue = oldValue - _subtractedValue;
        }
        _setAllowance(_tokenHolder, _spender, newValue);
        emit Approval(_tokenHolder, _spender, newValue);
    }</span></span>

    <span class="marker" id="mapping-153"></span><span class="token del" data-title="contract_body/function_definition">function _addAllowance(
        <span class="marker" id="mapping-154"></span><span class="token mv" id="move-src-86" data-title="function_definition/parameter">address <span class="marker" id="mapping-155"></span><span class="token upd" id="move-src-87" data-title="parameter/identifier">_who</span></span>,
        <span class="marker" id="mapping-156"></span><span class="token mv" id="move-src-88" data-title="function_definition/parameter">address <span class="marker" id="mapping-157"></span><span class="token upd" id="move-src-89" data-title="parameter/identifier">_<span class="cupd">spender</span></span></span>,
        <span class="marker" id="mapping-158"></span><span class="token del" data-title="function_definition/parameter">uint256 _value</span>
    ) <span class="marker" id="mapping-159"></span><span class="token del" data-title="function_definition/visibility">internal</span> <span class="marker" id="mapping-160"></span><span class="token del" data-title="function_definition/function_body">{
        <span class="marker" id="mapping-161"></span><span class="token mv" id="move-src-90" data-title="function_body/expression_statement"><span class="marker" id="mapping-162"></span><span class="token del" data-title="expression_statement/assignment_expression"><span class="marker" id="mapping-163"></span><span class="token del" data-title="assignment_expression/array_access">allowance[_who][_spender]</span> = <span class="marker" id="mapping-164"></span><span class="token mv" id="move-src-91" data-title="assignment_expression/call_expression"><span class="marker" id="mapping-165"></span><span class="token del" data-title="call_expression/member_expression">allowance[_who][_spender].add</span>(<span class="marker" id="mapping-166"></span><span class="token del" data-title="call_argument/identifier">_value</span>, "allowance overflow")</span></span>;</span>
    }</span></span>

    <span class="marker" id="mapping-167"></span><span class="token del" data-title="contract_body/function_definition">function _subAllowance(
        <span class="marker" id="mapping-168"></span><span class="token mv" id="move-src-92" data-title="function_definition/parameter">address <span class="marker" id="mapping-169"></span><span class="token upd" id="move-src-93" data-title="parameter/identifier">_who</span></span>,
        <span class="marker" id="mapping-170"></span><span class="token mv" id="move-src-94" data-title="function_definition/parameter">address <span class="marker" id="mapping-171"></span><span class="token upd" id="move-src-95" data-title="parameter/identifier">_<span class="cupd">spender</span></span></span>,
        <span class="marker" id="mapping-172"></span><span class="token del" data-title="function_definition/parameter">uint256 _value</span>
    ) <span class="marker" id="mapping-173"></span><span class="token del" data-title="function_definition/visibility">internal</span> <span class="marker" id="mapping-174"></span><span class="token del" data-title="function_definition/return_type_definition">returns (uint256 newAllowance)</span> <span class="marker" id="mapping-175"></span><span class="token del" data-title="function_definition/function_body">{
        <span class="marker" id="mapping-176"></span><span class="token mv" id="move-src-96" data-title="function_body/expression_statement"><span class="marker" id="mapping-177"></span><span class="token del" data-title="expression_statement/assignment_expression">newAllowance = <span class="marker" id="mapping-178"></span><span class="token mv" id="move-src-97" data-title="assignment_expression/call_expression"><span class="marker" id="mapping-179"></span><span class="token del" data-title="call_expression/member_expression">allowance[_who][_spender].sub</span>(<span class="marker" id="mapping-180"></span><span class="token del" data-title="call_argument/identifier">_value</span>, "insufficient allowance")</span></span>;</span>
        <span class="marker" id="mapping-181"></span><span class="token del" data-title="function_body/if_statement">if (newAllowance &lt; INFINITE_ALLOWANCE) {
            allowance[_who][_spender] = newAllowance;
        }</span>
    }</span></span>

    <span class="marker" id="mapping-182"></span><span class="token del" data-title="contract_body/function_definition">function _setAllowance(
        <span class="marker" id="mapping-183"></span><span class="token mv" id="move-src-98" data-title="function_definition/parameter">address <span class="marker" id="mapping-184"></span><span class="token upd" id="move-src-99" data-title="parameter/identifier">_who</span></span>,
        <span class="marker" id="mapping-185"></span><span class="token mv" id="move-src-100" data-title="function_definition/parameter">address <span class="marker" id="mapping-186"></span><span class="token upd" id="move-src-101" data-title="parameter/identifier">_s<span class="cupd">p</span><span class="cupd">en</span>der</span></span>,
        <span class="marker" id="mapping-187"></span><span class="token del" data-title="function_definition/parameter">uint256 _value</span>
    ) <span class="marker" id="mapping-188"></span><span class="token del" data-title="function_definition/visibility">internal</span> <span class="marker" id="mapping-189"></span><span class="token del" data-title="function_definition/function_body">{
        allowance[_who][_spender] = _value;
    }</span></span>
}</span>

<span class="marker" id="mapping-190"></span><span class="token upd" id="move-src-102" data-title="source_file/comment"><span class="cupd">// </span>File:<span class="cupd"> </span>contracts<span class="cupd">/</span>trusttokens/RegistrySubscriber.sol</span>

<span class="marker" id="mapping-191"></span><span class="token mv" id="move-src-103" data-title="source_file/pragma_directive">pragma solidity 0.6.10;</span>


<span class="marker" id="mapping-192"></span><span class="token del" data-title="source_file/contract_declaration">abstract contract RegistrySubscriber is <span class="marker" id="mapping-193"></span><span class="token del" data-title="contract_declaration/inheritance_specifier">ProxyStorage</span> <span class="marker" id="mapping-194"></span><span class="token del" data-title="contract_declaration/contract_body">{
    // Registry Attributes
    <span class="marker" id="mapping-195"></span><span class="token del" data-title="contract_body/state_variable_declaration"><span class="marker" id="mapping-196"></span><span class="token mv" id="move-src-104" data-title="state_variable_declaration/type_name">bytes32</span> constant PASSED_KYCAML = <span class="marker" id="mapping-197"></span><span class="token del" data-title="state_variable_declaration/string_literal">"hasPassedKYC/AML"</span>;</span>
    <span class="marker" id="mapping-198"></span><span class="token del" data-title="contract_body/state_variable_declaration">bytes32 constant IS_DEPOSIT_ADDRESS = "isDepositAddress";</span>
    <span class="marker" id="mapping-199"></span><span class="token del" data-title="contract_body/state_variable_declaration">bytes32 constant BLACKLISTED = 0x6973426c61636b6c697374656400000000000000000000000000000000000000;</span>
    <span class="marker" id="mapping-200"></span><span class="token del" data-title="contract_body/state_variable_declaration">bytes32 constant REGISTERED_CONTRACT = 0x697352656769737465726564436f6e7472616374000000000000000000000000;</span>

    // attributes Bitmasks
    <span class="marker" id="mapping-201"></span><span class="token del" data-title="contract_body/state_variable_declaration">uint256 constant ACCOUNT_BLACKLISTED = 0xff00000000000000000000000000000000000000000000000000000000000000;</span>
    <span class="marker" id="mapping-202"></span><span class="token del" data-title="contract_body/state_variable_declaration">uint256 constant ACCOUNT_BLACKLISTED_INV = 0x00ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff;</span>
    <span class="marker" id="mapping-203"></span><span class="token del" data-title="contract_body/state_variable_declaration">uint256 constant ACCOUNT_KYC = 0x00ff000000000000000000000000000000000000000000000000000000000000;</span>
    <span class="marker" id="mapping-204"></span><span class="token del" data-title="contract_body/state_variable_declaration">uint256 constant ACCOUNT_KYC_INV = 0xff00ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff;</span>
    <span class="marker" id="mapping-205"></span><span class="token del" data-title="contract_body/state_variable_declaration">uint256 constant ACCOUNT_ADDRESS = 0x000000000000000000000000ffffffffffffffffffffffffffffffffffffffff;</span>
    <span class="marker" id="mapping-206"></span><span class="token del" data-title="contract_body/state_variable_declaration">uint256 constant ACCOUNT_ADDRESS_INV = 0xffffffffffffffffffffffff0000000000000000000000000000000000000000;</span>
    <span class="marker" id="mapping-207"></span><span class="token del" data-title="contract_body/state_variable_declaration">uint256 constant ACCOUNT_HOOK = 0x0000ff0000000000000000000000000000000000000000000000000000000000;</span>
    <span class="marker" id="mapping-208"></span><span class="token del" data-title="contract_body/state_variable_declaration">uint256 constant ACCOUNT_HOOK_INV = 0xffff00ffffffffffffffffffffffffffffffffffffffffffffffffffffffffff;</span>

    <span class="marker" id="mapping-209"></span><span class="token del" data-title="contract_body/function_definition">function registry() <span class="marker" id="mapping-210"></span><span class="token mv" id="move-src-105" data-title="function_definition/visibility">public</span> virtual <span class="marker" id="mapping-211"></span><span class="token mv" id="move-src-106" data-title="function_definition/state_mutability">view</span> <span class="marker" id="mapping-212"></span><span class="token del" data-title="function_definition/return_type_definition">returns (Registry)</span>;</span>

    <span class="marker" id="mapping-213"></span><span class="token del" data-title="contract_body/modifier_definition">modifier onlyRegistry <span class="marker" id="mapping-214"></span><span class="token del" data-title="modifier_definition/function_body">{
        <span class="marker" id="mapping-215"></span><span class="token del" data-title="function_body/expression_statement"><span class="marker" id="mapping-216"></span><span class="token del" data-title="expression_statement/call_expression">require(<span class="marker" id="mapping-217"></span><span class="token del" data-title="call_expression/call_argument"><span class="marker" id="mapping-218"></span><span class="token del" data-title="call_argument/binary_expression"><span class="marker" id="mapping-219"></span><span class="token mv" id="move-src-107" data-title="binary_expression/member_expression">msg.sender</span> == <span class="marker" id="mapping-220"></span><span class="token del" data-title="binary_expression/type_cast_expression"><span class="marker" id="mapping-221"></span><span class="token mv" id="move-src-108" data-title="type_cast_expression/primitive_type">address</span>(<span class="marker" id="mapping-222"></span><span class="token del" data-title="type_cast_expression/call_argument">registry()</span>)</span></span></span>)</span>;</span>
        <span class="marker" id="mapping-223"></span><span class="token del" data-title="function_body/expression_statement">_;</span>
    }</span></span>

    /**
        Attributes are set per autosweep account
        The layout of attributes is detailed here
        lower bytes -&gt; upper bytes
        [0, 20)  recipient address
        [29, 30) REGISTERED_CONTRACT
        [30, 31) PASSED_KYCAML
        [31, 32) BLACKLISTED
    */
    <span class="marker" id="mapping-224"></span><span class="token del" data-title="contract_body/function_definition">function syncAttributeValue(
        <span class="marker" id="mapping-225"></span><span class="token mv" id="move-src-109" data-title="function_definition/parameter">address <span class="marker" id="mapping-226"></span><span class="token upd" id="move-src-110" data-title="parameter/identifier">_who</span></span>,
        <span class="marker" id="mapping-227"></span><span class="token del" data-title="function_definition/parameter"><span class="marker" id="mapping-228"></span><span class="token mv" id="move-src-111" data-title="parameter/type_name">bytes32</span> _attribute</span>,
        <span class="marker" id="mapping-229"></span><span class="token del" data-title="function_definition/parameter">uint256 _value</span>
    ) <span class="marker" id="mapping-230"></span><span class="token mv" id="move-src-112" data-title="function_definition/visibility">public</span> <span class="marker" id="mapping-231"></span><span class="token del" data-title="function_definition/modifier_invocation">onlyRegistry</span> <span class="marker" id="mapping-232"></span><span class="token del" data-title="function_definition/function_body">{
        uint144 who = uint144(uint160(_who) &gt;&gt; 20);
        uint256 prior = attributes[who];
        if (prior == 0) {
            prior = uint256(_who);
        }
        if (_attribute == IS_DEPOSIT_ADDRESS) {
            attributes[who] = (prior &amp; ACCOUNT_ADDRESS_INV) | uint256(address(_value));
        } else if (_attribute == BLACKLISTED) {
            if (_value != 0) {
                attributes[who] = prior | ACCOUNT_BLACKLISTED;
            } else {
                attributes[who] = prior &amp; ACCOUNT_BLACKLISTED_INV;
            }
        } else if (_attribute == PASSED_KYCAML) {
            if (_value != 0) {
                attributes[who] = prior | ACCOUNT_KYC;
            } else {
                attributes[who] = prior &amp; ACCOUNT_KYC_INV;
            }
        } else if (_attribute == REGISTERED_CONTRACT) {
            if (_value != 0) {
                attributes[who] = prior | ACCOUNT_HOOK;
            } else {
                attributes[who] = prior &amp; ACCOUNT_HOOK_INV;
            }
        }
    }</span></span>
}</span></span>

<span class="marker" id="mapping-233"></span><span class="token upd" id="move-src-113" data-title="source_file/comment"><span class="cupd">// </span>File:<span class="cupd"> </span>contracts<span class="cupd">/</span>trusttokens/TrueCoinReceiver.sol</span>

<span class="marker" id="mapping-234"></span><span class="token mv" id="move-src-114" data-title="source_file/pragma_directive">pragma solidity 0.6.10;</span>

<span class="marker" id="mapping-235"></span><span class="token del" data-title="source_file/interface_declaration">interface TrueCoinReceiver <span class="marker" id="mapping-236"></span><span class="token del" data-title="interface_declaration/contract_body">{
    <span class="marker" id="mapping-237"></span><span class="token del" data-title="contract_body/function_definition">function tokenFallback(<span class="marker" id="mapping-238"></span><span class="token mv" id="move-src-115" data-title="function_definition/parameter">address from</span>, <span class="marker" id="mapping-239"></span><span class="token mv" id="move-src-116" data-title="function_definition/parameter">uint256 value</span>) <span class="marker" id="mapping-240"></span><span class="token del" data-title="function_definition/visibility">external</span>;</span>
}</span></span>

<span class="marker" id="mapping-241"></span><span class="token upd" id="move-src-117" data-title="source_file/comment"><span class="cupd">// </span>File:<span class="cupd"> </span>contracts<span class="cupd">/</span>trusttokens/ValTokenWithHook.sol</span>

<span class="marker" id="mapping-242"></span><span class="token mv" id="move-src-118" data-title="source_file/pragma_directive">pragma solidity 0.6.10;</span>




<span class="marker" id="mapping-243"></span><span class="token del" data-title="source_file/contract_declaration">abstract contract ValTokenWithHook is <span class="marker" id="mapping-244"></span><span class="token del" data-title="contract_declaration/inheritance_specifier">ModularStandardToken</span>, <span class="marker" id="mapping-245"></span><span class="token del" data-title="contract_declaration/inheritance_specifier">RegistrySubscriber</span> <span class="marker" id="mapping-246"></span><span class="token del" data-title="contract_declaration/contract_body">{
    <span class="marker" id="mapping-247"></span><span class="token del" data-title="contract_body/event_definition">event Burn(address indexed from, uint256 indexed amount);</span>
    <span class="marker" id="mapping-248"></span><span class="token del" data-title="contract_body/event_definition">event Mint(<span class="marker" id="mapping-249"></span><span class="token del" data-title="event_definition/event_paramater"><span class="marker" id="mapping-250"></span><span class="token mv" id="move-src-119" data-title="event_paramater/type_name">address</span> indexed to</span>, <span class="marker" id="mapping-251"></span><span class="token del" data-title="event_definition/event_paramater">uint256 indexed amount</span>);</span>

    <span class="marker" id="mapping-252"></span><span class="token del" data-title="contract_body/function_definition">function _resolveRecipient(<span class="marker" id="mapping-253"></span><span class="token del" data-title="function_definition/parameter">address _to</span>) <span class="marker" id="mapping-254"></span><span class="token mv" id="move-src-120" data-title="function_definition/visibility">internal</span> <span class="marker" id="mapping-255"></span><span class="token mv" id="move-src-121" data-title="function_definition/state_mutability">view</span> <span class="marker" id="mapping-256"></span><span class="token del" data-title="function_definition/return_type_definition">returns (<span class="marker" id="mapping-257"></span><span class="token mv" id="move-src-122" data-title="return_type_definition/parameter">address to</span>, <span class="marker" id="mapping-258"></span><span class="token del" data-title="return_type_definition/parameter"><span class="marker" id="mapping-259"></span><span class="token mv" id="move-src-123" data-title="parameter/type_name">bool</span> hook</span>)</span> <span class="marker" id="mapping-260"></span><span class="token del" data-title="function_definition/function_body">{
        uint256 flags = (attributes[uint144(uint160(_to) &gt;&gt; 20)]);
        if (flags == 0) {
            to = _to;
            // attributes[uint144(uint160(to) &gt;&gt; 20)] = uint256(to);
            hook = false;
        } else {
            to = address(flags);
            hook = (flags &amp; ACCOUNT_HOOK) != 0;
        }
    }</span></span>

    <span class="marker" id="mapping-261"></span><span class="token del" data-title="contract_body/modifier_definition">modifier resolveSender(<span class="marker" id="mapping-262"></span><span class="token del" data-title="modifier_definition/parameter">address _from</span>) <span class="marker" id="mapping-263"></span><span class="token mv" id="move-src-124" data-title="modifier_definition/function_body">{
        <span class="marker" id="mapping-264"></span><span class="token del" data-title="function_body/variable_declaration_statement">uint256 flags = (attributes[uint144(uint160(_from) &gt;&gt; 20)]);</span>
        <span class="marker" id="mapping-265"></span><span class="token del" data-title="function_body/variable_declaration_statement">address from = address(flags);</span>
        <span class="marker" id="mapping-266"></span><span class="token del" data-title="function_body/if_statement">if (<span class="marker" id="mapping-267"></span><span class="token mv" id="move-src-125" data-title="if_statement/binary_expression"><span class="marker" id="mapping-268"></span><span class="token upd" id="move-src-126" data-title="binary_expression/identifier">from</span> != address(0)</span>) <span class="marker" id="mapping-269"></span><span class="token del" data-title="if_statement/block_statement">{
            <span class="marker" id="mapping-270"></span><span class="token mv" id="move-src-127" data-title="block_statement/expression_statement">require(<span class="marker" id="mapping-271"></span><span class="token del" data-title="call_argument/binary_expression">from == _from</span>, "account collision");</span>
        }</span></span>
        <span class="marker" id="mapping-272"></span><span class="token del" data-title="expression_statement/identifier">_</span>;
    }</span></span>

    <span class="marker" id="mapping-273"></span><span class="token del" data-title="contract_body/function_definition">function _transferFromAllArgs(
        <span class="marker" id="mapping-274"></span><span class="token del" data-title="function_definition/parameter">address _from</span>,
        <span class="marker" id="mapping-275"></span><span class="token del" data-title="function_definition/parameter">address _to</span>,
        <span class="marker" id="mapping-276"></span><span class="token del" data-title="function_definition/parameter">uint256 _value</span>,
        <span class="marker" id="mapping-277"></span><span class="token mv" id="move-src-128" data-title="function_definition/parameter">address <span class="marker" id="mapping-278"></span><span class="token upd" id="move-src-129" data-title="parameter/identifier">_s<span class="cupd">p</span><span class="cupd">en</span>der</span></span>
    ) <span class="marker" id="mapping-279"></span><span class="token mv" id="move-src-130" data-title="function_definition/visibility">internal</span> virtual <span class="marker" id="mapping-280"></span><span class="token del" data-title="function_definition/function_body">{
        _subAllowance(_from, _spender, _value);
        _transferAllArgs(_from, _to, _value);
    }</span></span>

    <span class="marker" id="mapping-281"></span><span class="token mv" id="move-src-131" data-title="contract_body/function_definition">function <span class="marker" id="mapping-282"></span><span class="token upd" id="move-src-132" data-title="function_definition/identifier">tr<span class="cupd">a</span>nsfe<span class="cupd">r</span>From</span>(
        <span class="marker" id="mapping-283"></span><span class="token del" data-title="function_definition/parameter">address _from</span>,
        <span class="marker" id="mapping-284"></span><span class="token del" data-title="function_definition/parameter">address _to</span><span class="marker" id="mapping-285"></span><span class="token del" data-title="function_definition/,">,</span>
        uint256 <span class="marker" id="mapping-286"></span><span class="token upd" id="move-src-133" data-title="parameter/identifier">_v<span class="cupd">a</span>lue</span>
    ) <span class="marker" id="mapping-287"></span><span class="token mv" id="move-src-134" data-title="function_definition/visibility">external</span> returns (bool) {
        <span class="marker" id="mapping-288"></span><span class="token upd" id="move-src-135" data-title="call_expression/identifier"><span class="cupd">_</span>tr<span class="cupd">a</span>nsfe<span class="cupd">r</span>FromAllArgs</span>(<span class="marker" id="mapping-289"></span><span class="token mv" id="move-src-136" data-title="call_expression/call_argument"><span class="marker" id="mapping-290"></span><span class="token upd" id="move-src-137" data-title="call_argument/identifier">_from</span></span>, <span class="marker" id="mapping-291"></span><span class="token mv" id="move-src-138" data-title="call_expression/call_argument"><span class="marker" id="mapping-292"></span><span class="token upd" id="move-src-139" data-title="call_argument/identifier">_to</span></span>, <span class="marker" id="mapping-293"></span><span class="token del" data-title="call_expression/call_argument">_value</span><span class="marker" id="mapping-294"></span><span class="token del" data-title="call_expression/,">,</span> <span class="marker" id="mapping-295"></span><span class="token del" data-title="call_expression/call_argument">msg.sender</span>);
        return true;
    }</span>

    <span class="marker" id="mapping-296"></span><span class="token mv" id="move-src-140" data-title="contract_body/function_definition">function <span class="marker" id="mapping-297"></span><span class="token upd" id="move-src-141" data-title="function_definition/identifier">t<span class="cupd">r</span>ansfer</span>(<span class="marker" id="mapping-298"></span><span class="token del" data-title="function_definition/parameter">address _to</span><span class="marker" id="mapping-299"></span><span class="token del" data-title="function_definition/,">,</span> uint256 <span class="marker" id="mapping-300"></span><span class="token upd" id="move-src-142" data-title="parameter/identifier">_v<span class="cupd">a</span>lue</span>) external <span class="marker" id="mapping-301"></span><span class="token mv" id="move-src-143" data-title="function_definition/return_type_definition">returns (bool)</span> {
        <span class="marker" id="mapping-302"></span><span class="token upd" id="move-src-144" data-title="call_expression/identifier"><span class="cupd">_</span>t<span class="cupd">r</span>ansferAllArgs</span>(msg.sender, <span class="marker" id="mapping-303"></span><span class="token upd" id="move-src-145" data-title="call_argument/identifier">_to</span><span class="marker" id="mapping-304"></span><span class="token del" data-title="call_expression/,">,</span> <span class="marker" id="mapping-305"></span><span class="token del" data-title="call_expression/call_argument">_value</span>);
        <span class="marker" id="mapping-306"></span><span class="token mv" id="move-src-146" data-title="function_body/return_statement">return true;</span>
    }</span>

    <span class="marker" id="mapping-307"></span><span class="token del" data-title="contract_body/function_definition">function _transferAllArgs(
        <span class="marker" id="mapping-308"></span><span class="token del" data-title="function_definition/parameter">address _from</span>,
        <span class="marker" id="mapping-309"></span><span class="token del" data-title="function_definition/parameter">address _to</span>,
        <span class="marker" id="mapping-310"></span><span class="token del" data-title="function_definition/parameter">uint256 _value</span>
    ) <span class="marker" id="mapping-311"></span><span class="token mv" id="move-src-147" data-title="function_definition/visibility">internal</span> virtual <span class="marker" id="mapping-312"></span><span class="token del" data-title="function_definition/modifier_invocation">resolveSender(_from)</span> <span class="marker" id="mapping-313"></span><span class="token del" data-title="function_definition/function_body">{
        <span class="marker" id="mapping-314"></span><span class="token del" data-title="function_body/expression_statement"><span class="marker" id="mapping-315"></span><span class="token del" data-title="expression_statement/call_expression">_subBalance(<span class="marker" id="mapping-316"></span><span class="token mv" id="move-src-148" data-title="call_expression/call_argument">_from</span>, <span class="marker" id="mapping-317"></span><span class="token del" data-title="call_expression/call_argument">_value</span>)</span>;</span>
        <span class="marker" id="mapping-318"></span><span class="token del" data-title="function_body/emit_statement">emit Transfer(_from, _to, _value);</span>
        <span class="marker" id="mapping-319"></span><span class="token del" data-title="function_body/variable_declaration_statement"><span class="marker" id="mapping-320"></span><span class="token mv" id="move-src-149" data-title="variable_declaration_statement/variable_declaration">bool <span class="marker" id="mapping-321"></span><span class="token upd" id="move-src-150" data-title="variable_declaration/identifier">hasHook</span></span>;</span>
        <span class="marker" id="mapping-322"></span><span class="token del" data-title="function_body/variable_declaration_statement">address to;</span>
        <span class="marker" id="mapping-323"></span><span class="token del" data-title="function_body/expression_statement">(to, hasHook) = _resolveRecipient(_to);</span>
        <span class="marker" id="mapping-324"></span><span class="token del" data-title="function_body/expression_statement">_addBalance(to, _value);</span>
        <span class="marker" id="mapping-325"></span><span class="token del" data-title="function_body/if_statement">if (_to != to) {
            emit Transfer(_to, to, _value);
        }</span>
        <span class="marker" id="mapping-326"></span><span class="token del" data-title="function_body/if_statement">if (hasHook) <span class="marker" id="mapping-327"></span><span class="token del" data-title="if_statement/block_statement">{
            <span class="marker" id="mapping-328"></span><span class="token del" data-title="block_statement/expression_statement"><span class="marker" id="mapping-329"></span><span class="token del" data-title="expression_statement/call_expression"><span class="marker" id="mapping-330"></span><span class="token del" data-title="call_expression/member_expression">TrueCoinReceiver(to).tokenFallback</span>(<span class="marker" id="mapping-331"></span><span class="token mv" id="move-src-151" data-title="call_expression/call_argument">_from</span>, <span class="marker" id="mapping-332"></span><span class="token mv" id="move-src-152" data-title="call_expression/call_argument">_value</span>)</span>;</span>
        }</span></span>
    }</span></span>

    <span class="marker" id="mapping-333"></span><span class="token mv" id="move-src-153" data-title="contract_body/function_definition">function _burn(address <span class="marker" id="mapping-334"></span><span class="token upd" id="move-src-154" data-title="parameter/identifier">_from</span>, uint256 <span class="marker" id="mapping-335"></span><span class="token upd" id="move-src-155" data-title="parameter/identifier">_v<span class="cupd">a</span>lue</span>) internal virtual <span class="marker" id="mapping-336"></span><span class="token del" data-title="function_definition/return_type_definition">returns (uint256 resultBalance_, uint256 resultSupply_)</span> {
        <span class="marker" id="mapping-337"></span><span class="token mv" id="move-src-156" data-title="function_body/emit_statement">emit Transfer(<span class="marker" id="mapping-338"></span><span class="token upd" id="move-src-157" data-title="call_argument/identifier">_from</span>, address(0), <span class="marker" id="mapping-339"></span><span class="token upd" id="move-src-158" data-title="call_argument/identifier">_v<span class="cupd">a</span>lue</span>);</span>
        <span class="marker" id="mapping-340"></span><span class="token del" data-title="function_body/emit_statement">emit Burn(_from, _value);</span>
        <span class="marker" id="mapping-341"></span><span class="token del" data-title="function_body/expression_statement">resultBalance_ = _subBalance(_from, _value);</span>
        <span class="marker" id="mapping-342"></span><span class="token upd" id="move-src-159" data-title="assignment_expression/identifier">resu<span class="cupd">l</span>t<span class="cupd">Supply</span>_</span> = totalSupply.sub(<span class="marker" id="mapping-343"></span><span class="token upd" id="move-src-160" data-title="call_argument/identifier">_v<span class="cupd">a</span>lue</span><span class="marker" id="mapping-344"></span><span class="token del" data-title="call_expression/,">,</span> <span class="marker" id="mapping-345"></span><span class="token mv" id="move-src-161" data-title="call_expression/call_argument">"removing more stake than in supply"</span>);
        <span class="marker" id="mapping-346"></span><span class="token del" data-title="function_body/expression_statement">totalSupply = resultSupply_;</span>
    }</span>

    <span class="marker" id="mapping-347"></span><span class="token mv" id="move-src-162" data-title="contract_body/function_definition">function _mint(address <span class="marker" id="mapping-348"></span><span class="token upd" id="move-src-163" data-title="parameter/identifier">_to</span>, uint256 <span class="marker" id="mapping-349"></span><span class="token upd" id="move-src-164" data-title="parameter/identifier">_v<span class="cupd">a</span>lue</span>) internal virtual {
        <span class="marker" id="mapping-350"></span><span class="token mv" id="move-src-165" data-title="function_body/emit_statement">emit Transfer(address(0), <span class="marker" id="mapping-351"></span><span class="token upd" id="move-src-166" data-title="call_argument/identifier">_to</span>, <span class="marker" id="mapping-352"></span><span class="token upd" id="move-src-167" data-title="call_argument/identifier">_v<span class="cupd">a</span>lue</span>);</span>
        <span class="marker" id="mapping-353"></span><span class="token del" data-title="function_body/emit_statement">emit Mint(_to, _value);</span>
        <span class="marker" id="mapping-354"></span><span class="token mv" id="move-src-168" data-title="function_body/variable_declaration_statement">(<span class="marker" id="mapping-355"></span><span class="token mv" id="move-src-169" data-title="variable_declaration_tuple/variable_declaration"><span class="marker" id="mapping-356"></span><span class="token del" data-title="primitive_type/address">address</span> <span class="marker" id="mapping-357"></span><span class="token upd" id="move-src-170" data-title="variable_declaration/identifier">to</span></span><span class="marker" id="mapping-358"></span><span class="token mv" id="move-src-171" data-title="variable_declaration_tuple/,">,</span> bool <span class="marker" id="mapping-359"></span><span class="token upd" id="move-src-172" data-title="variable_declaration/identifier">hook</span>) = <span class="marker" id="mapping-360"></span><span class="token del" data-title="call_expression/identifier">_resolveRecipient</span>(<span class="marker" id="mapping-361"></span><span class="token upd" id="move-src-173" data-title="call_argument/identifier">_to</span>);</span>
        <span class="marker" id="mapping-362"></span><span class="token del" data-title="function_body/if_statement">if (_to != to) {
            emit Transfer(_to, to, _value);
        }</span>
        <span class="marker" id="mapping-363"></span><span class="token del" data-title="function_body/expression_statement">_addBalance(to, _value);</span>
        totalSupply = totalSupply.add(<span class="marker" id="mapping-364"></span><span class="token upd" id="move-src-174" data-title="call_argument/identifier">_v<span class="cupd">a</span>lue</span><span class="marker" id="mapping-365"></span><span class="token del" data-title="call_expression/,">,</span> <span class="marker" id="mapping-366"></span><span class="token mv" id="move-src-175" data-title="call_expression/call_argument">"totalSupply overflow"</span>);
        <span class="marker" id="mapping-367"></span><span class="token del" data-title="function_body/if_statement">if (hook) <span class="marker" id="mapping-368"></span><span class="token del" data-title="if_statement/block_statement">{
            <span class="marker" id="mapping-369"></span><span class="token mv" id="move-src-176" data-title="block_statement/expression_statement"><span class="marker" id="mapping-370"></span><span class="token del" data-title="call_expression/member_expression">TrueCoinReceiver(to).tokenFallback</span>(<span class="marker" id="mapping-371"></span><span class="token mv" id="move-src-177" data-title="call_argument/type_cast_expression">address(<span class="marker" id="mapping-372"></span><span class="token del" data-title="call_argument/number_literal">0x0</span>)</span>, <span class="marker" id="mapping-373"></span><span class="token mv" id="move-src-178" data-title="call_expression/call_argument">_value</span>);</span>
        }</span></span>
    }</span>
}</span></span>

<span class="marker" id="mapping-374"></span><span class="token upd" id="move-src-179" data-title="source_file/comment"><span class="cupd">// </span>File:<span class="cupd"> </span>contracts<span class="cupd">/</span>trusttokens/ClaimableContract.sol</span>

pragma solidity 0.6.10;


/**
 * @title ClaimableContract
 * @dev The ClaimableContract contract is a copy of Claimable Contract by Zeppelin.
 and provides basic authorization control functions. Inherits storage layout of
 ProxyStorage.
 */
contract ClaimableContract is ProxyStorage {
    function owner() public view returns (address) {
        return owner_;
    }

    function pendingOwner() public view returns (address) {
        return pendingOwner_;
    }

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    /**
     * @dev sets the original `owner` of the contract to the sender
     * at construction. Must then be reinitialized
     */
    constructor() public {
        owner_ = msg.sender;
        emit OwnershipTransferred(address(0), msg.sender);
    }

    /**
     * @dev Throws if called by any account other than the owner.
     */
    modifier onlyOwner() {
        require(msg.sender == owner_, "only owner");
        _;
    }

    /**
     * @dev Modifier throws if called by any account other than the pendingOwner.
     */
    modifier onlyPendingOwner() {
        require(msg.sender == pendingOwner_);
        _;
    }

    /**
     * @dev Allows the current owner to set the pendingOwner address.
     * @param newOwner The address to transfer ownership to.
     */
    function transferOwnership(address newOwner) public onlyOwner {
        pendingOwner_ = newOwner;
    }

    /**
     * @dev Allows the pendingOwner address to finalize the transfer.
     */
    function claimOwnership() public onlyPendingOwner {
        address _pendingOwner = pendingOwner_;
        emit OwnershipTransferred(owner_, _pendingOwner);
        owner_ = _pendingOwner;
        pendingOwner_ = address(0);
    }
}

<span class="marker" id="mapping-375"></span><span class="token mv" id="move-src-180" data-title="source_file/comment"><span class="marker" id="mapping-376"></span><span class="token upd" id="move-src-181" data-title="source_file/comment"><span class="cupd">// </span>File:<span class="cupd"> </span>contracts/trusttokens/TimeLockedToken.sol</span></span>

<span class="marker" id="mapping-377"></span><span class="token mv" id="move-src-182" data-title="source_file/pragma_directive">pragma solidity 0.6.10;</span>




/**
 * @title TimeLockedToken
 * @notice Time Locked ERC20 Token
 * @author Harold Hyatt
 * @dev Contract which gives the ability to time-lock tokens
 *
 * The registerLockup() function allows an account to transfer
 * its tokens to another account, locking them according to the
 * distribution epoch periods
 *
 * By overriding the balanceOf(), transfer(), and transferFrom()
 * functions in ERC20, an account can show its full, post-distribution
 * balance but only transfer or spend up to an allowed amount
 *
 * Every time an epoch passes, a portion of previously non-spendable tokens
 * are allowed to be transferred, and after all epochs have passed, the full
 * account balance is unlocked
 */
abstract contract TimeLockedToken is <span class="marker" id="mapping-378"></span><span class="token upd" id="move-src-183" data-title="user_defined_type/identifier">ValTokenWithHook</span>, ClaimableContract {
    using SafeMath for uint256;

    // represents total distribution for locked balances
    mapping(address =&gt; uint256) distribution;

    // start of the lockup period
    // Friday, July 24, 2020 4:58:31 PM GMT
    uint256 constant LOCK_START = 1595609911;
    // length of time to delay first epoch
    uint256 constant FIRST_EPOCH_DELAY = 30 days;
    // how long does an epoch last
    uint256 constant EPOCH_DURATION = 90 days;
    // number of epochs
    uint256 constant TOTAL_EPOCHS = 8;
    // registry of locked addresses
    address public timeLockRegistry;

    modifier onlyTimeLockRegistry() {
        require(msg.sender == timeLockRegistry, "only TimeLockRegistry");
        _;
    }

    /**
     * @dev Set TimeLockRegistry address
     * @param newTimeLockRegistry Address of TimeLockRegistry contract
     */
    function setTimeLockRegistry(address newTimeLockRegistry) external onlyOwner {
        require(newTimeLockRegistry != address(0), "cannot be zero address");
        require(newTimeLockRegistry != timeLockRegistry, "must be new TimeLockRegistry");
        timeLockRegistry = newTimeLockRegistry;
    }

    <span class="marker" id="mapping-379"></span><span class="token mv" id="move-src-184" data-title="contract_body/comment"><span class="marker" id="mapping-380"></span><span class="token upd" id="move-src-185" data-title="contract_body/comment"><span class="cupd">/</span>**<span class="cupd"></span>
     * @dev T<span class="cupd">r</span>ansfer funct<span class="cupd">i</span>on<span class="cupd"> </span>whic<span class="cupd">h</span> inc<span class="cupd">l</span>udes <span class="cupd">unlocked </span>tok<span class="cupd">en</span>s
     * @param<span class="cupd"> </span>_from <span class="cupd">T</span>he a<span class="cupd">d</span>d<span class="cupd">r</span>e<span class="cupd">ss to</span> send tokens from
     <span class="cupd">*</span> @param _to<span class="cupd"> </span>The address that will<span class="cupd"> </span>r<span class="cupd">e</span>ceive the tokens
     <span class="cupd">*</span> @param<span class="cupd"> </span>_v<span class="cupd">a</span>lue <span class="cupd">T</span>h<span class="cupd">e am</span>ount of tokens to be transferred
     */</span></span>
    <span class="marker" id="mapping-381"></span><span class="token mv" id="move-src-186" data-title="contract_body/function_definition">function <span class="marker" id="mapping-382"></span><span class="token upd" id="move-src-187" data-title="function_definition/identifier">_<span class="cupd">transfer</span>AllArgs</span>(
        address _from,
        <span class="marker" id="mapping-383"></span><span class="token del" data-title="function_definition/parameter">address _to</span><span class="marker" id="mapping-384"></span><span class="token del" data-title="function_definition/,">,</span>
        uint256 _value
    ) internal <span class="marker" id="mapping-385"></span><span class="token mv" id="move-src-188" data-title="function_definition/override_specifier">override</span> <span class="marker" id="mapping-386"></span><span class="token del" data-title="function_definition/modifier_invocation">resolveSender(_from)</span> <span class="marker" id="mapping-387"></span><span class="token mv" id="move-src-189" data-title="function_definition/function_body">{
        require(balanceOf[_from] &gt;= _value, "insufficient balance");
        <span class="marker" id="mapping-388"></span><span class="token del" data-title="expression_statement/call_expression">require(unlockedBalance(_from) &gt;= _value, "attempting to transfer locked funds")</span>;

        <span class="marker" id="mapping-389"></span><span class="token mv" id="move-src-190" data-title="function_body/expression_statement">super.<span class="marker" id="mapping-390"></span><span class="token upd" id="move-src-191" data-title="member_expression/identifier"><span class="cupd">_transfer</span>AllArgs</span>(_from, <span class="marker" id="mapping-391"></span><span class="token upd" id="move-src-192" data-title="call_argument/identifier">_to</span>, _value);</span>
    }</span></span>

    <span class="marker" id="mapping-392"></span><span class="token upd" id="move-src-193" data-title="contract_body/comment"><span class="cupd">/**
     * @dev</span> <span class="cupd">t</span><span class="cupd">ra</span>ns<span class="cupd">f</span>erFrom f<span class="cupd">u</span>n<span class="cupd">c</span>tion which in<span class="cupd">c</span>lude<span class="cupd">s</span> u<span class="cupd">nloc</span>ke<span class="cupd">d </span>tok<span class="cupd">en</span>s
     * @<span class="cupd">p</span>ar<span class="cupd">a</span>m _<span class="cupd">f</span>r<span class="cupd">o</span>m <span class="cupd">T</span><span class="cupd">he addres</span>s <span class="cupd">t</span>o se<span class="cupd">n</span>d toke<span class="cupd">n</span>s fr<span class="cupd">om</span>
  <span class="cupd">  </span> * @param<span class="cupd"> </span><span class="cupd">_</span>to<span class="cupd"> </span>The <span class="cupd">a</span>d<span class="cupd">d</span><span class="cupd">r</span><span class="cupd">ess</span> that wi<span class="cupd">ll</span> r<span class="cupd">e</span>cei<span class="cupd">v</span>e <span class="cupd">t</span>he tokens
     <span class="cupd">*</span> <span class="cupd">@</span>p<span class="cupd">a</span>ra<span class="cupd">m</span> _v<span class="cupd">a</span>lue <span class="cupd">T</span>he am<span class="cupd">o</span>unt<span class="cupd"> o</span>f to<span class="cupd">k</span>ens to be <span class="cupd">t</span>r<span class="cupd">a</span>nsferred
     * @param<span class="cupd"> _</span>sp<span class="cupd">e</span>nder The addr<span class="cupd">e</span>s<span class="cupd">s</span> <span class="cupd">allow</span>ed <span class="cupd">to</span> make th<span class="cupd">e </span>tra<span class="cupd">nsfer
 </span>    */</span>
    function <span class="marker" id="mapping-393"></span><span class="token upd" id="move-src-194" data-title="function_definition/identifier"><span class="cupd">_transfer</span>FromAllArgs</span>(
        address _from,
        address _to,
        uint256 _value<span class="marker" id="mapping-394"></span><span class="token del" data-title="function_definition/,">,</span>
        <span class="marker" id="mapping-395"></span><span class="token mv" id="move-src-195" data-title="function_definition/parameter">address <span class="marker" id="mapping-396"></span><span class="token upd" id="move-src-196" data-title="parameter/identifier">_s<span class="cupd">p</span><span class="cupd">en</span>der</span></span>
    ) internal override {
        require(balanceOf[_from] &gt;= _value, "insufficient balance");
        require(unlockedBalance(_from) &gt;= _value, "attempting to transfer locked funds");

        super.<span class="marker" id="mapping-397"></span><span class="token upd" id="move-src-197" data-title="member_expression/identifier"><span class="cupd">_transfer</span>FromAllArgs</span>(_from, _to, _value<span class="marker" id="mapping-398"></span><span class="token del" data-title="call_expression/,">,</span> <span class="marker" id="mapping-399"></span><span class="token del" data-title="call_expression/call_argument">_spender</span>);
    }

    /**
     * @dev Check if amount we want to burn is unlocked before burning
     * @param _from The address whose tokens will burn
     * @param _value The amount of tokens to be burnt
     */
    function _burn(address _from, uint256 _value) internal override <span class="marker" id="mapping-400"></span><span class="token del" data-title="function_definition/return_type_definition">returns (uint256 resultBalance_, uint256 resultSupply_)</span> <span class="marker" id="mapping-401"></span><span class="token del" data-title="function_definition/function_body">{
        <span class="marker" id="mapping-402"></span><span class="token mv" id="move-src-198" data-title="function_body/expression_statement">require(unlockedBalance(_from) &gt;= _value, "attempting to burn locked funds");</span>

        <span class="marker" id="mapping-403"></span><span class="token del" data-title="function_body/expression_statement"><span class="marker" id="mapping-404"></span><span class="token del" data-title="expression_statement/assignment_expression"><span class="marker" id="mapping-405"></span><span class="token del" data-title="assignment_expression/tuple_expression">(resultBalance_, resultSupply_)</span> = <span class="marker" id="mapping-406"></span><span class="token mv" id="move-src-199" data-title="assignment_expression/call_expression">super._burn(_from, _value)</span></span>;</span>
    }</span>

    <span class="marker" id="mapping-407"></span><span class="token mv" id="move-src-200" data-title="contract_body/comment"><span class="marker" id="mapping-408"></span><span class="token upd" id="move-src-201" data-title="contract_body/comment"><span class="cupd">/**
     * @dev Transfer</span><span class="cupd"> </span><span class="cupd">t</span>ok<span class="cupd">e</span>n<span class="cupd">s</span> t<span class="cupd">o</span> <span class="cupd">a</span>nother <span class="cupd">a</span>cc<span class="cupd">o</span>un<span class="cupd">t u</span>nder the<span class="cupd"> loc</span>kup sc<span class="cupd">he</span>du<span class="cupd">l</span><span class="cupd">e
     </span>* E<span class="cupd">m</span><span class="cupd">it</span><span class="cupd">s</span><span class="cupd"> </span>a <span class="cupd">t</span>r<span class="cupd">a</span>nsf<span class="cupd">e</span><span class="cupd">r</span> eve<span class="cupd">n</span>t showing <span class="cupd">a transf</span><span class="cupd">e</span><span class="cupd">r to the </span>recip<span class="cupd">i</span>e<span class="cupd">n</span><span class="cupd">t
  </span><span class="cupd">  </span> <span class="cupd">*</span> Only<span class="cupd"> </span>t<span class="cupd">h</span>e<span class="cupd"> </span>re<span class="cupd">g</span>is<span class="cupd">t</span>ry<span class="cupd"> </span><span class="cupd">c</span>a<span class="cupd">n c</span><span class="cupd">a</span>ll<span class="cupd"> t</span><span class="cupd">h</span><span class="cupd">i</span><span class="cupd">s </span>f<span class="cupd">u</span>n<span class="cupd">c</span>t<span class="cupd">i</span><span class="cupd">on
 </span><span class="cupd">  </span>  * <span class="cupd">O</span><span class="cupd">n</span>ce reg<span class="cupd">i</span>ste<span class="cupd">r</span>e<span class="cupd">d, </span><span class="cupd">t</span>h<span class="cupd">e</span><span class="cupd"> </span>distri<span class="cupd">b</span><span class="cupd">u</span><span class="cupd">t</span>ion <span class="cupd">c</span>ann<span class="cupd">o</span><span class="cupd">t</span><span class="cupd"> </span>be regist<span class="cupd">e</span>red a<span class="cupd">gain</span>
<span class="cupd">     * @p</span>a<span class="cupd">r</span>am rec<span class="cupd">e</span>i<span class="cupd">ver Addr</span>e<span class="cupd">s</span><span class="cupd">s to receive the tokens
     * @</span><span class="cupd">p</span><span class="cupd">aram a</span>m<span class="cupd">o</span><span class="cupd">unt Tokens to be transferred
</span>     */</span></span>
    function registerLockup(address receiver, uint256 amount) external onlyTimeLockRegistry {
        require(balanceOf[msg.sender] &gt;= amount, "insufficient balance");
        <span class="marker" id="mapping-409"></span><span class="token mv" id="move-src-202" data-title="function_body/expression_statement"><span class="marker" id="mapping-410"></span><span class="token mv" id="move-src-203" data-title="expression_statement/call_expression"><span class="marker" id="mapping-411"></span><span class="token del" data-title="call_expression/identifier">require</span>(<span class="marker" id="mapping-412"></span><span class="token del" data-title="call_argument/binary_expression"><span class="marker" id="mapping-413"></span><span class="token mv" id="move-src-204" data-title="binary_expression/array_access">distribution[receiver]</span> == 0</span><span class="marker" id="mapping-414"></span><span class="token del" data-title="call_expression/,">,</span> <span class="marker" id="mapping-415"></span><span class="token mv" id="move-src-205" data-title="call_expression/call_argument">"distribution already set"</span>)</span>;</span>

        <span class="marker" id="mapping-416"></span><span class="token upd" id="move-src-206" data-title="function_body/comment"><span class="cupd">// </span>se<span class="cupd">t </span><span class="cupd">d</span><span class="cupd">istribution</span> to lockup amount</span>
        <span class="marker" id="mapping-417"></span><span class="token del" data-title="function_body/expression_statement"><span class="marker" id="mapping-418"></span><span class="token mv" id="move-src-207" data-title="expression_statement/assignment_expression">distribution[receiver] = <span class="marker" id="mapping-419"></span><span class="token del" data-title="assignment_expression/identifier">amount</span></span>;</span>

        // transfer to recipient
        <span class="marker" id="mapping-420"></span><span class="token upd" id="move-src-208" data-title="call_expression/identifier"><span class="cupd">_transfer</span>AllArgs</span>(msg.sender, receiver, amount);
    }

    /**
     * @dev Get locked balance for an account
     * @param account Account to check
     * @return Amount locked
     */
    function lockedBalance(address account) <span class="marker" id="mapping-421"></span><span class="token mv" id="move-src-209" data-title="function_definition/visibility">public</span> <span class="marker" id="mapping-422"></span><span class="token mv" id="move-src-210" data-title="function_definition/state_mutability">view</span> <span class="marker" id="mapping-423"></span><span class="token mv" id="move-src-211" data-title="function_definition/return_type_definition">returns (uint256)</span> {
        // distribution * (epochsLeft / totalEpochs)
        <span class="marker" id="mapping-424"></span><span class="token mv" id="move-src-212" data-title="function_body/variable_declaration_statement">uint256 <span class="marker" id="mapping-425"></span><span class="token upd" id="move-src-213" data-title="variable_declaration/identifier">ep<span class="cupd">oc</span>hsLeft</span> = <span class="marker" id="mapping-426"></span><span class="token mv" id="move-src-214" data-title="variable_declaration_statement/call_expression">TOTAL_EPOCHS.sub(epochsPassed())</span>;</span>
        return distribution[account].mul(<span class="marker" id="mapping-427"></span><span class="token del" data-title="call_argument/identifier">epochsLeft</span>).div(TOTAL_EPOCHS);
    }

    /**
     * @dev Get unlocked balance for an account
     * @param account Account to check
     * @return Amount that is unlocked and available eg. to transfer
     */
    function unlockedBalance(address account) public view returns (uint256) {
        // totalBalance - lockedBalance
        return balanceOf[account].sub(lockedBalance(account));
    }

    /*
     * @dev Get number of epochs passed
     * @return Value between 0 and 8 of lockup epochs already passed
     */
    function epochsPassed() public view returns (uint256) {
        // return 0 if timestamp is lower than start time
        if (block.timestamp &lt; LOCK_START) {
            return 0;
        }

        // how long it has been since the beginning of lockup period
        uint256 timePassed = block.timestamp.sub(LOCK_START);

        // 1st epoch is FIRST_EPOCH_DELAY longer; we check to prevent subtraction underflow
        if (timePassed &lt; FIRST_EPOCH_DELAY) {
            return 0;
        }

        // subtract the FIRST_EPOCH_DELAY, so that we can count all epochs as lasting EPOCH_DURATION
        uint256 totalEpochsPassed = timePassed.sub(FIRST_EPOCH_DELAY).div(EPOCH_DURATION);

        // epochs don't count over TOTAL_EPOCHS
        if (totalEpochsPassed &gt; TOTAL_EPOCHS) {
            return TOTAL_EPOCHS;
        }

        return totalEpochsPassed;
    }

    /**
     * @dev Get timestamp of next epoch
     * Will revert if all epochs have passed
     * @return Timestamp of when the next epoch starts
     */
    function nextEpoch() public view returns (uint256) {
        // get number of epochs passed
        uint256 passed = epochsPassed();

        // if all epochs passed, return
        if (passed == TOTAL_EPOCHS) {
            // return INT_MAX
            return uint256(-1);
        }

        // if no epochs passed, return latest epoch + delay + standard duration
        if (passed == 0) {
            return latestEpoch().add(FIRST_EPOCH_DELAY).add(EPOCH_DURATION);
        }

        // otherwise return latest epoch + epoch duration
        return latestEpoch().add(EPOCH_DURATION);
    }

    /**
     * @dev Get timestamp of latest epoch
     * @return Timestamp of when the current epoch has started
     */
    function latestEpoch() public view returns (uint256) {
        // get number of epochs passed
        uint256 passed = epochsPassed();

        // if no epochs passed, return lock start time
        if (passed == 0) {
            return LOCK_START;
        }

        // accounts for first epoch being longer
        // lockStart + firstEpochDelay + (epochsPassed * epochDuration)
        return LOCK_START.add(FIRST_EPOCH_DELAY).add(passed.mul(EPOCH_DURATION));
    }

    /**
     * @dev Get timestamp of final epoch
     * @return Timestamp of when the last epoch ends and all funds are released
     */
    function finalEpoch() public pure returns (uint256) {
        // lockStart + firstEpochDelay + (epochDuration * totalEpochs)
        return LOCK_START.add(FIRST_EPOCH_DELAY).add(EPOCH_DURATION.mul(TOTAL_EPOCHS));
    }

    /**
     * @dev Get timestamp of locking period start
     * @return Timestamp of locking period start
     */
    function lockStart() public pure returns (uint256) {
        return LOCK_START;
    }
}

<span class="marker" id="mapping-428"></span><span class="token mv" id="move-src-215" data-title="source_file/comment"><span class="marker" id="mapping-429"></span><span class="token upd" id="move-src-216" data-title="source_file/comment"><span class="cupd">// </span>File:<span class="cupd"> </span>contracts/trusttokens/TrustToken.sol</span></span>

<span class="marker" id="mapping-430"></span><span class="token mv" id="move-src-217" data-title="source_file/pragma_directive">pragma solidity 0.6.10;</span>




/**
 * @title TrustToken
 * @dev The TrustToken contract is a claimable contract where the
 * owner can only mint or transfer ownership. TrustTokens use 8 decimals
 * in order to prevent rewards from getting stuck in the remainder on division.
 * Tolerates dilution to slash stake and accept rewards.
 */
contract TrustToken is TimeLockedToken {
    using SafeMath for uint256;
    <span class="marker" id="mapping-431"></span><span class="token del" data-title="contract_body/state_variable_declaration">Registry registry_;</span>
    uint256 constant MAX_SUPPLY = 145000000000000000;

    /**
     * @dev initialize trusttoken and give ownership to sender
     * This is necessary to set ownership for proxy
     */
    function initialize(<span class="marker" id="mapping-432"></span><span class="token del" data-title="function_definition/parameter">Registry _registry</span>) public {
        require(!initalized, "already initalized");
        <span class="marker" id="mapping-433"></span><span class="token del" data-title="function_body/expression_statement">registry_ = _registry;</span>
        owner_ = msg.sender;
        initalized = true;
    }

    <span class="marker" id="mapping-434"></span><span class="token del" data-title="contract_body/function_definition">function registry() <span class="marker" id="mapping-435"></span><span class="token mv" id="move-src-218" data-title="function_definition/visibility">public</span> <span class="marker" id="mapping-436"></span><span class="token mv" id="move-src-219" data-title="function_definition/override_specifier">override</span> <span class="marker" id="mapping-437"></span><span class="token mv" id="move-src-220" data-title="function_definition/state_mutability">view</span> <span class="marker" id="mapping-438"></span><span class="token del" data-title="function_definition/return_type_definition">returns (Registry)</span> <span class="marker" id="mapping-439"></span><span class="token del" data-title="function_definition/function_body">{
        return registry_;
    }</span></span>

    /**
     * @dev mint TRU
     * Can never mint more than MAX_SUPPLY = 1.45 billion
     */
    function mint(address _to, uint256 _amount) external onlyOwner {
        if (totalSupply.add(_amount) &lt;= MAX_SUPPLY) {
            _mint(_to, _amount);
        } else {
            revert("Max supply exceeded");
        }
    }

    function decimals() public pure returns (uint8) {
        return 8;
    }

    function rounding() public pure returns (uint8) {
        return 8;
    }

    <span class="marker" id="mapping-440"></span><span class="token mv" id="move-src-221" data-title="contract_body/function_definition">function <span class="marker" id="mapping-441"></span><span class="token upd" id="move-src-222" data-title="function_definition/identifier">name</span>() public pure returns (string memory) <span class="marker" id="mapping-442"></span><span class="token mv" id="move-src-223" data-title="function_definition/function_body">{
        return "TrustToken";
    }</span></span>

    <span class="marker" id="mapping-443"></span><span class="token mv" id="move-src-224" data-title="contract_body/function_definition">function <span class="marker" id="mapping-444"></span><span class="token upd" id="move-src-225" data-title="function_definition/identifier">symbol</span>() public pure returns (string memory) <span class="marker" id="mapping-445"></span><span class="token mv" id="move-src-226" data-title="function_definition/function_body">{
        return "TRU";
    }</span></span>
}</pre></div><div class="col-6"><h5>0x4b4e1f67c7298d242555eb35d8e5016f0c4f6df4.etherscan.io-TrustToken.sol</h5><pre class="pre-scrollable"><span class="marker" id="mapping-446"></span><span class="token upd" id="move-dst-2" data-title="source_file/comment"><span class="cupd">// </span>&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;</span>
<span class="marker" id="mapping-447"></span><span class="token upd" id="move-dst-6" data-title="source_file/comment"><span class="cupd">// </span>&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;</span>
<span class="marker" id="mapping-448"></span><span class="token upd" id="move-dst-10" data-title="source_file/comment"><span class="cupd">// </span>&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;%&amp;&amp;&amp;&amp;%%%%&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;</span>
<span class="marker" id="mapping-449"></span><span class="token upd" id="move-dst-13" data-title="source_file/comment"><span class="cupd">// </span>&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;%(,<span class="cupd"> </span>                .*#&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;</span>
<span class="marker" id="mapping-450"></span><span class="token upd" id="move-dst-16" data-title="source_file/comment"><span class="cupd">// </span>&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;#.<span class="cupd"> </span>       ,<span class="cupd">/</span>#%%%%%%%#(/,      *%&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;</span>
<span class="marker" id="mapping-451"></span><span class="token upd" id="move-dst-17" data-title="source_file/comment"><span class="cupd">/</span>/<span class="cupd"> </span>&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;(<span class="cupd"> </span><span class="cupd"> </span><span class="cupd"> </span><span class="cupd"> </span><span class="cupd"> </span><span class="cupd"> </span><span class="cupd">/</span>&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;%&amp;%<span class="cupd">* </span><span class="cupd"> </span><span class="cupd"> </span>,%&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;</span>
<span class="marker" id="mapping-452"></span><span class="token upd" id="move-dst-34" data-title="source_file/comment"><span class="cupd">// </span>&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;%,    *%&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;%,  (&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;</span>
<span class="marker" id="mapping-453"></span><span class="token upd" id="move-dst-35" data-title="source_file/comment"><span class="cupd">// </span>&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;,<span class="cupd"> </span><span class="cupd"> </span>  #&amp;&amp;#                      ./#&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;%, %&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;</span>
<span class="marker" id="mapping-454"></span><span class="token upd" id="move-dst-36" data-title="source_file/comment"><span class="cupd">/</span>/<span class="cupd"> </span>&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;#<span class="cupd"> </span><span class="cupd"> </span><span class="cupd"> </span><span class="cupd"> </span>(&amp;&amp;&amp;&amp;#<span class="cupd">  </span><span class="cupd"> </span><span class="cupd"> </span><span class="cupd"> </span><span class="cupd"> </span><span class="cupd"> </span><span class="cupd"> </span><span class="cupd"> </span><span class="cupd"> </span><span class="cupd">  </span>                ,%&amp;&amp;&amp;&amp;&amp;&amp;<span class="cupd">*/</span>&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;</span>
<span class="marker" id="mapping-455"></span><span class="token upd" id="move-dst-46" data-title="source_file/comment"><span class="cupd">/</span>/<span class="cupd"> </span>&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;(<span class="cupd"> </span><span class="cupd"> </span><span class="cupd"> </span><span class="cupd"> </span>%&amp;&amp;&amp;&amp;&amp;#<span class="cupd"> </span><span class="cupd">  </span><span class="cupd"> </span><span class="cupd">/</span>&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;%#,<span class="cupd">  </span><span class="cupd"> </span><span class="cupd"> </span><span class="cupd"> </span>.%&amp;&amp;&amp;&amp;&amp;(%&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;</span>
<span class="marker" id="mapping-456"></span><span class="token upd" id="move-dst-102" data-title="source_file/comment"><span class="cupd">// </span>&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;%<span class="cupd"> </span>   #&amp;&amp;&amp;&amp;&amp;&amp;#    <span class="cupd">/</span>&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;(    .%&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;</span>
<span class="marker" id="mapping-457"></span><span class="token upd" id="move-dst-113" data-title="source_file/comment"><span class="cupd">// </span>&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;/<span class="cupd"> </span>  ,&amp;&amp;&amp;&amp;&amp;&amp;&amp;#    <span class="cupd">/</span>&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;%%%%&amp;&amp;&amp;&amp;%%    /&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;</span>
<span class="marker" id="mapping-458"></span><span class="token upd" id="move-dst-117" data-title="source_file/comment"><span class="cupd">// </span>&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;*<span class="cupd"> </span>  <span class="cupd">/</span>&amp;&amp;&amp;&amp;&amp;&amp;&amp;#             %&amp;&amp;&amp;&amp;&amp;&amp;,   (&amp;&amp;&amp;&amp;&amp;&amp;&amp;*   /&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;</span>
<span class="marker" id="mapping-459"></span><span class="token upd" id="move-dst-179" data-title="source_file/comment"><span class="cupd">// </span>&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;/<span class="cupd"> </span>  *&amp;&amp;&amp;&amp;&amp;&amp;&amp;%<span class="cupd">/</span>///////*    %&amp;&amp;&amp;&amp;&amp;&amp;,   (&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;,   #&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;</span>
<span class="marker" id="mapping-460"></span><span class="token mv" id="move-dst-181" data-title="source_file/comment"><span class="marker" id="mapping-461"></span><span class="token upd" id="move-dst-181" data-title="source_file/comment"><span class="cupd">// </span>&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;#<span class="cupd"> </span>   &amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;%.   %&amp;&amp;&amp;&amp;&amp;&amp;.   #&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;#   *&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;</span></span>
<span class="marker" id="mapping-462"></span><span class="token mv" id="move-dst-216" data-title="source_file/comment"><span class="marker" id="mapping-463"></span><span class="token upd" id="move-dst-216" data-title="source_file/comment"><span class="cupd">// </span>&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;*<span class="cupd"> </span>  ,&amp;&amp;%&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;%.   %&amp;&amp;&amp;&amp;&amp;(   .%&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;#   *&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;</span></span>
<span class="marker" id="mapping-464"></span><span class="token add" data-title="source_file/comment">// &amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;,   .&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;%.  /&amp;&amp;&amp;&amp;&amp;#    #&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;*   (&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;</span>
<span class="marker" id="mapping-465"></span><span class="token add" data-title="source_file/comment">// &amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;#    ,&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;%.,%&amp;&amp;&amp;&amp;%,    %&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;#   .%&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;</span>
<span class="marker" id="mapping-466"></span><span class="token add" data-title="source_file/comment">// &amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;(     ,#&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;(     (&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;/   .%&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;</span>
<span class="marker" id="mapping-467"></span><span class="token add" data-title="source_file/comment">// &amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;*          ..         ,%&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;#    *&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;</span>
<span class="marker" id="mapping-468"></span><span class="token add" data-title="source_file/comment">// &amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;%(.           ./%&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;%*    *&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;</span>
<span class="marker" id="mapping-469"></span><span class="token add" data-title="source_file/comment">// &amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;%(.    .#&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;</span>
<span class="marker" id="mapping-470"></span><span class="token add" data-title="source_file/comment">// &amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;%/(%&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;%#/.       *%&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;</span>
<span class="marker" id="mapping-471"></span><span class="token add" data-title="source_file/comment">// &amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;%(,             ,(%&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;</span>
<span class="marker" id="mapping-472"></span><span class="token add" data-title="source_file/comment">// &amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;</span>
<span class="marker" id="mapping-473"></span><span class="token add" data-title="source_file/comment">// &amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;</span>
<span class="marker" id="mapping-474"></span><span class="token add" data-title="source_file/comment">// &amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;</span>

<span class="marker" id="mapping-475"></span><span class="token mv" id="move-dst-1" data-title="source_file/comment">// SPDX-License-Identifier: MIT</span>

<span class="marker" id="mapping-476"></span><span class="token mv" id="move-dst-7" data-title="source_file/pragma_directive">pragma solidity ^0.6.0;</span>

<span class="marker" id="mapping-477"></span><span class="token mv" id="move-dst-4" data-title="source_file/comment">/**
 * @dev Wrappers over Solidity's arithmetic operations with added overflow
 * checks.
 *
 * Arithmetic operations in Solidity wrap on overflow. This can easily result
 * in bugs, because programmers usually assume that an overflow raises an
 * error, which is the standard behavior in high level programming languages.
 * `SafeMath` restores this intuition by reverting the transaction when an
 * operation overflows.
 *
 * Using this library instead of the unchecked operations eliminates an entire
 * class of bugs, so it's recommended to use it always.
 */</span>
<span class="marker" id="mapping-478"></span><span class="token mv" id="move-dst-5" data-title="source_file/library_declaration">library SafeMath {
    /**
     * @dev Returns the addition of two unsigned integers, reverting on
     * overflow.
     *
     * Counterpart to Solidity's `+` operator.
     *
     * Requirements:
     *
     * - Addition cannot overflow.
     */
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c &gt;= a, "SafeMath: addition overflow");

        return c;
    }

    /**
     * @dev Returns the subtraction of two unsigned integers, reverting on
     * overflow (when the result is negative).
     *
     * Counterpart to Solidity's `-` operator.
     *
     * Requirements:
     *
     * - Subtraction cannot overflow.
     */
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        return sub(a, b, "SafeMath: subtraction overflow");
    }

    /**
     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on
     * overflow (when the result is negative).
     *
     * Counterpart to Solidity's `-` operator.
     *
     * Requirements:
     *
     * - Subtraction cannot overflow.
     */
    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
        require(b &lt;= a, errorMessage);
        uint256 c = a - b;

        return c;
    }

    /**
     * @dev Returns the multiplication of two unsigned integers, reverting on
     * overflow.
     *
     * Counterpart to Solidity's `*` operator.
     *
     * Requirements:
     *
     * - Multiplication cannot overflow.
     */
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the
        // benefit is lost if 'b' is also tested.
        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522
        if (a == 0) {
            return 0;
        }

        uint256 c = a * b;
        require(c / a == b, "SafeMath: multiplication overflow");

        return c;
    }

    /**
     * @dev Returns the integer division of two unsigned integers. Reverts on
     * division by zero. The result is rounded towards zero.
     *
     * Counterpart to Solidity's `/` operator. Note: this function uses a
     * `revert` opcode (which leaves remaining gas untouched) while Solidity
     * uses an invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     *
     * - The divisor cannot be zero.
     */
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        return div(a, b, "SafeMath: division by zero");
    }

    /**
     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on
     * division by zero. The result is rounded towards zero.
     *
     * Counterpart to Solidity's `/` operator. Note: this function uses a
     * `revert` opcode (which leaves remaining gas untouched) while Solidity
     * uses an invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     *
     * - The divisor cannot be zero.
     */
    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
        require(b &gt; 0, errorMessage);
        uint256 c = a / b;
        // assert(a == b * c + a % b); // There is no case in which this doesn't hold

        return c;
    }

    /**
     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),
     * Reverts when dividing by zero.
     *
     * Counterpart to Solidity's `%` operator. This function uses a `revert`
     * opcode (which leaves remaining gas untouched) while Solidity uses an
     * invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     *
     * - The divisor cannot be zero.
     */
    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
        return mod(a, b, "SafeMath: modulo by zero");
    }

    /**
     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),
     * Reverts with custom message when dividing by zero.
     *
     * Counterpart to Solidity's `%` operator. This function uses a `revert`
     * opcode (which leaves remaining gas untouched) while Solidity uses an
     * invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     *
     * - The divisor cannot be zero.
     */
    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
        require(b != 0, errorMessage);
        return a % b;
    }
}</span>

<span class="marker" id="mapping-479"></span><span class="token mv" id="move-dst-3" data-title="source_file/pragma_directive">pragma solidity ^0.6.0;</span>

<span class="marker" id="mapping-480"></span><span class="token mv" id="move-dst-8" data-title="source_file/comment">/**
 * @dev Interface of the ERC20 standard as defined in the EIP.
 */</span>
<span class="marker" id="mapping-481"></span><span class="token mv" id="move-dst-9" data-title="source_file/interface_declaration">interface IERC20 {
    /**
     * @dev Returns the amount of tokens in existence.
     */
    function totalSupply() external view returns (uint256);

    /**
     * @dev Returns the amount of tokens owned by `account`.
     */
    function balanceOf(address account) external view returns (uint256);

    /**
     * @dev Moves `amount` tokens from the caller's account to `recipient`.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * Emits a {Transfer} event.
     */
    function transfer(address recipient, uint256 amount) external returns (bool);

    /**
     * @dev Returns the remaining number of tokens that `spender` will be
     * allowed to spend on behalf of `owner` through {transferFrom}. This is
     * zero by default.
     *
     * This value changes when {approve} or {transferFrom} are called.
     */
    function allowance(address owner, address spender) external view returns (uint256);

    /**
     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * IMPORTANT: Beware that changing an allowance with this method brings the risk
     * that someone may use both the old and the new allowance by unfortunate
     * transaction ordering. One possible solution to mitigate this race
     * condition is to first reduce the spender's allowance to 0 and set the
     * desired value afterwards:
     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
     *
     * Emits an {Approval} event.
     */
    function approve(address spender, uint256 amount) external returns (bool);

    /**
     * @dev Moves `amount` tokens from `sender` to `recipient` using the
     * allowance mechanism. `amount` is then deducted from the caller's
     * allowance.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * Emits a {Transfer} event.
     */
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);

    /**
     * @dev Emitted when `value` tokens are moved from one account (`from`) to
     * another (`to`).
     *
     * Note that `value` may be zero.
     */
    event Transfer(address indexed from, address indexed to, uint256 value);

    /**
     * @dev Emitted when the allowance of a `spender` for an `owner` is set by
     * a call to {approve}. `value` is the new allowance.
     */
    event Approval(address indexed owner, address indexed spender, uint256 value);
}</span>

<span class="marker" id="mapping-482"></span><span class="token mv" id="move-dst-118" data-title="source_file/pragma_directive">pragma solidity 0.6.10;</span>

<span class="marker" id="mapping-483"></span><span class="token mv" id="move-dst-11" data-title="source_file/interface_declaration">interface RegistryClone {
    function syncAttributeValue(
        address _who,
        bytes32 _attribute,
        uint256 _value
    ) external;
}</span>

<span class="marker" id="mapping-484"></span><span class="token mv" id="move-dst-12" data-title="source_file/contract_declaration">contract Registry {
    struct AttributeData {
        uint256 value;
        bytes32 notes;
        address adminAddr;
        uint256 timestamp;
    }

    // never remove any storage variables
    address public owner;
    address public pendingOwner;
    bool initialized;

    // Stores arbitrary attributes for users. An example use case is an IERC20
    // token that requires its users to go through a KYC/AML check - in this case
    // a validator can set an account's "hasPassedKYC/AML" attribute to 1 to indicate
    // that account can use the token. This mapping stores that value (1, in the
    // example) as well as which validator last set the value and at what time,
    // so that e.g. the check can be renewed at appropriate intervals.
    mapping(address =&gt; mapping(bytes32 =&gt; AttributeData)) attributes;
    // The logic governing who is allowed to set what attributes is abstracted as
    // this accessManager, so that it may be replaced by the owner as needed
    bytes32 constant WRITE_PERMISSION = keccak256("canWriteTo-");
    mapping(bytes32 =&gt; RegistryClone[]) subscribers;

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);
    event SetAttribute(address indexed who, bytes32 attribute, uint256 value, bytes32 notes, address indexed adminAddr);
    event SetManager(address indexed oldManager, address indexed newManager);
    event StartSubscription(bytes32 indexed attribute, RegistryClone indexed subscriber);
    event StopSubscription(bytes32 indexed attribute, RegistryClone indexed subscriber);

    // Allows a write if either a) the writer is that Registry's owner, or
    // b) the writer is writing to attribute foo and that writer already has
    // the canWriteTo-foo attribute set (in that same Registry)
    function confirmWrite(bytes32 _attribute, address _admin) internal view returns (bool) {
        return (_admin == owner || hasAttribute(_admin, keccak256(abi.encodePacked(WRITE_PERMISSION ^ _attribute))));
    }

    // Writes are allowed only if the accessManager approves
    function setAttribute(
        address _who,
        bytes32 _attribute,
        uint256 _value,
        bytes32 _notes
    ) public {
        require(confirmWrite(_attribute, msg.sender));
        attributes[_who][_attribute] = AttributeData(_value, _notes, msg.sender, block.timestamp);
        emit SetAttribute(_who, _attribute, _value, _notes, msg.sender);

        RegistryClone[] storage targets = subscribers[_attribute];
        uint256 index = targets.length;
        while (index-- &gt; 0) {
            targets[index].syncAttributeValue(_who, _attribute, _value);
        }
    }

    function subscribe(bytes32 _attribute, RegistryClone _syncer) external onlyOwner {
        subscribers[_attribute].push(_syncer);
        emit StartSubscription(_attribute, _syncer);
    }

    function unsubscribe(bytes32 _attribute, uint256 _index) external onlyOwner {
        uint256 length = subscribers[_attribute].length;
        require(_index &lt; length);
        emit StopSubscription(_attribute, subscribers[_attribute][_index]);
        subscribers[_attribute][_index] = subscribers[_attribute][length - 1];
        subscribers[_attribute].pop();
    }

    function subscriberCount(bytes32 _attribute) public view returns (uint256) {
        return subscribers[_attribute].length;
    }

    function setAttributeValue(
        address _who,
        bytes32 _attribute,
        uint256 _value
    ) public {
        require(confirmWrite(_attribute, msg.sender));
        attributes[_who][_attribute] = AttributeData(_value, "", msg.sender, block.timestamp);
        emit SetAttribute(_who, _attribute, _value, "", msg.sender);
        RegistryClone[] storage targets = subscribers[_attribute];
        uint256 index = targets.length;
        while (index-- &gt; 0) {
            targets[index].syncAttributeValue(_who, _attribute, _value);
        }
    }

    // Returns true if the uint256 value stored for this attribute is non-zero
    function hasAttribute(address _who, bytes32 _attribute) public view returns (bool) {
        return attributes[_who][_attribute].value != 0;
    }

    // Returns the exact value of the attribute, as well as its metadata
    function getAttribute(address _who, bytes32 _attribute)
        public
        view
        returns (
            uint256,
            bytes32,
            address,
            uint256
        )
    {
        AttributeData memory data = attributes[_who][_attribute];
        return (data.value, data.notes, data.adminAddr, data.timestamp);
    }

    function getAttributeValue(address _who, bytes32 _attribute) public view returns (uint256) {
        return attributes[_who][_attribute].value;
    }

    function getAttributeAdminAddr(address _who, bytes32 _attribute) public view returns (address) {
        return attributes[_who][_attribute].adminAddr;
    }

    function getAttributeTimestamp(address _who, bytes32 _attribute) public view returns (uint256) {
        return attributes[_who][_attribute].timestamp;
    }

    function syncAttribute(
        bytes32 _attribute,
        uint256 _startIndex,
        address[] calldata _addresses
    ) external {
        RegistryClone[] storage targets = subscribers[_attribute];
        uint256 index = targets.length;
        while (index-- &gt; _startIndex) {
            RegistryClone target = targets[index];
            for (uint256 i = _addresses.length; i-- &gt; 0; ) {
                address who = _addresses[i];
                target.syncAttributeValue(who, _attribute, attributes[who][_attribute].value);
            }
        }
    }

    function reclaimEther(address payable _to) external onlyOwner {
        _to.transfer(address(this).balance);
    }

    function reclaimToken(IERC20 token, address _to) external onlyOwner {
        uint256 balance = token.balanceOf(address(this));
        token.transfer(_to, balance);
    }

    /**
     * @dev Throws if called by any account other than the owner.
     */
    modifier onlyOwner() {
        require(msg.sender == owner, "only Owner");
        _;
    }

    /**
     * @dev Modifier throws if called by any account other than the pendingOwner.
     */
    modifier onlyPendingOwner() {
        require(msg.sender == pendingOwner);
        _;
    }

    /**
     * @dev Allows the current owner to set the pendingOwner address.
     * @param newOwner The address to transfer ownership to.
     */
    function transferOwnership(address newOwner) public onlyOwner {
        pendingOwner = newOwner;
    }

    /**
     * @dev Allows the pendingOwner address to finalize the transfer.
     */
    function claimOwnership() public onlyPendingOwner {
        emit OwnershipTransferred(owner, pendingOwner);
        owner = pendingOwner;
        pendingOwner = address(0);
    }
}</span>

pragma solidity 0.6.10;

<span class="marker" id="mapping-485"></span><span class="token mv" id="move-dst-14" data-title="source_file/comment">/**
 * All storage must be declared here
 * New storage must be appended to the end
 * Never remove items from this list
 */</span>
<span class="marker" id="mapping-486"></span><span class="token mv" id="move-dst-15" data-title="source_file/contract_declaration">contract ProxyStorage {
    bool initalized;
    uint256 public totalSupply;

    mapping(address =&gt; uint256) public balanceOf;
    mapping(address =&gt; mapping(address =&gt; uint256)) public allowance;
    mapping(uint144 =&gt; uint256) attributes; // see RegistrySubscriber

    address owner_;
    address pendingOwner_;

    /* Additionally, we have several keccak-based storage locations.
     * If you add more keccak-based storage mappings, such as mappings, you must document them here.
     * If the length of the keccak input is the same as an existing mapping, it is possible there could be a preimage collision.
     * A preimage collision can be used to attack the contract by treating one storage location as another,
     * which would always be a critical issue.
     * Carefully examine future keccak-based storage to ensure there can be no preimage collisions.
     *******************************************************************************************************
     ** length     input                                                         usage
     *******************************************************************************************************
     ** 19         "trueXXX.proxy.owner"                                         Proxy Owner
     ** 27         "trueXXX.pending.proxy.owner"                                 Pending Proxy Owner
     ** 28         "trueXXX.proxy.implementation"                                Proxy Implementation
     ** 64         uint256(address),uint256(1)                                   balanceOf
     ** 64         uint256(address),keccak256(uint256(address),uint256(2))       allowance
     ** 64         uint256(address),keccak256(bytes32,uint256(3))                attributes
     **/
}</span>

<span class="marker" id="mapping-487"></span><span class="token mv" id="move-dst-182" data-title="source_file/pragma_directive">pragma solidity 0.6.10;</span>

/**
 * @title ClaimableContract
 * @dev The ClaimableContract contract is a copy of Claimable Contract by Zeppelin.
 and provides basic authorization control functions. Inherits storage layout of
 ProxyStorage.
 */
contract ClaimableContract is ProxyStorage {
    function owner() public view returns (address) {
        return owner_;
    }

    function pendingOwner() public view returns (address) {
        return pendingOwner_;
    }

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    /**
     * @dev sets the original `owner` of the contract to the sender
     * at construction. Must then be reinitialized
     */
    constructor() public {
        owner_ = msg.sender;
        emit OwnershipTransferred(address(0), msg.sender);
    }

    /**
     * @dev Throws if called by any account other than the owner.
     */
    modifier onlyOwner() {
        require(msg.sender == owner_, "only owner");
        _;
    }

    /**
     * @dev Modifier throws if called by any account other than the pendingOwner.
     */
    modifier onlyPendingOwner() {
        require(msg.sender == pendingOwner_);
        _;
    }

    /**
     * @dev Allows the current owner to set the pendingOwner address.
     * @param newOwner The address to transfer ownership to.
     */
    function transferOwnership(address newOwner) public onlyOwner {
        pendingOwner_ = newOwner;
    }

    /**
     * @dev Allows the pendingOwner address to finalize the transfer.
     */
    function claimOwnership() public onlyPendingOwner {
        address _pendingOwner = pendingOwner_;
        emit OwnershipTransferred(owner_, _pendingOwner);
        owner_ = _pendingOwner;
        pendingOwner_ = address(0);
    }
}

<span class="marker" id="mapping-488"></span><span class="token add" data-title="source_file/pragma_directive">pragma solidity ^0.6.0;</span>

<span class="marker" id="mapping-489"></span><span class="token add" data-title="source_file/comment">/*
 * @dev Provides information about the current execution context, including the
 * sender of the transaction and its data. While these are generally available
 * via msg.sender and msg.data, they should not be accessed in such a direct
 * manner, since when dealing with GSN meta-transactions the account sending and
 * paying for execution may not be the actual sender (as far as an application
 * is concerned).
 *
 * This contract is only required for intermediate, library-like contracts.
 */</span>
<span class="marker" id="mapping-490"></span><span class="token add" data-title="source_file/contract_declaration">abstract contract Context <span class="marker" id="mapping-491"></span><span class="token add" data-title="contract_declaration/contract_body">{
    <span class="marker" id="mapping-492"></span><span class="token add" data-title="contract_body/function_definition">function _msgSender() <span class="marker" id="mapping-493"></span><span class="token mv" id="move-dst-45" data-title="function_definition/visibility">internal</span> <span class="marker" id="mapping-494"></span><span class="token mv" id="move-dst-121" data-title="function_definition/state_mutability">view</span> virtual <span class="marker" id="mapping-495"></span><span class="token add" data-title="function_definition/return_type_definition">returns (address payable)</span> <span class="marker" id="mapping-496"></span><span class="token add" data-title="function_definition/function_body">{
        <span class="marker" id="mapping-497"></span><span class="token add" data-title="function_body/return_statement">return <span class="marker" id="mapping-498"></span><span class="token mv" id="move-dst-107" data-title="return_statement/member_expression">msg.sender</span>;</span>
    }</span></span>

    <span class="marker" id="mapping-499"></span><span class="token add" data-title="contract_body/function_definition">function _msgData() <span class="marker" id="mapping-500"></span><span class="token mv" id="move-dst-130" data-title="function_definition/visibility">internal</span> <span class="marker" id="mapping-501"></span><span class="token mv" id="move-dst-220" data-title="function_definition/state_mutability">view</span> virtual <span class="marker" id="mapping-502"></span><span class="token add" data-title="function_definition/return_type_definition">returns (bytes memory)</span> <span class="marker" id="mapping-503"></span><span class="token add" data-title="function_definition/function_body">{
        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691
        return msg.data;
    }</span></span>
}</span></span>

<span class="marker" id="mapping-504"></span><span class="token add" data-title="source_file/pragma_directive">pragma solidity ^0.6.2;</span>

<span class="marker" id="mapping-505"></span><span class="token add" data-title="source_file/comment">/**
 * @dev Collection of functions related to the address type
 */</span>
<span class="marker" id="mapping-506"></span><span class="token mv" id="move-dst-18" data-title="source_file/library_declaration">library <span class="marker" id="mapping-507"></span><span class="token upd" id="move-dst-19" data-title="library_declaration/identifier">Address</span> {
    <span class="marker" id="mapping-508"></span><span class="token add" data-title="contract_body/comment">/**
     * @dev Returns true if `account` is a contract.
     *
     * [IMPORTANT]
     * ====
     * It is unsafe to assume that an address for which this function returns
     * false is an externally-owned account (EOA) and not a contract.
     *
     * Among others, `isContract` will return false for the following
     * types of addresses:
     *
     *  - an externally-owned account
     *  - a contract in construction
     *  - an address where a contract will be created
     *  - an address where a contract lived, but was destroyed
     * ====
     */</span>
    <span class="marker" id="mapping-509"></span><span class="token add" data-title="contract_body/function_definition">function isContract(<span class="marker" id="mapping-510"></span><span class="token add" data-title="function_definition/parameter">address account</span>) <span class="marker" id="mapping-511"></span><span class="token mv" id="move-dst-22" data-title="function_definition/visibility">internal</span> <span class="marker" id="mapping-512"></span><span class="token add" data-title="function_definition/state_mutability">view</span> <span class="marker" id="mapping-513"></span><span class="token add" data-title="function_definition/return_type_definition">returns (bool)</span> <span class="marker" id="mapping-514"></span><span class="token add" data-title="function_definition/function_body">{
        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts
        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned
        // for accounts without code, i.e. `keccak256('')`
        <span class="marker" id="mapping-515"></span><span class="token add" data-title="function_body/variable_declaration_statement"><span class="marker" id="mapping-516"></span><span class="token add" data-title="variable_declaration_statement/variable_declaration"><span class="marker" id="mapping-517"></span><span class="token mv" id="move-dst-104" data-title="variable_declaration/type_name">bytes32</span> codehash</span>;</span>
        <span class="marker" id="mapping-518"></span><span class="token add" data-title="function_body/variable_declaration_statement"><span class="marker" id="mapping-519"></span><span class="token add" data-title="variable_declaration_statement/variable_declaration"><span class="marker" id="mapping-520"></span><span class="token mv" id="move-dst-111" data-title="variable_declaration/type_name">bytes32</span> accountHash</span> = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;</span>
        // solhint-disable-next-line no-inline-assembly
        <span class="marker" id="mapping-521"></span><span class="token add" data-title="function_body/assembly_statement">assembly { codehash := extcodehash(account) }</span>
        <span class="marker" id="mapping-522"></span><span class="token add" data-title="function_body/return_statement">return (codehash != accountHash &amp;&amp; codehash != 0x0);</span>
    }</span></span>

    <span class="marker" id="mapping-523"></span><span class="token add" data-title="contract_body/comment">/**
     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to
     * `recipient`, forwarding all available gas and reverting on errors.
     *
     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost
     * of certain opcodes, possibly making contracts go over the 2300 gas limit
     * imposed by `transfer`, making them unable to receive funds via
     * `transfer`. {sendValue} removes this limitation.
     *
     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].
     *
     * IMPORTANT: because control is transferred to `recipient`, care must be
     * taken to not create reentrancy vulnerabilities. Consider using
     * {ReentrancyGuard} or the
     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].
     */</span>
    <span class="marker" id="mapping-524"></span><span class="token add" data-title="contract_body/function_definition">function sendValue(<span class="marker" id="mapping-525"></span><span class="token add" data-title="function_definition/parameter">address payable recipient</span>, <span class="marker" id="mapping-526"></span><span class="token add" data-title="function_definition/parameter">uint256 amount</span>) <span class="marker" id="mapping-527"></span><span class="token mv" id="move-dst-147" data-title="function_definition/visibility">internal</span> <span class="marker" id="mapping-528"></span><span class="token add" data-title="function_definition/function_body">{
        <span class="marker" id="mapping-529"></span><span class="token mv" id="move-dst-176" data-title="function_body/expression_statement"><span class="marker" id="mapping-530"></span><span class="token add" data-title="call_expression/identifier">require</span>(<span class="marker" id="mapping-531"></span><span class="token add" data-title="call_argument/binary_expression"><span class="marker" id="mapping-532"></span><span class="token add" data-title="binary_expression/member_expression"><span class="marker" id="mapping-533"></span><span class="token mv" id="move-dst-177" data-title="member_expression/type_cast_expression">address(<span class="marker" id="mapping-534"></span><span class="token add" data-title="call_argument/identifier">this</span>)</span>.balance</span> &gt;= amount</span>, <span class="marker" id="mapping-535"></span><span class="token add" data-title="call_expression/call_argument">"Address: insufficient balance"</span>);</span>

        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value
        <span class="marker" id="mapping-536"></span><span class="token add" data-title="function_body/variable_declaration_statement"><span class="marker" id="mapping-537"></span><span class="token add" data-title="variable_declaration_statement/variable_declaration_tuple">(<span class="marker" id="mapping-538"></span><span class="token mv" id="move-dst-149" data-title="variable_declaration_tuple/variable_declaration">bool <span class="marker" id="mapping-539"></span><span class="token upd" id="move-dst-150" data-title="variable_declaration/identifier">success</span></span>, )</span> = <span class="marker" id="mapping-540"></span><span class="token add" data-title="variable_declaration_statement/call_expression">recipient.call{ value: amount }("")</span>;</span>
        <span class="marker" id="mapping-541"></span><span class="token add" data-title="function_body/expression_statement">require(success, "Address: unable to send value, recipient may have reverted");</span>
    }</span></span>

    <span class="marker" id="mapping-542"></span><span class="token add" data-title="contract_body/comment">/**
     * @dev Performs a Solidity function call using a low level `call`. A
     * plain`call` is an unsafe replacement for a function call: use this
     * function instead.
     *
     * If `target` reverts with a revert reason, it is bubbled up by this
     * function (like regular Solidity function calls).
     *
     * Returns the raw returned data. To convert to the expected return value,
     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].
     *
     * Requirements:
     *
     * - `target` must be a contract.
     * - calling `target` with `data` must not revert.
     *
     * _Available since v3.1._
     */</span>
    <span class="marker" id="mapping-543"></span><span class="token add" data-title="contract_body/function_definition">function functionCall(<span class="marker" id="mapping-544"></span><span class="token mv" id="move-dst-58" data-title="function_definition/parameter">address <span class="marker" id="mapping-545"></span><span class="token upd" id="move-dst-59" data-title="parameter/identifier">target</span></span>, <span class="marker" id="mapping-546"></span><span class="token add" data-title="function_definition/parameter">bytes memory data</span>) <span class="marker" id="mapping-547"></span><span class="token mv" id="move-dst-60" data-title="function_definition/visibility">internal</span> <span class="marker" id="mapping-548"></span><span class="token add" data-title="function_definition/return_type_definition">returns (bytes memory)</span> <span class="marker" id="mapping-549"></span><span class="token add" data-title="function_definition/function_body">{
      return functionCall(target, data, "Address: low-level call failed");
    }</span></span>

    <span class="marker" id="mapping-550"></span><span class="token add" data-title="contract_body/comment">/**
     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with
     * `errorMessage` as a fallback revert reason when `target` reverts.
     *
     * _Available since v3.1._
     */</span>
    <span class="marker" id="mapping-551"></span><span class="token add" data-title="contract_body/function_definition">function functionCall(<span class="marker" id="mapping-552"></span><span class="token mv" id="move-dst-64" data-title="function_definition/parameter">address <span class="marker" id="mapping-553"></span><span class="token upd" id="move-dst-65" data-title="parameter/identifier">target</span></span>, <span class="marker" id="mapping-554"></span><span class="token add" data-title="function_definition/parameter">bytes memory data</span>, <span class="marker" id="mapping-555"></span><span class="token mv" id="move-dst-30" data-title="function_definition/parameter">string memory <span class="marker" id="mapping-556"></span><span class="token upd" id="move-dst-31" data-title="parameter/identifier"><span class="cupd">e</span><span class="cupd">r</span>r<span class="cupd">o</span>r<span class="cupd">Message</span></span></span>) <span class="marker" id="mapping-557"></span><span class="token mv" id="move-dst-32" data-title="function_definition/visibility">internal</span> <span class="marker" id="mapping-558"></span><span class="token add" data-title="function_definition/return_type_definition">returns (bytes memory)</span> <span class="marker" id="mapping-559"></span><span class="token add" data-title="function_definition/function_body">{
        return _functionCallWithValue(target, data, 0, errorMessage);
    }</span></span>

    <span class="marker" id="mapping-560"></span><span class="token add" data-title="contract_body/comment">/**
     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],
     * but also transferring `value` wei to `target`.
     *
     * Requirements:
     *
     * - the calling contract must have an ETH balance of at least `value`.
     * - the called Solidity function must be `payable`.
     *
     * _Available since v3.1._
     */</span>
    <span class="marker" id="mapping-561"></span><span class="token add" data-title="contract_body/function_definition">function functionCallWithValue(<span class="marker" id="mapping-562"></span><span class="token mv" id="move-dst-73" data-title="function_definition/parameter">address <span class="marker" id="mapping-563"></span><span class="token upd" id="move-dst-74" data-title="parameter/identifier">target</span></span>, <span class="marker" id="mapping-564"></span><span class="token add" data-title="function_definition/parameter">bytes memory data</span>, <span class="marker" id="mapping-565"></span><span class="token mv" id="move-dst-116" data-title="function_definition/parameter">uint256 value</span>) <span class="marker" id="mapping-566"></span><span class="token mv" id="move-dst-26" data-title="function_definition/visibility">internal</span> <span class="marker" id="mapping-567"></span><span class="token add" data-title="function_definition/return_type_definition">returns (bytes memory)</span> <span class="marker" id="mapping-568"></span><span class="token add" data-title="function_definition/function_body">{
        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");
    }</span></span>

    <span class="marker" id="mapping-569"></span><span class="token add" data-title="contract_body/comment">/**
     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but
     * with `errorMessage` as a fallback revert reason when `target` reverts.
     *
     * _Available since v3.1._
     */</span>
    <span class="marker" id="mapping-570"></span><span class="token add" data-title="contract_body/function_definition">function functionCallWithValue(<span class="marker" id="mapping-571"></span><span class="token mv" id="move-dst-69" data-title="function_definition/parameter">address <span class="marker" id="mapping-572"></span><span class="token upd" id="move-dst-70" data-title="parameter/identifier">target</span></span>, <span class="marker" id="mapping-573"></span><span class="token add" data-title="function_definition/parameter">bytes memory data</span>, <span class="marker" id="mapping-574"></span><span class="token add" data-title="function_definition/parameter">uint256 value</span>, <span class="marker" id="mapping-575"></span><span class="token mv" id="move-dst-24" data-title="function_definition/parameter">string memory <span class="marker" id="mapping-576"></span><span class="token upd" id="move-dst-25" data-title="parameter/identifier"><span class="cupd">er</span>r<span class="cupd">o</span>r<span class="cupd">Message</span></span></span>) <span class="marker" id="mapping-577"></span><span class="token mv" id="move-dst-71" data-title="function_definition/visibility">internal</span> <span class="marker" id="mapping-578"></span><span class="token add" data-title="function_definition/return_type_definition">returns (bytes memory)</span> <span class="marker" id="mapping-579"></span><span class="token add" data-title="function_definition/function_body">{
        <span class="marker" id="mapping-580"></span><span class="token add" data-title="function_body/expression_statement"><span class="marker" id="mapping-581"></span><span class="token add" data-title="expression_statement/call_expression">require(<span class="marker" id="mapping-582"></span><span class="token add" data-title="call_expression/call_argument"><span class="marker" id="mapping-583"></span><span class="token add" data-title="call_argument/binary_expression"><span class="marker" id="mapping-584"></span><span class="token add" data-title="binary_expression/member_expression"><span class="marker" id="mapping-585"></span><span class="token add" data-title="member_expression/type_cast_expression"><span class="marker" id="mapping-586"></span><span class="token mv" id="move-dst-108" data-title="type_cast_expression/primitive_type">address</span>(<span class="marker" id="mapping-587"></span><span class="token add" data-title="type_cast_expression/call_argument">this</span>)</span>.balance</span> &gt;= value</span></span>, <span class="marker" id="mapping-588"></span><span class="token add" data-title="call_expression/call_argument">"Address: insufficient balance for call"</span>)</span>;</span>
        <span class="marker" id="mapping-589"></span><span class="token add" data-title="function_body/return_statement">return _functionCallWithValue(target, data, value, errorMessage);</span>
    }</span></span>

    <span class="marker" id="mapping-590"></span><span class="token add" data-title="contract_body/function_definition">function _functionCallWithValue(<span class="marker" id="mapping-591"></span><span class="token mv" id="move-dst-84" data-title="function_definition/parameter">address <span class="marker" id="mapping-592"></span><span class="token upd" id="move-dst-85" data-title="parameter/identifier"><span class="cupd">t</span>arget</span></span>, <span class="marker" id="mapping-593"></span><span class="token add" data-title="function_definition/parameter">bytes memory data</span>, <span class="marker" id="mapping-594"></span><span class="token mv" id="move-dst-28" data-title="function_definition/parameter">uint256 <span class="marker" id="mapping-595"></span><span class="token upd" id="move-dst-29" data-title="parameter/identifier">weiValue</span></span>, <span class="marker" id="mapping-596"></span><span class="token mv" id="move-dst-20" data-title="function_definition/parameter">string memory <span class="marker" id="mapping-597"></span><span class="token upd" id="move-dst-21" data-title="parameter/identifier"><span class="cupd">er</span>r<span class="cupd">o</span>r<span class="cupd">Message</span></span></span>) <span class="marker" id="mapping-598"></span><span class="token add" data-title="function_definition/visibility">private</span> <span class="marker" id="mapping-599"></span><span class="token add" data-title="function_definition/return_type_definition">returns (bytes memory)</span> <span class="marker" id="mapping-600"></span><span class="token add" data-title="function_definition/function_body">{
        <span class="marker" id="mapping-601"></span><span class="token add" data-title="function_body/expression_statement">require(isContract(target), "Address: call to non-contract");</span>

        // solhint-disable-next-line avoid-low-level-calls
        <span class="marker" id="mapping-602"></span><span class="token mv" id="move-dst-168" data-title="function_body/variable_declaration_statement">(bool <span class="marker" id="mapping-603"></span><span class="token upd" id="move-dst-172" data-title="variable_declaration/identifier">success</span><span class="marker" id="mapping-604"></span><span class="token mv" id="move-dst-171" data-title="variable_declaration_tuple/,">,</span> <span class="marker" id="mapping-605"></span><span class="token mv" id="move-dst-169" data-title="variable_declaration_tuple/variable_declaration"><span class="marker" id="mapping-606"></span><span class="token add" data-title="primitive_type/bytes">bytes</span> <span class="marker" id="mapping-607"></span><span class="token add" data-title="variable_declaration/memory">memory</span> <span class="marker" id="mapping-608"></span><span class="token upd" id="move-dst-170" data-title="variable_declaration/identifier">returndata</span></span>) = <span class="marker" id="mapping-609"></span><span class="token add" data-title="call_expression/struct_expression">target.call{ value: weiValue }</span>(<span class="marker" id="mapping-610"></span><span class="token upd" id="move-dst-173" data-title="call_argument/identifier">data</span>);</span>
        <span class="marker" id="mapping-611"></span><span class="token add" data-title="function_body/if_statement">if (success) {
            return returndata;
        } else {
            // Look for revert reason and bubble it up if present
            if (returndata.length &gt; 0) {
                // The easiest way to bubble the revert reason is using memory via assembly

                // solhint-disable-next-line no-inline-assembly
                assembly {
                    let returndata_size := mload(returndata)
                    revert(add(32, returndata), returndata_size)
                }
            } else {
                revert(errorMessage);
            }
        }</span>
    }</span></span>
}</span>

<span class="marker" id="mapping-612"></span><span class="token add" data-title="source_file/comment">// File: contracts/trusttoken/common/ERC20.sol</span>

<span class="marker" id="mapping-613"></span><span class="token add" data-title="source_file/comment">/**
 * @notice This is a copy of openzeppelin ERC20 contract with removed state variables.
 * Removing state variables has been necessary due to proxy pattern usage.
 * Changes to Openzeppelin ERC20 https://github.com/OpenZeppelin/openzeppelin-contracts/blob/de99bccbfd4ecd19d7369d01b070aa72c64423c9/contracts/token/ERC20/ERC20.sol:
 * - Remove state variables _name, _symbol, _decimals
 * - Use state variables balances, allowances, totalSupply from ProxyStorage
 * - Remove constructor
 * - Solidity version changed from ^0.6.0 to 0.6.10
 * - Contract made abstract
 * - Remove inheritance from IERC20 because of ProxyStorage name conflicts
 *
 * See also: ClaimableOwnable.sol and ProxyStorage.sol
 */</span>

<span class="marker" id="mapping-614"></span><span class="token mv" id="move-dst-217" data-title="source_file/pragma_directive">pragma solidity 0.6.10;</span>

<span class="marker" id="mapping-615"></span><span class="token add" data-title="source_file/comment">/**
 * @dev Implementation of the {IERC20} interface.
 *
 * This implementation is agnostic to the way tokens are created. This means
 * that a supply mechanism has to be added in a derived contract using {_mint}.
 * For a generic mechanism see {ERC20PresetMinterPauser}.
 *
 * TIP: For a detailed writeup see our guide
 * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How
 * to implement supply mechanisms].
 *
 * We have followed general OpenZeppelin guidelines: functions revert instead
 * of returning `false` on failure. This behavior is nonetheless conventional
 * and does not conflict with the expectations of ERC20 applications.
 *
 * Additionally, an {Approval} event is emitted on calls to {transferFrom}.
 * This allows applications to reconstruct the allowance for all accounts just
 * by listening to said events. Other implementations of the EIP may not emit
 * these events, as it isn't required by the specification.
 *
 * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}
 * functions have been added to mitigate the well-known issues around setting
 * allowances. See {IERC20-approve}.
 */</span>
<span class="marker" id="mapping-616"></span><span class="token mv" id="move-dst-47" data-title="source_file/contract_declaration"><span class="marker" id="mapping-617"></span><span class="token add" data-title="contract_declaration/abstract">abstract</span> contract <span class="marker" id="mapping-618"></span><span class="token upd" id="move-dst-48" data-title="contract_declaration/identifier">ERC20</span> is <span class="marker" id="mapping-619"></span><span class="token mv" id="move-dst-37" data-title="contract_declaration/inheritance_specifier">ProxyStorage</span><span class="marker" id="mapping-620"></span><span class="token add" data-title="contract_declaration/,">,</span> <span class="marker" id="mapping-621"></span><span class="token upd" id="move-dst-49" data-title="user_defined_type/identifier">C<span class="cupd">o</span>ntext</span> {
    using <span class="marker" id="mapping-622"></span><span class="token upd" id="move-dst-50" data-title="type_alias/identifier"><span class="cupd">SafeMath</span></span> for uint256;
    <span class="marker" id="mapping-623"></span><span class="token add" data-title="contract_body/using_directive">using <span class="marker" id="mapping-624"></span><span class="token add" data-title="using_directive/type_alias">Address</span> for <span class="marker" id="mapping-625"></span><span class="token mv" id="move-dst-119" data-title="using_directive/type_name">address</span>;</span>

    <span class="marker" id="mapping-626"></span><span class="token upd" id="move-dst-52" data-title="contract_body/comment"><span class="cupd">/**
     * @dev</span> Em<span class="cupd">i</span><span class="cupd">t</span><span class="cupd">t</span><span class="cupd">ed</span> <span class="cupd">wh</span>e<span class="cupd">n</span> `<span class="cupd">v</span>a<span class="cupd">l</span>ue<span class="cupd">`</span><span class="cupd"> tokens</span><span class="cupd"> </span><span class="cupd">a</span><span class="cupd">r</span><span class="cupd">e</span> <span class="cupd">m</span>o<span class="cupd">v</span><span class="cupd">ed</span> <span class="cupd">f</span><span class="cupd">ro</span><span class="cupd">m</span><span class="cupd"> </span><span class="cupd">o</span><span class="cupd">ne</span><span class="cupd"> </span><span class="cupd">a</span>c<span class="cupd">c</span><span class="cupd">ou</span><span class="cupd">n</span><span class="cupd">t</span> (`<span class="cupd">f</span><span class="cupd">r</span>om`<span class="cupd">)</span><span class="cupd"> </span><span class="cupd">t</span><span class="cupd">o</span><span class="cupd"></span><span class="cupd">
</span><span class="cupd">   </span><span class="cupd">  </span><span class="cupd">*</span><span class="cupd"> </span><span class="cupd">a</span><span class="cupd">n</span><span class="cupd">ot</span><span class="cupd">h</span><span class="cupd">e</span>r <span class="cupd">(`</span>to`<span class="cupd">)</span><span class="cupd">.</span><span class="cupd"></span><span class="cupd">
</span><span class="cupd"> </span><span class="cupd"> </span> <span class="cupd"> </span><span class="cupd"> *
 </span><span class="cupd">  </span> <span class="cupd"> </span><span class="cupd">*</span><span class="cupd"> </span>N<span class="cupd">o</span><span class="cupd">t</span><span class="cupd">e</span><span class="cupd"> </span><span class="cupd">t</span>h<span class="cupd">at `v</span>a<span class="cupd">l</span>u<span class="cupd">e</span>`<span class="cupd"> </span><span class="cupd">may</span> <span class="cupd">b</span>e <span class="cupd">zero.
  </span>   */</span>
    <span class="marker" id="mapping-627"></span><span class="token mv" id="move-dst-38" data-title="contract_body/event_definition">event Transfer(address indexed from, address indexed to, uint256 value);</span>

    <span class="marker" id="mapping-628"></span><span class="token upd" id="move-dst-61" data-title="contract_body/comment"><span class="cupd">/**
     * @dev</span> Emit<span class="cupd">t</span>e<span class="cupd">d</span> <span class="cupd">wh</span><span class="cupd">e</span><span class="cupd">n</span><span class="cupd"> </span><span class="cupd">t</span><span class="cupd">h</span><span class="cupd">e allo</span><span class="cupd">w</span><span class="cupd">a</span>n<span class="cupd">c</span><span class="cupd">e</span><span class="cupd"> </span>o<span class="cupd">f</span><span class="cupd"> </span><span class="cupd">a</span> <span class="cupd">`spende</span>r<span class="cupd">`</span> <span class="cupd">f</span><span class="cupd">o</span><span class="cupd">r</span><span class="cupd"> </span><span class="cupd">a</span><span class="cupd">n</span> <span class="cupd">`</span><span class="cupd">o</span><span class="cupd">w</span><span class="cupd">n</span>er<span class="cupd">`</span><span class="cupd"> </span><span class="cupd">i</span><span class="cupd">s</span><span class="cupd"> </span><span class="cupd">s</span><span class="cupd">e</span><span class="cupd">t</span> b<span class="cupd">y
     </span><span class="cupd">*</span><span class="cupd"> </span>a<span class="cupd"> </span><span class="cupd">cal</span><span class="cupd">l</span> <span class="cupd">t</span>o <span class="cupd">{</span>a<span class="cupd">p</span>prove<span class="cupd">}</span>. <span class="cupd">`</span><span class="cupd">val</span>u<span class="cupd">e</span>` <span class="cupd">i</span><span class="cupd">s</span> <span class="cupd">t</span><span class="cupd">h</span><span class="cupd">e</span><span class="cupd"> </span>n<span class="cupd">e</span><span class="cupd">w allowan</span><span class="cupd">ce.
    </span> */</span>
    <span class="marker" id="mapping-629"></span><span class="token mv" id="move-dst-51" data-title="contract_body/event_definition">event Approval(address indexed owner, address indexed spender, uint256 value);</span>


    <span class="marker" id="mapping-630"></span><span class="token upd" id="move-dst-72" data-title="contract_body/comment"><span class="cupd">/**
     * @dev</span> <span class="cupd">R</span><span class="cupd">e</span><span class="cupd">t</span><span class="cupd">u</span><span class="cupd">r</span><span class="cupd">n</span><span class="cupd">s</span><span class="cupd"> </span><span class="cupd">t</span><span class="cupd">he</span><span class="cupd"> </span><span class="cupd">n</span><span class="cupd">a</span><span class="cupd">m</span><span class="cupd">e</span><span class="cupd"> </span><span class="cupd">o</span><span class="cupd">f</span><span class="cupd"> </span><span class="cupd">the</span><span class="cupd"> </span><span class="cupd">t</span><span class="cupd">oke</span><span class="cupd">n.
     </span>*/</span>
    <span class="marker" id="mapping-631"></span><span class="token mv" id="move-dst-224" data-title="contract_body/function_definition">function <span class="marker" id="mapping-632"></span><span class="token upd" id="move-dst-225" data-title="function_definition/identifier">name</span>() public <span class="marker" id="mapping-633"></span><span class="token add" data-title="function_definition/virtual">virtual</span> pure returns (string memory);</span>

    <span class="marker" id="mapping-634"></span><span class="token add" data-title="contract_body/comment">/**
     * @dev Returns the symbol of the token, usually a shorter version of the
     * name.
     */</span>
    <span class="marker" id="mapping-635"></span><span class="token mv" id="move-dst-221" data-title="contract_body/function_definition">function <span class="marker" id="mapping-636"></span><span class="token upd" id="move-dst-222" data-title="function_definition/identifier">symbol</span>() public <span class="marker" id="mapping-637"></span><span class="token add" data-title="function_definition/virtual">virtual</span> pure returns (string memory);</span>

    <span class="marker" id="mapping-638"></span><span class="token add" data-title="contract_body/comment">/**
     * @dev Returns the number of decimals used to get its user representation.
     * For example, if `decimals` equals `2`, a balance of `505` tokens should
     * be displayed to a user as `5,05` (`505 / 10 ** 2`).
     *
     * Tokens usually opt for a value of 18, imitating the relationship between
     * Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is
     * called.
     *
     * NOTE: This information is only used for _display_ purposes: it in
     * no way affects any of the arithmetic of the contract, including
     * {IERC20-balanceOf} and {IERC20-transfer}.
     */</span>
    <span class="marker" id="mapping-639"></span><span class="token add" data-title="contract_body/function_definition">function decimals() <span class="marker" id="mapping-640"></span><span class="token mv" id="move-dst-218" data-title="function_definition/visibility">public</span> virtual <span class="marker" id="mapping-641"></span><span class="token mv" id="move-dst-33" data-title="function_definition/state_mutability">pure</span> <span class="marker" id="mapping-642"></span><span class="token add" data-title="function_definition/return_type_definition">returns (uint8)</span> <span class="marker" id="mapping-643"></span><span class="token add" data-title="function_definition/function_body">{
        return 18;
    }</span></span>

    <span class="marker" id="mapping-644"></span><span class="token add" data-title="contract_body/comment">/**
     * @dev See {IERC20-transfer}.
     *
     * Requirements:
     *
     * - `recipient` cannot be the zero address.
     * - the caller must have a balance of at least `amount`.
     */</span>
    <span class="marker" id="mapping-645"></span><span class="token add" data-title="contract_body/function_definition">function transfer(<span class="marker" id="mapping-646"></span><span class="token mv" id="move-dst-128" data-title="function_definition/parameter">address <span class="marker" id="mapping-647"></span><span class="token upd" id="move-dst-129" data-title="parameter/identifier">reci<span class="cupd">p</span>i<span class="cupd">en</span>t</span></span>, <span class="marker" id="mapping-648"></span><span class="token add" data-title="function_definition/parameter">uint256 amount</span>) <span class="marker" id="mapping-649"></span><span class="token mv" id="move-dst-105" data-title="function_definition/visibility">public</span> virtual <span class="marker" id="mapping-650"></span><span class="token mv" id="move-dst-143" data-title="function_definition/return_type_definition">returns (bool)</span> <span class="marker" id="mapping-651"></span><span class="token add" data-title="function_definition/function_body">{
        <span class="marker" id="mapping-652"></span><span class="token add" data-title="function_body/expression_statement">_transfer(_msgSender(), recipient, amount);</span>
        <span class="marker" id="mapping-653"></span><span class="token mv" id="move-dst-146" data-title="function_body/return_statement">return true;</span>
    }</span></span>

    <span class="marker" id="mapping-654"></span><span class="token add" data-title="contract_body/comment">/**
     * @dev See {IERC20-approve}.
     *
     * Requirements:
     *
     * - `spender` cannot be the zero address.
     */</span>
    <span class="marker" id="mapping-655"></span><span class="token mv" id="move-dst-131" data-title="contract_body/function_definition">function <span class="marker" id="mapping-656"></span><span class="token upd" id="move-dst-132" data-title="function_definition/identifier"><span class="cupd">a</span>pp<span class="cupd">r</span>ove</span>(<span class="marker" id="mapping-657"></span><span class="token mv" id="move-dst-98" data-title="function_definition/parameter">address <span class="marker" id="mapping-658"></span><span class="token upd" id="move-dst-99" data-title="parameter/identifier">spender</span></span>, uint256 <span class="marker" id="mapping-659"></span><span class="token upd" id="move-dst-133" data-title="parameter/identifier"><span class="cupd">a</span>mount</span>) <span class="marker" id="mapping-660"></span><span class="token mv" id="move-dst-112" data-title="function_definition/visibility">public</span> <span class="marker" id="mapping-661"></span><span class="token add" data-title="function_definition/virtual">virtual</span> returns (bool) {
        <span class="marker" id="mapping-662"></span><span class="token upd" id="move-dst-135" data-title="call_expression/identifier"><span class="cupd">_</span><span class="cupd">a</span>pp<span class="cupd">r</span>ove</span>(<span class="marker" id="mapping-663"></span><span class="token add" data-title="call_expression/call_argument">_msgSender()</span>, <span class="marker" id="mapping-664"></span><span class="token mv" id="move-dst-136" data-title="call_expression/call_argument"><span class="marker" id="mapping-665"></span><span class="token upd" id="move-dst-137" data-title="call_argument/identifier">spender</span></span>, <span class="marker" id="mapping-666"></span><span class="token mv" id="move-dst-138" data-title="call_expression/call_argument"><span class="marker" id="mapping-667"></span><span class="token upd" id="move-dst-139" data-title="call_argument/identifier">amount</span></span>);
        return true;
    }</span>

    <span class="marker" id="mapping-668"></span><span class="token add" data-title="contract_body/comment">/**
     * @dev See {IERC20-transferFrom}.
     *
     * Emits an {Approval} event indicating the updated allowance. This is not
     * required by the EIP. See the note at the beginning of {ERC20};
     *
     * Requirements:
     * - `sender` and `recipient` cannot be the zero address.
     * - `sender` must have a balance of at least `amount`.
     * - the caller must have allowance for ``sender``'s tokens of at least
     * `amount`.
     */</span>
    <span class="marker" id="mapping-669"></span><span class="token add" data-title="contract_body/function_definition">function transferFrom(<span class="marker" id="mapping-670"></span><span class="token mv" id="move-dst-109" data-title="function_definition/parameter">address <span class="marker" id="mapping-671"></span><span class="token upd" id="move-dst-110" data-title="parameter/identifier">sender</span></span>, <span class="marker" id="mapping-672"></span><span class="token mv" id="move-dst-100" data-title="function_definition/parameter">address <span class="marker" id="mapping-673"></span><span class="token upd" id="move-dst-101" data-title="parameter/identifier">reci<span class="cupd">p</span>i<span class="cupd">en</span>t</span></span>, <span class="marker" id="mapping-674"></span><span class="token add" data-title="function_definition/parameter">uint256 amount</span>) <span class="marker" id="mapping-675"></span><span class="token mv" id="move-dst-77" data-title="function_definition/visibility">public</span> virtual <span class="marker" id="mapping-676"></span><span class="token mv" id="move-dst-78" data-title="function_definition/return_type_definition">returns (bool)</span> <span class="marker" id="mapping-677"></span><span class="token add" data-title="function_definition/function_body">{
        <span class="marker" id="mapping-678"></span><span class="token add" data-title="function_body/expression_statement">_transfer(sender, recipient, amount);</span>
        <span class="marker" id="mapping-679"></span><span class="token add" data-title="function_body/expression_statement">_approve(sender, _msgSender(), allowance[sender][_msgSender()].sub(amount, "ERC20: transfer amount exceeds allowance"));</span>
        <span class="marker" id="mapping-680"></span><span class="token mv" id="move-dst-79" data-title="function_body/return_statement">return true;</span>
    }</span></span>

    <span class="marker" id="mapping-681"></span><span class="token add" data-title="contract_body/comment">/**
     * @dev Atomically increases the allowance granted to `spender` by the caller.
     *
     * This is an alternative to {approve} that can be used as a mitigation for
     * problems described in {IERC20-approve}.
     *
     * Emits an {Approval} event indicating the updated allowance.
     *
     * Requirements:
     *
     * - `spender` cannot be the zero address.
     */</span>
    <span class="marker" id="mapping-682"></span><span class="token mv" id="move-dst-62" data-title="contract_body/function_definition">function <span class="marker" id="mapping-683"></span><span class="token upd" id="move-dst-63" data-title="function_definition/identifier"><span class="cupd">increaseA</span>ll<span class="cupd">o</span>wance</span>(<span class="marker" id="mapping-684"></span><span class="token mv" id="move-dst-92" data-title="function_definition/parameter">address <span class="marker" id="mapping-685"></span><span class="token upd" id="move-dst-93" data-title="parameter/identifier">spender</span></span>, <span class="marker" id="mapping-686"></span><span class="token mv" id="move-dst-82" data-title="function_definition/parameter">uint256 <span class="marker" id="mapping-687"></span><span class="token upd" id="move-dst-83" data-title="parameter/identifier"><span class="cupd">a</span>dd<span class="cupd">edValue</span></span></span>) public <span class="marker" id="mapping-688"></span><span class="token add" data-title="function_definition/virtual">virtual</span> returns (bool) {
        <span class="marker" id="mapping-689"></span><span class="token upd" id="move-dst-66" data-title="call_expression/identifier"><span class="cupd">_</span><span class="cupd">a</span><span class="cupd">pprov</span>e</span>(<span class="marker" id="mapping-690"></span><span class="token add" data-title="call_expression/call_argument">_msgSender()</span>, <span class="marker" id="mapping-691"></span><span class="token mv" id="move-dst-67" data-title="call_expression/call_argument"><span class="marker" id="mapping-692"></span><span class="token upd" id="move-dst-68" data-title="call_argument/identifier"><span class="cupd">spender</span></span></span>, <span class="marker" id="mapping-693"></span><span class="token add" data-title="call_expression/call_argument">allowance[_msgSender()][spender].add(addedValue)</span>);
        return true;
    }</span>

    <span class="marker" id="mapping-694"></span><span class="token add" data-title="contract_body/comment">/**
     * @dev Atomically decreases the allowance granted to `spender` by the caller.
     *
     * This is an alternative to {approve} that can be used as a mitigation for
     * problems described in {IERC20-approve}.
     *
     * Emits an {Approval} event indicating the updated allowance.
     *
     * Requirements:
     *
     * - `spender` cannot be the zero address.
     * - `spender` must have allowance for the caller of at least
     * `subtractedValue`.
     */</span>
    <span class="marker" id="mapping-695"></span><span class="token mv" id="move-dst-53" data-title="contract_body/function_definition">function <span class="marker" id="mapping-696"></span><span class="token upd" id="move-dst-54" data-title="function_definition/identifier">decre<span class="cupd">a</span>seAll<span class="cupd">o</span>wance</span>(<span class="marker" id="mapping-697"></span><span class="token mv" id="move-dst-94" data-title="function_definition/parameter">address <span class="marker" id="mapping-698"></span><span class="token upd" id="move-dst-95" data-title="parameter/identifier"><span class="cupd">spender</span></span></span>, <span class="marker" id="mapping-699"></span><span class="token mv" id="move-dst-75" data-title="function_definition/parameter">uint256 <span class="marker" id="mapping-700"></span><span class="token upd" id="move-dst-76" data-title="parameter/identifier"><span class="cupd">subtractedValue</span></span></span>) public <span class="marker" id="mapping-701"></span><span class="token add" data-title="function_definition/virtual">virtual</span> returns (bool) {
        <span class="marker" id="mapping-702"></span><span class="token upd" id="move-dst-55" data-title="call_expression/identifier"><span class="cupd">_approve</span></span>(<span class="marker" id="mapping-703"></span><span class="token add" data-title="call_expression/call_argument">_msgSender()</span>, <span class="marker" id="mapping-704"></span><span class="token mv" id="move-dst-56" data-title="call_expression/call_argument"><span class="marker" id="mapping-705"></span><span class="token upd" id="move-dst-57" data-title="call_argument/identifier"><span class="cupd">spender</span></span></span>, <span class="marker" id="mapping-706"></span><span class="token add" data-title="call_expression/call_argument">allowance[_msgSender()][spender].sub(subtractedValue, "ERC20: decreased allowance below zero")</span>);
        return true;
    }</span>

    <span class="marker" id="mapping-707"></span><span class="token add" data-title="contract_body/comment">/**
     * @dev Moves tokens `amount` from `sender` to `recipient`.
     *
     * This is internal function is equivalent to {transfer}, and can be used to
     * e.g. implement automatic token fees, slashing mechanisms, etc.
     *
     * Emits a {Transfer} event.
     *
     * Requirements:
     *
     * - `sender` cannot be the zero address.
     * - `recipient` cannot be the zero address.
     * - `sender` must have a balance of at least `amount`.
     */</span>
    <span class="marker" id="mapping-708"></span><span class="token add" data-title="contract_body/function_definition">function _transfer(<span class="marker" id="mapping-709"></span><span class="token mv" id="move-dst-86" data-title="function_definition/parameter">address <span class="marker" id="mapping-710"></span><span class="token upd" id="move-dst-87" data-title="parameter/identifier">sender</span></span>, <span class="marker" id="mapping-711"></span><span class="token mv" id="move-dst-195" data-title="function_definition/parameter">address <span class="marker" id="mapping-712"></span><span class="token upd" id="move-dst-196" data-title="parameter/identifier">reci<span class="cupd">p</span>i<span class="cupd">en</span>t</span></span>, <span class="marker" id="mapping-713"></span><span class="token add" data-title="function_definition/parameter">uint256 amount</span>) <span class="marker" id="mapping-714"></span><span class="token mv" id="move-dst-39" data-title="function_definition/visibility">internal</span> virtual <span class="marker" id="mapping-715"></span><span class="token add" data-title="function_definition/function_body">{
        <span class="marker" id="mapping-716"></span><span class="token mv" id="move-dst-96" data-title="function_body/expression_statement"><span class="marker" id="mapping-717"></span><span class="token mv" id="move-dst-97" data-title="expression_statement/call_expression"><span class="marker" id="mapping-718"></span><span class="token add" data-title="call_expression/identifier">require</span>(<span class="marker" id="mapping-719"></span><span class="token add" data-title="call_argument/binary_expression">sender != address(0)</span>, "ERC20: transfer from the zero address")</span>;</span>
        <span class="marker" id="mapping-720"></span><span class="token mv" id="move-dst-40" data-title="function_body/expression_statement"><span class="marker" id="mapping-721"></span><span class="token mv" id="move-dst-41" data-title="expression_statement/call_expression"><span class="marker" id="mapping-722"></span><span class="token add" data-title="call_expression/identifier">require</span>(<span class="marker" id="mapping-723"></span><span class="token add" data-title="call_argument/binary_expression">recipient != address(0)</span>, "ERC20: transfer to the zero address")</span>;</span>

        <span class="marker" id="mapping-724"></span><span class="token add" data-title="function_body/expression_statement">_beforeTokenTransfer(sender, recipient, amount);</span>

        <span class="marker" id="mapping-725"></span><span class="token add" data-title="function_body/expression_statement"><span class="marker" id="mapping-726"></span><span class="token add" data-title="expression_statement/assignment_expression"><span class="marker" id="mapping-727"></span><span class="token add" data-title="assignment_expression/array_access">balanceOf[sender]</span> = <span class="marker" id="mapping-728"></span><span class="token add" data-title="assignment_expression/call_expression"><span class="marker" id="mapping-729"></span><span class="token add" data-title="call_expression/member_expression">balanceOf[sender].sub</span>(<span class="marker" id="mapping-730"></span><span class="token add" data-title="call_expression/call_argument">amount</span>, <span class="marker" id="mapping-731"></span><span class="token mv" id="move-dst-175" data-title="call_expression/call_argument">"ERC20: transfer amount exceeds balance"</span>)</span></span>;</span>
        <span class="marker" id="mapping-732"></span><span class="token add" data-title="function_body/expression_statement">balanceOf[recipient] = balanceOf[recipient].add(amount);</span>
        <span class="marker" id="mapping-733"></span><span class="token add" data-title="function_body/emit_statement">emit Transfer(sender, recipient, amount);</span>
    }</span></span>

    <span class="marker" id="mapping-734"></span><span class="token add" data-title="contract_body/comment">/** @dev Creates `amount` tokens and assigns them to `account`, increasing
     * the total supply.
     *
     * Emits a {Transfer} event with `from` set to the zero address.
     *
     * Requirements
     *
     * - `to` cannot be the zero address.
     */</span>
    <span class="marker" id="mapping-735"></span><span class="token mv" id="move-dst-162" data-title="contract_body/function_definition">function _mint(address <span class="marker" id="mapping-736"></span><span class="token upd" id="move-dst-163" data-title="parameter/identifier">account</span>, uint256 <span class="marker" id="mapping-737"></span><span class="token upd" id="move-dst-164" data-title="parameter/identifier"><span class="cupd">a</span>mount</span>) internal virtual {
        <span class="marker" id="mapping-738"></span><span class="token add" data-title="function_body/expression_statement"><span class="marker" id="mapping-739"></span><span class="token add" data-title="expression_statement/call_expression">require(<span class="marker" id="mapping-740"></span><span class="token add" data-title="call_expression/call_argument">account != address(0)</span>, <span class="marker" id="mapping-741"></span><span class="token mv" id="move-dst-205" data-title="call_expression/call_argument">"ERC20: mint to the zero address"</span>)</span>;</span>

        <span class="marker" id="mapping-742"></span><span class="token add" data-title="function_body/expression_statement">_beforeTokenTransfer(address(0), account, amount);</span>

        totalSupply = totalSupply.add(<span class="marker" id="mapping-743"></span><span class="token upd" id="move-dst-174" data-title="call_argument/identifier"><span class="cupd">a</span>mount</span>);
        <span class="marker" id="mapping-744"></span><span class="token add" data-title="function_body/expression_statement">balanceOf[account] = balanceOf[account].add(amount);</span>
        <span class="marker" id="mapping-745"></span><span class="token mv" id="move-dst-165" data-title="function_body/emit_statement">emit Transfer(address(0), <span class="marker" id="mapping-746"></span><span class="token upd" id="move-dst-166" data-title="call_argument/identifier">account</span>, <span class="marker" id="mapping-747"></span><span class="token upd" id="move-dst-167" data-title="call_argument/identifier"><span class="cupd">a</span>mount</span>);</span>
    }</span>

    <span class="marker" id="mapping-748"></span><span class="token add" data-title="contract_body/comment">/**
     * @dev Destroys `amount` tokens from `account`, reducing the
     * total supply.
     *
     * Emits a {Transfer} event with `to` set to the zero address.
     *
     * Requirements
     *
     * - `account` cannot be the zero address.
     * - `account` must have at least `amount` tokens.
     */</span>
    <span class="marker" id="mapping-749"></span><span class="token mv" id="move-dst-153" data-title="contract_body/function_definition">function _burn(address <span class="marker" id="mapping-750"></span><span class="token upd" id="move-dst-154" data-title="parameter/identifier">account</span>, uint256 <span class="marker" id="mapping-751"></span><span class="token upd" id="move-dst-155" data-title="parameter/identifier"><span class="cupd">a</span>mount</span>) internal virtual {
        <span class="marker" id="mapping-752"></span><span class="token mv" id="move-dst-90" data-title="function_body/expression_statement"><span class="marker" id="mapping-753"></span><span class="token mv" id="move-dst-91" data-title="expression_statement/call_expression"><span class="marker" id="mapping-754"></span><span class="token add" data-title="call_expression/identifier">require</span>(<span class="marker" id="mapping-755"></span><span class="token add" data-title="call_argument/binary_expression">account != address(0)</span>, "ERC20: burn from the zero address")</span>;</span>

        <span class="marker" id="mapping-756"></span><span class="token add" data-title="function_body/expression_statement">_beforeTokenTransfer(account, address(0), amount);</span>

        <span class="marker" id="mapping-757"></span><span class="token add" data-title="function_body/expression_statement"><span class="marker" id="mapping-758"></span><span class="token add" data-title="expression_statement/assignment_expression"><span class="marker" id="mapping-759"></span><span class="token add" data-title="assignment_expression/array_access">balanceOf[account]</span> = <span class="marker" id="mapping-760"></span><span class="token add" data-title="assignment_expression/call_expression"><span class="marker" id="mapping-761"></span><span class="token add" data-title="call_expression/member_expression">balanceOf[account].sub</span>(<span class="marker" id="mapping-762"></span><span class="token add" data-title="call_expression/call_argument">amount</span>, <span class="marker" id="mapping-763"></span><span class="token mv" id="move-dst-161" data-title="call_expression/call_argument">"ERC20: burn amount exceeds balance"</span>)</span></span>;</span>
        <span class="marker" id="mapping-764"></span><span class="token upd" id="move-dst-159" data-title="assignment_expression/identifier">tota<span class="cupd">l</span><span class="cupd">Supply</span></span> = totalSupply.sub(<span class="marker" id="mapping-765"></span><span class="token upd" id="move-dst-160" data-title="call_argument/identifier"><span class="cupd">a</span>mount</span>);
        <span class="marker" id="mapping-766"></span><span class="token mv" id="move-dst-156" data-title="function_body/emit_statement">emit Transfer(<span class="marker" id="mapping-767"></span><span class="token upd" id="move-dst-157" data-title="call_argument/identifier">account</span>, address(0), <span class="marker" id="mapping-768"></span><span class="token upd" id="move-dst-158" data-title="call_argument/identifier"><span class="cupd">a</span>mount</span>);</span>
    }</span>

    <span class="marker" id="mapping-769"></span><span class="token add" data-title="contract_body/comment">/**
     * @dev Sets `amount` as the allowance of `spender` over the `owner`s tokens.
     *
     * This is internal function is equivalent to `approve`, and can be used to
     * e.g. set automatic allowances for certain subsystems, etc.
     *
     * Emits an {Approval} event.
     *
     * Requirements:
     *
     * - `owner` cannot be the zero address.
     * - `spender` cannot be the zero address.
     */</span>
    <span class="marker" id="mapping-770"></span><span class="token add" data-title="contract_body/function_definition">function _approve(<span class="marker" id="mapping-771"></span><span class="token mv" id="move-dst-80" data-title="function_definition/parameter">address <span class="marker" id="mapping-772"></span><span class="token upd" id="move-dst-81" data-title="parameter/identifier">ow<span class="cupd">n</span><span class="cupd">er</span></span></span>, <span class="marker" id="mapping-773"></span><span class="token mv" id="move-dst-88" data-title="function_definition/parameter">address <span class="marker" id="mapping-774"></span><span class="token upd" id="move-dst-89" data-title="parameter/identifier"><span class="cupd">spender</span></span></span>, <span class="marker" id="mapping-775"></span><span class="token add" data-title="function_definition/parameter">uint256 amount</span>) <span class="marker" id="mapping-776"></span><span class="token mv" id="move-dst-42" data-title="function_definition/visibility">internal</span> virtual <span class="marker" id="mapping-777"></span><span class="token mv" id="move-dst-124" data-title="function_definition/function_body">{
        <span class="marker" id="mapping-778"></span><span class="token mv" id="move-dst-43" data-title="function_body/expression_statement"><span class="marker" id="mapping-779"></span><span class="token mv" id="move-dst-44" data-title="expression_statement/call_expression"><span class="marker" id="mapping-780"></span><span class="token add" data-title="call_expression/identifier">require</span>(<span class="marker" id="mapping-781"></span><span class="token add" data-title="call_argument/binary_expression">owner != address(0)</span>, "ERC20: approve from the zero address")</span>;</span>
        <span class="marker" id="mapping-782"></span><span class="token mv" id="move-dst-127" data-title="function_body/expression_statement">require(<span class="marker" id="mapping-783"></span><span class="token mv" id="move-dst-125" data-title="call_argument/binary_expression"><span class="marker" id="mapping-784"></span><span class="token upd" id="move-dst-126" data-title="binary_expression/identifier">spender</span> != address(0)</span>, "ERC20: approve to the zero address");</span>

        <span class="marker" id="mapping-785"></span><span class="token add" data-title="expression_statement/assignment_expression">allowance[owner][spender] = amount</span>;
        <span class="marker" id="mapping-786"></span><span class="token add" data-title="function_body/emit_statement">emit Approval(owner, spender, amount);</span>
    }</span></span>

    <span class="marker" id="mapping-787"></span><span class="token add" data-title="contract_body/comment">/**
     * @dev Hook that is called before any transfer of tokens. This includes
     * minting and burning.
     *
     * Calling conditions:
     *
     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens
     * will be to transferred to `to`.
     * - when `from` is zero, `amount` tokens will be minted for `to`.
     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.
     * - `from` and `to` are never both zero.
     *
     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].
     */</span>
    <span class="marker" id="mapping-788"></span><span class="token add" data-title="contract_body/comment">// solhint-disable-next-line no-empty-blocks</span>
    <span class="marker" id="mapping-789"></span><span class="token add" data-title="contract_body/function_definition">function _beforeTokenTransfer(<span class="marker" id="mapping-790"></span><span class="token mv" id="move-dst-115" data-title="function_definition/parameter">address from</span>, <span class="marker" id="mapping-791"></span><span class="token mv" id="move-dst-122" data-title="function_definition/parameter">address to</span>, <span class="marker" id="mapping-792"></span><span class="token add" data-title="function_definition/parameter">uint256 amount</span>) <span class="marker" id="mapping-793"></span><span class="token mv" id="move-dst-120" data-title="function_definition/visibility">internal</span> virtual <span class="marker" id="mapping-794"></span><span class="token add" data-title="function_definition/function_body">{ }</span></span>
}</span>

<span class="marker" id="mapping-795"></span><span class="token mv" id="move-dst-114" data-title="source_file/pragma_directive">pragma solidity 0.6.10;</span>

/**
 * @title TimeLockedToken
 * @notice Time Locked ERC20 Token
 * @author Harold Hyatt
 * @dev Contract which gives the ability to time-lock tokens
 *
 * The registerLockup() function allows an account to transfer
 * its tokens to another account, locking them according to the
 * distribution epoch periods
 *
 * By overriding the balanceOf(), transfer(), and transferFrom()
 * functions in ERC20, an account can show its full, post-distribution
 * balance but only transfer or spend up to an allowed amount
 *
 * Every time an epoch passes, a portion of previously non-spendable tokens
 * are allowed to be transferred, and after all epochs have passed, the full
 * account balance is unlocked
 */
abstract contract TimeLockedToken is <span class="marker" id="mapping-796"></span><span class="token upd" id="move-dst-183" data-title="user_defined_type/identifier">ERC20</span>, ClaimableContract {
    using SafeMath for uint256;

    // represents total distribution for locked balances
    mapping(address =&gt; uint256) distribution;

    // start of the lockup period
    // Friday, July 24, 2020 4:58:31 PM GMT
    uint256 constant LOCK_START = 1595609911;
    // length of time to delay first epoch
    uint256 constant FIRST_EPOCH_DELAY = 30 days;
    // how long does an epoch last
    uint256 constant EPOCH_DURATION = 90 days;
    // number of epochs
    uint256 constant TOTAL_EPOCHS = 8;
    // registry of locked addresses
    address public timeLockRegistry;
    <span class="marker" id="mapping-797"></span><span class="token mv" id="move-dst-185" data-title="contract_body/comment"><span class="marker" id="mapping-798"></span><span class="token upd" id="move-dst-185" data-title="contract_body/comment"><span class="cupd">/</span>/<span class="cupd"> </span><span class="cupd">a</span>ll<span class="cupd">o</span><span class="cupd">w</span><span class="cupd"> </span><span class="cupd">u</span><span class="cupd">nlocked t</span>ra<span class="cupd">ns</span><span class="cupd">f</span><span class="cupd">e</span><span class="cupd">r</span><span class="cupd">s</span><span class="cupd"> to s</span><span class="cupd">p</span><span class="cupd">e</span><span class="cupd">c</span><span class="cupd">i</span><span class="cupd">a</span><span class="cupd">l</span><span class="cupd"> </span><span class="cupd">a</span>cc<span class="cupd">ount</span></span></span>
    <span class="marker" id="mapping-799"></span><span class="token add" data-title="contract_body/state_variable_declaration"><span class="marker" id="mapping-800"></span><span class="token mv" id="move-dst-123" data-title="state_variable_declaration/type_name">bool</span> <span class="marker" id="mapping-801"></span><span class="token add" data-title="state_variable_declaration/visibility">public</span> returnsLocked;</span>

    modifier onlyTimeLockRegistry() {
        require(msg.sender == timeLockRegistry, "only TimeLockRegistry");
        _;
    }

    /**
     * @dev Set TimeLockRegistry address
     * @param newTimeLockRegistry Address of TimeLockRegistry contract
     */
    function setTimeLockRegistry(address newTimeLockRegistry) external onlyOwner {
        require(newTimeLockRegistry != address(0), "cannot be zero address");
        require(newTimeLockRegistry != timeLockRegistry, "must be new TimeLockRegistry");
        timeLockRegistry = newTimeLockRegistry;
    }

    <span class="marker" id="mapping-802"></span><span class="token upd" id="move-dst-193" data-title="contract_body/comment"><span class="cupd">/**
     * @dev</span> P<span class="cupd">e</span>r<span class="cupd">ma</span><span class="cupd">n</span><span class="cupd">e</span><span class="cupd">n</span><span class="cupd">t</span>l<span class="cupd">y</span><span class="cupd"> loc</span><span class="cupd">k </span>tr<span class="cupd">an</span>sf<span class="cupd">e</span>r<span class="cupd">s</span> <span class="cupd">t</span><span class="cupd">o</span> <span class="cupd">r</span>etur<span class="cupd">n address</span><span class="cupd"></span><span class="cupd">
</span><span class="cupd"> </span><span class="cupd">  </span><span class="cupd">  </span>*<span class="cupd"> </span>Lo<span class="cupd">c</span>k<span class="cupd"> </span>re<span class="cupd">t</span>u<span class="cupd">r</span>n<span class="cupd">s</span> <span class="cupd">so </span>t<span class="cupd">he</span>r<span class="cupd">e</span> is<span class="cupd">n</span><span class="cupd">'</span><span class="cupd">t</span> a<span class="cupd">l</span>wa<span class="cupd">y</span><span class="cupd">s</span><span class="cupd"> </span>a<span class="cupd"> </span>w<span class="cupd">a</span><span class="cupd">y </span><span class="cupd">t</span><span class="cupd">o</span><span class="cupd"> </span><span class="cupd">se</span><span class="cupd">n</span><span class="cupd">d</span><span class="cupd"> </span>lo<span class="cupd">cked </span><span class="cupd">to</span><span class="cupd">ke</span><span class="cupd">ns
    </span> */</span>
    <span class="marker" id="mapping-803"></span><span class="token add" data-title="contract_body/function_definition">function lockReturns() <span class="marker" id="mapping-804"></span><span class="token mv" id="move-dst-134" data-title="function_definition/visibility">external</span> <span class="marker" id="mapping-805"></span><span class="token add" data-title="function_definition/modifier_invocation">onlyOwner</span> <span class="marker" id="mapping-806"></span><span class="token add" data-title="function_definition/function_body">{
        returnsLocked = true;
    }</span></span>

    <span class="marker" id="mapping-807"></span><span class="token mv" id="move-dst-201" data-title="contract_body/comment"><span class="marker" id="mapping-808"></span><span class="token upd" id="move-dst-201" data-title="contract_body/comment"><span class="cupd">/**
     * @dev Transfer</span> fun<span class="cupd">c</span>t<span class="cupd">i</span><span class="cupd">o</span><span class="cupd">n</span> whic<span class="cupd">h</span> <span class="cupd">i</span><span class="cupd">n</span>c<span class="cupd">l</span>ude<span class="cupd">s u</span><span class="cupd">nloc</span><span class="cupd">ke</span>d to<span class="cupd">k</span>en<span class="cupd">s
     </span>* Locke<span class="cupd">d</span> tok<span class="cupd">en</span>s<span class="cupd"> </span>c<span class="cupd">a</span><span class="cupd">n</span> alw<span class="cupd">a</span><span class="cupd">y</span>s<span class="cupd"> </span><span class="cupd">b</span><span class="cupd">e transf</span>er<span class="cupd">e</span>d bac<span class="cupd">k to the </span>ret<span class="cupd">u</span>r<span class="cupd">n</span>s addre<span class="cupd">ss
 </span> <span class="cupd">  </span> * <span class="cupd">T</span>ra<span class="cupd">n</span><span class="cupd">s</span>fer<span class="cupd">r</span>i<span class="cupd">n</span>g<span class="cupd"> </span>to<span class="cupd"> </span>ow<span class="cupd">n</span><span class="cupd">er </span>all<span class="cupd">o</span>ws <span class="cupd">re</span>-issua<span class="cupd">n</span>c<span class="cupd">e</span> o<span class="cupd">f </span>fun<span class="cupd">d</span>s <span class="cupd">t</span>hro<span class="cupd">u</span>gh regis<span class="cupd">try
</span> <span class="cupd">  </span><span class="cupd"> </span> *
     <span class="cupd">*</span> @par<span class="cupd">a</span>m <span class="cupd">_</span>f<span class="cupd">rom</span> <span class="cupd">T</span>he <span class="cupd">a</span>dd<span class="cupd">r</span><span class="cupd">e</span>ss <span class="cupd">t</span>o<span class="cupd"> </span>s<span class="cupd">e</span>n<span class="cupd">d</span> t<span class="cupd">o</span>k<span class="cupd">e</span>ns<span class="cupd"> </span><span class="cupd">from</span><span class="cupd">
     * @</span>param <span class="cupd">_</span><span class="cupd">t</span>o<span class="cupd"> The add</span>res<span class="cupd">s</span> that<span class="cupd"> will receive the tokens
     * </span>@p<span class="cupd">a</span>ram _valu<span class="cupd">e The </span><span class="cupd">a</span>moun<span class="cupd">t of tokens to be transferred</span>
     */</span></span>
    function <span class="marker" id="mapping-809"></span><span class="token upd" id="move-dst-194" data-title="function_definition/identifier"><span class="cupd">_transfer</span></span>(
        address _from,
        address _to,
        uint256 _value
    ) internal override {
        require(balanceOf[_from] &gt;= _value, "insufficient balance");

        <span class="marker" id="mapping-810"></span><span class="token add" data-title="function_body/comment">// transfers to owner proceed as normal when returns allowed</span>
        <span class="marker" id="mapping-811"></span><span class="token add" data-title="function_body/if_statement">if (<span class="marker" id="mapping-812"></span><span class="token add" data-title="if_statement/binary_expression">!returnsLocked &amp;&amp; _to == owner_</span>) <span class="marker" id="mapping-813"></span><span class="token add" data-title="if_statement/block_statement">{
            <span class="marker" id="mapping-814"></span><span class="token add" data-title="block_statement/expression_statement"><span class="marker" id="mapping-815"></span><span class="token add" data-title="expression_statement/call_expression">transferToOwner(<span class="marker" id="mapping-816"></span><span class="token mv" id="move-dst-151" data-title="call_expression/call_argument">_from</span>, <span class="marker" id="mapping-817"></span><span class="token mv" id="move-dst-178" data-title="call_expression/call_argument">_value</span>)</span>;</span>
            <span class="marker" id="mapping-818"></span><span class="token add" data-title="block_statement/return_statement">return;</span>
        }</span></span>
        <span class="marker" id="mapping-819"></span><span class="token add" data-title="function_body/comment">// check if enough unlocked balance to transfer</span>
        require(unlockedBalance(_from) &gt;= _value, "attempting to transfer locked funds");
        super.<span class="marker" id="mapping-820"></span><span class="token upd" id="move-dst-197" data-title="member_expression/identifier"><span class="cupd">_transfer</span></span>(_from, _to, _value);
    }

    <span class="marker" id="mapping-821"></span><span class="token add" data-title="contract_body/comment">/**
     * @dev Transfer tokens to owner. Used only when returns allowed.
     * @param _from The address to send tokens from
     * @param _value The amount of tokens to be transferred
     */</span>
    <span class="marker" id="mapping-822"></span><span class="token mv" id="move-dst-186" data-title="contract_body/function_definition">function <span class="marker" id="mapping-823"></span><span class="token upd" id="move-dst-187" data-title="function_definition/identifier"><span class="cupd">transfer</span>ToOwner</span>(address _from, uint256 _value) internal <span class="marker" id="mapping-824"></span><span class="token add" data-title="function_definition/function_body">{
        <span class="marker" id="mapping-825"></span><span class="token mv" id="move-dst-212" data-title="function_body/variable_declaration_statement">uint256 <span class="marker" id="mapping-826"></span><span class="token upd" id="move-dst-213" data-title="variable_declaration/identifier">unl<span class="cupd">oc</span>ked</span> = <span class="marker" id="mapping-827"></span><span class="token add" data-title="variable_declaration_statement/call_expression">unlockedBalance(<span class="marker" id="mapping-828"></span><span class="token mv" id="move-dst-148" data-title="call_expression/call_argument">_from</span>)</span>;</span>

        <span class="marker" id="mapping-829"></span><span class="token add" data-title="function_body/if_statement">if (<span class="marker" id="mapping-830"></span><span class="token add" data-title="if_statement/binary_expression">unlocked &lt; _value</span>) <span class="marker" id="mapping-831"></span><span class="token add" data-title="if_statement/block_statement">{
            // We want to have unlocked = value, i.e.
            // value = balance - distribution * epochsLeft / totalEpochs
            // distribution = (balance - value) * totalEpochs / epochsLeft
            <span class="marker" id="mapping-832"></span><span class="token add" data-title="block_statement/expression_statement"><span class="marker" id="mapping-833"></span><span class="token add" data-title="expression_statement/assignment_expression"><span class="marker" id="mapping-834"></span><span class="token add" data-title="assignment_expression/array_access">distribution[_from]</span> = <span class="marker" id="mapping-835"></span><span class="token add" data-title="assignment_expression/call_expression"><span class="marker" id="mapping-836"></span><span class="token add" data-title="call_expression/member_expression"><span class="marker" id="mapping-837"></span><span class="token add" data-title="member_expression/call_expression"><span class="marker" id="mapping-838"></span><span class="token add" data-title="call_expression/member_expression"><span class="marker" id="mapping-839"></span><span class="token add" data-title="member_expression/call_expression"><span class="marker" id="mapping-840"></span><span class="token add" data-title="call_expression/member_expression">balanceOf[_from].sub</span>(<span class="marker" id="mapping-841"></span><span class="token mv" id="move-dst-152" data-title="call_expression/call_argument">_value</span>)</span>.mul</span>(<span class="marker" id="mapping-842"></span><span class="token add" data-title="call_expression/call_argument">TOTAL_EPOCHS</span>)</span>.div</span>(<span class="marker" id="mapping-843"></span><span class="token add" data-title="call_expression/call_argument">epochsLeft()</span>)</span></span>;</span>
        }</span></span>
        <span class="marker" id="mapping-844"></span><span class="token mv" id="move-dst-190" data-title="function_body/expression_statement">super.<span class="marker" id="mapping-845"></span><span class="token upd" id="move-dst-191" data-title="member_expression/identifier"><span class="cupd">_transfer</span></span>(_from, <span class="marker" id="mapping-846"></span><span class="token upd" id="move-dst-192" data-title="call_argument/identifier">owner_</span>, _value);</span>
    }</span></span>

    /**
     * @dev Check if amount we want to burn is unlocked before burning
     * @param _from The address whose tokens will burn
     * @param _value The amount of tokens to be burnt
     */
    function _burn(address _from, uint256 _value) internal override <span class="marker" id="mapping-847"></span><span class="token mv" id="move-dst-189" data-title="function_definition/function_body">{
        require(balanceOf[_from] &gt;= _value, "insufficient balance");
        <span class="marker" id="mapping-848"></span><span class="token mv" id="move-dst-198" data-title="function_body/expression_statement">require(unlockedBalance(_from) &gt;= _value, "attempting to burn locked funds");</span>

        <span class="marker" id="mapping-849"></span><span class="token mv" id="move-dst-199" data-title="expression_statement/call_expression">super._burn(_from, _value)</span>;
    }</span>

    <span class="marker" id="mapping-850"></span><span class="token add" data-title="contract_body/comment">/**
     * @dev Transfer tokens to another account under the lockup schedule
     * Emits a transfer event showing a transfer to the recipient
     * Only the registry can call this function
     * @param receiver Address to receive the tokens
     * @param amount Tokens to be transferred
     */</span>
    function registerLockup(address receiver, uint256 amount) external onlyTimeLockRegistry {
        require(balanceOf[msg.sender] &gt;= amount, "insufficient balance");

        <span class="marker" id="mapping-851"></span><span class="token upd" id="move-dst-206" data-title="function_body/comment"><span class="cupd">// </span>add amoun<span class="cupd">t </span>to locke<span class="cupd">d</span> d<span class="cupd">istribution</span></span>
        <span class="marker" id="mapping-852"></span><span class="token mv" id="move-dst-202" data-title="function_body/expression_statement"><span class="marker" id="mapping-853"></span><span class="token mv" id="move-dst-207" data-title="expression_statement/assignment_expression">distribution[receiver] = <span class="marker" id="mapping-854"></span><span class="token mv" id="move-dst-203" data-title="assignment_expression/call_expression"><span class="marker" id="mapping-855"></span><span class="token add" data-title="call_expression/member_expression"><span class="marker" id="mapping-856"></span><span class="token mv" id="move-dst-204" data-title="member_expression/array_access">distribution[receiver]</span>.add</span>(<span class="marker" id="mapping-857"></span><span class="token add" data-title="call_argument/identifier">amount</span>)</span></span>;</span>

        // transfer to recipient
        <span class="marker" id="mapping-858"></span><span class="token upd" id="move-dst-208" data-title="call_expression/identifier"><span class="cupd">_transfer</span></span>(msg.sender, receiver, amount);
    }

    /**
     * @dev Get locked balance for an account
     * @param account Account to check
     * @return Amount locked
     */
    function lockedBalance(address account) <span class="marker" id="mapping-859"></span><span class="token add" data-title="function_definition/visibility">public</span> <span class="marker" id="mapping-860"></span><span class="token mv" id="move-dst-106" data-title="function_definition/state_mutability">view</span> <span class="marker" id="mapping-861"></span><span class="token add" data-title="function_definition/return_type_definition">returns (uint256)</span> {
        // distribution * (epochsLeft / totalEpochs)
        return distribution[account].mul(<span class="marker" id="mapping-862"></span><span class="token add" data-title="call_argument/call_expression">epochsLeft()</span>).div(TOTAL_EPOCHS);
    }

    /**
     * @dev Get unlocked balance for an account
     * @param account Account to check
     * @return Amount that is unlocked and available eg. to transfer
     */
    function unlockedBalance(address account) public view returns (uint256) {
        // totalBalance - lockedBalance
        return balanceOf[account].sub(lockedBalance(account));
    }

    /*
     * @dev Get number of epochs passed
     * @return Value between 0 and 8 of lockup epochs already passed
     */
    function epochsPassed() public view returns (uint256) {
        // return 0 if timestamp is lower than start time
        if (block.timestamp &lt; LOCK_START) {
            return 0;
        }

        // how long it has been since the beginning of lockup period
        uint256 timePassed = block.timestamp.sub(LOCK_START);

        // 1st epoch is FIRST_EPOCH_DELAY longer; we check to prevent subtraction underflow
        if (timePassed &lt; FIRST_EPOCH_DELAY) {
            return 0;
        }

        // subtract the FIRST_EPOCH_DELAY, so that we can count all epochs as lasting EPOCH_DURATION
        uint256 totalEpochsPassed = timePassed.sub(FIRST_EPOCH_DELAY).div(EPOCH_DURATION);

        // epochs don't count over TOTAL_EPOCHS
        if (totalEpochsPassed &gt; TOTAL_EPOCHS) {
            return TOTAL_EPOCHS;
        }

        return totalEpochsPassed;
    }

    <span class="marker" id="mapping-863"></span><span class="token add" data-title="contract_body/function_definition">function epochsLeft() <span class="marker" id="mapping-864"></span><span class="token mv" id="move-dst-209" data-title="function_definition/visibility">public</span> <span class="marker" id="mapping-865"></span><span class="token mv" id="move-dst-210" data-title="function_definition/state_mutability">view</span> <span class="marker" id="mapping-866"></span><span class="token mv" id="move-dst-211" data-title="function_definition/return_type_definition">returns (uint256)</span> <span class="marker" id="mapping-867"></span><span class="token add" data-title="function_definition/function_body">{
        <span class="marker" id="mapping-868"></span><span class="token add" data-title="function_body/return_statement">return <span class="marker" id="mapping-869"></span><span class="token mv" id="move-dst-214" data-title="return_statement/call_expression">TOTAL_EPOCHS.sub(epochsPassed())</span>;</span>
    }</span></span>

    /**
     * @dev Get timestamp of next epoch
     * Will revert if all epochs have passed
     * @return Timestamp of when the next epoch starts
     */
    function nextEpoch() public view returns (uint256) {
        // get number of epochs passed
        uint256 passed = epochsPassed();

        // if all epochs passed, return
        if (passed == TOTAL_EPOCHS) {
            // return INT_MAX
            return uint256(-1);
        }

        // if no epochs passed, return latest epoch + delay + standard duration
        if (passed == 0) {
            return latestEpoch().add(FIRST_EPOCH_DELAY).add(EPOCH_DURATION);
        }

        // otherwise return latest epoch + epoch duration
        return latestEpoch().add(EPOCH_DURATION);
    }

    /**
     * @dev Get timestamp of latest epoch
     * @return Timestamp of when the current epoch has started
     */
    function latestEpoch() public view returns (uint256) {
        // get number of epochs passed
        uint256 passed = epochsPassed();

        // if no epochs passed, return lock start time
        if (passed == 0) {
            return LOCK_START;
        }

        // accounts for first epoch being longer
        // lockStart + firstEpochDelay + (epochsPassed * epochDuration)
        return LOCK_START.add(FIRST_EPOCH_DELAY).add(passed.mul(EPOCH_DURATION));
    }

    /**
     * @dev Get timestamp of final epoch
     * @return Timestamp of when the last epoch ends and all funds are released
     */
    function finalEpoch() public pure returns (uint256) {
        // lockStart + firstEpochDelay + (epochDuration * totalEpochs)
        return LOCK_START.add(FIRST_EPOCH_DELAY).add(EPOCH_DURATION.mul(TOTAL_EPOCHS));
    }

    /**
     * @dev Get timestamp of locking period start
     * @return Timestamp of locking period start
     */
    function lockStart() public pure returns (uint256) {
        return LOCK_START;
    }
}

<span class="marker" id="mapping-870"></span><span class="token mv" id="move-dst-103" data-title="source_file/pragma_directive">pragma solidity 0.6.10;</span>

/**
 * @title TrustToken
 * @dev The TrustToken contract is a claimable contract where the
 * owner can only mint or transfer ownership. TrustTokens use 8 decimals
 * in order to prevent rewards from getting stuck in the remainder on division.
 * Tolerates dilution to slash stake and accept rewards.
 */
contract TrustToken is TimeLockedToken {
    using SafeMath for uint256;

    uint256 constant MAX_SUPPLY = 145000000000000000;

    /**
     * @dev initialize trusttoken and give ownership to sender
     * This is necessary to set ownership for proxy
     */
    function initialize() public {
        require(!initalized, "already initialized");
        owner_ = msg.sender;
        initalized = true;
    }

    /**
     * @dev mint TRU
     * Can never mint more than MAX_SUPPLY = 1.45 billion
     */
    function mint(address _to, uint256 _amount) external onlyOwner {
        if (totalSupply.add(_amount) &lt;= MAX_SUPPLY) {
            _mint(_to, _amount);
        } else {
            revert("Max supply exceeded");
        }
    }

    <span class="marker" id="mapping-871"></span><span class="token mv" id="move-dst-140" data-title="contract_body/function_definition">function <span class="marker" id="mapping-872"></span><span class="token upd" id="move-dst-141" data-title="function_definition/identifier">bu<span class="cupd">r</span>n</span>(uint256 <span class="marker" id="mapping-873"></span><span class="token upd" id="move-dst-142" data-title="parameter/identifier"><span class="cupd">a</span>mount</span>) external {
        <span class="marker" id="mapping-874"></span><span class="token upd" id="move-dst-144" data-title="call_expression/identifier"><span class="cupd">_</span>bu<span class="cupd">r</span>n</span>(msg.sender, <span class="marker" id="mapping-875"></span><span class="token upd" id="move-dst-145" data-title="call_argument/identifier">amount</span>);
    }</span>

    function decimals() public <span class="marker" id="mapping-876"></span><span class="token mv" id="move-dst-219" data-title="function_definition/override_specifier">override</span> pure returns (uint8) {
        return 8;
    }

    function rounding() public pure returns (uint8) {
        return 8;
    }

    <span class="marker" id="mapping-877"></span><span class="token add" data-title="contract_body/function_definition">function name() <span class="marker" id="mapping-878"></span><span class="token add" data-title="function_definition/visibility">public</span> <span class="marker" id="mapping-879"></span><span class="token add" data-title="function_definition/override_specifier">override</span> <span class="marker" id="mapping-880"></span><span class="token mv" id="move-dst-27" data-title="function_definition/state_mutability">pure</span> <span class="marker" id="mapping-881"></span><span class="token add" data-title="function_definition/return_type_definition">returns (string memory)</span> <span class="marker" id="mapping-882"></span><span class="token mv" id="move-dst-226" data-title="function_definition/function_body">{
        return "TrustToken";
    }</span></span>

    <span class="marker" id="mapping-883"></span><span class="token add" data-title="contract_body/function_definition">function symbol() <span class="marker" id="mapping-884"></span><span class="token add" data-title="function_definition/visibility">public</span> <span class="marker" id="mapping-885"></span><span class="token mv" id="move-dst-188" data-title="function_definition/override_specifier">override</span> <span class="marker" id="mapping-886"></span><span class="token mv" id="move-dst-23" data-title="function_definition/state_mutability">pure</span> <span class="marker" id="mapping-887"></span><span class="token add" data-title="function_definition/return_type_definition">returns (string memory)</span> <span class="marker" id="mapping-888"></span><span class="token mv" id="move-dst-223" data-title="function_definition/function_body">{
        return "TRU";
    }</span></span>
}</pre></div></div></div></body></html>