<html lang="en"><head><meta charset="utf8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>GumTree</title><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css"><style type="text/css">/*
 * This file is part of GumTree.
 *
 * GumTree is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * GumTree is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with GumTree.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Copyright 2011-2015 Jean-Rémy Falleri <jr.falleri@gmail.com>
 * Copyright 2011-2015 Floréal Morandat <florealm@gmail.com>
 */

.add {
	border: 1px solid black;
	background-color: MediumSeaGreen;
}

.del {
	border: 1px solid black;
	background-color: IndianRed;
}

.mv {
	border: 1px solid black;
	background-color: Plum;
}

.upd {
	border: 1px solid black;
	background-color: DarkOrange;
	font-weight: bold;
}

.cupd {
	font-weight: normal;
	color: DimGray;
}

.selected {
	background-color: Gold;
}

.marker {
	margin: 0;
	padding: 0;
}

div {
	margin: 0px;
	padding: 0px;
}

.pre-scrollable {
	margin: 0px;
	padding: 0px;
	font-size: 10pt;
	color: black;
	max-height: 90vh;
	background-color: white;
	border: 1px solid black;
	font-family: "Hack, Inconsolata", "Consolas", "Liberation Sans Regular", "DejaVu Sans Mono", monospace;
}

.tooltip-inner {
    max-width: none;
}
</style><script type="text/javascript" src="https://code.jquery.com/jquery-3.4.1.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/js/bootstrap.bundle.min.js"></script><script type="text/javascript">/*
 * This file is part of GumTree.
 *
 * GumTree is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * GumTree is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with GumTree.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Copyright 2011-2015 Jean-Rémy Falleri <jr.falleri@gmail.com>
 * Copyright 2011-2015 Floréal Morandat <florealm@gmail.com>
 */

$(function(){
    let popoverTriggerList = [].slice.call(document.querySelectorAll('[data-bs-toggle="popover"]'))
    let popoverList = popoverTriggerList.map(function (popoverTriggerEl) {
      return new bootstrap.Popover(popoverTriggerEl)
    })

    $("body").keypress(function (event) {
        switch (event.which) {
            case 116:
                $('html, body').animate({scrollTop: 0}, 100);
                break;
            case 98:
                $("html, body").animate({ scrollTop: $(document).height() }, 100);
                break;
            case 113:
                window.location = "/quit";
                break;
            case 108:
                window.location = "/list";
                break;
        }
    });
});
</script><script type="text/javascript">/*
 * This file is part of GumTree.
 *
 * GumTree is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * GumTree is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with GumTree.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Copyright 2011-2015 Jean-Rémy Falleri <jr.falleri@gmail.com>
 * Copyright 2011-2015 Floréal Morandat <florealm@gmail.com>
 */

currentMapping = 0;

if (typeof String.prototype.startsWith != 'function') {
  String.prototype.startsWith = function (str){
    return this.slice(0, str.length) == str;
  };
}

function getMappedElement(eltId) {
	if (eltId.startsWith("move-src")) {
		return eltId.replace("src","dst");  	 	
  	}
  	else {
  		return eltId.replace("dst","src");
  	}
}

function nextMapping() {
	if (currentMapping == 0) {
		currentMapping = 1;
		return "#mapping-" + currentMapping.toString();
	} else {
		currentMapping++;
		
		if ($("#mapping-" + currentMapping.toString()).length > 0) {
			return "#mapping-" + currentMapping.toString();
		} else {
			currentMapping = 1;
			return "#mapping-" + currentMapping.toString();		
		}		
	}
}

function isSrc(eltId) {
	return eltId.startsWith("move-src");
}

$(function() {
    $("body").keypress(function (event) {
        switch(event.which) {
            case 110:
                const mapping = $(nextMapping());
                const pre = mapping.closest("pre");
                pre.animate({scrollTop: pre.scrollTop() + mapping.position().top - 200}, 100);
                break;
        }
    });

    // highlight
    $("span.mv.token, span.token.upd").click(function(event) {
        if ($(this).hasClass("selected")) {
            $("span.mv.token, span.token.upd").removeClass("selected");
        } else {
            $("span.mv.token, span.token.upd").removeClass("selected");
            const refElt = $("#" + getMappedElement($(this).attr("id")));
            $(this).addClass("selected");
            refElt.addClass("selected");
            const pre = refElt.closest("pre");
            console.log(pre);
            pre.animate({scrollTop: pre.scrollTop() + refElt.position().top - 200}, 100);
        }
        event.stopPropagation();
    });
    
    $("span.add.token, span.token.del").click(function(event) {
        $("span.mv.token, span.token.upd").removeClass("selected");
        event.stopPropagation();
    });

    // tooltip
    $("span.token").hover(
    	function (event) {
    		$(this).tooltip('show');
    		event.stopPropagation();
    	},
    	function (event) {
    		$(this).tooltip('hide');
    		event.stopPropagation();
    	}
    );
});
</script></head><body><div class="container-fluid"><div class="row"><div class="col"><div class="btn-toolbar justify-content-end"><div class="btn-group mr-2"><button class="btn btn-primary btn-sm" id="legend" data-bs-toggle="popover" data-bs-placement="bottom" data-bs-html="true" data-bs-content="<span class='del'>&nbsp;&nbsp;</span> deleted<br><span class='add'>&nbsp;&nbsp;</span> added<br><span class='mv'>&nbsp;&nbsp;</span> moved<br><span class='upd';>&nbsp;&nbsp;</span> updated<br>">Legend</button><button class="btn btn-primary btn-sm" id="shortcuts" data-bs-toggle="popover" data-bs-placement="bottom" data-bs-html="true" data-bs-content="<b>q</b> quit<br><b>l</b> list<br><b>n</b> next<br><b>t</b> top<br><b>b</b> bottom">Shortcuts</button></div><div class="btn-group"><a href="/list" class="btn btn-default btn-sm btn-primary">Back</a><a href="/quit" class="btn btn-default btn-sm btn-danger">Quit</a></div></div></div></div><div class="row"><div class="col-6"><h5>Output.sol</h5><pre class="pre-scrollable"><span class="marker" id="mapping-1"></span><span class="token del" data-title="source_file/comment">/*
  Copyright 2019-2021 StarkWare Industries Ltd.

  Licensed under the Apache License, Version 2.0 (the "License").
  You may not use this file except in compliance with the License.
  You may obtain a copy of the License at

  https://www.starkware.co/open-source-license/

  Unless required by applicable law or agreed to in writing,
  software distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions
  and limitations under the License.
*/</span>
// SPDX-License-Identifier: Apache-2.0.
pragma solidity ^0.6.12;

library CommitmentTreeUpdateOutput {
    /**
      Returns the previous commitment tree root.
    */
    function getPrevRoot(uint256[] calldata commitment_tree_update_data)
        internal
        pure
        returns (uint256)
    {
        return commitment_tree_update_data[0];
    }

    /**
      Returns the new commitment tree root.
    */
    function getNewRoot(uint256[] calldata commitment_tree_update_data)
        internal
        pure
        returns (uint256)
    {
        return commitment_tree_update_data[1];
    }
}

library StarknetOutput {
    uint256 internal constant MERKLE_UPDATE_OFFSET = 0;
    uint256 internal constant <span class="marker" id="mapping-2"></span><span class="token upd" id="move-src-1" data-title="state_variable_declaration/identifier">H<span class="cupd">E</span>ADE<span class="cupd">R_</span><span class="cupd">S</span>IZE</span> = 2;

    uint256 constant <span class="marker" id="mapping-3"></span><span class="token upd" id="move-src-2" data-title="state_variable_declaration/identifier">M<span class="cupd">E</span>SS<span class="cupd">A</span>G<span class="cupd">E</span>_F<span class="cupd">R</span>OM<span class="cupd">_</span>ADDRE<span class="cupd">S</span>S_OFFSET</span> = <span class="marker" id="mapping-4"></span><span class="token upd" id="move-src-3" data-title="state_variable_declaration/number_literal">0</span>;
    uint256 constant <span class="marker" id="mapping-5"></span><span class="token upd" id="move-src-4" data-title="state_variable_declaration/identifier"><span class="cupd">MESSAGE_TO_</span><span class="cupd">ADDRESS_OFFSET</span></span> = <span class="marker" id="mapping-6"></span><span class="token upd" id="move-src-5" data-title="state_variable_declaration/number_literal">1</span>;
    uint256 constant <span class="marker" id="mapping-7"></span><span class="token upd" id="move-src-6" data-title="state_variable_declaration/identifier"><span class="cupd">MESSAGE_</span>PAY<span class="cupd">L</span><span class="cupd">O</span><span class="cupd">AD</span>_<span class="cupd">S</span>IZE<span class="cupd">_OFFSET</span></span> = <span class="marker" id="mapping-8"></span><span class="token upd" id="move-src-7" data-title="state_variable_declaration/number_literal">2</span>;
    uint256 constant <span class="marker" id="mapping-9"></span><span class="token upd" id="move-src-8" data-title="state_variable_declaration/identifier"><span class="cupd">MESSAGE_</span><span class="cupd">P</span>REFIX<span class="cupd">_SIZE</span></span> = <span class="marker" id="mapping-10"></span><span class="token upd" id="move-src-9" data-title="state_variable_declaration/number_literal">3</span>;
    uint256 constant <span class="marker" id="mapping-11"></span><span class="token upd" id="move-src-10" data-title="state_variable_declaration/identifier"><span class="cupd">S</span><span class="cupd">E</span>LEC<span class="cupd">TO</span><span class="cupd">R</span><span class="cupd">_SIZE</span></span> = <span class="marker" id="mapping-12"></span><span class="token upd" id="move-src-11" data-title="state_variable_declaration/number_literal">1</span>;

    // An event that is raised when a message is sent from L2 to L1.
    event LogMessageToL1(
        uint256 indexed from_address,
        address indexed to_address,
        uint256[] payload
    );

    // An event that is raised when a message from L1 to L2 is consumed.
    event ConsumedMessageToL2(
        address indexed from_address,
        uint256 indexed to_address,
        uint256 indexed selector,
        uint256[] payload
    );

    /**
      Does a sanity check of the output_data length.
    */
    function validate(uint256[] calldata output_data) internal pure {
        require(output_data.length &gt; HEADER_SIZE, "STARKNET_OUTPUT_TOO_SHORT");
    }

    /**
      Returns a slice of the 'output_data' with the commitment tree update information.
    */
    function getMerkleUpdate(uint256[] calldata output_data)
        internal
        pure
        returns (uint256[] calldata)
    {
        return output_data[MERKLE_UPDATE_OFFSET:MERKLE_UPDATE_OFFSET + 2];
    }

    /**
      Processes a message segment from the program output.
      The format of a message segment is the length of the messages in words followed
      by the concatenation of all the messages.

      The 'messages' mapping is updated according to the messages and the direction ('isL2ToL1').
    */
    function processMessages(
        bool isL2ToL1,
        uint256[] calldata programOutputSlice,
        mapping(bytes32 =&gt; uint256) storage messages
    ) internal returns (uint256) {
        uint256 message_segment_size = programOutputSlice[0];
        require(message_segment_size &lt; 2**30, "INVALID_MESSAGE_SEGMENT_SIZE");

        uint256 offset = 1;
        uint256 message_segment_end = offset + message_segment_size;
        while (offset &lt; message_segment_end) {
            uint256 payloadLengthOffset = offset + <span class="marker" id="mapping-13"></span><span class="token upd" id="move-src-12" data-title="binary_expression/identifier">ME<span class="cupd">S</span>SAGE_PAYLOAD_SIZE_OFFSET</span>;
            require(payloadLengthOffset &lt; programOutputSlice.length, "MESSAGE_TOO_SHORT");

            uint256 payloadLength = programOutputSlice[payloadLengthOffset];
            require(payloadLength &lt; 2**30, "INVALID_PAYLOAD_LENGTH");

            uint256 endOffset = <span class="marker" id="mapping-14"></span><span class="token upd" id="move-src-13" data-title="binary_expression/identifier"><span class="cupd">o</span><span class="cupd">ffset</span></span> + <span class="marker" id="mapping-15"></span><span class="token del" data-title="binary_expression/identifier">MESSAGE_PREFIX_SIZE</span> + payloadLength;
            require(endOffset &lt;= programOutputSlice.length, "TRUNCATED_MESSAGE_PAYLOAD");

            <span class="marker" id="mapping-16"></span><span class="token mv" id="move-src-14" data-title="block_statement/variable_declaration_statement">bytes32 messageHash = keccak256(abi.encodePacked(programOutputSlice[offset:endOffset]));</span>
            if (isL2ToL1) {
                emit LogMessageToL1(
                    // from=
                    programOutputSlice[offset + <span class="marker" id="mapping-17"></span><span class="token upd" id="move-src-15" data-title="binary_expression/identifier"><span class="cupd">MESSAGE_</span><span class="cupd">FROM_ADDRESS_OFFSET</span></span>],
                    // to=
                    address(programOutputSlice[offset + <span class="marker" id="mapping-18"></span><span class="token upd" id="move-src-16" data-title="binary_expression/identifier"><span class="cupd">MESSAGE_TO_</span><span class="cupd">ADDRESS_OFFSET</span></span>]),
                    // payload=
                    (uint256[])(programOutputSlice[offset + <span class="marker" id="mapping-19"></span><span class="token upd" id="move-src-17" data-title="binary_expression/identifier"><span class="cupd">MESSAGE_</span><span class="cupd">PREFIX_SIZE</span></span>:endOffset])
                );
                messages[messageHash] += 1;
            } else {
                <span class="marker" id="mapping-20"></span><span class="token mv" id="move-src-18" data-title="block_statement/expression_statement">require(messages[messageHash] &gt; 0, "INVALID_MESSAGE_TO_CONSUME");</span>

                // Note that in the case of a message from L1 to L2, the selector (a single integer)
                // is prepended to the payload.
                emit ConsumedMessageToL2(
                    // from=
                    <span class="marker" id="mapping-21"></span><span class="token del" data-title="emit_statement/call_argument"><span class="marker" id="mapping-22"></span><span class="token del" data-title="call_argument/type_cast_expression"><span class="marker" id="mapping-23"></span><span class="token mv" id="move-src-19" data-title="type_cast_expression/primitive_type">address</span>(<span class="marker" id="mapping-24"></span><span class="token del" data-title="type_cast_expression/call_argument">programOutputSlice[offset + MESSAGE_FROM_ADDRESS_OFFSET]</span>)</span></span>,
                    // to=
                    programOutputSlice[offset + <span class="marker" id="mapping-25"></span><span class="token upd" id="move-src-20" data-title="binary_expression/identifier"><span class="cupd">MESSAGE_TO_</span><span class="cupd">ADDRESS_OFFSET</span></span>],
                    // selector=
                    programOutputSlice[offset + <span class="marker" id="mapping-26"></span><span class="token upd" id="move-src-21" data-title="binary_expression/identifier"><span class="cupd">MESSAGE_</span>P<span class="cupd">R</span>E<span class="cupd">F</span>IX_<span class="cupd">S</span>IZE</span>],
                    // payload=
                    (uint256[])(programOutputSlice[<span class="marker" id="mapping-27"></span><span class="token del" data-title="binary_expression/binary_expression">offset + MESSAGE_PREFIX_SIZE</span> + <span class="marker" id="mapping-28"></span><span class="token del" data-title="binary_expression/number_literal">1</span>:endOffset])
                );
                <span class="marker" id="mapping-29"></span><span class="token mv" id="move-src-22" data-title="block_statement/expression_statement">messages[messageHash] -= 1;</span>
            }

            offset = endOffset;
        }
        require(offset == message_segment_end, "INVALID_MESSAGE_SEGMENT_SIZE");

        return offset;
    }
}
</pre></div><div class="col-6"><h5>Output.sol</h5><pre class="pre-scrollable">// SPDX-License-Identifier: Apache-2.0.
pragma solidity ^0.6.12;

library CommitmentTreeUpdateOutput {
    /**
      Returns the previous commitment tree root.
    */
    function getPrevRoot(uint256[] calldata commitment_tree_update_data)
        internal
        pure
        returns (uint256)
    {
        return commitment_tree_update_data[0];
    }

    /**
      Returns the new commitment tree root.
    */
    function getNewRoot(uint256[] calldata commitment_tree_update_data)
        internal
        pure
        returns (uint256)
    {
        return commitment_tree_update_data[1];
    }
}

library StarknetOutput {
    uint256 internal constant MERKLE_UPDATE_OFFSET = 0;
    uint256 internal constant <span class="marker" id="mapping-30"></span><span class="token upd" id="move-dst-1" data-title="state_variable_declaration/identifier">BLOCK_NUMB<span class="cupd">E</span><span class="cupd">R_</span>OFF<span class="cupd">S</span>ET</span> = 2;
    uint256 <span class="marker" id="mapping-31"></span><span class="token add" data-title="state_variable_declaration/visibility">internal</span> constant <span class="marker" id="mapping-32"></span><span class="token upd" id="move-dst-2" data-title="state_variable_declaration/identifier">H<span class="cupd">E</span><span class="cupd">A</span>D<span class="cupd">E</span><span class="cupd">R</span><span class="cupd">_</span><span class="cupd">S</span>IZE</span> = <span class="marker" id="mapping-33"></span><span class="token upd" id="move-dst-3" data-title="state_variable_declaration/number_literal">3</span>;

    uint256 constant <span class="marker" id="mapping-34"></span><span class="token upd" id="move-dst-4" data-title="state_variable_declaration/identifier"><span class="cupd">MESSAGE_TO_</span>L1_FROM_<span class="cupd">ADDRESS_OFFSET</span></span> = <span class="marker" id="mapping-35"></span><span class="token upd" id="move-dst-5" data-title="state_variable_declaration/number_literal">0</span>;
    uint256 constant <span class="marker" id="mapping-36"></span><span class="token upd" id="move-dst-6" data-title="state_variable_declaration/identifier"><span class="cupd">MESSAGE_</span>TO_<span class="cupd">L</span>1_T<span class="cupd">O</span>_<span class="cupd">AD</span>DRE<span class="cupd">S</span>S<span class="cupd">_OFFSET</span></span> = <span class="marker" id="mapping-37"></span><span class="token upd" id="move-dst-7" data-title="state_variable_declaration/number_literal">1</span>;
    uint256 constant <span class="marker" id="mapping-38"></span><span class="token upd" id="move-dst-8" data-title="state_variable_declaration/identifier"><span class="cupd">MESSAGE_</span>TO_L1_<span class="cupd">P</span>AYLOAD<span class="cupd">_SIZE</span>_OFFSET</span> = <span class="marker" id="mapping-39"></span><span class="token upd" id="move-dst-9" data-title="state_variable_declaration/number_literal">2</span>;
    uint256 constant <span class="marker" id="mapping-40"></span><span class="token upd" id="move-dst-10" data-title="state_variable_declaration/identifier">ME<span class="cupd">S</span>SAG<span class="cupd">E</span>_<span class="cupd">TO</span>_L1_P<span class="cupd">R</span>EFIX<span class="cupd">_SIZE</span></span> = <span class="marker" id="mapping-41"></span><span class="token upd" id="move-dst-11" data-title="state_variable_declaration/number_literal">3</span>;

    <span class="marker" id="mapping-42"></span><span class="token add" data-title="contract_body/state_variable_declaration">uint256 constant MESSAGE_TO_L2_FROM_ADDRESS_OFFSET = 0;</span>
    <span class="marker" id="mapping-43"></span><span class="token add" data-title="contract_body/state_variable_declaration">uint256 constant MESSAGE_TO_L2_TO_ADDRESS_OFFSET = 1;</span>
    <span class="marker" id="mapping-44"></span><span class="token add" data-title="contract_body/state_variable_declaration">uint256 constant MESSAGE_TO_L2_NONCE_OFFSET = 2;</span>
    <span class="marker" id="mapping-45"></span><span class="token add" data-title="contract_body/state_variable_declaration">uint256 constant MESSAGE_TO_L2_SELECTOR_OFFSET = 3;</span>
    <span class="marker" id="mapping-46"></span><span class="token add" data-title="contract_body/state_variable_declaration">uint256 constant MESSAGE_TO_L2_PAYLOAD_SIZE_OFFSET = 4;</span>
    <span class="marker" id="mapping-47"></span><span class="token add" data-title="contract_body/state_variable_declaration">uint256 constant MESSAGE_TO_L2_PREFIX_SIZE = 5;</span>

    // An event that is raised when a message is sent from L2 to L1.
    event LogMessageToL1(
        uint256 indexed from_address,
        address indexed to_address,
        uint256[] payload
    );

    // An event that is raised when a message from L1 to L2 is consumed.
    event ConsumedMessageToL2(
        address indexed from_address,
        uint256 indexed to_address,
        uint256 indexed selector,
        uint256[] payload<span class="marker" id="mapping-48"></span><span class="token add" data-title="event_definition/,">,</span>
        <span class="marker" id="mapping-49"></span><span class="token add" data-title="event_definition/event_paramater">uint256 nonce</span>
    );

    /**
      Does a sanity check of the output_data length.
    */
    function validate(uint256[] calldata output_data) internal pure {
        require(output_data.length &gt; HEADER_SIZE, "STARKNET_OUTPUT_TOO_SHORT");
    }

    /**
      Returns a slice of the 'output_data' with the commitment tree update information.
    */
    function getMerkleUpdate(uint256[] calldata output_data)
        internal
        pure
        returns (uint256[] calldata)
    {
        return output_data[MERKLE_UPDATE_OFFSET:MERKLE_UPDATE_OFFSET + 2];
    }

    /**
      Processes a message segment from the program output.
      The format of a message segment is the length of the messages in words followed
      by the concatenation of all the messages.

      The 'messages' mapping is updated according to the messages and the direction ('isL2ToL1').
    */
    function processMessages(
        bool isL2ToL1,
        uint256[] calldata programOutputSlice,
        mapping(bytes32 =&gt; uint256) storage messages
    ) internal returns (uint256) {
        uint256 message_segment_size = programOutputSlice[0];
        require(message_segment_size &lt; 2**30, "INVALID_MESSAGE_SEGMENT_SIZE");

        uint256 offset = 1;
        uint256 message_segment_end = offset + message_segment_size;

        <span class="marker" id="mapping-50"></span><span class="token add" data-title="function_body/variable_declaration_statement">uint256 payloadSizeOffset = (
            isL2ToL1 ? MESSAGE_TO_L1_PAYLOAD_SIZE_OFFSET : MESSAGE_TO_L2_PAYLOAD_SIZE_OFFSET
        );</span>
        while (offset &lt; message_segment_end) {
            uint256 payloadLengthOffset = offset + <span class="marker" id="mapping-51"></span><span class="token upd" id="move-dst-12" data-title="binary_expression/identifier">payload<span class="cupd">S</span>izeOffset</span>;
            require(payloadLengthOffset &lt; programOutputSlice.length, "MESSAGE_TOO_SHORT");

            uint256 payloadLength = programOutputSlice[payloadLengthOffset];
            require(payloadLength &lt; 2**30, "INVALID_PAYLOAD_LENGTH");

            uint256 endOffset = <span class="marker" id="mapping-52"></span><span class="token upd" id="move-dst-13" data-title="binary_expression/identifier">payl<span class="cupd">o</span>adLengthO<span class="cupd">ffset</span></span> + <span class="marker" id="mapping-53"></span><span class="token add" data-title="binary_expression/number_literal">1</span> + payloadLength;
            require(endOffset &lt;= programOutputSlice.length, "TRUNCATED_MESSAGE_PAYLOAD");

            if (isL2ToL1) {
                <span class="marker" id="mapping-54"></span><span class="token add" data-title="block_statement/variable_declaration_statement">bytes32 messageHash = keccak256(
                    abi.encodePacked(programOutputSlice[offset:endOffset])
                );</span>

                emit LogMessageToL1(
                    // from=
                    programOutputSlice[offset + <span class="marker" id="mapping-55"></span><span class="token upd" id="move-dst-15" data-title="binary_expression/identifier"><span class="cupd">MESSAGE_</span>TO_L1_<span class="cupd">FROM_ADDRESS_OFFSET</span></span>],
                    // to=
                    address(programOutputSlice[offset + <span class="marker" id="mapping-56"></span><span class="token upd" id="move-dst-16" data-title="binary_expression/identifier"><span class="cupd">MESSAGE_TO_</span>L1_TO_<span class="cupd">ADDRESS_OFFSET</span></span>]),
                    // payload=
                    (uint256[])(programOutputSlice[offset + <span class="marker" id="mapping-57"></span><span class="token upd" id="move-dst-17" data-title="binary_expression/identifier"><span class="cupd">MESSAGE_</span>TO_L1_<span class="cupd">PREFIX_SIZE</span></span>:endOffset])
                );
                messages[messageHash] += 1;
            } else {
                <span class="marker" id="mapping-58"></span><span class="token add" data-title="block_statement/block_statement">{
                    <span class="marker" id="mapping-59"></span><span class="token mv" id="move-dst-14" data-title="block_statement/variable_declaration_statement">bytes32 messageHash = keccak256(
                        abi.encodePacked(programOutputSlice[offset:endOffset])
                    );</span>

                    <span class="marker" id="mapping-60"></span><span class="token mv" id="move-dst-18" data-title="block_statement/expression_statement">require(messages[messageHash] &gt; 0, "INVALID_MESSAGE_TO_CONSUME");</span>
                    <span class="marker" id="mapping-61"></span><span class="token mv" id="move-dst-22" data-title="block_statement/expression_statement">messages[messageHash] -= 1;</span>
                }</span>

                <span class="marker" id="mapping-62"></span><span class="token add" data-title="block_statement/variable_declaration_statement">uint256 nonce = programOutputSlice[offset + MESSAGE_TO_L2_NONCE_OFFSET];</span>
                // Note that in the case of a message from L1 to L2, the selector (a single integer)
                // is prepended to the payload.
                emit ConsumedMessageToL2(
                    // from=
                    <span class="marker" id="mapping-63"></span><span class="token add" data-title="emit_statement/call_argument"><span class="marker" id="mapping-64"></span><span class="token add" data-title="call_argument/type_cast_expression"><span class="marker" id="mapping-65"></span><span class="token mv" id="move-dst-19" data-title="type_cast_expression/primitive_type">address</span>(<span class="marker" id="mapping-66"></span><span class="token add" data-title="type_cast_expression/call_argument">programOutputSlice[offset + MESSAGE_TO_L2_FROM_ADDRESS_OFFSET]</span>)</span></span>,
                    // to=
                    programOutputSlice[offset + <span class="marker" id="mapping-67"></span><span class="token upd" id="move-dst-20" data-title="binary_expression/identifier"><span class="cupd">MESSAGE_TO_</span>L2_TO_<span class="cupd">ADDRESS_OFFSET</span></span>],
                    // selector=
                    programOutputSlice[offset + <span class="marker" id="mapping-68"></span><span class="token upd" id="move-dst-21" data-title="binary_expression/identifier"><span class="cupd">MESSAGE_</span>TO_L2_SELECTO<span class="cupd">R</span>_O<span class="cupd">F</span>F<span class="cupd">S</span>ET</span>],
                    // payload=
                    (uint256[])(programOutputSlice[<span class="marker" id="mapping-69"></span><span class="token add" data-title="binary_expression/identifier">offset</span> + <span class="marker" id="mapping-70"></span><span class="token add" data-title="binary_expression/identifier">MESSAGE_TO_L2_PREFIX_SIZE</span>:endOffset])<span class="marker" id="mapping-71"></span><span class="token add" data-title="emit_statement/,">,</span>
                    <span class="marker" id="mapping-72"></span><span class="token add" data-title="emit_statement/comment">// nonce =</span>
                    <span class="marker" id="mapping-73"></span><span class="token add" data-title="emit_statement/call_argument">nonce</span>
                );
            }

            offset = endOffset;
        }
        require(offset == message_segment_end, "INVALID_MESSAGE_SEGMENT_SIZE");

        return offset;
    }
}
</pre></div></div></div></body></html>