<html lang="en"><head><meta charset="utf8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>GumTree</title><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css"><style type="text/css">/*
 * This file is part of GumTree.
 *
 * GumTree is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * GumTree is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with GumTree.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Copyright 2011-2015 Jean-Rémy Falleri <jr.falleri@gmail.com>
 * Copyright 2011-2015 Floréal Morandat <florealm@gmail.com>
 */

.add {
	border: 1px solid black;
	background-color: MediumSeaGreen;
}

.del {
	border: 1px solid black;
	background-color: IndianRed;
}

.mv {
	border: 1px solid black;
	background-color: Plum;
}

.upd {
	border: 1px solid black;
	background-color: DarkOrange;
	font-weight: bold;
}

.cupd {
	font-weight: normal;
	color: DimGray;
}

.selected {
	background-color: Gold;
}

.marker {
	margin: 0;
	padding: 0;
}

div {
	margin: 0px;
	padding: 0px;
}

.pre-scrollable {
	margin: 0px;
	padding: 0px;
	font-size: 10pt;
	color: black;
	max-height: 90vh;
	background-color: white;
	border: 1px solid black;
	font-family: "Hack, Inconsolata", "Consolas", "Liberation Sans Regular", "DejaVu Sans Mono", monospace;
}

.tooltip-inner {
    max-width: none;
}
</style><script type="text/javascript" src="https://code.jquery.com/jquery-3.4.1.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/js/bootstrap.bundle.min.js"></script><script type="text/javascript">/*
 * This file is part of GumTree.
 *
 * GumTree is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * GumTree is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with GumTree.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Copyright 2011-2015 Jean-Rémy Falleri <jr.falleri@gmail.com>
 * Copyright 2011-2015 Floréal Morandat <florealm@gmail.com>
 */

$(function(){
    let popoverTriggerList = [].slice.call(document.querySelectorAll('[data-bs-toggle="popover"]'))
    let popoverList = popoverTriggerList.map(function (popoverTriggerEl) {
      return new bootstrap.Popover(popoverTriggerEl)
    })

    $("body").keypress(function (event) {
        switch (event.which) {
            case 116:
                $('html, body').animate({scrollTop: 0}, 100);
                break;
            case 98:
                $("html, body").animate({ scrollTop: $(document).height() }, 100);
                break;
            case 113:
                window.location = "/quit";
                break;
            case 108:
                window.location = "/list";
                break;
        }
    });
});
</script><script type="text/javascript">/*
 * This file is part of GumTree.
 *
 * GumTree is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * GumTree is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with GumTree.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Copyright 2011-2015 Jean-Rémy Falleri <jr.falleri@gmail.com>
 * Copyright 2011-2015 Floréal Morandat <florealm@gmail.com>
 */

currentMapping = 0;

if (typeof String.prototype.startsWith != 'function') {
  String.prototype.startsWith = function (str){
    return this.slice(0, str.length) == str;
  };
}

function getMappedElement(eltId) {
	if (eltId.startsWith("move-src")) {
		return eltId.replace("src","dst");  	 	
  	}
  	else {
  		return eltId.replace("dst","src");
  	}
}

function nextMapping() {
	if (currentMapping == 0) {
		currentMapping = 1;
		return "#mapping-" + currentMapping.toString();
	} else {
		currentMapping++;
		
		if ($("#mapping-" + currentMapping.toString()).length > 0) {
			return "#mapping-" + currentMapping.toString();
		} else {
			currentMapping = 1;
			return "#mapping-" + currentMapping.toString();		
		}		
	}
}

function isSrc(eltId) {
	return eltId.startsWith("move-src");
}

$(function() {
    $("body").keypress(function (event) {
        switch(event.which) {
            case 110:
                const mapping = $(nextMapping());
                const pre = mapping.closest("pre");
                pre.animate({scrollTop: pre.scrollTop() + mapping.position().top - 200}, 100);
                break;
        }
    });

    // highlight
    $("span.mv.token, span.token.upd").click(function(event) {
        if ($(this).hasClass("selected")) {
            $("span.mv.token, span.token.upd").removeClass("selected");
        } else {
            $("span.mv.token, span.token.upd").removeClass("selected");
            const refElt = $("#" + getMappedElement($(this).attr("id")));
            $(this).addClass("selected");
            refElt.addClass("selected");
            const pre = refElt.closest("pre");
            console.log(pre);
            pre.animate({scrollTop: pre.scrollTop() + refElt.position().top - 200}, 100);
        }
        event.stopPropagation();
    });
    
    $("span.add.token, span.token.del").click(function(event) {
        $("span.mv.token, span.token.upd").removeClass("selected");
        event.stopPropagation();
    });

    // tooltip
    $("span.token").hover(
    	function (event) {
    		$(this).tooltip('show');
    		event.stopPropagation();
    	},
    	function (event) {
    		$(this).tooltip('hide');
    		event.stopPropagation();
    	}
    );
});
</script></head><body><div class="container-fluid"><div class="row"><div class="col"><div class="btn-toolbar justify-content-end"><div class="btn-group mr-2"><button class="btn btn-primary btn-sm" id="legend" data-bs-toggle="popover" data-bs-placement="bottom" data-bs-html="true" data-bs-content="<span class='del'>&nbsp;&nbsp;</span> deleted<br><span class='add'>&nbsp;&nbsp;</span> added<br><span class='mv'>&nbsp;&nbsp;</span> moved<br><span class='upd';>&nbsp;&nbsp;</span> updated<br>">Legend</button><button class="btn btn-primary btn-sm" id="shortcuts" data-bs-toggle="popover" data-bs-placement="bottom" data-bs-html="true" data-bs-content="<b>q</b> quit<br><b>l</b> list<br><b>n</b> next<br><b>t</b> top<br><b>b</b> bottom">Shortcuts</button></div><div class="btn-group"><a href="/list" class="btn btn-default btn-sm btn-primary">Back</a><a href="/quit" class="btn btn-default btn-sm btn-danger">Quit</a></div></div></div></div><div class="row"><div class="col-6"><h5>StarknetMessaging.sol</h5><pre class="pre-scrollable">// SPDX-License-Identifier: Apache-2.0.
pragma solidity ^0.6.12;

<span class="marker" id="mapping-1"></span><span class="token mv" id="move-src-1" data-title="source_file/import_directive">import "IStarknetMessaging.sol";</span>
import "NamedStorage.sol";

/**
  Implements sending messages to L2 by adding them to a pipe and consuming messages from L2 by
  removing them from a different pipe. A deriving contract can handle the former pipe and add items
  to the latter pipe while interacting with L2.
*/
contract StarknetMessaging is IStarknetMessaging {
    /**
      Random slot storage elements and accessors.
    */
    string constant L1L2_MESSAGE_MAP_TAG = "STARKNET_1.0_MSGING_L1TOL2_MAPPPING_V2";
    string constant L2L1_MESSAGE_MAP_TAG = "STARKNET_1.0_MSGING_L2TOL1_MAPPPING";

    string constant L1L2_MESSAGE_NONCE_TAG = "STARKNET_1.0_MSGING_L1TOL2_NONCE";

    function l1ToL2Messages(bytes32 msgHash) external view returns (uint256) {
        return l1ToL2Messages()[msgHash];
    }

    function l2ToL1Messages(bytes32 msgHash) external view returns (uint256) {
        return l2ToL1Messages()[msgHash];
    }

    function l1ToL2Messages() internal pure returns (mapping(bytes32 =&gt; uint256) storage) {
        return NamedStorage.bytes32ToUint256Mapping(L1L2_MESSAGE_MAP_TAG);
    }

    function l2ToL1Messages() internal pure returns (mapping(bytes32 =&gt; uint256) storage) {
        return NamedStorage.bytes32ToUint256Mapping(L2L1_MESSAGE_MAP_TAG);
    }

    function l1ToL2MessageNonce() public view returns (uint256) {
        return NamedStorage.getUintValue(L1L2_MESSAGE_NONCE_TAG);
    }

    /**
      Sends a message to an L2 contract.
    */
    function sendMessageToL2(
        <span class="marker" id="mapping-2"></span><span class="token mv" id="move-src-2" data-title="function_definition/parameter">uint256 <span class="marker" id="mapping-3"></span><span class="token upd" id="move-src-3" data-title="parameter/identifier"><span class="cupd">to</span>_a<span class="cupd">ddress</span></span></span>,
        uint256 selector,
        uint256[] calldata payload
    ) external override returns (bytes32) {
        uint256 nonce = l1ToL2MessageNonce();
        NamedStorage.setUintValue(L1L2_MESSAGE_NONCE_TAG, nonce + 1);
        <span class="marker" id="mapping-4"></span><span class="token mv" id="move-src-4" data-title="function_body/emit_statement">emit <span class="marker" id="mapping-5"></span><span class="token upd" id="move-src-5" data-title="emit_statement/identifier">L<span class="cupd">o</span>g<span class="cupd">MessageToL</span>2</span>(<span class="marker" id="mapping-6"></span><span class="token mv" id="move-src-6" data-title="emit_statement/call_argument">msg.sender</span><span class="marker" id="mapping-7"></span><span class="token mv" id="move-src-7" data-title="emit_statement/,">,</span> <span class="marker" id="mapping-8"></span><span class="token upd" id="move-src-8" data-title="call_argument/identifier">t<span class="cupd">o</span>_a<span class="cupd">ddress</span></span>, <span class="marker" id="mapping-9"></span><span class="token mv" id="move-src-9" data-title="emit_statement/call_argument">selector</span><span class="marker" id="mapping-10"></span><span class="token del" data-title="emit_statement/,">,</span> payload<span class="marker" id="mapping-11"></span><span class="token del" data-title="emit_statement/,">,</span> <span class="marker" id="mapping-12"></span><span class="token mv" id="move-src-10" data-title="emit_statement/call_argument">nonce</span>);</span>
        bytes32 msgHash = <span class="marker" id="mapping-13"></span><span class="token mv" id="move-src-11" data-title="variable_declaration_statement/call_expression">keccak256(
            abi.encodePacked(
                uint256(msg.sender),
                <span class="marker" id="mapping-14"></span><span class="token upd" id="move-src-12" data-title="call_argument/identifier"><span class="cupd">to</span>_a<span class="cupd">ddress</span></span>,
                nonce,
                selector,
                payload.length,
                payload
            )
        )</span>;
        l1ToL2Messages()[msgHash] += 1;

        return msgHash;
    }

    /**
      Consumes a message that was sent from an L2 contract.

      Returns the hash of the message.
    */
    function consumeMessageFromL2(<span class="marker" id="mapping-15"></span><span class="token mv" id="move-src-13" data-title="function_definition/parameter">uint256 <span class="marker" id="mapping-16"></span><span class="token upd" id="move-src-14" data-title="parameter/identifier">fr<span class="cupd">o</span>m_a<span class="cupd">d</span>dress</span></span>, uint256[] calldata payload)
        external
        override
        returns (bytes32)
    {
        bytes32 msgHash = keccak256(
            abi.encodePacked(<span class="marker" id="mapping-17"></span><span class="token upd" id="move-src-15" data-title="call_argument/identifier"><span class="cupd">from</span>_a<span class="cupd">ddress</span></span>, uint256(msg.sender), payload.length, payload)
        );

        require(l2ToL1Messages()[msgHash] &gt; 0, "INVALID_MESSAGE_TO_CONSUME");
        <span class="marker" id="mapping-18"></span><span class="token mv" id="move-src-16" data-title="function_body/emit_statement">emit <span class="marker" id="mapping-19"></span><span class="token upd" id="move-src-17" data-title="emit_statement/identifier">C<span class="cupd">o</span>nsumed<span class="cupd">MessageToL</span>1</span>(<span class="marker" id="mapping-20"></span><span class="token mv" id="move-src-18" data-title="emit_statement/call_argument"><span class="marker" id="mapping-21"></span><span class="token upd" id="move-src-19" data-title="call_argument/identifier">fr<span class="cupd">o</span>m_a<span class="cupd">ddress</span></span></span><span class="marker" id="mapping-22"></span><span class="token mv" id="move-src-20" data-title="emit_statement/,">,</span> msg.sender, payload);</span>
        l2ToL1Messages()[msgHash] -= 1;
        return msgHash;
    }
}
</pre></div><div class="col-6"><h5>StarknetMessaging.sol</h5><pre class="pre-scrollable"><span class="marker" id="mapping-23"></span><span class="token add" data-title="source_file/comment">/*
  Copyright 2019-2022 StarkWare Industries Ltd.

  Licensed under the Apache License, Version 2.0 (the "License").
  You may not use this file except in compliance with the License.
  You may obtain a copy of the License at

  https://www.starkware.co/open-source-license/

  Unless required by applicable law or agreed to in writing,
  software distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions
  and limitations under the License.
*/</span>
// SPDX-License-Identifier: Apache-2.0.
pragma solidity ^0.6.12;

import "IStarknetMessaging.sol";
<span class="marker" id="mapping-24"></span><span class="token mv" id="move-dst-1" data-title="source_file/import_directive">import "NamedStorage.sol";</span>

/**
  Implements sending messages to L2 by adding them to a pipe and consuming messages from L2 by
  removing them from a different pipe. A deriving contract can handle the former pipe and add items
  to the latter pipe while interacting with L2.
*/
contract StarknetMessaging is IStarknetMessaging {
    /**
      Random slot storage elements and accessors.
    */
    string constant L1L2_MESSAGE_MAP_TAG = "STARKNET_1.0_MSGING_L1TOL2_MAPPPING_V2";
    string constant L2L1_MESSAGE_MAP_TAG = "STARKNET_1.0_MSGING_L2TOL1_MAPPPING";

    string constant L1L2_MESSAGE_NONCE_TAG = "STARKNET_1.0_MSGING_L1TOL2_NONCE";

    <span class="marker" id="mapping-25"></span><span class="token add" data-title="contract_body/state_variable_declaration">string constant L1L2_MESSAGE_CANCELLATION_MAP_TAG = (
        "STARKNET_1.0_MSGING_L1TOL2_CANCELLATION_MAPPPING"
    );</span>

    <span class="marker" id="mapping-26"></span><span class="token add" data-title="contract_body/state_variable_declaration">string constant L1L2_MESSAGE_CANCELLATION_DELAY_TAG = (
        "STARKNET_1.0_MSGING_L1TOL2_CANCELLATION_DELAY"
    );</span>

    function l1ToL2Messages(bytes32 msgHash) external view returns (uint256) {
        return l1ToL2Messages()[msgHash];
    }

    function l2ToL1Messages(bytes32 msgHash) external view returns (uint256) {
        return l2ToL1Messages()[msgHash];
    }

    function l1ToL2Messages() internal pure returns (mapping(bytes32 =&gt; uint256) storage) {
        return NamedStorage.bytes32ToUint256Mapping(L1L2_MESSAGE_MAP_TAG);
    }

    function l2ToL1Messages() internal pure returns (mapping(bytes32 =&gt; uint256) storage) {
        return NamedStorage.bytes32ToUint256Mapping(L2L1_MESSAGE_MAP_TAG);
    }

    function l1ToL2MessageNonce() public view returns (uint256) {
        return NamedStorage.getUintValue(L1L2_MESSAGE_NONCE_TAG);
    }

    <span class="marker" id="mapping-27"></span><span class="token add" data-title="contract_body/function_definition">function messageCancellationDelay() public view returns (uint256) {
        return NamedStorage.getUintValue(L1L2_MESSAGE_CANCELLATION_DELAY_TAG);
    }</span>

    <span class="marker" id="mapping-28"></span><span class="token add" data-title="contract_body/function_definition">function messageCancellationDelay(<span class="marker" id="mapping-29"></span><span class="token mv" id="move-dst-13" data-title="function_definition/parameter">uint256 <span class="marker" id="mapping-30"></span><span class="token upd" id="move-dst-14" data-title="parameter/identifier">delayInSec<span class="cupd">o</span>n<span class="cupd">d</span>s</span></span>) <span class="marker" id="mapping-31"></span><span class="token add" data-title="function_definition/visibility">internal</span> <span class="marker" id="mapping-32"></span><span class="token add" data-title="function_definition/function_body">{
        NamedStorage.setUintValue(L1L2_MESSAGE_CANCELLATION_DELAY_TAG, delayInSeconds);
    }</span></span>

    <span class="marker" id="mapping-33"></span><span class="token add" data-title="contract_body/comment">/**
      Returns the timestamp at the time cancelL1ToL2Message was called with a message
      matching 'msgHash'.

      The function returns 0 if cancelL1ToL2Message was never called.
    */</span>
    <span class="marker" id="mapping-34"></span><span class="token add" data-title="contract_body/function_definition">function l1ToL2MessageCancellations(bytes32 msgHash) external view returns (uint256) {
        return l1ToL2MessageCancellations()[msgHash];
    }</span>

    <span class="marker" id="mapping-35"></span><span class="token add" data-title="contract_body/function_definition">function l1ToL2MessageCancellations()
        internal
        pure
        returns (mapping(bytes32 =&gt; uint256) storage)
    {
        return NamedStorage.bytes32ToUint256Mapping(L1L2_MESSAGE_CANCELLATION_MAP_TAG);
    }</span>

    <span class="marker" id="mapping-36"></span><span class="token add" data-title="contract_body/comment">/**
      Returns the hash of an L1 -&gt; L2 message from msg.sender.
    */</span>
    <span class="marker" id="mapping-37"></span><span class="token add" data-title="contract_body/function_definition">function getL1ToL2MsgHash(
        <span class="marker" id="mapping-38"></span><span class="token mv" id="move-dst-2" data-title="function_definition/parameter">uint256 <span class="marker" id="mapping-39"></span><span class="token upd" id="move-dst-3" data-title="parameter/identifier"><span class="cupd">to</span>A<span class="cupd">ddress</span></span></span>,
        <span class="marker" id="mapping-40"></span><span class="token add" data-title="function_definition/parameter">uint256 selector</span>,
        <span class="marker" id="mapping-41"></span><span class="token add" data-title="function_definition/parameter">uint256[] calldata payload</span>,
        <span class="marker" id="mapping-42"></span><span class="token add" data-title="function_definition/parameter">uint256 nonce</span>
    ) <span class="marker" id="mapping-43"></span><span class="token add" data-title="function_definition/visibility">internal</span> <span class="marker" id="mapping-44"></span><span class="token add" data-title="function_definition/return_type_definition">returns (bytes32)</span> <span class="marker" id="mapping-45"></span><span class="token add" data-title="function_definition/function_body">{
        <span class="marker" id="mapping-46"></span><span class="token add" data-title="function_body/return_statement">return
            <span class="marker" id="mapping-47"></span><span class="token mv" id="move-dst-11" data-title="return_statement/call_expression">keccak256(
                abi.encodePacked(
                    uint256(msg.sender),
                    <span class="marker" id="mapping-48"></span><span class="token upd" id="move-dst-12" data-title="call_argument/identifier"><span class="cupd">to</span>A<span class="cupd">ddress</span></span>,
                    nonce,
                    selector,
                    payload.length,
                    payload
                )
            )</span>;</span>
    }</span></span>

    /**
      Sends a message to an L2 contract.
    */
    function sendMessageToL2(
        <span class="marker" id="mapping-49"></span><span class="token add" data-title="function_definition/parameter">uint256 toAddress</span>,
        uint256 selector,
        uint256[] calldata payload
    ) external override returns (bytes32) {
        uint256 nonce = l1ToL2MessageNonce();
        NamedStorage.setUintValue(L1L2_MESSAGE_NONCE_TAG, nonce + 1);
        <span class="marker" id="mapping-50"></span><span class="token mv" id="move-dst-16" data-title="function_body/emit_statement">emit <span class="marker" id="mapping-51"></span><span class="token upd" id="move-dst-17" data-title="emit_statement/identifier">L<span class="cupd">o</span>g<span class="cupd">MessageToL</span>2</span>(msg.sender<span class="marker" id="mapping-52"></span><span class="token mv" id="move-dst-20" data-title="emit_statement/,">,</span> <span class="marker" id="mapping-53"></span><span class="token mv" id="move-dst-18" data-title="emit_statement/call_argument"><span class="marker" id="mapping-54"></span><span class="token upd" id="move-dst-19" data-title="call_argument/identifier">t<span class="cupd">o</span>A<span class="cupd">ddress</span></span></span>, <span class="marker" id="mapping-55"></span><span class="token mv" id="move-dst-9" data-title="emit_statement/call_argument">selector</span><span class="marker" id="mapping-56"></span><span class="token add" data-title="emit_statement/,">,</span> payload<span class="marker" id="mapping-57"></span><span class="token add" data-title="emit_statement/,">,</span> <span class="marker" id="mapping-58"></span><span class="token mv" id="move-dst-10" data-title="emit_statement/call_argument">nonce</span>);</span>
        bytes32 msgHash = <span class="marker" id="mapping-59"></span><span class="token add" data-title="variable_declaration_statement/call_expression">getL1ToL2MsgHash(toAddress, selector, payload, nonce)</span>;
        l1ToL2Messages()[msgHash] += 1;

        return msgHash;
    }

    /**
      Consumes a message that was sent from an L2 contract.

      Returns the hash of the message.
    */
    function consumeMessageFromL2(<span class="marker" id="mapping-60"></span><span class="token add" data-title="function_definition/parameter">uint256 fromAddress</span>, uint256[] calldata payload)
        external
        override
        returns (bytes32)
    {
        bytes32 msgHash = keccak256(
            abi.encodePacked(<span class="marker" id="mapping-61"></span><span class="token upd" id="move-dst-15" data-title="call_argument/identifier"><span class="cupd">from</span>A<span class="cupd">ddress</span></span>, uint256(msg.sender), payload.length, payload)
        );

        require(l2ToL1Messages()[msgHash] &gt; 0, "INVALID_MESSAGE_TO_CONSUME");
        <span class="marker" id="mapping-62"></span><span class="token mv" id="move-dst-4" data-title="function_body/emit_statement">emit <span class="marker" id="mapping-63"></span><span class="token upd" id="move-dst-5" data-title="emit_statement/identifier">C<span class="cupd">o</span>nsumed<span class="cupd">MessageToL</span>1</span>(<span class="marker" id="mapping-64"></span><span class="token upd" id="move-dst-8" data-title="call_argument/identifier">fr<span class="cupd">o</span>mA<span class="cupd">ddress</span></span><span class="marker" id="mapping-65"></span><span class="token mv" id="move-dst-7" data-title="emit_statement/,">,</span> <span class="marker" id="mapping-66"></span><span class="token mv" id="move-dst-6" data-title="emit_statement/call_argument">msg.sender</span>, payload);</span>
        l2ToL1Messages()[msgHash] -= 1;
        return msgHash;
    }

    <span class="marker" id="mapping-67"></span><span class="token add" data-title="contract_body/function_definition">function startL1ToL2MessageCancellation(
        uint256 toAddress,
        uint256 selector,
        uint256[] calldata payload,
        uint256 nonce
    ) external override {
        emit MessageToL2CancellationStarted(msg.sender, toAddress, selector, payload, nonce);
        bytes32 msgHash = getL1ToL2MsgHash(toAddress, selector, payload, nonce);
        uint256 msgCount = l1ToL2Messages()[msgHash];
        require(msgCount &gt; 0, "NO_MESSAGE_TO_CANCEL");
        l1ToL2MessageCancellations()[msgHash] = block.timestamp;
    }</span>

    <span class="marker" id="mapping-68"></span><span class="token add" data-title="contract_body/function_definition">function cancelL1ToL2Message(
        uint256 toAddress,
        uint256 selector,
        uint256[] calldata payload,
        uint256 nonce
    ) external override {
        emit MessageToL2Canceled(msg.sender, toAddress, selector, payload, nonce);
        bytes32 msgHash = getL1ToL2MsgHash(toAddress, selector, payload, nonce);
        uint256 msgCount = l1ToL2Messages()[msgHash];
        require(msgCount &gt; 0, "NO_MESSAGE_TO_CANCEL");

        uint256 requestTime = l1ToL2MessageCancellations()[msgHash];
        require(requestTime != 0, "MESSAGE_CANCELLATION_NOT_REQUESTED");

        uint256 cancelAllowedTime = requestTime + messageCancellationDelay();
        require(cancelAllowedTime &gt;= requestTime, "CANCEL_ALLOWED_TIME_OVERFLOW");
        require(block.timestamp &gt;= cancelAllowedTime, "MESSAGE_CANCELLATION_NOT_ALLOWED_YET");

        l1ToL2Messages()[msgHash] = msgCount - 1;
    }</span>
}
</pre></div></div></div></body></html>