<html lang="en"><head><meta charset="utf8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>GumTree</title><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css"><style type="text/css">/*
 * This file is part of GumTree.
 *
 * GumTree is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * GumTree is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with GumTree.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Copyright 2011-2015 Jean-Rémy Falleri <jr.falleri@gmail.com>
 * Copyright 2011-2015 Floréal Morandat <florealm@gmail.com>
 */

.add {
	border: 1px solid black;
	background-color: MediumSeaGreen;
}

.del {
	border: 1px solid black;
	background-color: IndianRed;
}

.mv {
	border: 1px solid black;
	background-color: Plum;
}

.upd {
	border: 1px solid black;
	background-color: DarkOrange;
	font-weight: bold;
}

.cupd {
	font-weight: normal;
	color: DimGray;
}

.selected {
	background-color: Gold;
}

.marker {
	margin: 0;
	padding: 0;
}

div {
	margin: 0px;
	padding: 0px;
}

.pre-scrollable {
	margin: 0px;
	padding: 0px;
	font-size: 10pt;
	color: black;
	max-height: 90vh;
	background-color: white;
	border: 1px solid black;
	font-family: "Hack, Inconsolata", "Consolas", "Liberation Sans Regular", "DejaVu Sans Mono", monospace;
}

.tooltip-inner {
    max-width: none;
}
</style><script type="text/javascript" src="https://code.jquery.com/jquery-3.4.1.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/js/bootstrap.bundle.min.js"></script><script type="text/javascript">/*
 * This file is part of GumTree.
 *
 * GumTree is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * GumTree is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with GumTree.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Copyright 2011-2015 Jean-Rémy Falleri <jr.falleri@gmail.com>
 * Copyright 2011-2015 Floréal Morandat <florealm@gmail.com>
 */

$(function(){
    let popoverTriggerList = [].slice.call(document.querySelectorAll('[data-bs-toggle="popover"]'))
    let popoverList = popoverTriggerList.map(function (popoverTriggerEl) {
      return new bootstrap.Popover(popoverTriggerEl)
    })

    $("body").keypress(function (event) {
        switch (event.which) {
            case 116:
                $('html, body').animate({scrollTop: 0}, 100);
                break;
            case 98:
                $("html, body").animate({ scrollTop: $(document).height() }, 100);
                break;
            case 113:
                window.location = "/quit";
                break;
            case 108:
                window.location = "/list";
                break;
        }
    });
});
</script><script type="text/javascript">/*
 * This file is part of GumTree.
 *
 * GumTree is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * GumTree is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with GumTree.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Copyright 2011-2015 Jean-Rémy Falleri <jr.falleri@gmail.com>
 * Copyright 2011-2015 Floréal Morandat <florealm@gmail.com>
 */

currentMapping = 0;

if (typeof String.prototype.startsWith != 'function') {
  String.prototype.startsWith = function (str){
    return this.slice(0, str.length) == str;
  };
}

function getMappedElement(eltId) {
	if (eltId.startsWith("move-src")) {
		return eltId.replace("src","dst");  	 	
  	}
  	else {
  		return eltId.replace("dst","src");
  	}
}

function nextMapping() {
	if (currentMapping == 0) {
		currentMapping = 1;
		return "#mapping-" + currentMapping.toString();
	} else {
		currentMapping++;
		
		if ($("#mapping-" + currentMapping.toString()).length > 0) {
			return "#mapping-" + currentMapping.toString();
		} else {
			currentMapping = 1;
			return "#mapping-" + currentMapping.toString();		
		}		
	}
}

function isSrc(eltId) {
	return eltId.startsWith("move-src");
}

$(function() {
    $("body").keypress(function (event) {
        switch(event.which) {
            case 110:
                const mapping = $(nextMapping());
                const pre = mapping.closest("pre");
                pre.animate({scrollTop: pre.scrollTop() + mapping.position().top - 200}, 100);
                break;
        }
    });

    // highlight
    $("span.mv.token, span.token.upd").click(function(event) {
        if ($(this).hasClass("selected")) {
            $("span.mv.token, span.token.upd").removeClass("selected");
        } else {
            $("span.mv.token, span.token.upd").removeClass("selected");
            const refElt = $("#" + getMappedElement($(this).attr("id")));
            $(this).addClass("selected");
            refElt.addClass("selected");
            const pre = refElt.closest("pre");
            console.log(pre);
            pre.animate({scrollTop: pre.scrollTop() + refElt.position().top - 200}, 100);
        }
        event.stopPropagation();
    });
    
    $("span.add.token, span.token.del").click(function(event) {
        $("span.mv.token, span.token.upd").removeClass("selected");
        event.stopPropagation();
    });

    // tooltip
    $("span.token").hover(
    	function (event) {
    		$(this).tooltip('show');
    		event.stopPropagation();
    	},
    	function (event) {
    		$(this).tooltip('hide');
    		event.stopPropagation();
    	}
    );
});
</script></head><body><div class="container-fluid"><div class="row"><div class="col"><div class="btn-toolbar justify-content-end"><div class="btn-group mr-2"><button class="btn btn-primary btn-sm" id="legend" data-bs-toggle="popover" data-bs-placement="bottom" data-bs-html="true" data-bs-content="<span class='del'>&nbsp;&nbsp;</span> deleted<br><span class='add'>&nbsp;&nbsp;</span> added<br><span class='mv'>&nbsp;&nbsp;</span> moved<br><span class='upd';>&nbsp;&nbsp;</span> updated<br>">Legend</button><button class="btn btn-primary btn-sm" id="shortcuts" data-bs-toggle="popover" data-bs-placement="bottom" data-bs-html="true" data-bs-content="<b>q</b> quit<br><b>l</b> list<br><b>n</b> next<br><b>t</b> top<br><b>b</b> bottom">Shortcuts</button></div><div class="btn-group"><a href="/list" class="btn btn-default btn-sm btn-primary">Back</a><a href="/quit" class="btn btn-default btn-sm btn-danger">Quit</a></div></div></div></div><div class="row"><div class="col-6"><h5>0xfdc26cda2d2440d0e83cd1dee8e8be48405806dc.etherscan.io-MintableERC20Predicate.sol</h5><pre class="pre-scrollable">// File: @openzeppelin/contracts/token/ERC20/IERC20.sol

// SPDX-License-Identifier: MIT

pragma solidity ^0.6.0;

/**
 * @dev Interface of the ERC20 standard as defined in the EIP.
 */
interface IERC20 {
    /**
     * @dev Returns the amount of tokens in existence.
     */
    function totalSupply() external view returns (uint256);

    /**
     * @dev Returns the amount of tokens owned by `account`.
     */
    function balanceOf(address account) external view returns (uint256);

    /**
     * @dev Moves `amount` tokens from the caller's account to `recipient`.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * Emits a {Transfer} event.
     */
    function transfer(address recipient, uint256 amount) external returns (bool);

    /**
     * @dev Returns the remaining number of tokens that `spender` will be
     * allowed to spend on behalf of `owner` through {transferFrom}. This is
     * zero by default.
     *
     * This value changes when {approve} or {transferFrom} are called.
     */
    function allowance(address owner, address spender) external view returns (uint256);

    /**
     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * IMPORTANT: Beware that changing an allowance with this method brings the risk
     * that someone may use both the old and the new allowance by unfortunate
     * transaction ordering. One possible solution to mitigate this race
     * condition is to first reduce the spender's allowance to 0 and set the
     * desired value afterwards:
     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
     *
     * Emits an {Approval} event.
     */
    function approve(address spender, uint256 amount) external returns (bool);

    /**
     * @dev Moves `amount` tokens from `sender` to `recipient` using the
     * allowance mechanism. `amount` is then deducted from the caller's
     * allowance.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * Emits a {Transfer} event.
     */
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);

    /**
     * @dev Emitted when `value` tokens are moved from one account (`from`) to
     * another (`to`).
     *
     * Note that `value` may be zero.
     */
    event Transfer(address indexed from, address indexed to, uint256 value);

    /**
     * @dev Emitted when the allowance of a `spender` for an `owner` is set by
     * a call to {approve}. `value` is the new allowance.
     */
    event Approval(address indexed owner, address indexed spender, uint256 value);
}

// File: contracts/root/RootToken/IMintableERC20.sol

<span class="marker" id="mapping-1"></span><span class="token mv" id="move-src-1" data-title="source_file/pragma_directive">pragma solidity 0.6.6;</span>

interface IMintableERC20 is IERC20 {
    /**
     * @notice called by predicate contract to mint tokens while withdrawing
     * @dev Should be callable only by MintableERC20Predicate
     * Make sure minting is done only by this function
     * @param user user address for whom token is being minted
     * @param amount amount of token being minted
     */
    function mint(address user, uint256 amount) external;
}

// File: @openzeppelin/contracts/utils/EnumerableSet.sol

// SPDX-License-Identifier: MIT

<span class="marker" id="mapping-2"></span><span class="token mv" id="move-src-2" data-title="source_file/pragma_directive">pragma solidity ^0.6.0;</span>

/**
 * @dev Library for managing
 * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive
 * types.
 *
 * Sets have the following properties:
 *
 * - Elements are added, removed, and checked for existence in constant time
 * (O(1)).
 * - Elements are enumerated in O(n). No guarantees are made on the ordering.
 *
 * ```
 * contract Example {
 *     // Add the library methods
 *     using EnumerableSet for EnumerableSet.AddressSet;
 *
 *     // Declare a set state variable
 *     EnumerableSet.AddressSet private mySet;
 * }
 * ```
 *
 * As of v3.0.0, only sets of type `address` (`AddressSet`) and `uint256`
 * (`UintSet`) are supported.
 */
library EnumerableSet {
    // To implement this library for multiple types with as little code
    // repetition as possible, we write it in terms of a generic Set type with
    // bytes32 values.
    // The Set implementation uses private functions, and user-facing
    // implementations (such as AddressSet) are just wrappers around the
    // underlying Set.
    // This means that we can only create new EnumerableSets for types that fit
    // in bytes32.

    struct Set {
        // Storage of set values
        bytes32[] _values;

        // Position of the value in the `values` array, plus 1 because index 0
        // means a value is not in the set.
        mapping (bytes32 =&gt; uint256) _indexes;
    }

    /**
     * @dev Add a value to a set. O(1).
     *
     * Returns true if the value was added to the set, that is if it was not
     * already present.
     */
    function _add(Set storage set, bytes32 value) private returns (bool) {
        if (!_contains(set, value)) {
            set._values.push(value);
            // The value is stored at length-1, but we add 1 to all indexes
            // and use 0 as a sentinel value
            set._indexes[value] = set._values.length;
            return true;
        } else {
            return false;
        }
    }

    /**
     * @dev Removes a value from a set. O(1).
     *
     * Returns true if the value was removed from the set, that is if it was
     * present.
     */
    function _remove(Set storage set, bytes32 value) private returns (bool) {
        // We read and store the value's index to prevent multiple reads from the same storage slot
        uint256 valueIndex = set._indexes[value];

        if (valueIndex != 0) { // Equivalent to contains(set, value)
            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in
            // the array, and then remove the last element (sometimes called as 'swap and pop').
            // This modifies the order of the array, as noted in {at}.

            uint256 toDeleteIndex = valueIndex - 1;
            uint256 lastIndex = set._values.length - 1;

            // When the value to delete is the last one, the swap operation is unnecessary. However, since this occurs
            // so rarely, we still do the swap anyway to avoid the gas cost of adding an 'if' statement.

            bytes32 lastvalue = set._values[lastIndex];

            // Move the last value to the index where the value to delete is
            set._values[toDeleteIndex] = lastvalue;
            // Update the index for the moved value
            set._indexes[lastvalue] = toDeleteIndex + 1; // All indexes are 1-based

            // Delete the slot where the moved value was stored
            set._values.pop();

            // Delete the index for the deleted slot
            delete set._indexes[value];

            return true;
        } else {
            return false;
        }
    }

    /**
     * @dev Returns true if the value is in the set. O(1).
     */
    function _contains(Set storage set, bytes32 value) private view returns (bool) {
        return set._indexes[value] != 0;
    }

    /**
     * @dev Returns the number of values on the set. O(1).
     */
    function _length(Set storage set) private view returns (uint256) {
        return set._values.length;
    }

   /**
    * @dev Returns the value stored at position `index` in the set. O(1).
    *
    * Note that there are no guarantees on the ordering of values inside the
    * array, and it may change when more values are added or removed.
    *
    * Requirements:
    *
    * - `index` must be strictly less than {length}.
    */
    function _at(Set storage set, uint256 index) private view returns (bytes32) {
        require(set._values.length &gt; index, "EnumerableSet: index out of bounds");
        return set._values[index];
    }

    // AddressSet

    struct AddressSet {
        Set _inner;
    }

    /**
     * @dev Add a value to a set. O(1).
     *
     * Returns true if the value was added to the set, that is if it was not
     * already present.
     */
    function add(AddressSet storage set, address value) internal returns (bool) {
        return _add(set._inner, bytes32(uint256(value)));
    }

    /**
     * @dev Removes a value from a set. O(1).
     *
     * Returns true if the value was removed from the set, that is if it was
     * present.
     */
    function remove(AddressSet storage set, address value) internal returns (bool) {
        return _remove(set._inner, bytes32(uint256(value)));
    }

    /**
     * @dev Returns true if the value is in the set. O(1).
     */
    function contains(AddressSet storage set, address value) internal view returns (bool) {
        return _contains(set._inner, bytes32(uint256(value)));
    }

    /**
     * @dev Returns the number of values in the set. O(1).
     */
    function length(AddressSet storage set) internal view returns (uint256) {
        return _length(set._inner);
    }

   /**
    * @dev Returns the value stored at position `index` in the set. O(1).
    *
    * Note that there are no guarantees on the ordering of values inside the
    * array, and it may change when more values are added or removed.
    *
    * Requirements:
    *
    * - `index` must be strictly less than {length}.
    */
    function at(AddressSet storage set, uint256 index) internal view returns (address) {
        return address(uint256(_at(set._inner, index)));
    }


    // UintSet

    struct UintSet {
        Set _inner;
    }

    /**
     * @dev Add a value to a set. O(1).
     *
     * Returns true if the value was added to the set, that is if it was not
     * already present.
     */
    function add(UintSet storage set, uint256 value) internal returns (bool) {
        return _add(set._inner, bytes32(value));
    }

    /**
     * @dev Removes a value from a set. O(1).
     *
     * Returns true if the value was removed from the set, that is if it was
     * present.
     */
    function remove(UintSet storage set, uint256 value) internal returns (bool) {
        return _remove(set._inner, bytes32(value));
    }

    /**
     * @dev Returns true if the value is in the set. O(1).
     */
    function contains(UintSet storage set, uint256 value) internal view returns (bool) {
        return _contains(set._inner, bytes32(value));
    }

    /**
     * @dev Returns the number of values on the set. O(1).
     */
    function length(UintSet storage set) internal view returns (uint256) {
        return _length(set._inner);
    }

   /**
    * @dev Returns the value stored at position `index` in the set. O(1).
    *
    * Note that there are no guarantees on the ordering of values inside the
    * array, and it may change when more values are added or removed.
    *
    * Requirements:
    *
    * - `index` must be strictly less than {length}.
    */
    function at(UintSet storage set, uint256 index) internal view returns (uint256) {
        return uint256(_at(set._inner, index));
    }
}

<span class="marker" id="mapping-3"></span><span class="token mv" id="move-src-3" data-title="source_file/comment"><span class="marker" id="mapping-4"></span><span class="token upd" id="move-src-4" data-title="source_file/comment"><span class="cupd">// File: @openzeppelin/contracts/</span>u<span class="cupd">t</span>ils<span class="cupd">/</span>Addr<span class="cupd">e</span>ss<span class="cupd">.sol</span></span></span>

<span class="marker" id="mapping-5"></span><span class="token mv" id="move-src-5" data-title="source_file/comment">// SPDX-License-Identifier: MIT</span>

<span class="marker" id="mapping-6"></span><span class="token mv" id="move-src-6" data-title="source_file/pragma_directive">pragma solidity ^0.6.2;</span>

<span class="marker" id="mapping-7"></span><span class="token mv" id="move-src-7" data-title="source_file/comment"><span class="marker" id="mapping-8"></span><span class="token upd" id="move-src-8" data-title="source_file/comment"><span class="cupd">/**
 * @dev</span> <span class="cupd">C</span><span class="cupd">o</span>l<span class="cupd">l</span><span class="cupd">e</span><span class="cupd">ctio</span><span class="cupd">n</span><span class="cupd"> </span><span class="cupd">o</span><span class="cupd">f</span> fu<span class="cupd">n</span><span class="cupd">c</span><span class="cupd">t</span><span class="cupd">i</span><span class="cupd">ons</span><span class="cupd"> </span><span class="cupd">r</span><span class="cupd">e</span><span class="cupd">l</span><span class="cupd">a</span><span class="cupd">t</span>e<span class="cupd">d</span><span class="cupd"> </span><span class="cupd">t</span><span class="cupd">o</span><span class="cupd"> the</span><span class="cupd"> </span><span class="cupd">a</span><span class="cupd">d</span><span class="cupd">d</span><span class="cupd">r</span><span class="cupd">e</span><span class="cupd">s</span><span class="cupd">s </span><span class="cupd">t</span><span class="cupd">yp</span><span class="cupd">e</span><span class="cupd"></span><span class="cupd">
</span> */</span></span>
<span class="marker" id="mapping-9"></span><span class="token mv" id="move-src-9" data-title="source_file/library_declaration">library Address {
    /**
     * @dev Returns true if `account` is a contract.
     *
     * [IMPORTANT]
     * ====
     * It is unsafe to assume that an address for which this function returns
     * false is an externally-owned account (EOA) and not a contract.
     *
     * Among others, `isContract` will return false for the following
     * types of addresses:
     *
     *  - an externally-owned account
     *  - a contract in construction
     *  - an address where a contract will be created
     *  - an address where a contract lived, but was destroyed
     * ====
     */
    function isContract(address account) internal view returns (bool) {
        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts
        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned
        // for accounts without code, i.e. `keccak256('')`
        bytes32 codehash;
        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;
        // solhint-disable-next-line no-inline-assembly
        assembly { codehash := extcodehash(account) }
        return (codehash != accountHash &amp;&amp; codehash != 0x0);
    }

    /**
     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to
     * `recipient`, forwarding all available gas and reverting on errors.
     *
     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost
     * of certain opcodes, possibly making contracts go over the 2300 gas limit
     * imposed by `transfer`, making them unable to receive funds via
     * `transfer`. {sendValue} removes this limitation.
     *
     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].
     *
     * IMPORTANT: because control is transferred to `recipient`, care must be
     * taken to not create reentrancy vulnerabilities. Consider using
     * {ReentrancyGuard} or the
     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].
     */
    function sendValue(address payable recipient, uint256 amount) internal {
        require(address(this).balance &gt;= amount, "Address: insufficient balance");

        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value
        (bool success, ) = recipient.call{ value: amount }("");
        require(success, "Address: unable to send value, recipient may have reverted");
    }

    /**
     * @dev Performs a Solidity function call using a low level `call`. A
     * plain`call` is an unsafe replacement for a function call: use this
     * function instead.
     *
     * If `target` reverts with a revert reason, it is bubbled up by this
     * function (like regular Solidity function calls).
     *
     * Returns the raw returned data. To convert to the expected return value,
     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].
     *
     * Requirements:
     *
     * - `target` must be a contract.
     * - calling `target` with `data` must not revert.
     *
     * _Available since v3.1._
     */
    function functionCall(address target, bytes memory data) internal returns (bytes memory) {
      return functionCall(target, data, "Address: low-level call failed");
    }

    /**
     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with
     * `errorMessage` as a fallback revert reason when `target` reverts.
     *
     * _Available since v3.1._
     */
    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {
        return _functionCallWithValue(target, data, 0, errorMessage);
    }

    /**
     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],
     * but also transferring `value` wei to `target`.
     *
     * Requirements:
     *
     * - the calling contract must have an ETH balance of at least `value`.
     * - the called Solidity function must be `payable`.
     *
     * _Available since v3.1._
     */
    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {
        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");
    }

    /**
     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but
     * with `errorMessage` as a fallback revert reason when `target` reverts.
     *
     * _Available since v3.1._
     */
    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {
        require(address(this).balance &gt;= value, "Address: insufficient balance for call");
        return _functionCallWithValue(target, data, value, errorMessage);
    }

    function _functionCallWithValue(address target, bytes memory data, uint256 weiValue, string memory errorMessage) private returns (bytes memory) {
        require(isContract(target), "Address: call to non-contract");

        // solhint-disable-next-line avoid-low-level-calls
        (bool success, bytes memory returndata) = target.call{ value: weiValue }(data);
        if (success) {
            return returndata;
        } else {
            // Look for revert reason and bubble it up if present
            if (returndata.length &gt; 0) {
                // The easiest way to bubble the revert reason is using memory via assembly

                // solhint-disable-next-line no-inline-assembly
                assembly {
                    let returndata_size := mload(returndata)
                    revert(add(32, returndata), returndata_size)
                }
            } else {
                revert(errorMessage);
            }
        }
    }
}</span>

// File: @openzeppelin/contracts/GSN/Context.sol

// SPDX-License-Identifier: MIT

<span class="marker" id="mapping-10"></span><span class="token mv" id="move-src-10" data-title="source_file/pragma_directive">pragma solidity ^0.6.0;</span>

/*
 * @dev Provides information about the current execution context, including the
 * sender of the transaction and its data. While these are generally available
 * via msg.sender and msg.data, they should not be accessed in such a direct
 * manner, since when dealing with GSN meta-transactions the account sending and
 * paying for execution may not be the actual sender (as far as an application
 * is concerned).
 *
 * This contract is only required for intermediate, library-like contracts.
 */
abstract contract Context {
    function _msgSender() internal view virtual returns (address payable) {
        return msg.sender;
    }

    function _msgData() internal view virtual returns (bytes memory) {
        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691
        return msg.data;
    }
}

// File: @openzeppelin/contracts/access/AccessControl.sol

// SPDX-License-Identifier: MIT

<span class="marker" id="mapping-11"></span><span class="token mv" id="move-src-11" data-title="source_file/pragma_directive">pragma solidity ^0.6.0;</span>




/**
 * @dev Contract module that allows children to implement role-based access
 * control mechanisms.
 *
 * Roles are referred to by their `bytes32` identifier. These should be exposed
 * in the external API and be unique. The best way to achieve this is by
 * using `public constant` hash digests:
 *
 * ```
 * bytes32 public constant MY_ROLE = keccak256("MY_ROLE");
 * ```
 *
 * Roles can be used to represent a set of permissions. To restrict access to a
 * function call, use {hasRole}:
 *
 * ```
 * function foo() public {
 *     require(hasRole(MY_ROLE, msg.sender));
 *     ...
 * }
 * ```
 *
 * Roles can be granted and revoked dynamically via the {grantRole} and
 * {revokeRole} functions. Each role has an associated admin role, and only
 * accounts that have a role's admin role can call {grantRole} and {revokeRole}.
 *
 * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means
 * that only accounts with this role will be able to grant or revoke other
 * roles. More complex role relationships can be created by using
 * {_setRoleAdmin}.
 *
 * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to
 * grant and revoke this role. Extra precautions should be taken to secure
 * accounts that have been granted it.
 */
abstract contract AccessControl is Context {
    using EnumerableSet for EnumerableSet.AddressSet;
    using Address for address;

    struct RoleData {
        EnumerableSet.AddressSet members;
        bytes32 adminRole;
    }

    mapping (bytes32 =&gt; RoleData) private _roles;

    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;

    /**
     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`
     *
     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite
     * {RoleAdminChanged} not being emitted signaling this.
     *
     * _Available since v3.1._
     */
    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);

    /**
     * @dev Emitted when `account` is granted `role`.
     *
     * `sender` is the account that originated the contract call, an admin role
     * bearer except when using {_setupRole}.
     */
    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);

    /**
     * @dev Emitted when `account` is revoked `role`.
     *
     * `sender` is the account that originated the contract call:
     *   - if using `revokeRole`, it is the admin role bearer
     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)
     */
    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);

    /**
     * @dev Returns `true` if `account` has been granted `role`.
     */
    function hasRole(bytes32 role, address account) public view returns (bool) {
        return _roles[role].members.contains(account);
    }

    /**
     * @dev Returns the number of accounts that have `role`. Can be used
     * together with {getRoleMember} to enumerate all bearers of a role.
     */
    function getRoleMemberCount(bytes32 role) public view returns (uint256) {
        return _roles[role].members.length();
    }

    /**
     * @dev Returns one of the accounts that have `role`. `index` must be a
     * value between 0 and {getRoleMemberCount}, non-inclusive.
     *
     * Role bearers are not sorted in any particular way, and their ordering may
     * change at any point.
     *
     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure
     * you perform all queries on the same block. See the following
     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]
     * for more information.
     */
    function getRoleMember(bytes32 role, uint256 index) public view returns (address) {
        return _roles[role].members.at(index);
    }

    /**
     * @dev Returns the admin role that controls `role`. See {grantRole} and
     * {revokeRole}.
     *
     * To change a role's admin, use {_setRoleAdmin}.
     */
    function getRoleAdmin(bytes32 role) public view returns (bytes32) {
        return _roles[role].adminRole;
    }

    /**
     * @dev Grants `role` to `account`.
     *
     * If `account` had not been already granted `role`, emits a {RoleGranted}
     * event.
     *
     * Requirements:
     *
     * - the caller must have ``role``'s admin role.
     */
    function grantRole(bytes32 role, address account) public virtual {
        require(hasRole(_roles[role].adminRole, _msgSender()), "AccessControl: sender must be an admin to grant");

        _grantRole(role, account);
    }

    /**
     * @dev Revokes `role` from `account`.
     *
     * If `account` had been granted `role`, emits a {RoleRevoked} event.
     *
     * Requirements:
     *
     * - the caller must have ``role``'s admin role.
     */
    function revokeRole(bytes32 role, address account) public virtual {
        require(hasRole(_roles[role].adminRole, _msgSender()), "AccessControl: sender must be an admin to revoke");

        _revokeRole(role, account);
    }

    /**
     * @dev Revokes `role` from the calling account.
     *
     * Roles are often managed via {grantRole} and {revokeRole}: this function's
     * purpose is to provide a mechanism for accounts to lose their privileges
     * if they are compromised (such as when a trusted device is misplaced).
     *
     * If the calling account had been granted `role`, emits a {RoleRevoked}
     * event.
     *
     * Requirements:
     *
     * - the caller must be `account`.
     */
    function renounceRole(bytes32 role, address account) public virtual {
        require(account == _msgSender(), "AccessControl: can only renounce roles for self");

        _revokeRole(role, account);
    }

    /**
     * @dev Grants `role` to `account`.
     *
     * If `account` had not been already granted `role`, emits a {RoleGranted}
     * event. Note that unlike {grantRole}, this function doesn't perform any
     * checks on the calling account.
     *
     * [WARNING]
     * ====
     * This function should only be called from the constructor when setting
     * up the initial roles for the system.
     *
     * Using this function in any other way is effectively circumventing the admin
     * system imposed by {AccessControl}.
     * ====
     */
    function _setupRole(bytes32 role, address account) internal virtual {
        _grantRole(role, account);
    }

    /**
     * @dev Sets `adminRole` as ``role``'s admin role.
     *
     * Emits a {RoleAdminChanged} event.
     */
    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {
        emit RoleAdminChanged(role, _roles[role].adminRole, adminRole);
        _roles[role].adminRole = adminRole;
    }

    function _grantRole(bytes32 role, address account) private {
        if (_roles[role].members.add(account)) {
            emit RoleGranted(role, account, _msgSender());
        }
    }

    function _revokeRole(bytes32 role, address account) private {
        if (_roles[role].members.remove(account)) {
            emit RoleRevoked(role, account, _msgSender());
        }
    }
}

// File: contracts/common/AccessControlMixin.sol

<span class="marker" id="mapping-12"></span><span class="token mv" id="move-src-12" data-title="source_file/pragma_directive">pragma solidity 0.6.6;</span>


contract AccessControlMixin is AccessControl {
    string private _revertMsg;
    function _setupContractId(string memory contractId) internal {
        _revertMsg = string(abi.encodePacked(contractId, ": INSUFFICIENT_PERMISSIONS"));
    }

    modifier only(bytes32 role) {
        require(
            hasRole(role, _msgSender()),
            _revertMsg
        );
        _;
    }
}

// File: contracts/lib/RLPReader.sol

/*
 * @author Hamdi Allam hamdi.allam97@gmail.com
 * Please reach out with any questions or concerns
 * https://github.com/hamdiallam/Solidity-RLP/blob/e681e25a376dbd5426b509380bc03446f05d0f97/contracts/RLPReader.sol
 */
<span class="marker" id="mapping-13"></span><span class="token mv" id="move-src-13" data-title="source_file/pragma_directive">pragma solidity 0.6.6;</span>

library RLPReader {
    uint8 constant STRING_SHORT_START = 0x80;
    uint8 constant STRING_LONG_START = 0xb8;
    uint8 constant LIST_SHORT_START = 0xc0;
    uint8 constant LIST_LONG_START = 0xf8;
    uint8 constant WORD_SIZE = 32;

    <span class="marker" id="mapping-14"></span><span class="token del" data-title="contract_body/struct_declaration">struct RLPItem {
        <span class="marker" id="mapping-15"></span><span class="token del" data-title="struct_declaration/struct_member"><span class="marker" id="mapping-16"></span><span class="token mv" id="move-src-14" data-title="struct_member/type_name">uint256</span> len;</span>
        <span class="marker" id="mapping-17"></span><span class="token del" data-title="struct_declaration/struct_member">uint256 memPtr;</span>
    }</span>

    <span class="marker" id="mapping-18"></span><span class="token upd" id="move-src-15" data-title="contract_body/comment"><span class="cupd">/*
   </span><span class="cupd"> </span><span class="cupd"> * @param</span><span class="cupd"> it</span>e<span class="cupd">m</span> RL<span class="cupd">P</span><span class="cupd"> </span><span class="cupd">e</span>nco<span class="cupd">d</span>e<span class="cupd">d</span> b<span class="cupd">y</span><span class="cupd">t</span>e<span class="cupd">s</span><span class="cupd"></span><span class="cupd">
</span><span class="cupd">   </span><span class="cupd">  </span>*/</span>
    <span class="marker" id="mapping-19"></span><span class="token mv" id="move-src-16" data-title="contract_body/function_definition">function toRlpItem(bytes memory item)
        internal
        pure
        returns (RLPItem memory)
    {
        <span class="marker" id="mapping-20"></span><span class="token mv" id="move-src-17" data-title="function_body/expression_statement">require(<span class="marker" id="mapping-21"></span><span class="token del" data-title="binary_expression/member_expression">item.length</span> <span class="marker" id="mapping-22"></span><span class="token del" data-title="binary_expression/>">&gt;</span> <span class="marker" id="mapping-23"></span><span class="token del" data-title="binary_expression/number_literal">0</span>, "RLPReader: INVALID_BYTES_LENGTH");</span>
        <span class="marker" id="mapping-24"></span><span class="token mv" id="move-src-18" data-title="variable_declaration_statement/variable_declaration">uint256 <span class="marker" id="mapping-25"></span><span class="token upd" id="move-src-19" data-title="variable_declaration/identifier">memPtr</span></span>;
        assembly {
            memPtr := add(item, 0x20)
        }

        return RLPItem(item.length, memPtr);
    }</span>

    <span class="marker" id="mapping-26"></span><span class="token upd" id="move-src-20" data-title="contract_body/comment"><span class="cupd">/*
   </span><span class="cupd"> </span><span class="cupd"> * @param</span><span class="cupd"> it</span>e<span class="cupd">m</span> RL<span class="cupd">P</span><span class="cupd"> </span><span class="cupd">e</span>nco<span class="cupd">d</span>e<span class="cupd">d</span> <span class="cupd">l</span>i<span class="cupd">s</span><span class="cupd">t </span><span class="cupd">in</span> b<span class="cupd">y</span>t<span class="cupd">e</span><span class="cupd">s
  </span> <span class="cupd">  </span>*/</span>
    function toList(RLPItem memory item)
        internal
        pure
        returns (RLPItem[] memory)
    {
        require(isList(item)<span class="marker" id="mapping-27"></span><span class="token del" data-title="call_expression/,">,</span> <span class="marker" id="mapping-28"></span><span class="token mv" id="move-src-21" data-title="call_expression/call_argument">"RLPReader: ITEM_NOT_LIST"</span>);

        <span class="marker" id="mapping-29"></span><span class="token mv" id="move-src-22" data-title="variable_declaration_statement/variable_declaration">uint256 <span class="marker" id="mapping-30"></span><span class="token upd" id="move-src-23" data-title="variable_declaration/identifier">items</span></span> = numItems(item);
        RLPItem[] memory result = new RLPItem[](items);
        <span class="marker" id="mapping-31"></span><span class="token mv" id="move-src-24" data-title="function_body/variable_declaration_statement">uint256 <span class="marker" id="mapping-32"></span><span class="token upd" id="move-src-25" data-title="variable_declaration/identifier">listLength</span> = <span class="marker" id="mapping-33"></span><span class="token del" data-title="variable_declaration_statement/call_expression">_itemLength(item.memPtr)</span>;</span>
        <span class="marker" id="mapping-34"></span><span class="token mv" id="move-src-26" data-title="function_body/expression_statement">require(<span class="marker" id="mapping-35"></span><span class="token mv" id="move-src-27" data-title="call_argument/binary_expression"><span class="marker" id="mapping-36"></span><span class="token del" data-title="binary_expression/identifier">listLength</span> <span class="marker" id="mapping-37"></span><span class="token del" data-title="binary_expression/==">==</span> item.len</span><span class="marker" id="mapping-38"></span><span class="token del" data-title="call_expression/,">,</span> <span class="marker" id="mapping-39"></span><span class="token mv" id="move-src-28" data-title="call_expression/call_argument">"RLPReader: LIST_DECODED_LENGTH_MISMATCH"</span>);</span>

        <span class="marker" id="mapping-40"></span><span class="token mv" id="move-src-29" data-title="function_body/variable_declaration_statement"><span class="marker" id="mapping-41"></span><span class="token mv" id="move-src-30" data-title="variable_declaration_statement/variable_declaration">uint256 <span class="marker" id="mapping-42"></span><span class="token upd" id="move-src-31" data-title="variable_declaration/identifier">memPtr</span></span> = item.memPtr + _payloadOffset(item.memPtr);</span>
        <span class="marker" id="mapping-43"></span><span class="token mv" id="move-src-32" data-title="function_body/variable_declaration_statement">uint256 <span class="marker" id="mapping-44"></span><span class="token upd" id="move-src-33" data-title="variable_declaration/identifier">dataLen</span>;</span>
        for (<span class="marker" id="mapping-45"></span><span class="token del" data-title="primitive_type/uint256">uint256</span> i = 0; i &lt; items; i++) {
            dataLen = _itemLength(memPtr);
            result[i] = RLPItem(dataLen, memPtr);
            memPtr = memPtr + dataLen;
        }

        return result;
    }

    // @return indicator whether encoded payload is a list. negate this function call for isData.
    function isList(RLPItem memory item) internal pure returns (bool) {
        uint8 byte0;
        <span class="marker" id="mapping-46"></span><span class="token mv" id="move-src-34" data-title="function_body/variable_declaration_statement">uint256 <span class="marker" id="mapping-47"></span><span class="token upd" id="move-src-35" data-title="variable_declaration/identifier">memPtr</span> = <span class="marker" id="mapping-48"></span><span class="token mv" id="move-src-36" data-title="variable_declaration_statement/member_expression">item.memPtr</span>;</span>
        assembly {
            byte0 := byte(0, mload(memPtr))
        }

        if (byte0 &lt; LIST_SHORT_START) return false;
        return true;
    }

    /** RLPItem conversions into data types **/

    // @returns raw rlp encoding in bytes
    function toRlpBytes(RLPItem memory item)
        internal
        pure
        returns (bytes memory)
    {
        bytes memory result = new bytes(item.len);

        <span class="marker" id="mapping-49"></span><span class="token mv" id="move-src-37" data-title="function_body/variable_declaration_statement">uint256 ptr;</span>
        assembly {
            ptr := add(0x20, result)
        }

        copy(item.memPtr, ptr, item.len);
        return result;
    }

    function toAddress(RLPItem memory item) internal pure returns (address) {
        <span class="marker" id="mapping-50"></span><span class="token del" data-title="function_body/expression_statement"><span class="marker" id="mapping-51"></span><span class="token del" data-title="expression_statement/call_expression">require(<span class="marker" id="mapping-52"></span><span class="token del" data-title="call_expression/call_argument"><span class="marker" id="mapping-53"></span><span class="token del" data-title="call_argument/unary_expression">!<span class="marker" id="mapping-54"></span><span class="token mv" id="move-src-38" data-title="unary_expression/call_expression"><span class="marker" id="mapping-55"></span><span class="token upd" id="move-src-39" data-title="call_expression/identifier">is<span class="cupd">L</span>ist</span>(item)</span></span></span>, <span class="marker" id="mapping-56"></span><span class="token mv" id="move-src-40" data-title="call_expression/call_argument">"RLPReader: DECODING_LIST_AS_ADDRESS"</span>)</span>;</span>
        // 1 byte for the length prefix
        require(item.len == 21<span class="marker" id="mapping-57"></span><span class="token del" data-title="call_expression/,">,</span> <span class="marker" id="mapping-58"></span><span class="token mv" id="move-src-41" data-title="call_expression/call_argument">"RLPReader: INVALID_ADDRESS_LENGTH"</span>);

        return address(toUint(item));
    }

    function toUint(RLPItem memory item) internal pure <span class="marker" id="mapping-59"></span><span class="token mv" id="move-src-42" data-title="function_definition/return_type_definition">returns (uint256)</span> {
        <span class="marker" id="mapping-60"></span><span class="token del" data-title="function_body/expression_statement"><span class="marker" id="mapping-61"></span><span class="token mv" id="move-src-43" data-title="expression_statement/call_expression"><span class="marker" id="mapping-62"></span><span class="token upd" id="move-src-44" data-title="call_expression/identifier">require</span>(<span class="marker" id="mapping-63"></span><span class="token del" data-title="call_expression/call_argument"><span class="marker" id="mapping-64"></span><span class="token del" data-title="call_argument/unary_expression">!<span class="marker" id="mapping-65"></span><span class="token mv" id="move-src-45" data-title="unary_expression/call_expression"><span class="marker" id="mapping-66"></span><span class="token upd" id="move-src-46" data-title="call_expression/identifier">is<span class="cupd">L</span>ist</span>(item)</span></span></span>, "RLPReader: DECODING_LIST_AS_UINT")</span>;</span>
        <span class="marker" id="mapping-67"></span><span class="token del" data-title="function_body/expression_statement"><span class="marker" id="mapping-68"></span><span class="token mv" id="move-src-47" data-title="expression_statement/call_expression"><span class="marker" id="mapping-69"></span><span class="token upd" id="move-src-48" data-title="call_expression/identifier">require</span>(<span class="marker" id="mapping-70"></span><span class="token del" data-title="call_expression/call_argument"><span class="marker" id="mapping-71"></span><span class="token mv" id="move-src-49" data-title="call_argument/binary_expression">item.len <span class="marker" id="mapping-72"></span><span class="token del" data-title="binary_expression/<=">&lt;=</span> <span class="marker" id="mapping-73"></span><span class="token upd" id="move-src-50" data-title="binary_expression/number_literal">33</span></span></span>, "RLPReader: INVALID_UINT_LENGTH")</span>;</span>

        <span class="marker" id="mapping-74"></span><span class="token mv" id="move-src-51" data-title="function_body/variable_declaration_statement"><span class="marker" id="mapping-75"></span><span class="token mv" id="move-src-52" data-title="variable_declaration/type_name">uint256</span> <span class="marker" id="mapping-76"></span><span class="token upd" id="move-src-53" data-title="variable_declaration/identifier">it<span class="cupd">em</span>Length</span> = <span class="marker" id="mapping-77"></span><span class="token del" data-title="variable_declaration_statement/call_expression">_itemLength(<span class="marker" id="mapping-78"></span><span class="token del" data-title="call_expression/call_argument"><span class="marker" id="mapping-79"></span><span class="token mv" id="move-src-54" data-title="call_argument/member_expression">item.memPtr</span></span>)</span>;</span>
        <span class="marker" id="mapping-80"></span><span class="token del" data-title="function_body/expression_statement"><span class="marker" id="mapping-81"></span><span class="token mv" id="move-src-55" data-title="expression_statement/call_expression"><span class="marker" id="mapping-82"></span><span class="token upd" id="move-src-56" data-title="call_expression/identifier">require</span>(<span class="marker" id="mapping-83"></span><span class="token del" data-title="call_expression/call_argument"><span class="marker" id="mapping-84"></span><span class="token mv" id="move-src-57" data-title="call_argument/binary_expression"><span class="marker" id="mapping-85"></span><span class="token del" data-title="binary_expression/identifier">itemLength</span> <span class="marker" id="mapping-86"></span><span class="token del" data-title="binary_expression/==">==</span> item.len</span></span>, "RLPReader: UINT_DECODED_LENGTH_MISMATCH")</span>;</span>

        <span class="marker" id="mapping-87"></span><span class="token del" data-title="function_body/variable_declaration_statement"><span class="marker" id="mapping-88"></span><span class="token del" data-title="variable_declaration_statement/variable_declaration"><span class="marker" id="mapping-89"></span><span class="token mv" id="move-src-58" data-title="variable_declaration/type_name">uint256</span> offset</span> = <span class="marker" id="mapping-90"></span><span class="token del" data-title="variable_declaration_statement/call_expression">_payloadOffset(item.memPtr)</span>;</span>
        <span class="marker" id="mapping-91"></span><span class="token del" data-title="function_body/variable_declaration_statement">uint256 len = item.len - offset;</span>
        <span class="marker" id="mapping-92"></span><span class="token del" data-title="function_body/variable_declaration_statement"><span class="marker" id="mapping-93"></span><span class="token del" data-title="variable_declaration_statement/variable_declaration"><span class="marker" id="mapping-94"></span><span class="token mv" id="move-src-59" data-title="variable_declaration/type_name">uint256</span> result</span>;</span>
        <span class="marker" id="mapping-95"></span><span class="token mv" id="move-src-60" data-title="function_body/variable_declaration_statement"><span class="marker" id="mapping-96"></span><span class="token mv" id="move-src-61" data-title="variable_declaration/type_name">uint256</span> memPtr = item.memPtr + offset;</span>
        assembly {
            result := mload(memPtr)

            // shfit to the correct location if neccesary
            if lt(len, 32) {
                result := div(result, exp(256, sub(32, len)))
            }
        }

        return result;
    }

    // enforces 32 byte length
    function toUintStrict(RLPItem memory item) internal pure <span class="marker" id="mapping-97"></span><span class="token mv" id="move-src-62" data-title="function_definition/return_type_definition">returns (uint256)</span> {
        <span class="marker" id="mapping-98"></span><span class="token del" data-title="function_body/variable_declaration_statement"><span class="marker" id="mapping-99"></span><span class="token del" data-title="variable_declaration_statement/variable_declaration"><span class="marker" id="mapping-100"></span><span class="token mv" id="move-src-63" data-title="variable_declaration/type_name">uint256</span> itemLength</span> = <span class="marker" id="mapping-101"></span><span class="token del" data-title="variable_declaration_statement/call_expression">_itemLength(item.memPtr)</span>;</span>
        <span class="marker" id="mapping-102"></span><span class="token mv" id="move-src-64" data-title="function_body/expression_statement">require(<span class="marker" id="mapping-103"></span><span class="token del" data-title="binary_expression/identifier">itemLength</span> <span class="marker" id="mapping-104"></span><span class="token del" data-title="binary_expression/==">==</span> item.len<span class="marker" id="mapping-105"></span><span class="token del" data-title="call_expression/,">,</span> <span class="marker" id="mapping-106"></span><span class="token del" data-title="call_expression/call_argument">"RLPReader: UINT_STRICT_DECODED_LENGTH_MISMATCH"</span>);</span>
        // one byte prefix
        require(item.len == 33<span class="marker" id="mapping-107"></span><span class="token del" data-title="call_expression/,">,</span> <span class="marker" id="mapping-108"></span><span class="token del" data-title="call_expression/call_argument">"RLPReader: INVALID_UINT_STRICT_LENGTH"</span>);

        <span class="marker" id="mapping-109"></span><span class="token del" data-title="function_body/variable_declaration_statement"><span class="marker" id="mapping-110"></span><span class="token del" data-title="variable_declaration_statement/variable_declaration"><span class="marker" id="mapping-111"></span><span class="token mv" id="move-src-65" data-title="variable_declaration/type_name">uint256</span> result</span>;</span>
        <span class="marker" id="mapping-112"></span><span class="token mv" id="move-src-66" data-title="variable_declaration/type_name">uint256</span> memPtr = item.memPtr + 1;
        assembly {
            result := mload(memPtr)
        }

        return result;
    }

    function toBytes(RLPItem memory item) internal pure returns (bytes memory) {
        <span class="marker" id="mapping-113"></span><span class="token del" data-title="function_body/variable_declaration_statement"><span class="marker" id="mapping-114"></span><span class="token del" data-title="variable_declaration_statement/variable_declaration"><span class="marker" id="mapping-115"></span><span class="token mv" id="move-src-67" data-title="variable_declaration/type_name">uint256</span> listLength</span> = <span class="marker" id="mapping-116"></span><span class="token del" data-title="variable_declaration_statement/call_expression">_itemLength(<span class="marker" id="mapping-117"></span><span class="token del" data-title="call_expression/call_argument"><span class="marker" id="mapping-118"></span><span class="token mv" id="move-src-68" data-title="call_argument/member_expression">item.memPtr</span></span>)</span>;</span>
        <span class="marker" id="mapping-119"></span><span class="token mv" id="move-src-69" data-title="function_body/expression_statement">require(<span class="marker" id="mapping-120"></span><span class="token del" data-title="binary_expression/identifier">listLength</span> <span class="marker" id="mapping-121"></span><span class="token mv" id="move-src-70" data-title="binary_expression/==">==</span> item.len<span class="marker" id="mapping-122"></span><span class="token del" data-title="call_expression/,">,</span> <span class="marker" id="mapping-123"></span><span class="token del" data-title="call_expression/call_argument">"RLPReader: BYTES_DECODED_LENGTH_MISMATCH"</span>);</span>
        <span class="marker" id="mapping-124"></span><span class="token mv" id="move-src-71" data-title="function_body/variable_declaration_statement"><span class="marker" id="mapping-125"></span><span class="token mv" id="move-src-72" data-title="variable_declaration/type_name">uint256</span> offset = _payloadOffset(item.memPtr);</span>

        <span class="marker" id="mapping-126"></span><span class="token mv" id="move-src-73" data-title="function_body/variable_declaration_statement"><span class="marker" id="mapping-127"></span><span class="token mv" id="move-src-74" data-title="variable_declaration_statement/variable_declaration">uint256 len</span> = item.len - offset;</span> <span class="marker" id="mapping-128"></span><span class="token del" data-title="function_body/comment">// data length</span>
        bytes memory result = new bytes(len);

        <span class="marker" id="mapping-129"></span><span class="token del" data-title="function_body/variable_declaration_statement"><span class="marker" id="mapping-130"></span><span class="token del" data-title="variable_declaration_statement/variable_declaration"><span class="marker" id="mapping-131"></span><span class="token mv" id="move-src-75" data-title="variable_declaration/type_name">uint256</span> destPtr</span>;</span>
        assembly {
            destPtr := add(0x20, result)
        }

        copy(<span class="marker" id="mapping-132"></span><span class="token del" data-title="call_argument/binary_expression">item.memPtr + offset</span>, destPtr, len);
        return result;
    }

    <span class="marker" id="mapping-133"></span><span class="token mv" id="move-src-76" data-title="contract_body/comment"><span class="marker" id="mapping-134"></span><span class="token upd" id="move-src-77" data-title="contract_body/comment"><span class="cupd">/*
   </span> <span class="cupd"> *</span> <span class="cupd">P</span><span class="cupd">r</span>iv<span class="cupd">at</span><span class="cupd">e</span> <span class="cupd">H</span>el<span class="cupd">p</span>e<span class="cupd">rs
  </span> <span class="cupd">  </span>*/</span></span>

    // @return number of payload items inside an encoded list.
    function numItems(RLPItem memory item) private pure <span class="marker" id="mapping-135"></span><span class="token mv" id="move-src-78" data-title="function_definition/return_type_definition">returns (uint256)</span> {
        <span class="marker" id="mapping-136"></span><span class="token del" data-title="function_body/comment">// add `isList` check if `item` is expected to be passsed without a check from calling function</span>
        <span class="marker" id="mapping-137"></span><span class="token del" data-title="function_body/comment">// require(isList(item), "RLPReader: NUM_ITEMS_NOT_LIST");</span>

        <span class="marker" id="mapping-138"></span><span class="token mv" id="move-src-79" data-title="variable_declaration/type_name">uint256</span> count = 0;
        <span class="marker" id="mapping-139"></span><span class="token mv" id="move-src-80" data-title="function_body/variable_declaration_statement"><span class="marker" id="mapping-140"></span><span class="token mv" id="move-src-81" data-title="variable_declaration/type_name">uint256</span> <span class="marker" id="mapping-141"></span><span class="token upd" id="move-src-82" data-title="variable_declaration/identifier">curr<span class="cupd">Ptr</span></span> = item.memPtr + _payloadOffset(item.memPtr);</span>
        <span class="marker" id="mapping-142"></span><span class="token mv" id="move-src-83" data-title="variable_declaration/type_name">uint256</span> endPtr = item.memPtr + item.len;
        while (currPtr &lt; endPtr) {
            currPtr = currPtr + _itemLength(currPtr); // skip over an item
            <span class="marker" id="mapping-143"></span><span class="token del" data-title="block_statement/expression_statement"><span class="marker" id="mapping-144"></span><span class="token del" data-title="expression_statement/call_expression">require(<span class="marker" id="mapping-145"></span><span class="token del" data-title="call_expression/call_argument">currPtr &lt;= endPtr</span>, <span class="marker" id="mapping-146"></span><span class="token mv" id="move-src-84" data-title="call_expression/call_argument">"RLPReader: NUM_ITEMS_DECODED_LENGTH_MISMATCH"</span>)</span>;</span>
            count++;
        }

        return count;
    }

    // @return entire rlp item byte length
    function _itemLength(<span class="marker" id="mapping-147"></span><span class="token mv" id="move-src-85" data-title="function_definition/parameter">uint256 <span class="marker" id="mapping-148"></span><span class="token upd" id="move-src-86" data-title="parameter/identifier">memPtr</span></span>) private pure <span class="marker" id="mapping-149"></span><span class="token mv" id="move-src-87" data-title="function_definition/return_type_definition">returns (uint256)</span> {
        <span class="marker" id="mapping-150"></span><span class="token del" data-title="function_body/variable_declaration_statement"><span class="marker" id="mapping-151"></span><span class="token del" data-title="variable_declaration_statement/variable_declaration"><span class="marker" id="mapping-152"></span><span class="token mv" id="move-src-88" data-title="variable_declaration/type_name">uint256</span> itemLen</span>;</span>
        <span class="marker" id="mapping-153"></span><span class="token del" data-title="function_body/variable_declaration_statement"><span class="marker" id="mapping-154"></span><span class="token del" data-title="variable_declaration_statement/variable_declaration"><span class="marker" id="mapping-155"></span><span class="token mv" id="move-src-89" data-title="variable_declaration/type_name">uint256</span> byte0</span>;</span>
        assembly {
            byte0 := byte(0, mload(memPtr))
        }

        if (byte0 &lt; STRING_SHORT_START) itemLen = 1;
        else if (byte0 &lt; STRING_LONG_START)
            itemLen = byte0 - STRING_SHORT_START + 1;
        else if (byte0 &lt; LIST_SHORT_START) {
            assembly {
                let byteLen := sub(byte0, 0xb7) // # of bytes the actual length is
                memPtr := add(memPtr, 1) // skip over the first byte

                /* 32 byte word size */
                let dataLen := div(mload(memPtr), exp(256, sub(32, byteLen))) // right shifting to get the len
                itemLen := add(dataLen, add(byteLen, 1))
            }
        } else if (byte0 &lt; LIST_LONG_START) {
            itemLen = byte0 - LIST_SHORT_START + 1;
        } else {
            assembly {
                let byteLen := sub(byte0, 0xf7)
                memPtr := add(memPtr, 1)

                let dataLen := div(mload(memPtr), exp(256, sub(32, byteLen))) // right shifting to the correct length
                itemLen := add(dataLen, add(byteLen, 1))
            }
        }

        return itemLen;
    }

    // @return number of bytes until the data
    function _payloadOffset(<span class="marker" id="mapping-156"></span><span class="token mv" id="move-src-90" data-title="function_definition/parameter">uint256 <span class="marker" id="mapping-157"></span><span class="token upd" id="move-src-91" data-title="parameter/identifier">memPtr</span></span>) private pure <span class="marker" id="mapping-158"></span><span class="token mv" id="move-src-92" data-title="function_definition/return_type_definition">returns (uint256)</span> {
        <span class="marker" id="mapping-159"></span><span class="token mv" id="move-src-93" data-title="variable_declaration/type_name">uint256</span> byte0;
        assembly {
            byte0 := byte(0, mload(memPtr))
        }

        if (byte0 &lt; STRING_SHORT_START) return 0;
        else if (
            byte0 &lt; STRING_LONG_START ||
            (byte0 &gt;= LIST_SHORT_START &amp;&amp; byte0 &lt; LIST_LONG_START)
        ) return 1;
        else if (byte0 &lt; LIST_SHORT_START)
            // being explicit
            return byte0 - (STRING_LONG_START - 1) + 1;
        else return byte0 - (LIST_LONG_START - 1) + 1;
    }

    <span class="marker" id="mapping-160"></span><span class="token mv" id="move-src-94" data-title="contract_body/comment"><span class="marker" id="mapping-161"></span><span class="token upd" id="move-src-95" data-title="contract_body/comment"><span class="cupd">/*
   </span> <span class="cupd"> * </span>@p<span class="cupd">a</span><span class="cupd">r</span>a<span class="cupd">m</span> sr<span class="cupd">c</span> P<span class="cupd">o</span>i<span class="cupd">nte</span>r<span class="cupd"> t</span><span class="cupd">o</span><span class="cupd"> </span>sour<span class="cupd">c</span><span class="cupd">e</span><span class="cupd"></span><span class="cupd">
</span><span class="cupd"> </span><span class="cupd">  </span><span class="cupd">  * @para</span>m<span class="cupd"> </span>de<span class="cupd">s</span>t Poi<span class="cupd">n</span>t<span class="cupd">e</span>r <span class="cupd">t</span>o de<span class="cupd">s</span>ti<span class="cupd">n</span>ati<span class="cupd">on
 </span> <span class="cupd">   </span>* <span class="cupd">@</span>para<span class="cupd">m</span><span class="cupd"> le</span>n A<span class="cupd">m</span><span class="cupd">o</span>unt o<span class="cupd">f</span> m<span class="cupd">e</span>mo<span class="cupd">ry</span><span class="cupd"> </span>t<span class="cupd">o</span> cop<span class="cupd">y</span> f<span class="cupd">rom t</span>he so<span class="cupd">u</span><span class="cupd">rce
</span> <span class="cupd">  </span>  */</span></span>
    function copy(
        <span class="marker" id="mapping-162"></span><span class="token mv" id="move-src-96" data-title="function_definition/parameter">uint256 <span class="marker" id="mapping-163"></span><span class="token upd" id="move-src-97" data-title="parameter/identifier">src</span></span>,
        <span class="marker" id="mapping-164"></span><span class="token mv" id="move-src-98" data-title="function_definition/parameter">uint256 <span class="marker" id="mapping-165"></span><span class="token upd" id="move-src-99" data-title="parameter/identifier">dest</span></span>,
        <span class="marker" id="mapping-166"></span><span class="token mv" id="move-src-100" data-title="function_definition/parameter">uint256 <span class="marker" id="mapping-167"></span><span class="token upd" id="move-src-101" data-title="parameter/identifier"><span class="cupd">l</span>en</span></span>
    ) private pure {
        if (len == 0) return;

        // copy as many word sizes as possible
        for (; len &gt;= WORD_SIZE; len -= WORD_SIZE) {
            assembly {
                mstore(dest, mload(src))
            }

            src += WORD_SIZE;
            dest += WORD_SIZE;
        }

        <span class="marker" id="mapping-168"></span><span class="token del" data-title="function_body/comment">// left over bytes. Mask is used to remove unwanted bytes from the word</span>
        <span class="marker" id="mapping-169"></span><span class="token mv" id="move-src-102" data-title="function_body/variable_declaration_statement"><span class="marker" id="mapping-170"></span><span class="token del" data-title="primitive_type/uint256">uint256</span> mask = 256**(WORD_SIZE - len) - 1;</span>
        <span class="marker" id="mapping-171"></span><span class="token mv" id="move-src-103" data-title="function_body/assembly_statement">assembly {
            let srcpart := and(mload(src), not(mask)) // zero out src
            let destpart := and(mload(dest), mask) // retrieve the bytes
            mstore(dest, or(destpart, srcpart))
        }</span>
    }
}

// File: contracts/root/TokenPredicates/ITokenPredicate.sol

pragma solidity 0.6.6;


/// @title Token predicate interface for all pos portal predicates
/// @notice Abstract interface that defines methods for custom predicates
interface ITokenPredicate {

    /**
     * @notice Deposit tokens into pos portal
     * @dev When `depositor` deposits tokens into pos portal, tokens get locked into predicate contract.
     * @param depositor Address who wants to deposit tokens
     * @param depositReceiver Address (address) who wants to receive tokens on side chain
     * @param rootToken Token which gets deposited
     * @param depositData Extra data for deposit (amount for ERC20, token id for ERC721 etc.) [ABI encoded]
     */
    function lockTokens(
        address depositor,
        address depositReceiver,
        address rootToken,
        bytes calldata depositData
    ) external;

    /**
     * @notice Validates and processes exit while withdraw process
     * @dev Validates exit log emitted on sidechain. Reverts if validation fails.
     * @dev Processes withdraw based on custom logic. Example: transfer ERC20/ERC721, mint ERC721 if mintable withdraw
     * @param sender Address
     * @param rootToken Token which gets withdrawn
     * @param logRLPList Valid sidechain log for data like amount, token id etc.
     */
    function exitTokens(
        address sender,
        address rootToken,
        bytes calldata logRLPList
    ) external;
}

// File: contracts/common/Initializable.sol

<span class="marker" id="mapping-172"></span><span class="token mv" id="move-src-104" data-title="source_file/pragma_directive">pragma solidity 0.6.6;</span>

contract Initializable {
    bool inited = false;

    modifier initializer() {
        require(!inited, "already inited");
        _;
        inited = true;
    }
}

// File: contracts/root/TokenPredicates/MintableERC20Predicate.sol

<span class="marker" id="mapping-173"></span><span class="token mv" id="move-src-105" data-title="source_file/pragma_directive">pragma solidity 0.6.6;</span>






contract MintableERC20Predicate is
    ITokenPredicate,
    AccessControlMixin,
    Initializable
{
    using RLPReader for bytes;
    using RLPReader for RLPReader.RLPItem;

    bytes32 public constant MANAGER_ROLE = keccak256("MANAGER_ROLE");
    bytes32 public constant TOKEN_TYPE = keccak256("MintableERC20");
    bytes32 public constant TRANSFER_EVENT_SIG = keccak256(
        "Transfer(address,address,uint256)"
    );

    event LockedMintableERC20(
        address indexed depositor,
        address indexed depositReceiver,
        address indexed rootToken,
        uint256 amount
    );

    constructor() public {}

    function initialize(address _owner) external initializer {
        _setupContractId("MintableERC20Predicate");
        _setupRole(DEFAULT_ADMIN_ROLE, _owner);
        _setupRole(MANAGER_ROLE, _owner);
    }

    /**
     * @notice Lock ERC20 tokens for deposit, callable only by manager
     * @param depositor Address who wants to deposit tokens
     * @param depositReceiver Address (address) who wants to receive tokens on child chain
     * @param rootToken Token which gets deposited
     * @param depositData ABI encoded amount
     */
    function lockTokens(
        address depositor,
        address depositReceiver,
        address rootToken,
        bytes calldata depositData
    ) external override only(MANAGER_ROLE) {
        uint256 amount = abi.decode(depositData, (uint256));

        emit LockedMintableERC20(depositor, depositReceiver, rootToken, amount);
        <span class="marker" id="mapping-174"></span><span class="token upd" id="move-src-106" data-title="call_expression/identifier"><span class="cupd">I</span>Mintable<span class="cupd">ERC20</span></span>(rootToken).<span class="marker" id="mapping-175"></span><span class="token upd" id="move-src-107" data-title="member_expression/identifier">t<span class="cupd">ransferFrom</span></span>(
            depositor,
            address(this),
            amount
        );
    }

    /**
     * @notice Validates log signature, from and to address
     * then sends the correct amount to withdrawer
     * callable only by manager
     * @param rootToken Token which gets withdrawn
     * @param log Valid ERC20 burn log from child chain
     */
    function exitTokens(
        address,
        address rootToken,
        bytes memory log
    ) public override only(MANAGER_ROLE) {
        RLPReader.RLPItem[] memory logRLPList = log.toRlpItem().toList();
        RLPReader.RLPItem[] memory logTopicRLPList = logRLPList[1].toList(); // topics

        require(
            bytes32(logTopicRLPList[0].toUint()) == TRANSFER_EVENT_SIG, // topic0 is `Transfer` event sig
            "MintableERC20Predicate: INVALID_SIGNATURE"
        );

        address withdrawer = address(logTopicRLPList[1].toUint()); // topic1 is `from` address

        require(
            address(logTopicRLPList[2].toUint()) == address(0), // topic2 is `to` address
            "MintableERC20Predicate: INVALID_RECEIVER"
        );

        IMintableERC20 token = IMintableERC20(rootToken);

        uint256 tokenBalance = token.balanceOf(address(this));
        uint256 amount = logRLPList[2].toUint();

        // Checking whether MintableERC20Predicate has enough balance
        // to transfer `amount` to withdrawer or not
        //
        // If no, it'll mint those extra tokens &amp; transfer `amount`
        // to withdrawer
        if (tokenBalance &lt; amount) {
            token.mint(address(this), amount - tokenBalance);
        }

        <span class="marker" id="mapping-176"></span><span class="token mv" id="move-src-108" data-title="call_expression/member_expression">token.transfer</span>(withdrawer, amount);
    }
}</pre></div><div class="col-6"><h5>0x0f92d459b20d21f6bf9e02056ea9165d3f78ba62.etherscan.io-MintableERC20Predicate.sol</h5><pre class="pre-scrollable">// File: @openzeppelin/contracts/token/ERC20/IERC20.sol

// SPDX-License-Identifier: MIT

pragma solidity ^0.6.0;

/**
 * @dev Interface of the ERC20 standard as defined in the EIP.
 */
interface IERC20 {
    /**
     * @dev Returns the amount of tokens in existence.
     */
    function totalSupply() external view returns (uint256);

    /**
     * @dev Returns the amount of tokens owned by `account`.
     */
    function balanceOf(address account) external view returns (uint256);

    /**
     * @dev Moves `amount` tokens from the caller's account to `recipient`.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * Emits a {Transfer} event.
     */
    function transfer(address recipient, uint256 amount) external returns (bool);

    /**
     * @dev Returns the remaining number of tokens that `spender` will be
     * allowed to spend on behalf of `owner` through {transferFrom}. This is
     * zero by default.
     *
     * This value changes when {approve} or {transferFrom} are called.
     */
    function allowance(address owner, address spender) external view returns (uint256);

    /**
     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * IMPORTANT: Beware that changing an allowance with this method brings the risk
     * that someone may use both the old and the new allowance by unfortunate
     * transaction ordering. One possible solution to mitigate this race
     * condition is to first reduce the spender's allowance to 0 and set the
     * desired value afterwards:
     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
     *
     * Emits an {Approval} event.
     */
    function approve(address spender, uint256 amount) external returns (bool);

    /**
     * @dev Moves `amount` tokens from `sender` to `recipient` using the
     * allowance mechanism. `amount` is then deducted from the caller's
     * allowance.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * Emits a {Transfer} event.
     */
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);

    /**
     * @dev Emitted when `value` tokens are moved from one account (`from`) to
     * another (`to`).
     *
     * Note that `value` may be zero.
     */
    event Transfer(address indexed from, address indexed to, uint256 value);

    /**
     * @dev Emitted when the allowance of a `spender` for an `owner` is set by
     * a call to {approve}. `value` is the new allowance.
     */
    event Approval(address indexed owner, address indexed spender, uint256 value);
}

<span class="marker" id="mapping-177"></span><span class="token mv" id="move-dst-4" data-title="source_file/comment"><span class="marker" id="mapping-178"></span><span class="token upd" id="move-dst-4" data-title="source_file/comment"><span class="cupd">// File: @openzeppelin/contracts/</span>ma<span class="cupd">t</span>h<span class="cupd">/</span>Saf<span class="cupd">e</span>Math<span class="cupd">.sol</span></span></span>

<span class="marker" id="mapping-179"></span><span class="token mv" id="move-dst-5" data-title="source_file/comment">// SPDX-License-Identifier: MIT</span>

<span class="marker" id="mapping-180"></span><span class="token mv" id="move-dst-2" data-title="source_file/pragma_directive">pragma solidity ^0.6.0;</span>

<span class="marker" id="mapping-181"></span><span class="token mv" id="move-dst-8" data-title="source_file/comment"><span class="marker" id="mapping-182"></span><span class="token upd" id="move-dst-8" data-title="source_file/comment"><span class="cupd">/**
 * @dev</span> Wrappers<span class="cupd"> </span>over S<span class="cupd">o</span>lidity's arith<span class="cupd">m</span>et<span class="cupd">i</span>c oper<span class="cupd">atio</span>n<span class="cupd">s</span> with added<span class="cupd"> </span>ove<span class="cupd">r</span>flo<span class="cupd">w</span>
 <span class="cupd">*</span> checks.
 *
 *<span class="cupd"> </span>Arit<span class="cupd">h</span>me<span class="cupd">t</span>ic oper<span class="cupd">ati</span>ons in Solidi<span class="cupd">t</span>y wrap o<span class="cupd">n</span> o<span class="cupd">v</span>erflow. Th<span class="cupd">i</span>s can easily r<span class="cupd">e</span>sult
 * in bu<span class="cupd">g</span>s, be<span class="cupd">c</span>ause programmers usually as<span class="cupd">s</span>ume tha<span class="cupd">t</span> an ove<span class="cupd">r</span>flow raises an
 * error, whi<span class="cupd">ch i</span>s <span class="cupd">t</span>h<span class="cupd">e</span> s<span class="cupd">t</span>andard b<span class="cupd">e</span>havior in <span class="cupd">h</span>igh level programming la<span class="cupd">n</span>guages.
 * `SafeM<span class="cupd">a</span>th` r<span class="cupd">es</span>tores this intu<span class="cupd">i</span>tion by reverting the transaction when <span class="cupd">an</span>
 * o<span class="cupd">p</span>eration ov<span class="cupd">e</span>r<span class="cupd">f</span>lows.
 *
 * Using this library instead of the unchecked operations eliminates an entire
 * class of bugs, so it's recommended to use it always.
 */</span></span>
<span class="marker" id="mapping-183"></span><span class="token add" data-title="source_file/library_declaration">library SafeMath <span class="marker" id="mapping-184"></span><span class="token add" data-title="library_declaration/contract_body">{
    /**
     * @dev Returns the addition of two unsigned integers, reverting on
     * overflow.
     *
     * Counterpart to Solidity's `+` operator.
     *
     * Requirements:
     *
     * - Addition cannot overflow.
     */
    <span class="marker" id="mapping-185"></span><span class="token add" data-title="contract_body/function_definition">function add(<span class="marker" id="mapping-186"></span><span class="token add" data-title="function_definition/parameter"><span class="marker" id="mapping-187"></span><span class="token mv" id="move-dst-63" data-title="parameter/type_name">uint256</span> a</span>, <span class="marker" id="mapping-188"></span><span class="token add" data-title="function_definition/parameter"><span class="marker" id="mapping-189"></span><span class="token mv" id="move-dst-67" data-title="parameter/type_name">uint256</span> b</span>) <span class="marker" id="mapping-190"></span><span class="token add" data-title="function_definition/visibility">internal</span> <span class="marker" id="mapping-191"></span><span class="token add" data-title="function_definition/state_mutability">pure</span> <span class="marker" id="mapping-192"></span><span class="token add" data-title="function_definition/return_type_definition">returns (uint256)</span> <span class="marker" id="mapping-193"></span><span class="token add" data-title="function_definition/function_body">{
        <span class="marker" id="mapping-194"></span><span class="token mv" id="move-dst-32" data-title="function_body/variable_declaration_statement">uint256 <span class="marker" id="mapping-195"></span><span class="token upd" id="move-dst-33" data-title="variable_declaration/identifier">c</span> <span class="marker" id="mapping-196"></span><span class="token add" data-title="variable_declaration_statement/=">=</span> <span class="marker" id="mapping-197"></span><span class="token add" data-title="variable_declaration_statement/binary_expression">a + b</span>;</span>
        <span class="marker" id="mapping-198"></span><span class="token add" data-title="function_body/expression_statement"><span class="marker" id="mapping-199"></span><span class="token add" data-title="expression_statement/call_expression">require(<span class="marker" id="mapping-200"></span><span class="token add" data-title="call_expression/call_argument">c &gt;= a</span>, <span class="marker" id="mapping-201"></span><span class="token mv" id="move-dst-21" data-title="call_expression/call_argument">"SafeMath: addition overflow"</span>)</span>;</span>

        <span class="marker" id="mapping-202"></span><span class="token add" data-title="function_body/return_statement">return c;</span>
    }</span></span>

    /**
     * @dev Returns the subtraction of two unsigned integers, reverting on
     * overflow (when the result is negative).
     *
     * Counterpart to Solidity's `-` operator.
     *
     * Requirements:
     *
     * - Subtraction cannot overflow.
     */
    <span class="marker" id="mapping-203"></span><span class="token add" data-title="contract_body/function_definition">function sub(<span class="marker" id="mapping-204"></span><span class="token add" data-title="function_definition/parameter"><span class="marker" id="mapping-205"></span><span class="token mv" id="move-dst-52" data-title="parameter/type_name">uint256</span> a</span>, <span class="marker" id="mapping-206"></span><span class="token add" data-title="function_definition/parameter"><span class="marker" id="mapping-207"></span><span class="token mv" id="move-dst-81" data-title="parameter/type_name">uint256</span> b</span>) <span class="marker" id="mapping-208"></span><span class="token add" data-title="function_definition/visibility">internal</span> <span class="marker" id="mapping-209"></span><span class="token add" data-title="function_definition/state_mutability">pure</span> <span class="marker" id="mapping-210"></span><span class="token add" data-title="function_definition/return_type_definition">returns (uint256)</span> <span class="marker" id="mapping-211"></span><span class="token add" data-title="function_definition/function_body">{
        <span class="marker" id="mapping-212"></span><span class="token add" data-title="function_body/return_statement">return <span class="marker" id="mapping-213"></span><span class="token mv" id="move-dst-55" data-title="return_statement/call_expression"><span class="marker" id="mapping-214"></span><span class="token upd" id="move-dst-56" data-title="call_expression/identifier">sub</span>(<span class="marker" id="mapping-215"></span><span class="token add" data-title="call_expression/call_argument">a</span>, <span class="marker" id="mapping-216"></span><span class="token add" data-title="call_expression/call_argument">b</span><span class="marker" id="mapping-217"></span><span class="token add" data-title="call_expression/,">,</span> "SafeMath: subtraction overflow")</span>;</span>
    }</span></span>

    /**
     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on
     * overflow (when the result is negative).
     *
     * Counterpart to Solidity's `-` operator.
     *
     * Requirements:
     *
     * - Subtraction cannot overflow.
     */
    <span class="marker" id="mapping-218"></span><span class="token add" data-title="contract_body/function_definition">function sub(<span class="marker" id="mapping-219"></span><span class="token add" data-title="function_definition/parameter"><span class="marker" id="mapping-220"></span><span class="token mv" id="move-dst-58" data-title="parameter/type_name">uint256</span> a</span>, <span class="marker" id="mapping-221"></span><span class="token add" data-title="function_definition/parameter"><span class="marker" id="mapping-222"></span><span class="token mv" id="move-dst-66" data-title="parameter/type_name">uint256</span> b</span>, <span class="marker" id="mapping-223"></span><span class="token add" data-title="function_definition/parameter">string memory errorMessage</span>) <span class="marker" id="mapping-224"></span><span class="token add" data-title="function_definition/visibility">internal</span> <span class="marker" id="mapping-225"></span><span class="token add" data-title="function_definition/state_mutability">pure</span> <span class="marker" id="mapping-226"></span><span class="token add" data-title="function_definition/return_type_definition">returns (uint256)</span> <span class="marker" id="mapping-227"></span><span class="token add" data-title="function_definition/function_body">{
        <span class="marker" id="mapping-228"></span><span class="token add" data-title="function_body/expression_statement">require(b &lt;= a, errorMessage);</span>
        <span class="marker" id="mapping-229"></span><span class="token add" data-title="function_body/variable_declaration_statement"><span class="marker" id="mapping-230"></span><span class="token mv" id="move-dst-30" data-title="variable_declaration_statement/variable_declaration">uint256 <span class="marker" id="mapping-231"></span><span class="token upd" id="move-dst-31" data-title="variable_declaration/identifier">c</span></span> = <span class="marker" id="mapping-232"></span><span class="token add" data-title="variable_declaration_statement/binary_expression">a - b</span>;</span>

        <span class="marker" id="mapping-233"></span><span class="token add" data-title="function_body/return_statement">return c;</span>
    }</span></span>

    /**
     * @dev Returns the multiplication of two unsigned integers, reverting on
     * overflow.
     *
     * Counterpart to Solidity's `*` operator.
     *
     * Requirements:
     *
     * - Multiplication cannot overflow.
     */
    <span class="marker" id="mapping-234"></span><span class="token add" data-title="contract_body/function_definition">function mul(<span class="marker" id="mapping-235"></span><span class="token add" data-title="function_definition/parameter"><span class="marker" id="mapping-236"></span><span class="token mv" id="move-dst-61" data-title="parameter/type_name">uint256</span> a</span>, <span class="marker" id="mapping-237"></span><span class="token add" data-title="function_definition/parameter"><span class="marker" id="mapping-238"></span><span class="token mv" id="move-dst-75" data-title="parameter/type_name">uint256</span> b</span>) <span class="marker" id="mapping-239"></span><span class="token add" data-title="function_definition/visibility">internal</span> <span class="marker" id="mapping-240"></span><span class="token add" data-title="function_definition/state_mutability">pure</span> <span class="marker" id="mapping-241"></span><span class="token mv" id="move-dst-92" data-title="function_definition/return_type_definition">returns (uint256)</span> <span class="marker" id="mapping-242"></span><span class="token add" data-title="function_definition/function_body">{
        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the
        // benefit is lost if 'b' is also tested.
        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522
        <span class="marker" id="mapping-243"></span><span class="token add" data-title="function_body/if_statement">if (a == 0) {
            return 0;
        }</span>

        <span class="marker" id="mapping-244"></span><span class="token mv" id="move-dst-24" data-title="function_body/variable_declaration_statement">uint256 <span class="marker" id="mapping-245"></span><span class="token upd" id="move-dst-25" data-title="variable_declaration/identifier">c</span> = <span class="marker" id="mapping-246"></span><span class="token add" data-title="variable_declaration_statement/binary_expression">a * b</span>;</span>
        <span class="marker" id="mapping-247"></span><span class="token mv" id="move-dst-17" data-title="function_body/expression_statement">require(<span class="marker" id="mapping-248"></span><span class="token add" data-title="binary_expression/binary_expression">c / a</span> <span class="marker" id="mapping-249"></span><span class="token add" data-title="binary_expression/==">==</span> <span class="marker" id="mapping-250"></span><span class="token add" data-title="binary_expression/identifier">b</span>, "SafeMath: multiplication overflow");</span>

        <span class="marker" id="mapping-251"></span><span class="token add" data-title="function_body/return_statement">return c;</span>
    }</span></span>

    /**
     * @dev Returns the integer division of two unsigned integers. Reverts on
     * division by zero. The result is rounded towards zero.
     *
     * Counterpart to Solidity's `/` operator. Note: this function uses a
     * `revert` opcode (which leaves remaining gas untouched) while Solidity
     * uses an invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     *
     * - The divisor cannot be zero.
     */
    <span class="marker" id="mapping-252"></span><span class="token add" data-title="contract_body/function_definition">function div(<span class="marker" id="mapping-253"></span><span class="token add" data-title="function_definition/parameter"><span class="marker" id="mapping-254"></span><span class="token mv" id="move-dst-59" data-title="parameter/type_name">uint256</span> a</span>, <span class="marker" id="mapping-255"></span><span class="token add" data-title="function_definition/parameter"><span class="marker" id="mapping-256"></span><span class="token mv" id="move-dst-83" data-title="parameter/type_name">uint256</span> b</span>) <span class="marker" id="mapping-257"></span><span class="token add" data-title="function_definition/visibility">internal</span> <span class="marker" id="mapping-258"></span><span class="token add" data-title="function_definition/state_mutability">pure</span> <span class="marker" id="mapping-259"></span><span class="token mv" id="move-dst-87" data-title="function_definition/return_type_definition">returns (uint256)</span> <span class="marker" id="mapping-260"></span><span class="token add" data-title="function_definition/function_body">{
        <span class="marker" id="mapping-261"></span><span class="token add" data-title="function_body/return_statement">return <span class="marker" id="mapping-262"></span><span class="token mv" id="move-dst-47" data-title="return_statement/call_expression"><span class="marker" id="mapping-263"></span><span class="token upd" id="move-dst-48" data-title="call_expression/identifier">div</span>(<span class="marker" id="mapping-264"></span><span class="token add" data-title="call_expression/call_argument">a</span>, <span class="marker" id="mapping-265"></span><span class="token add" data-title="call_expression/call_argument">b</span><span class="marker" id="mapping-266"></span><span class="token add" data-title="call_expression/,">,</span> "SafeMath: division by zero")</span>;</span>
    }</span></span>

    /**
     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on
     * division by zero. The result is rounded towards zero.
     *
     * Counterpart to Solidity's `/` operator. Note: this function uses a
     * `revert` opcode (which leaves remaining gas untouched) while Solidity
     * uses an invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     *
     * - The divisor cannot be zero.
     */
    <span class="marker" id="mapping-267"></span><span class="token add" data-title="contract_body/function_definition">function div(<span class="marker" id="mapping-268"></span><span class="token add" data-title="function_definition/parameter"><span class="marker" id="mapping-269"></span><span class="token mv" id="move-dst-79" data-title="parameter/type_name">uint256</span> a</span>, <span class="marker" id="mapping-270"></span><span class="token add" data-title="function_definition/parameter"><span class="marker" id="mapping-271"></span><span class="token mv" id="move-dst-89" data-title="parameter/type_name">uint256</span> b</span>, <span class="marker" id="mapping-272"></span><span class="token add" data-title="function_definition/parameter">string memory errorMessage</span>) <span class="marker" id="mapping-273"></span><span class="token add" data-title="function_definition/visibility">internal</span> <span class="marker" id="mapping-274"></span><span class="token add" data-title="function_definition/state_mutability">pure</span> <span class="marker" id="mapping-275"></span><span class="token mv" id="move-dst-78" data-title="function_definition/return_type_definition">returns (uint256)</span> <span class="marker" id="mapping-276"></span><span class="token add" data-title="function_definition/function_body">{
        <span class="marker" id="mapping-277"></span><span class="token add" data-title="function_body/expression_statement">require(b &gt; 0, errorMessage);</span>
        <span class="marker" id="mapping-278"></span><span class="token mv" id="move-dst-34" data-title="function_body/variable_declaration_statement">uint256 <span class="marker" id="mapping-279"></span><span class="token upd" id="move-dst-35" data-title="variable_declaration/identifier">c</span> = <span class="marker" id="mapping-280"></span><span class="token add" data-title="variable_declaration_statement/binary_expression">a / b</span>;</span>
        // assert(a == b * c + a % b); // There is no case in which this doesn't hold

        <span class="marker" id="mapping-281"></span><span class="token add" data-title="function_body/return_statement">return c;</span>
    }</span></span>

    /**
     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),
     * Reverts when dividing by zero.
     *
     * Counterpart to Solidity's `%` operator. This function uses a `revert`
     * opcode (which leaves remaining gas untouched) while Solidity uses an
     * invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     *
     * - The divisor cannot be zero.
     */
    <span class="marker" id="mapping-282"></span><span class="token add" data-title="contract_body/function_definition">function mod(<span class="marker" id="mapping-283"></span><span class="token add" data-title="function_definition/parameter"><span class="marker" id="mapping-284"></span><span class="token mv" id="move-dst-88" data-title="parameter/type_name">uint256</span> a</span>, <span class="marker" id="mapping-285"></span><span class="token add" data-title="function_definition/parameter"><span class="marker" id="mapping-286"></span><span class="token mv" id="move-dst-93" data-title="parameter/type_name">uint256</span> b</span>) <span class="marker" id="mapping-287"></span><span class="token add" data-title="function_definition/visibility">internal</span> <span class="marker" id="mapping-288"></span><span class="token add" data-title="function_definition/state_mutability">pure</span> <span class="marker" id="mapping-289"></span><span class="token mv" id="move-dst-42" data-title="function_definition/return_type_definition">returns (uint256)</span> <span class="marker" id="mapping-290"></span><span class="token add" data-title="function_definition/function_body">{
        <span class="marker" id="mapping-291"></span><span class="token add" data-title="function_body/return_statement">return <span class="marker" id="mapping-292"></span><span class="token mv" id="move-dst-43" data-title="return_statement/call_expression"><span class="marker" id="mapping-293"></span><span class="token upd" id="move-dst-44" data-title="call_expression/identifier">mod</span>(<span class="marker" id="mapping-294"></span><span class="token add" data-title="call_expression/call_argument">a</span>, <span class="marker" id="mapping-295"></span><span class="token add" data-title="call_expression/call_argument">b</span><span class="marker" id="mapping-296"></span><span class="token add" data-title="call_expression/,">,</span> "SafeMath: modulo by zero")</span>;</span>
    }</span></span>

    /**
     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),
     * Reverts with custom message when dividing by zero.
     *
     * Counterpart to Solidity's `%` operator. This function uses a `revert`
     * opcode (which leaves remaining gas untouched) while Solidity uses an
     * invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     *
     * - The divisor cannot be zero.
     */
    <span class="marker" id="mapping-297"></span><span class="token add" data-title="contract_body/function_definition">function mod(<span class="marker" id="mapping-298"></span><span class="token mv" id="move-dst-96" data-title="function_definition/parameter">uint256 <span class="marker" id="mapping-299"></span><span class="token upd" id="move-dst-97" data-title="parameter/identifier">a</span></span>, <span class="marker" id="mapping-300"></span><span class="token mv" id="move-dst-98" data-title="function_definition/parameter">uint256 <span class="marker" id="mapping-301"></span><span class="token upd" id="move-dst-99" data-title="parameter/identifier">b</span></span>, <span class="marker" id="mapping-302"></span><span class="token add" data-title="function_definition/parameter">string memory errorMessage</span>) <span class="marker" id="mapping-303"></span><span class="token add" data-title="function_definition/visibility">internal</span> <span class="marker" id="mapping-304"></span><span class="token add" data-title="function_definition/state_mutability">pure</span> <span class="marker" id="mapping-305"></span><span class="token mv" id="move-dst-62" data-title="function_definition/return_type_definition">returns (uint256)</span> <span class="marker" id="mapping-306"></span><span class="token add" data-title="function_definition/function_body">{
        require(b != 0, errorMessage);
        return a % b;
    }</span></span>
}</span></span>

<span class="marker" id="mapping-307"></span><span class="token add" data-title="source_file/comment">// File: @openzeppelin/contracts/utils/Address.sol</span>

<span class="marker" id="mapping-308"></span><span class="token add" data-title="source_file/comment">// SPDX-License-Identifier: MIT</span>

<span class="marker" id="mapping-309"></span><span class="token mv" id="move-dst-6" data-title="source_file/pragma_directive">pragma solidity ^0.6.2;</span>

<span class="marker" id="mapping-310"></span><span class="token add" data-title="source_file/comment">/**
 * @dev Collection of functions related to the address type
 */</span>
<span class="marker" id="mapping-311"></span><span class="token mv" id="move-dst-9" data-title="source_file/library_declaration">library Address {
    /**
     * @dev Returns true if `account` is a contract.
     *
     * [IMPORTANT]
     * ====
     * It is unsafe to assume that an address for which this function returns
     * false is an externally-owned account (EOA) and not a contract.
     *
     * Among others, `isContract` will return false for the following
     * types of addresses:
     *
     *  - an externally-owned account
     *  - a contract in construction
     *  - an address where a contract will be created
     *  - an address where a contract lived, but was destroyed
     * ====
     */
    function isContract(address account) internal view returns (bool) {
        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts
        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned
        // for accounts without code, i.e. `keccak256('')`
        bytes32 codehash;
        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;
        // solhint-disable-next-line no-inline-assembly
        assembly { codehash := extcodehash(account) }
        return (codehash != accountHash &amp;&amp; codehash != 0x0);
    }

    /**
     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to
     * `recipient`, forwarding all available gas and reverting on errors.
     *
     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost
     * of certain opcodes, possibly making contracts go over the 2300 gas limit
     * imposed by `transfer`, making them unable to receive funds via
     * `transfer`. {sendValue} removes this limitation.
     *
     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].
     *
     * IMPORTANT: because control is transferred to `recipient`, care must be
     * taken to not create reentrancy vulnerabilities. Consider using
     * {ReentrancyGuard} or the
     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].
     */
    function sendValue(address payable recipient, uint256 amount) internal {
        require(address(this).balance &gt;= amount, "Address: insufficient balance");

        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value
        (bool success, ) = recipient.call{ value: amount }("");
        require(success, "Address: unable to send value, recipient may have reverted");
    }

    /**
     * @dev Performs a Solidity function call using a low level `call`. A
     * plain`call` is an unsafe replacement for a function call: use this
     * function instead.
     *
     * If `target` reverts with a revert reason, it is bubbled up by this
     * function (like regular Solidity function calls).
     *
     * Returns the raw returned data. To convert to the expected return value,
     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].
     *
     * Requirements:
     *
     * - `target` must be a contract.
     * - calling `target` with `data` must not revert.
     *
     * _Available since v3.1._
     */
    function functionCall(address target, bytes memory data) internal returns (bytes memory) {
      return functionCall(target, data, "Address: low-level call failed");
    }

    /**
     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with
     * `errorMessage` as a fallback revert reason when `target` reverts.
     *
     * _Available since v3.1._
     */
    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {
        return _functionCallWithValue(target, data, 0, errorMessage);
    }

    /**
     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],
     * but also transferring `value` wei to `target`.
     *
     * Requirements:
     *
     * - the calling contract must have an ETH balance of at least `value`.
     * - the called Solidity function must be `payable`.
     *
     * _Available since v3.1._
     */
    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {
        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");
    }

    /**
     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but
     * with `errorMessage` as a fallback revert reason when `target` reverts.
     *
     * _Available since v3.1._
     */
    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {
        require(address(this).balance &gt;= value, "Address: insufficient balance for call");
        return _functionCallWithValue(target, data, value, errorMessage);
    }

    function _functionCallWithValue(address target, bytes memory data, uint256 weiValue, string memory errorMessage) private returns (bytes memory) {
        require(isContract(target), "Address: call to non-contract");

        // solhint-disable-next-line avoid-low-level-calls
        (bool success, bytes memory returndata) = target.call{ value: weiValue }(data);
        if (success) {
            return returndata;
        } else {
            // Look for revert reason and bubble it up if present
            if (returndata.length &gt; 0) {
                // The easiest way to bubble the revert reason is using memory via assembly

                // solhint-disable-next-line no-inline-assembly
                assembly {
                    let returndata_size := mload(returndata)
                    revert(add(32, returndata), returndata_size)
                }
            } else {
                revert(errorMessage);
            }
        }
    }
}</span>

<span class="marker" id="mapping-312"></span><span class="token add" data-title="source_file/comment">// File: @openzeppelin/contracts/token/ERC20/SafeERC20.sol</span>

<span class="marker" id="mapping-313"></span><span class="token add" data-title="source_file/comment">// SPDX-License-Identifier: MIT</span>

<span class="marker" id="mapping-314"></span><span class="token mv" id="move-dst-10" data-title="source_file/pragma_directive">pragma solidity ^0.6.0;</span>




<span class="marker" id="mapping-315"></span><span class="token add" data-title="source_file/comment">/**
 * @title SafeERC20
 * @dev Wrappers around ERC20 operations that throw on failure (when the token
 * contract returns false). Tokens that return no value (and instead revert or
 * throw on failure) are also supported, non-reverting calls are assumed to be
 * successful.
 * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,
 * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.
 */</span>
<span class="marker" id="mapping-316"></span><span class="token add" data-title="source_file/library_declaration">library SafeERC20 <span class="marker" id="mapping-317"></span><span class="token add" data-title="library_declaration/contract_body">{
    <span class="marker" id="mapping-318"></span><span class="token add" data-title="contract_body/using_directive">using <span class="marker" id="mapping-319"></span><span class="token add" data-title="using_directive/type_alias">SafeMath</span> for <span class="marker" id="mapping-320"></span><span class="token mv" id="move-dst-14" data-title="using_directive/type_name">uint256</span>;</span>
    <span class="marker" id="mapping-321"></span><span class="token add" data-title="contract_body/using_directive">using Address for address;</span>

    <span class="marker" id="mapping-322"></span><span class="token add" data-title="contract_body/function_definition">function safeTransfer(<span class="marker" id="mapping-323"></span><span class="token add" data-title="function_definition/parameter">IERC20 token</span>, <span class="marker" id="mapping-324"></span><span class="token add" data-title="function_definition/parameter">address to</span>, <span class="marker" id="mapping-325"></span><span class="token add" data-title="function_definition/parameter"><span class="marker" id="mapping-326"></span><span class="token mv" id="move-dst-72" data-title="parameter/type_name">uint256</span> value</span>) <span class="marker" id="mapping-327"></span><span class="token add" data-title="function_definition/visibility">internal</span> <span class="marker" id="mapping-328"></span><span class="token add" data-title="function_definition/function_body">{
        <span class="marker" id="mapping-329"></span><span class="token add" data-title="function_body/expression_statement"><span class="marker" id="mapping-330"></span><span class="token add" data-title="expression_statement/call_expression">_callOptionalReturn(<span class="marker" id="mapping-331"></span><span class="token add" data-title="call_expression/call_argument">token</span>, <span class="marker" id="mapping-332"></span><span class="token add" data-title="call_expression/call_argument"><span class="marker" id="mapping-333"></span><span class="token add" data-title="call_argument/call_expression"><span class="marker" id="mapping-334"></span><span class="token add" data-title="call_expression/member_expression">abi.encodeWithSelector</span>(<span class="marker" id="mapping-335"></span><span class="token add" data-title="call_expression/call_argument"><span class="marker" id="mapping-336"></span><span class="token add" data-title="call_argument/member_expression"><span class="marker" id="mapping-337"></span><span class="token mv" id="move-dst-108" data-title="member_expression/member_expression">token.transfer</span>.selector</span></span>, <span class="marker" id="mapping-338"></span><span class="token add" data-title="call_expression/call_argument">to</span>, <span class="marker" id="mapping-339"></span><span class="token add" data-title="call_expression/call_argument">value</span>)</span></span>)</span>;</span>
    }</span></span>

    <span class="marker" id="mapping-340"></span><span class="token add" data-title="contract_body/function_definition">function safeTransferFrom(<span class="marker" id="mapping-341"></span><span class="token add" data-title="function_definition/parameter">IERC20 token</span>, <span class="marker" id="mapping-342"></span><span class="token add" data-title="function_definition/parameter">address from</span>, <span class="marker" id="mapping-343"></span><span class="token add" data-title="function_definition/parameter">address to</span>, <span class="marker" id="mapping-344"></span><span class="token add" data-title="function_definition/parameter"><span class="marker" id="mapping-345"></span><span class="token mv" id="move-dst-65" data-title="parameter/type_name">uint256</span> value</span>) <span class="marker" id="mapping-346"></span><span class="token add" data-title="function_definition/visibility">internal</span> <span class="marker" id="mapping-347"></span><span class="token add" data-title="function_definition/function_body">{
        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));
    }</span></span>

    /**
     * @dev Deprecated. This function has issues similar to the ones found in
     * {IERC20-approve}, and its usage is discouraged.
     *
     * Whenever possible, use {safeIncreaseAllowance} and
     * {safeDecreaseAllowance} instead.
     */
    <span class="marker" id="mapping-348"></span><span class="token add" data-title="contract_body/function_definition">function safeApprove(<span class="marker" id="mapping-349"></span><span class="token add" data-title="function_definition/parameter">IERC20 token</span>, <span class="marker" id="mapping-350"></span><span class="token add" data-title="function_definition/parameter">address spender</span>, <span class="marker" id="mapping-351"></span><span class="token mv" id="move-dst-100" data-title="function_definition/parameter">uint256 <span class="marker" id="mapping-352"></span><span class="token upd" id="move-dst-101" data-title="parameter/identifier">va<span class="cupd">l</span>ue</span></span>) <span class="marker" id="mapping-353"></span><span class="token add" data-title="function_definition/visibility">internal</span> <span class="marker" id="mapping-354"></span><span class="token add" data-title="function_definition/function_body">{
        // safeApprove should only be called when setting an initial allowance,
        // or when resetting it to zero. To increase and decrease it, use
        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'
        // solhint-disable-next-line max-line-length
        <span class="marker" id="mapping-355"></span><span class="token add" data-title="function_body/expression_statement"><span class="marker" id="mapping-356"></span><span class="token add" data-title="expression_statement/call_expression">require(<span class="marker" id="mapping-357"></span><span class="token add" data-title="call_expression/call_argument">(value == 0) || (token.allowance(address(this), spender) == 0)</span>,
            <span class="marker" id="mapping-358"></span><span class="token mv" id="move-dst-28" data-title="call_expression/call_argument">"SafeERC20: approve from non-zero to non-zero allowance"</span>
        )</span>;</span>
        <span class="marker" id="mapping-359"></span><span class="token add" data-title="function_body/expression_statement">_callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));</span>
    }</span></span>

    <span class="marker" id="mapping-360"></span><span class="token add" data-title="contract_body/function_definition">function safeIncreaseAllowance(<span class="marker" id="mapping-361"></span><span class="token add" data-title="function_definition/parameter">IERC20 token</span>, <span class="marker" id="mapping-362"></span><span class="token add" data-title="function_definition/parameter">address spender</span>, <span class="marker" id="mapping-363"></span><span class="token mv" id="move-dst-90" data-title="function_definition/parameter">uint256 <span class="marker" id="mapping-364"></span><span class="token upd" id="move-dst-91" data-title="parameter/identifier">value</span></span>) <span class="marker" id="mapping-365"></span><span class="token add" data-title="function_definition/visibility">internal</span> <span class="marker" id="mapping-366"></span><span class="token add" data-title="function_definition/function_body">{
        <span class="marker" id="mapping-367"></span><span class="token add" data-title="function_body/variable_declaration_statement"><span class="marker" id="mapping-368"></span><span class="token mv" id="move-dst-22" data-title="variable_declaration_statement/variable_declaration">uint256 <span class="marker" id="mapping-369"></span><span class="token upd" id="move-dst-23" data-title="variable_declaration/identifier">newAllowance</span></span> = <span class="marker" id="mapping-370"></span><span class="token add" data-title="variable_declaration_statement/call_expression">token.allowance(address(this), spender).add(value)</span>;</span>
        <span class="marker" id="mapping-371"></span><span class="token add" data-title="function_body/expression_statement">_callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));</span>
    }</span></span>

    <span class="marker" id="mapping-372"></span><span class="token add" data-title="contract_body/function_definition">function safeDecreaseAllowance(<span class="marker" id="mapping-373"></span><span class="token add" data-title="function_definition/parameter">IERC20 token</span>, <span class="marker" id="mapping-374"></span><span class="token add" data-title="function_definition/parameter">address spender</span>, <span class="marker" id="mapping-375"></span><span class="token mv" id="move-dst-85" data-title="function_definition/parameter">uint256 <span class="marker" id="mapping-376"></span><span class="token upd" id="move-dst-86" data-title="parameter/identifier">value</span></span>) <span class="marker" id="mapping-377"></span><span class="token add" data-title="function_definition/visibility">internal</span> <span class="marker" id="mapping-378"></span><span class="token add" data-title="function_definition/function_body">{
        <span class="marker" id="mapping-379"></span><span class="token add" data-title="function_body/variable_declaration_statement"><span class="marker" id="mapping-380"></span><span class="token mv" id="move-dst-18" data-title="variable_declaration_statement/variable_declaration">uint256 <span class="marker" id="mapping-381"></span><span class="token upd" id="move-dst-19" data-title="variable_declaration/identifier">newAllowance</span></span> = <span class="marker" id="mapping-382"></span><span class="token add" data-title="variable_declaration_statement/call_expression"><span class="marker" id="mapping-383"></span><span class="token add" data-title="call_expression/member_expression">token.allowance(address(this), spender).sub</span>(<span class="marker" id="mapping-384"></span><span class="token add" data-title="call_expression/call_argument">value</span>, <span class="marker" id="mapping-385"></span><span class="token mv" id="move-dst-40" data-title="call_expression/call_argument">"SafeERC20: decreased allowance below zero"</span>)</span>;</span>
        <span class="marker" id="mapping-386"></span><span class="token add" data-title="function_body/expression_statement">_callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));</span>
    }</span></span>

    /**
     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement
     * on the return value: the return value is optional (but if data is returned, it must not be false).
     * @param token The token targeted by the call.
     * @param data The call data (encoded using abi.encode or one of its variants).
     */
    <span class="marker" id="mapping-387"></span><span class="token add" data-title="contract_body/function_definition">function _callOptionalReturn(<span class="marker" id="mapping-388"></span><span class="token add" data-title="function_definition/parameter">IERC20 token</span>, <span class="marker" id="mapping-389"></span><span class="token add" data-title="function_definition/parameter">bytes memory data</span>) <span class="marker" id="mapping-390"></span><span class="token add" data-title="function_definition/visibility">private</span> <span class="marker" id="mapping-391"></span><span class="token add" data-title="function_definition/function_body">{
        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since
        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that
        // the target address contains contract code and also asserts for success in the low-level call.

        <span class="marker" id="mapping-392"></span><span class="token add" data-title="function_body/variable_declaration_statement"><span class="marker" id="mapping-393"></span><span class="token add" data-title="variable_declaration_statement/variable_declaration">bytes memory returndata</span> = <span class="marker" id="mapping-394"></span><span class="token add" data-title="variable_declaration_statement/call_expression"><span class="marker" id="mapping-395"></span><span class="token add" data-title="call_expression/member_expression">address(token).functionCall</span>(<span class="marker" id="mapping-396"></span><span class="token add" data-title="call_expression/call_argument">data</span>, <span class="marker" id="mapping-397"></span><span class="token mv" id="move-dst-41" data-title="call_expression/call_argument">"SafeERC20: low-level call failed"</span>)</span>;</span>
        <span class="marker" id="mapping-398"></span><span class="token add" data-title="function_body/if_statement">if (<span class="marker" id="mapping-399"></span><span class="token add" data-title="if_statement/binary_expression">returndata.length &gt; 0</span>) <span class="marker" id="mapping-400"></span><span class="token add" data-title="if_statement/block_statement">{ // Return data is optional
            // solhint-disable-next-line max-line-length
            <span class="marker" id="mapping-401"></span><span class="token add" data-title="block_statement/expression_statement"><span class="marker" id="mapping-402"></span><span class="token add" data-title="expression_statement/call_expression">require(<span class="marker" id="mapping-403"></span><span class="token add" data-title="call_expression/call_argument">abi.decode(returndata, (bool))</span>, <span class="marker" id="mapping-404"></span><span class="token mv" id="move-dst-84" data-title="call_expression/call_argument">"SafeERC20: ERC20 operation did not succeed"</span>)</span>;</span>
        }</span></span>
    }</span></span>
}</span></span>

// File: contracts/root/RootToken/IMintableERC20.sol

<span class="marker" id="mapping-405"></span><span class="token mv" id="move-dst-12" data-title="source_file/pragma_directive">pragma solidity 0.6.6;</span>

interface IMintableERC20 is IERC20 {
    /**
     * @notice called by predicate contract to mint tokens while withdrawing
     * @dev Should be callable only by MintableERC20Predicate
     * Make sure minting is done only by this function
     * @param user user address for whom token is being minted
     * @param amount amount of token being minted
     */
    function mint(address user, uint256 amount) external;
}

// File: @openzeppelin/contracts/utils/EnumerableSet.sol

// SPDX-License-Identifier: MIT

<span class="marker" id="mapping-406"></span><span class="token mv" id="move-dst-11" data-title="source_file/pragma_directive">pragma solidity ^0.6.0;</span>

/**
 * @dev Library for managing
 * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive
 * types.
 *
 * Sets have the following properties:
 *
 * - Elements are added, removed, and checked for existence in constant time
 * (O(1)).
 * - Elements are enumerated in O(n). No guarantees are made on the ordering.
 *
 * ```
 * contract Example {
 *     // Add the library methods
 *     using EnumerableSet for EnumerableSet.AddressSet;
 *
 *     // Declare a set state variable
 *     EnumerableSet.AddressSet private mySet;
 * }
 * ```
 *
 * As of v3.0.0, only sets of type `address` (`AddressSet`) and `uint256`
 * (`UintSet`) are supported.
 */
library EnumerableSet {
    // To implement this library for multiple types with as little code
    // repetition as possible, we write it in terms of a generic Set type with
    // bytes32 values.
    // The Set implementation uses private functions, and user-facing
    // implementations (such as AddressSet) are just wrappers around the
    // underlying Set.
    // This means that we can only create new EnumerableSets for types that fit
    // in bytes32.

    struct Set {
        // Storage of set values
        bytes32[] _values;

        // Position of the value in the `values` array, plus 1 because index 0
        // means a value is not in the set.
        mapping (bytes32 =&gt; uint256) _indexes;
    }

    /**
     * @dev Add a value to a set. O(1).
     *
     * Returns true if the value was added to the set, that is if it was not
     * already present.
     */
    function _add(Set storage set, bytes32 value) private returns (bool) {
        if (!_contains(set, value)) {
            set._values.push(value);
            // The value is stored at length-1, but we add 1 to all indexes
            // and use 0 as a sentinel value
            set._indexes[value] = set._values.length;
            return true;
        } else {
            return false;
        }
    }

    /**
     * @dev Removes a value from a set. O(1).
     *
     * Returns true if the value was removed from the set, that is if it was
     * present.
     */
    function _remove(Set storage set, bytes32 value) private returns (bool) {
        // We read and store the value's index to prevent multiple reads from the same storage slot
        uint256 valueIndex = set._indexes[value];

        if (valueIndex != 0) { // Equivalent to contains(set, value)
            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in
            // the array, and then remove the last element (sometimes called as 'swap and pop').
            // This modifies the order of the array, as noted in {at}.

            uint256 toDeleteIndex = valueIndex - 1;
            uint256 lastIndex = set._values.length - 1;

            // When the value to delete is the last one, the swap operation is unnecessary. However, since this occurs
            // so rarely, we still do the swap anyway to avoid the gas cost of adding an 'if' statement.

            bytes32 lastvalue = set._values[lastIndex];

            // Move the last value to the index where the value to delete is
            set._values[toDeleteIndex] = lastvalue;
            // Update the index for the moved value
            set._indexes[lastvalue] = toDeleteIndex + 1; // All indexes are 1-based

            // Delete the slot where the moved value was stored
            set._values.pop();

            // Delete the index for the deleted slot
            delete set._indexes[value];

            return true;
        } else {
            return false;
        }
    }

    /**
     * @dev Returns true if the value is in the set. O(1).
     */
    function _contains(Set storage set, bytes32 value) private view returns (bool) {
        return set._indexes[value] != 0;
    }

    /**
     * @dev Returns the number of values on the set. O(1).
     */
    function _length(Set storage set) private view returns (uint256) {
        return set._values.length;
    }

   /**
    * @dev Returns the value stored at position `index` in the set. O(1).
    *
    * Note that there are no guarantees on the ordering of values inside the
    * array, and it may change when more values are added or removed.
    *
    * Requirements:
    *
    * - `index` must be strictly less than {length}.
    */
    function _at(Set storage set, uint256 index) private view returns (bytes32) {
        require(set._values.length &gt; index, "EnumerableSet: index out of bounds");
        return set._values[index];
    }

    // AddressSet

    struct AddressSet {
        Set _inner;
    }

    /**
     * @dev Add a value to a set. O(1).
     *
     * Returns true if the value was added to the set, that is if it was not
     * already present.
     */
    function add(AddressSet storage set, address value) internal returns (bool) {
        return _add(set._inner, bytes32(uint256(value)));
    }

    /**
     * @dev Removes a value from a set. O(1).
     *
     * Returns true if the value was removed from the set, that is if it was
     * present.
     */
    function remove(AddressSet storage set, address value) internal returns (bool) {
        return _remove(set._inner, bytes32(uint256(value)));
    }

    /**
     * @dev Returns true if the value is in the set. O(1).
     */
    function contains(AddressSet storage set, address value) internal view returns (bool) {
        return _contains(set._inner, bytes32(uint256(value)));
    }

    /**
     * @dev Returns the number of values in the set. O(1).
     */
    function length(AddressSet storage set) internal view returns (uint256) {
        return _length(set._inner);
    }

   /**
    * @dev Returns the value stored at position `index` in the set. O(1).
    *
    * Note that there are no guarantees on the ordering of values inside the
    * array, and it may change when more values are added or removed.
    *
    * Requirements:
    *
    * - `index` must be strictly less than {length}.
    */
    function at(AddressSet storage set, uint256 index) internal view returns (address) {
        return address(uint256(_at(set._inner, index)));
    }


    // UintSet

    struct UintSet {
        Set _inner;
    }

    /**
     * @dev Add a value to a set. O(1).
     *
     * Returns true if the value was added to the set, that is if it was not
     * already present.
     */
    function add(UintSet storage set, uint256 value) internal returns (bool) {
        return _add(set._inner, bytes32(value));
    }

    /**
     * @dev Removes a value from a set. O(1).
     *
     * Returns true if the value was removed from the set, that is if it was
     * present.
     */
    function remove(UintSet storage set, uint256 value) internal returns (bool) {
        return _remove(set._inner, bytes32(value));
    }

    /**
     * @dev Returns true if the value is in the set. O(1).
     */
    function contains(UintSet storage set, uint256 value) internal view returns (bool) {
        return _contains(set._inner, bytes32(value));
    }

    /**
     * @dev Returns the number of values on the set. O(1).
     */
    function length(UintSet storage set) internal view returns (uint256) {
        return _length(set._inner);
    }

   /**
    * @dev Returns the value stored at position `index` in the set. O(1).
    *
    * Note that there are no guarantees on the ordering of values inside the
    * array, and it may change when more values are added or removed.
    *
    * Requirements:
    *
    * - `index` must be strictly less than {length}.
    */
    function at(UintSet storage set, uint256 index) internal view returns (uint256) {
        return uint256(_at(set._inner, index));
    }
}

// File: @openzeppelin/contracts/GSN/Context.sol

// SPDX-License-Identifier: MIT

<span class="marker" id="mapping-407"></span><span class="token add" data-title="source_file/pragma_directive">pragma solidity ^0.6.0;</span>

/*
 * @dev Provides information about the current execution context, including the
 * sender of the transaction and its data. While these are generally available
 * via msg.sender and msg.data, they should not be accessed in such a direct
 * manner, since when dealing with GSN meta-transactions the account sending and
 * paying for execution may not be the actual sender (as far as an application
 * is concerned).
 *
 * This contract is only required for intermediate, library-like contracts.
 */
abstract contract Context {
    function _msgSender() internal view virtual returns (address payable) {
        return msg.sender;
    }

    function _msgData() internal view virtual returns (bytes memory) {
        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691
        return msg.data;
    }
}

// File: @openzeppelin/contracts/access/AccessControl.sol

// SPDX-License-Identifier: MIT

<span class="marker" id="mapping-408"></span><span class="token add" data-title="source_file/pragma_directive">pragma solidity ^0.6.0;</span>




/**
 * @dev Contract module that allows children to implement role-based access
 * control mechanisms.
 *
 * Roles are referred to by their `bytes32` identifier. These should be exposed
 * in the external API and be unique. The best way to achieve this is by
 * using `public constant` hash digests:
 *
 * ```
 * bytes32 public constant MY_ROLE = keccak256("MY_ROLE");
 * ```
 *
 * Roles can be used to represent a set of permissions. To restrict access to a
 * function call, use {hasRole}:
 *
 * ```
 * function foo() public {
 *     require(hasRole(MY_ROLE, msg.sender));
 *     ...
 * }
 * ```
 *
 * Roles can be granted and revoked dynamically via the {grantRole} and
 * {revokeRole} functions. Each role has an associated admin role, and only
 * accounts that have a role's admin role can call {grantRole} and {revokeRole}.
 *
 * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means
 * that only accounts with this role will be able to grant or revoke other
 * roles. More complex role relationships can be created by using
 * {_setRoleAdmin}.
 *
 * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to
 * grant and revoke this role. Extra precautions should be taken to secure
 * accounts that have been granted it.
 */
abstract contract AccessControl is Context {
    using EnumerableSet for EnumerableSet.AddressSet;
    using Address for address;

    struct RoleData {
        EnumerableSet.AddressSet members;
        bytes32 adminRole;
    }

    mapping (bytes32 =&gt; RoleData) private _roles;

    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;

    /**
     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`
     *
     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite
     * {RoleAdminChanged} not being emitted signaling this.
     *
     * _Available since v3.1._
     */
    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);

    /**
     * @dev Emitted when `account` is granted `role`.
     *
     * `sender` is the account that originated the contract call, an admin role
     * bearer except when using {_setupRole}.
     */
    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);

    /**
     * @dev Emitted when `account` is revoked `role`.
     *
     * `sender` is the account that originated the contract call:
     *   - if using `revokeRole`, it is the admin role bearer
     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)
     */
    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);

    /**
     * @dev Returns `true` if `account` has been granted `role`.
     */
    function hasRole(bytes32 role, address account) public view returns (bool) {
        return _roles[role].members.contains(account);
    }

    /**
     * @dev Returns the number of accounts that have `role`. Can be used
     * together with {getRoleMember} to enumerate all bearers of a role.
     */
    function getRoleMemberCount(bytes32 role) public view returns (uint256) {
        return _roles[role].members.length();
    }

    /**
     * @dev Returns one of the accounts that have `role`. `index` must be a
     * value between 0 and {getRoleMemberCount}, non-inclusive.
     *
     * Role bearers are not sorted in any particular way, and their ordering may
     * change at any point.
     *
     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure
     * you perform all queries on the same block. See the following
     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]
     * for more information.
     */
    function getRoleMember(bytes32 role, uint256 index) public view returns (address) {
        return _roles[role].members.at(index);
    }

    /**
     * @dev Returns the admin role that controls `role`. See {grantRole} and
     * {revokeRole}.
     *
     * To change a role's admin, use {_setRoleAdmin}.
     */
    function getRoleAdmin(bytes32 role) public view returns (bytes32) {
        return _roles[role].adminRole;
    }

    /**
     * @dev Grants `role` to `account`.
     *
     * If `account` had not been already granted `role`, emits a {RoleGranted}
     * event.
     *
     * Requirements:
     *
     * - the caller must have ``role``'s admin role.
     */
    function grantRole(bytes32 role, address account) public virtual {
        require(hasRole(_roles[role].adminRole, _msgSender()), "AccessControl: sender must be an admin to grant");

        _grantRole(role, account);
    }

    /**
     * @dev Revokes `role` from `account`.
     *
     * If `account` had been granted `role`, emits a {RoleRevoked} event.
     *
     * Requirements:
     *
     * - the caller must have ``role``'s admin role.
     */
    function revokeRole(bytes32 role, address account) public virtual {
        require(hasRole(_roles[role].adminRole, _msgSender()), "AccessControl: sender must be an admin to revoke");

        _revokeRole(role, account);
    }

    /**
     * @dev Revokes `role` from the calling account.
     *
     * Roles are often managed via {grantRole} and {revokeRole}: this function's
     * purpose is to provide a mechanism for accounts to lose their privileges
     * if they are compromised (such as when a trusted device is misplaced).
     *
     * If the calling account had been granted `role`, emits a {RoleRevoked}
     * event.
     *
     * Requirements:
     *
     * - the caller must be `account`.
     */
    function renounceRole(bytes32 role, address account) public virtual {
        require(account == _msgSender(), "AccessControl: can only renounce roles for self");

        _revokeRole(role, account);
    }

    /**
     * @dev Grants `role` to `account`.
     *
     * If `account` had not been already granted `role`, emits a {RoleGranted}
     * event. Note that unlike {grantRole}, this function doesn't perform any
     * checks on the calling account.
     *
     * [WARNING]
     * ====
     * This function should only be called from the constructor when setting
     * up the initial roles for the system.
     *
     * Using this function in any other way is effectively circumventing the admin
     * system imposed by {AccessControl}.
     * ====
     */
    function _setupRole(bytes32 role, address account) internal virtual {
        _grantRole(role, account);
    }

    /**
     * @dev Sets `adminRole` as ``role``'s admin role.
     *
     * Emits a {RoleAdminChanged} event.
     */
    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {
        emit RoleAdminChanged(role, _roles[role].adminRole, adminRole);
        _roles[role].adminRole = adminRole;
    }

    function _grantRole(bytes32 role, address account) private {
        if (_roles[role].members.add(account)) {
            emit RoleGranted(role, account, _msgSender());
        }
    }

    function _revokeRole(bytes32 role, address account) private {
        if (_roles[role].members.remove(account)) {
            emit RoleRevoked(role, account, _msgSender());
        }
    }
}

// File: contracts/common/AccessControlMixin.sol

<span class="marker" id="mapping-409"></span><span class="token mv" id="move-dst-104" data-title="source_file/pragma_directive">pragma solidity 0.6.6;</span>


contract AccessControlMixin is AccessControl {
    string private _revertMsg;
    function _setupContractId(string memory contractId) internal {
        _revertMsg = string(abi.encodePacked(contractId, ": INSUFFICIENT_PERMISSIONS"));
    }

    modifier only(bytes32 role) {
        require(
            hasRole(role, _msgSender()),
            _revertMsg
        );
        _;
    }
}

// File: contracts/lib/RLPReader.sol

/*
 * @author Hamdi Allam hamdi.allam97@gmail.com
 * Please reach out with any questions or concerns
 * https://github.com/hamdiallam/Solidity-RLP/blob/e681e25a376dbd5426b509380bc03446f05d0f97/contracts/RLPReader.sol
 */
<span class="marker" id="mapping-410"></span><span class="token mv" id="move-dst-105" data-title="source_file/pragma_directive">pragma solidity 0.6.6;</span>

library RLPReader {
    uint8 constant STRING_SHORT_START = 0x80;
    uint8 constant STRING_LONG_START  = 0xb8;
    uint8 constant LIST_SHORT_START   = 0xc0;
    uint8 constant LIST_LONG_START    = 0xf8;
    uint8 constant WORD_SIZE = 32;

    <span class="marker" id="mapping-411"></span><span class="token add" data-title="contract_body/struct_declaration">struct RLPItem {
        uint len;
        uint memPtr;
    }</span>

    <span class="marker" id="mapping-412"></span><span class="token add" data-title="contract_body/struct_declaration">struct Iterator {
        RLPItem item;   // Item that's being iterated over.
        uint nextPtr;   // Position of the next item in the list.
    }</span>

    <span class="marker" id="mapping-413"></span><span class="token upd" id="move-dst-15" data-title="contract_body/comment"><span class="cupd">/*
   </span> <span class="cupd">*</span> @dev Returns the next element in the iteration. Reverts if it has not next element.
  <span class="cupd">  * @para</span>m self Th<span class="cupd">e i</span>terato<span class="cupd">r</span><span class="cupd">.</span>
    *<span class="cupd"> </span>@re<span class="cupd">t</span>urn<span class="cupd"> </span><span class="cupd">T</span>he <span class="cupd">n</span>e<span class="cupd">x</span>t elem<span class="cupd">e</span>nt<span class="cupd"> </span>in <span class="cupd">t</span>he iterati<span class="cupd">on.</span>
<span class="cupd">  </span>  */</span>
    <span class="marker" id="mapping-414"></span><span class="token add" data-title="contract_body/function_definition">function next(Iterator memory self) internal pure returns (RLPItem memory) {
        require(hasNext(self));

        uint ptr = self.nextPtr;
        uint itemLength = _itemLength(ptr);
        self.nextPtr = ptr + itemLength;

        return RLPItem(itemLength, ptr);
    }</span>

    <span class="marker" id="mapping-415"></span><span class="token upd" id="move-dst-20" data-title="contract_body/comment"><span class="cupd">/*
   </span> <span class="cupd">*</span> @dev Returns true if the iteration has more elements.
  <span class="cupd">  * @para</span>m self Th<span class="cupd">e i</span>terato<span class="cupd">r</span><span class="cupd">.</span>
    *<span class="cupd"> </span>@re<span class="cupd">t</span>urn <span class="cupd">t</span><span class="cupd">r</span><span class="cupd">u</span>e <span class="cupd">i</span>f <span class="cupd">th</span>e itera<span class="cupd">ti</span>on has more ele<span class="cupd">m</span><span class="cupd">e</span>n<span class="cupd">ts.
</span><span class="cupd">  </span>  */</span>
    <span class="marker" id="mapping-416"></span><span class="token add" data-title="contract_body/function_definition">function hasNext(<span class="marker" id="mapping-417"></span><span class="token add" data-title="function_definition/parameter">Iterator memory self</span>) <span class="marker" id="mapping-418"></span><span class="token add" data-title="function_definition/visibility">internal</span> <span class="marker" id="mapping-419"></span><span class="token add" data-title="function_definition/state_mutability">pure</span> <span class="marker" id="mapping-420"></span><span class="token add" data-title="function_definition/return_type_definition">returns (bool)</span> <span class="marker" id="mapping-421"></span><span class="token add" data-title="function_definition/function_body">{
        <span class="marker" id="mapping-422"></span><span class="token add" data-title="function_body/variable_declaration_statement">RLPItem memory item = self.item;</span>
        <span class="marker" id="mapping-423"></span><span class="token add" data-title="function_body/return_statement">return <span class="marker" id="mapping-424"></span><span class="token mv" id="move-dst-57" data-title="return_statement/binary_expression"><span class="marker" id="mapping-425"></span><span class="token add" data-title="binary_expression/member_expression">self.nextPtr &lt; item.memPtr</span> <span class="marker" id="mapping-426"></span><span class="token add" data-title="binary_expression/+">+</span> item.len</span>;</span>
    }</span></span>

    <span class="marker" id="mapping-427"></span><span class="token mv" id="move-dst-77" data-title="contract_body/comment"><span class="marker" id="mapping-428"></span><span class="token upd" id="move-dst-77" data-title="contract_body/comment"><span class="cupd">/*
   </span><span class="cupd"> *</span> @p<span class="cupd">a</span>ram<span class="cupd"> </span><span class="cupd">it</span>e<span class="cupd">m</span> RLP<span class="cupd"> </span>enco<span class="cupd">d</span>ed byt<span class="cupd">es
  </span><span class="cupd">  </span>*/</span></span>
    <span class="marker" id="mapping-429"></span><span class="token mv" id="move-dst-16" data-title="contract_body/function_definition">function toRlpItem(bytes memory item) internal pure returns (RLPItem memory) {
        <span class="marker" id="mapping-430"></span><span class="token add" data-title="variable_declaration_statement/variable_declaration">uint memPtr</span>;
        assembly {
            memPtr := add(item, 0x20)
        }

        return RLPItem(item.length, memPtr);
    }</span>

    <span class="marker" id="mapping-431"></span><span class="token mv" id="move-dst-95" data-title="contract_body/comment"><span class="marker" id="mapping-432"></span><span class="token upd" id="move-dst-95" data-title="contract_body/comment"><span class="cupd">/*
   </span><span class="cupd"> * </span>@dev <span class="cupd">C</span>r<span class="cupd">e</span>at<span class="cupd">e</span> a<span class="cupd">n</span><span class="cupd"> </span><span class="cupd">ite</span>r<span class="cupd">at</span>or<span class="cupd">.</span> Rever<span class="cupd">t</span>s if i<span class="cupd">t</span>e<span class="cupd">m</span> i<span class="cupd">s</span> no<span class="cupd">t</span> <span class="cupd">a</span> list<span class="cupd">.</span>
  <span class="cupd">  * @para</span>m<span class="cupd"> </span>se<span class="cupd">l</span>f <span class="cupd">T</span><span class="cupd">h</span>e R<span class="cupd">L</span><span class="cupd">P</span><span class="cupd"> </span>ite<span class="cupd">m.
 </span><span class="cupd">   </span><span class="cupd">*</span><span class="cupd"> </span>@re<span class="cupd">tur</span><span class="cupd">n</span> An<span class="cupd"> </span><span class="cupd">'</span><span class="cupd">I</span>t<span class="cupd">er</span>at<span class="cupd">o</span><span class="cupd">r</span>' <span class="cupd">o</span><span class="cupd">ver t</span>he<span class="cupd"> </span>it<span class="cupd">em.
</span><span class="cupd">  </span>  */</span></span>
    <span class="marker" id="mapping-433"></span><span class="token add" data-title="contract_body/function_definition">function iterator(RLPItem memory self) internal pure returns (Iterator memory) {
        require(isList(self));

        uint ptr = self.memPtr + _payloadOffset(self.memPtr);
        return Iterator(self, ptr);
    }</span>

    <span class="marker" id="mapping-434"></span><span class="token add" data-title="contract_body/comment">/*
    * @param the RLP item.
    */</span>
    <span class="marker" id="mapping-435"></span><span class="token add" data-title="contract_body/function_definition">function rlpLen(RLPItem memory item) internal pure returns (uint) {
        return item.len;
    }</span>

    <span class="marker" id="mapping-436"></span><span class="token add" data-title="contract_body/comment">/*
     * @param the RLP item.
     * @return (memPtr, len) pair: location of the item's payload in memory.
     */</span>
    <span class="marker" id="mapping-437"></span><span class="token add" data-title="contract_body/function_definition">function payloadLocation(<span class="marker" id="mapping-438"></span><span class="token add" data-title="function_definition/parameter">RLPItem memory item</span>) <span class="marker" id="mapping-439"></span><span class="token add" data-title="function_definition/visibility">internal</span> <span class="marker" id="mapping-440"></span><span class="token add" data-title="function_definition/state_mutability">pure</span> <span class="marker" id="mapping-441"></span><span class="token add" data-title="function_definition/return_type_definition">returns (uint, uint)</span> <span class="marker" id="mapping-442"></span><span class="token add" data-title="function_definition/function_body">{
        <span class="marker" id="mapping-443"></span><span class="token mv" id="move-dst-71" data-title="function_body/variable_declaration_statement"><span class="marker" id="mapping-444"></span><span class="token add" data-title="variable_declaration/type_name">uint</span> offset = _payloadOffset(item.memPtr);</span>
        <span class="marker" id="mapping-445"></span><span class="token mv" id="move-dst-60" data-title="function_body/variable_declaration_statement"><span class="marker" id="mapping-446"></span><span class="token add" data-title="variable_declaration/type_name">uint</span> memPtr = item.memPtr + offset;</span>
        <span class="marker" id="mapping-447"></span><span class="token mv" id="move-dst-73" data-title="function_body/variable_declaration_statement"><span class="marker" id="mapping-448"></span><span class="token add" data-title="variable_declaration_statement/variable_declaration">uint len</span> = item.len - offset;</span> // data length
        <span class="marker" id="mapping-449"></span><span class="token add" data-title="function_body/return_statement">return (memPtr, len);</span>
    }</span></span>

    <span class="marker" id="mapping-450"></span><span class="token add" data-title="contract_body/comment">/*
    * @param the RLP item.
    */</span>
    <span class="marker" id="mapping-451"></span><span class="token add" data-title="contract_body/function_definition">function payloadLen(<span class="marker" id="mapping-452"></span><span class="token add" data-title="function_definition/parameter">RLPItem memory item</span>) <span class="marker" id="mapping-453"></span><span class="token add" data-title="function_definition/visibility">internal</span> <span class="marker" id="mapping-454"></span><span class="token add" data-title="function_definition/state_mutability">pure</span> <span class="marker" id="mapping-455"></span><span class="token add" data-title="function_definition/return_type_definition">returns (uint)</span> <span class="marker" id="mapping-456"></span><span class="token add" data-title="function_definition/function_body">{
        <span class="marker" id="mapping-457"></span><span class="token add" data-title="function_body/variable_declaration_statement"><span class="marker" id="mapping-458"></span><span class="token add" data-title="variable_declaration_statement/variable_declaration_tuple">(, uint len)</span> = <span class="marker" id="mapping-459"></span><span class="token mv" id="move-dst-45" data-title="variable_declaration_statement/call_expression"><span class="marker" id="mapping-460"></span><span class="token upd" id="move-dst-46" data-title="call_expression/identifier">payload<span class="cupd">L</span>ocation</span>(item)</span>;</span>
        <span class="marker" id="mapping-461"></span><span class="token add" data-title="function_body/return_statement">return len;</span>
    }</span></span>

    <span class="marker" id="mapping-462"></span><span class="token add" data-title="contract_body/comment">/*
    * @param the RLP item containing the encoded list.
    */</span>
    function toList(RLPItem memory item) internal pure returns (RLPItem[] memory) {
        require(isList(item));

        <span class="marker" id="mapping-463"></span><span class="token add" data-title="variable_declaration_statement/variable_declaration">uint items</span> = numItems(item);
        RLPItem[] memory result = new RLPItem[](items);

        <span class="marker" id="mapping-464"></span><span class="token mv" id="move-dst-80" data-title="function_body/variable_declaration_statement"><span class="marker" id="mapping-465"></span><span class="token add" data-title="variable_declaration/type_name">uint</span> <span class="marker" id="mapping-466"></span><span class="token upd" id="move-dst-82" data-title="variable_declaration/identifier">mem<span class="cupd">Ptr</span></span> = item.memPtr + _payloadOffset(item.memPtr);</span>
        <span class="marker" id="mapping-467"></span><span class="token add" data-title="function_body/variable_declaration_statement">uint dataLen;</span>
        for (<span class="marker" id="mapping-468"></span><span class="token add" data-title="primitive_type/uint">uint</span> i = 0; i &lt; items; i++) {
            dataLen = _itemLength(memPtr);
            result[i] = RLPItem(dataLen, memPtr); 
            memPtr = memPtr + dataLen;
        }

        return result;
    }

    // @return indicator whether encoded payload is a list. negate this function call for isData.
    function isList(RLPItem memory item) internal pure returns (bool) {
        <span class="marker" id="mapping-469"></span><span class="token add" data-title="function_body/if_statement">if (<span class="marker" id="mapping-470"></span><span class="token mv" id="move-dst-49" data-title="if_statement/binary_expression">item.len <span class="marker" id="mapping-471"></span><span class="token add" data-title="binary_expression/==">==</span> <span class="marker" id="mapping-472"></span><span class="token upd" id="move-dst-50" data-title="binary_expression/number_literal">0</span></span>) <span class="marker" id="mapping-473"></span><span class="token add" data-title="if_statement/return_statement">return false;</span></span>

        uint8 byte0;
        <span class="marker" id="mapping-474"></span><span class="token add" data-title="function_body/variable_declaration_statement"><span class="marker" id="mapping-475"></span><span class="token add" data-title="variable_declaration_statement/variable_declaration">uint memPtr</span> = <span class="marker" id="mapping-476"></span><span class="token mv" id="move-dst-36" data-title="variable_declaration_statement/member_expression">item.memPtr</span>;</span>
        assembly {
            byte0 := byte(0, mload(memPtr))
        }

        if (byte0 &lt; LIST_SHORT_START)
            return false;
        return true;
    }

    <span class="marker" id="mapping-477"></span><span class="token add" data-title="contract_body/comment">/*
     * @dev A cheaper version of keccak256(toRlpBytes(item)) that avoids copying memory.
     * @return keccak256 hash of RLP encoded bytes.
     */</span>
    <span class="marker" id="mapping-478"></span><span class="token add" data-title="contract_body/function_definition">function rlpBytesKeccak256(<span class="marker" id="mapping-479"></span><span class="token add" data-title="function_definition/parameter">RLPItem memory item</span>) <span class="marker" id="mapping-480"></span><span class="token add" data-title="function_definition/visibility">internal</span> <span class="marker" id="mapping-481"></span><span class="token add" data-title="function_definition/state_mutability">pure</span> <span class="marker" id="mapping-482"></span><span class="token add" data-title="function_definition/return_type_definition">returns (bytes32)</span> <span class="marker" id="mapping-483"></span><span class="token add" data-title="function_definition/function_body">{
        <span class="marker" id="mapping-484"></span><span class="token mv" id="move-dst-37" data-title="function_body/variable_declaration_statement">uint256 ptr <span class="marker" id="mapping-485"></span><span class="token add" data-title="variable_declaration_statement/=">=</span> <span class="marker" id="mapping-486"></span><span class="token mv" id="move-dst-68" data-title="variable_declaration_statement/member_expression">item.memPtr</span>;</span>
        <span class="marker" id="mapping-487"></span><span class="token add" data-title="function_body/variable_declaration_statement"><span class="marker" id="mapping-488"></span><span class="token mv" id="move-dst-74" data-title="variable_declaration_statement/variable_declaration">uint256 len</span> = <span class="marker" id="mapping-489"></span><span class="token add" data-title="variable_declaration_statement/member_expression">item.len</span>;</span>
        <span class="marker" id="mapping-490"></span><span class="token add" data-title="function_body/variable_declaration_statement">bytes32 result;</span>
        <span class="marker" id="mapping-491"></span><span class="token add" data-title="function_body/assembly_statement">assembly {
            result := keccak256(ptr, len)
        }</span>
        <span class="marker" id="mapping-492"></span><span class="token add" data-title="function_body/return_statement">return result;</span>
    }</span></span>

    <span class="marker" id="mapping-493"></span><span class="token add" data-title="contract_body/comment">/*
     * @dev A cheaper version of keccak256(toBytes(item)) that avoids copying memory.
     * @return keccak256 hash of the item payload.
     */</span>
    <span class="marker" id="mapping-494"></span><span class="token add" data-title="contract_body/function_definition">function payloadKeccak256(<span class="marker" id="mapping-495"></span><span class="token add" data-title="function_definition/parameter">RLPItem memory item</span>) <span class="marker" id="mapping-496"></span><span class="token add" data-title="function_definition/visibility">internal</span> <span class="marker" id="mapping-497"></span><span class="token add" data-title="function_definition/state_mutability">pure</span> <span class="marker" id="mapping-498"></span><span class="token add" data-title="function_definition/return_type_definition">returns (bytes32)</span> <span class="marker" id="mapping-499"></span><span class="token add" data-title="function_definition/function_body">{
        <span class="marker" id="mapping-500"></span><span class="token add" data-title="function_body/variable_declaration_statement"><span class="marker" id="mapping-501"></span><span class="token add" data-title="variable_declaration_statement/variable_declaration_tuple">(uint memPtr, uint len)</span> = <span class="marker" id="mapping-502"></span><span class="token mv" id="move-dst-38" data-title="variable_declaration_statement/call_expression"><span class="marker" id="mapping-503"></span><span class="token upd" id="move-dst-39" data-title="call_expression/identifier">payload<span class="cupd">L</span>ocation</span>(item)</span>;</span>
        <span class="marker" id="mapping-504"></span><span class="token add" data-title="function_body/variable_declaration_statement">bytes32 result;</span>
        <span class="marker" id="mapping-505"></span><span class="token add" data-title="function_body/assembly_statement">assembly {
            result := keccak256(memPtr, len)
        }</span>
        <span class="marker" id="mapping-506"></span><span class="token add" data-title="function_body/return_statement">return result;</span>
    }</span></span>

    /** RLPItem conversions into data types **/

    // @returns raw rlp encoding in bytes
    function toRlpBytes(RLPItem memory item) internal pure returns (bytes memory) {
        bytes memory result = new bytes(item.len);
        <span class="marker" id="mapping-507"></span><span class="token add" data-title="function_body/if_statement">if (result.length == 0) return result;</span>
        
        <span class="marker" id="mapping-508"></span><span class="token add" data-title="function_body/variable_declaration_statement">uint ptr;</span>
        assembly {
            ptr := add(0x20, result)
        }

        copy(item.memPtr, ptr, item.len);
        return result;
    }

    <span class="marker" id="mapping-509"></span><span class="token add" data-title="contract_body/comment">// any non-zero byte except "0x80" is considered true</span>
    <span class="marker" id="mapping-510"></span><span class="token add" data-title="contract_body/function_definition">function toBoolean(<span class="marker" id="mapping-511"></span><span class="token add" data-title="function_definition/parameter">RLPItem memory item</span>) <span class="marker" id="mapping-512"></span><span class="token add" data-title="function_definition/visibility">internal</span> <span class="marker" id="mapping-513"></span><span class="token add" data-title="function_definition/state_mutability">pure</span> <span class="marker" id="mapping-514"></span><span class="token add" data-title="function_definition/return_type_definition">returns (bool)</span> <span class="marker" id="mapping-515"></span><span class="token add" data-title="function_definition/function_body">{
        <span class="marker" id="mapping-516"></span><span class="token mv" id="move-dst-69" data-title="function_body/expression_statement">require(item.len <span class="marker" id="mapping-517"></span><span class="token mv" id="move-dst-70" data-title="binary_expression/==">==</span> <span class="marker" id="mapping-518"></span><span class="token add" data-title="binary_expression/number_literal">1</span>);</span>
        <span class="marker" id="mapping-519"></span><span class="token add" data-title="function_body/variable_declaration_statement">uint result;</span>
        <span class="marker" id="mapping-520"></span><span class="token mv" id="move-dst-51" data-title="function_body/variable_declaration_statement"><span class="marker" id="mapping-521"></span><span class="token add" data-title="variable_declaration/type_name">uint</span> <span class="marker" id="mapping-522"></span><span class="token upd" id="move-dst-53" data-title="variable_declaration/identifier">m<span class="cupd">em</span>Ptr</span> = <span class="marker" id="mapping-523"></span><span class="token mv" id="move-dst-54" data-title="variable_declaration_statement/member_expression">item.memPtr</span>;</span>
        <span class="marker" id="mapping-524"></span><span class="token add" data-title="function_body/assembly_statement">assembly {
            result := byte(0, mload(memPtr))
        }</span>

        // SEE Github Issue #5.
        // Summary: Most commonly used RLP libraries (i.e Geth) will encode
        // "0" as "0x80" instead of as "0". We handle this edge case explicitly
        // here.
        <span class="marker" id="mapping-525"></span><span class="token add" data-title="function_body/if_statement">if (result == 0 || result == STRING_SHORT_START) {
            return false;
        } else {
            return true;
        }</span>
    }</span></span>

    function toAddress(RLPItem memory item) internal pure returns (address) {
        // 1 byte for the length prefix
        require(item.len == 21);

        return address(toUint(item));
    }

    function toUint(RLPItem memory item) internal pure <span class="marker" id="mapping-526"></span><span class="token add" data-title="function_definition/return_type_definition">returns (uint)</span> {
        <span class="marker" id="mapping-527"></span><span class="token mv" id="move-dst-26" data-title="function_body/expression_statement">require(<span class="marker" id="mapping-528"></span><span class="token add" data-title="call_argument/binary_expression"><span class="marker" id="mapping-529"></span><span class="token add" data-title="binary_expression/member_expression"><span class="marker" id="mapping-530"></span><span class="token add" data-title="member_expression/binary_expression"><span class="marker" id="mapping-531"></span><span class="token mv" id="move-dst-27" data-title="binary_expression/binary_expression">item.len <span class="marker" id="mapping-532"></span><span class="token add" data-title="binary_expression/>">&gt;</span> <span class="marker" id="mapping-533"></span><span class="token add" data-title="binary_expression/number_literal">0</span></span> &amp;&amp; item</span>.len</span> &lt;= 33</span>);</span>

        <span class="marker" id="mapping-534"></span><span class="token add" data-title="function_body/variable_declaration_statement">(uint memPtr, uint len) = payloadLocation(item);</span>

        <span class="marker" id="mapping-535"></span><span class="token add" data-title="function_body/variable_declaration_statement">uint result;</span>
        assembly {
            result := mload(memPtr)

            // shfit to the correct location if neccesary
            if lt(len, 32) {
                result := div(result, exp(256, sub(32, len)))
            }
        }

        return result;
    }

    // enforces 32 byte length
    function toUintStrict(RLPItem memory item) internal pure <span class="marker" id="mapping-536"></span><span class="token add" data-title="function_definition/return_type_definition">returns (uint)</span> {
        // one byte prefix
        require(item.len == 33);

        <span class="marker" id="mapping-537"></span><span class="token add" data-title="function_body/variable_declaration_statement">uint result;</span>
        <span class="marker" id="mapping-538"></span><span class="token add" data-title="variable_declaration/type_name">uint</span> memPtr = item.memPtr + 1;
        assembly {
            result := mload(memPtr)
        }

        return result;
    }

    function toBytes(RLPItem memory item) internal pure returns (bytes memory) {
        <span class="marker" id="mapping-539"></span><span class="token mv" id="move-dst-64" data-title="function_body/expression_statement">require(item.len <span class="marker" id="mapping-540"></span><span class="token add" data-title="binary_expression/>">&gt;</span> <span class="marker" id="mapping-541"></span><span class="token add" data-title="binary_expression/number_literal">0</span>);</span>

        <span class="marker" id="mapping-542"></span><span class="token add" data-title="function_body/variable_declaration_statement">(uint memPtr, uint len) = payloadLocation(item);</span>
        bytes memory result = new bytes(len);

        <span class="marker" id="mapping-543"></span><span class="token add" data-title="function_body/variable_declaration_statement">uint destPtr;</span>
        assembly {
            destPtr := add(0x20, result)
        }

        copy(<span class="marker" id="mapping-544"></span><span class="token add" data-title="call_argument/identifier">memPtr</span>, destPtr, len);
        return result;
    }

    <span class="marker" id="mapping-545"></span><span class="token add" data-title="contract_body/comment">/*
    * Private Helpers
    */</span>

    // @return number of payload items inside an encoded list.
    function numItems(RLPItem memory item) private pure <span class="marker" id="mapping-546"></span><span class="token add" data-title="function_definition/return_type_definition">returns (uint)</span> {
        <span class="marker" id="mapping-547"></span><span class="token add" data-title="function_body/if_statement">if (item.len == 0) return 0;</span>

        <span class="marker" id="mapping-548"></span><span class="token add" data-title="variable_declaration/type_name">uint</span> count = 0;
        <span class="marker" id="mapping-549"></span><span class="token mv" id="move-dst-29" data-title="function_body/variable_declaration_statement"><span class="marker" id="mapping-550"></span><span class="token add" data-title="variable_declaration_statement/variable_declaration">uint currPtr</span> = item.memPtr + _payloadOffset(item.memPtr);</span>
        <span class="marker" id="mapping-551"></span><span class="token add" data-title="variable_declaration/type_name">uint</span> endPtr = item.memPtr + item.len;
        while (currPtr &lt; endPtr) {
           currPtr = currPtr + _itemLength(currPtr); // skip over an item
           count++;
        }

        return count;
    }

    // @return entire rlp item byte length
    function _itemLength(<span class="marker" id="mapping-552"></span><span class="token add" data-title="function_definition/parameter">uint memPtr</span>) private pure <span class="marker" id="mapping-553"></span><span class="token add" data-title="function_definition/return_type_definition">returns (uint)</span> {
        <span class="marker" id="mapping-554"></span><span class="token add" data-title="function_body/variable_declaration_statement">uint itemLen;</span>
        <span class="marker" id="mapping-555"></span><span class="token add" data-title="function_body/variable_declaration_statement">uint byte0;</span>
        assembly {
            byte0 := byte(0, mload(memPtr))
        }

        if (byte0 &lt; STRING_SHORT_START)
            itemLen = 1;
        
        else if (byte0 &lt; STRING_LONG_START)
            itemLen = byte0 - STRING_SHORT_START + 1;

        else if (byte0 &lt; LIST_SHORT_START) {
            assembly {
                let byteLen := sub(byte0, 0xb7) // # of bytes the actual length is
                memPtr := add(memPtr, 1) // skip over the first byte
                
                /* 32 byte word size */
                let dataLen := div(mload(memPtr), exp(256, sub(32, byteLen))) // right shifting to get the len
                itemLen := add(dataLen, add(byteLen, 1))
            }
        }

        else if (byte0 &lt; LIST_LONG_START) {
            itemLen = byte0 - LIST_SHORT_START + 1;
        } 

        else {
            assembly {
                let byteLen := sub(byte0, 0xf7)
                memPtr := add(memPtr, 1)

                let dataLen := div(mload(memPtr), exp(256, sub(32, byteLen))) // right shifting to the correct length
                itemLen := add(dataLen, add(byteLen, 1))
            }
        }

        return itemLen;
    }

    // @return number of bytes until the data
    function _payloadOffset(<span class="marker" id="mapping-556"></span><span class="token add" data-title="function_definition/parameter">uint memPtr</span>) private pure <span class="marker" id="mapping-557"></span><span class="token add" data-title="function_definition/return_type_definition">returns (uint)</span> {
        <span class="marker" id="mapping-558"></span><span class="token add" data-title="variable_declaration/type_name">uint</span> byte0;
        assembly {
            byte0 := byte(0, mload(memPtr))
        }

        if (byte0 &lt; STRING_SHORT_START) 
            return 0;
        else if (byte0 &lt; STRING_LONG_START || (byte0 &gt;= LIST_SHORT_START &amp;&amp; byte0 &lt; LIST_LONG_START))
            return 1;
        else if (byte0 &lt; LIST_SHORT_START)  // being explicit
            return byte0 - (STRING_LONG_START - 1) + 1;
        else
            return byte0 - (LIST_LONG_START - 1) + 1;
    }

    <span class="marker" id="mapping-559"></span><span class="token add" data-title="contract_body/comment">/*
    * @param src Pointer to source
    * @param dest Pointer to destination
    * @param len Amount of memory to copy from the source
    */</span>
    function copy(<span class="marker" id="mapping-560"></span><span class="token add" data-title="function_definition/parameter">uint src</span>, <span class="marker" id="mapping-561"></span><span class="token add" data-title="function_definition/parameter">uint dest</span>, <span class="marker" id="mapping-562"></span><span class="token add" data-title="function_definition/parameter">uint len</span>) private pure {
        if (len == 0) return;

        // copy as many word sizes as possible
        for (; len &gt;= WORD_SIZE; len -= WORD_SIZE) {
            assembly {
                mstore(dest, mload(src))
            }

            src += WORD_SIZE;
            dest += WORD_SIZE;
        }

        <span class="marker" id="mapping-563"></span><span class="token add" data-title="function_body/if_statement">if (<span class="marker" id="mapping-564"></span><span class="token add" data-title="if_statement/binary_expression">len &gt; 0</span>) <span class="marker" id="mapping-565"></span><span class="token add" data-title="if_statement/block_statement">{
            // left over bytes. Mask is used to remove unwanted bytes from the word
            <span class="marker" id="mapping-566"></span><span class="token mv" id="move-dst-102" data-title="block_statement/variable_declaration_statement"><span class="marker" id="mapping-567"></span><span class="token add" data-title="primitive_type/uint">uint</span> mask = 256 ** (WORD_SIZE - len) - 1;</span>
            <span class="marker" id="mapping-568"></span><span class="token mv" id="move-dst-103" data-title="block_statement/assembly_statement">assembly {
                let srcpart := and(mload(src), not(mask)) // zero out src
                let destpart := and(mload(dest), mask) // retrieve the bytes
                mstore(dest, or(destpart, srcpart))
            }</span>
        }</span></span>
    }
}

// File: contracts/root/TokenPredicates/ITokenPredicate.sol

pragma solidity 0.6.6;


/// @title Token predicate interface for all pos portal predicates
/// @notice Abstract interface that defines methods for custom predicates
interface ITokenPredicate {

    /**
     * @notice Deposit tokens into pos portal
     * @dev When `depositor` deposits tokens into pos portal, tokens get locked into predicate contract.
     * @param depositor Address who wants to deposit tokens
     * @param depositReceiver Address (address) who wants to receive tokens on side chain
     * @param rootToken Token which gets deposited
     * @param depositData Extra data for deposit (amount for ERC20, token id for ERC721 etc.) [ABI encoded]
     */
    function lockTokens(
        address depositor,
        address depositReceiver,
        address rootToken,
        bytes calldata depositData
    ) external;

    /**
     * @notice Validates and processes exit while withdraw process
     * @dev Validates exit log emitted on sidechain. Reverts if validation fails.
     * @dev Processes withdraw based on custom logic. Example: transfer ERC20/ERC721, mint ERC721 if mintable withdraw
     * @param sender Address
     * @param rootToken Token which gets withdrawn
     * @param logRLPList Valid sidechain log for data like amount, token id etc.
     */
    function exitTokens(
        address sender,
        address rootToken,
        bytes calldata logRLPList
    ) external;
}

// File: contracts/common/Initializable.sol

<span class="marker" id="mapping-569"></span><span class="token mv" id="move-dst-13" data-title="source_file/pragma_directive">pragma solidity 0.6.6;</span>

contract Initializable {
    bool inited = false;

    modifier initializer() {
        require(!inited, "already inited");
        _;
        inited = true;
    }
}

// File: contracts/root/TokenPredicates/MintableERC20Predicate.sol

<span class="marker" id="mapping-570"></span><span class="token mv" id="move-dst-1" data-title="source_file/pragma_directive">pragma solidity 0.6.6;</span>








contract MintableERC20Predicate is
    ITokenPredicate,
    AccessControlMixin,
    Initializable
{
    using RLPReader for bytes;
    using RLPReader for RLPReader.RLPItem;
    <span class="marker" id="mapping-571"></span><span class="token add" data-title="contract_body/using_directive">using SafeERC20 for IERC20;</span>

    bytes32 public constant MANAGER_ROLE = keccak256("MANAGER_ROLE");
    bytes32 public constant TOKEN_TYPE = keccak256("MintableERC20");
    bytes32 public constant TRANSFER_EVENT_SIG = keccak256(
        "Transfer(address,address,uint256)"
    );

    event LockedMintableERC20(
        address indexed depositor,
        address indexed depositReceiver,
        address indexed rootToken,
        uint256 amount
    );

    constructor() public {}

    function initialize(address _owner) external initializer {
        _setupContractId("MintableERC20Predicate");
        _setupRole(DEFAULT_ADMIN_ROLE, _owner);
        _setupRole(MANAGER_ROLE, _owner);
    }

    /**
     * @notice Lock ERC20 tokens for deposit, callable only by manager
     * @param depositor Address who wants to deposit tokens
     * @param depositReceiver Address (address) who wants to receive tokens on child chain
     * @param rootToken Token which gets deposited
     * @param depositData ABI encoded amount
     */
    function lockTokens(
        address depositor,
        address depositReceiver,
        address rootToken,
        bytes calldata depositData
    ) external override only(MANAGER_ROLE) {

        uint256 amount = abi.decode(depositData, (uint256));
        emit LockedMintableERC20(depositor, depositReceiver, rootToken, amount);

        <span class="marker" id="mapping-572"></span><span class="token add" data-title="function_body/comment">// Attempt to perform safe transfer from i.e. check function return value</span>
        <span class="marker" id="mapping-573"></span><span class="token add" data-title="function_body/comment">// using low-level call &amp; revert if didn't succeed</span>
        <span class="marker" id="mapping-574"></span><span class="token upd" id="move-dst-106" data-title="call_expression/identifier"><span class="cupd">I</span><span class="cupd">ERC20</span></span>(rootToken).<span class="marker" id="mapping-575"></span><span class="token upd" id="move-dst-107" data-title="member_expression/identifier">safeT<span class="cupd">ransferFrom</span></span>(depositor, address(this), amount);
    }

    /**
     * @notice Validates log signature, from and to address
     * then sends the correct amount to withdrawer
     * callable only by manager
     * @param rootToken Token which gets withdrawn
     * @param log Valid ERC20 burn log from child chain
     */
    function exitTokens(
        address,
        address rootToken,
        bytes memory log
    ) public override only(MANAGER_ROLE) {
        RLPReader.RLPItem[] memory logRLPList = log.toRlpItem().toList();
        RLPReader.RLPItem[] memory logTopicRLPList = logRLPList[1].toList(); // topics

        require(
            bytes32(logTopicRLPList[0].toUint()) == TRANSFER_EVENT_SIG, // topic0 is `Transfer` event sig
            "MintableERC20Predicate: INVALID_SIGNATURE"
        );

        address withdrawer = address(logTopicRLPList[1].toUint()); // topic1 is `from` address

        require(
            address(logTopicRLPList[2].toUint()) == address(0), // topic2 is `to` address
            "MintableERC20Predicate: INVALID_RECEIVER"
        );

        IMintableERC20 token = IMintableERC20(rootToken);
        uint256 tokenBalance = token.balanceOf(address(this));
        uint256 amount = logRLPList[2].toUint();

        // Checking whether MintableERC20Predicate has enough balance
        // to transfer `amount` to withdrawer or not
        //
        // If no, it'll mint those extra tokens &amp; transfer `amount`
        // to withdrawer
        if (tokenBalance &lt; amount) {
            token.mint(address(this), amount - tokenBalance);
        }

        <span class="marker" id="mapping-576"></span><span class="token add" data-title="function_body/comment">// Attempt to perform safe transfer i.e. check function return value</span>
        <span class="marker" id="mapping-577"></span><span class="token add" data-title="function_body/comment">// using low-level call &amp; revert if didn't succeed</span>
        <span class="marker" id="mapping-578"></span><span class="token add" data-title="call_expression/member_expression">IERC20(rootToken).safeTransfer</span>(withdrawer, amount);
    }
}</pre></div></div></div></body></html>