<html lang="en"><head><meta charset="utf8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>GumTree</title><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css"><style type="text/css">/*
 * This file is part of GumTree.
 *
 * GumTree is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * GumTree is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with GumTree.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Copyright 2011-2015 Jean-Rémy Falleri <jr.falleri@gmail.com>
 * Copyright 2011-2015 Floréal Morandat <florealm@gmail.com>
 */

.add {
	border: 1px solid black;
	background-color: MediumSeaGreen;
}

.del {
	border: 1px solid black;
	background-color: IndianRed;
}

.mv {
	border: 1px solid black;
	background-color: Plum;
}

.upd {
	border: 1px solid black;
	background-color: DarkOrange;
	font-weight: bold;
}

.cupd {
	font-weight: normal;
	color: DimGray;
}

.selected {
	background-color: Gold;
}

.marker {
	margin: 0;
	padding: 0;
}

div {
	margin: 0px;
	padding: 0px;
}

.pre-scrollable {
	margin: 0px;
	padding: 0px;
	font-size: 10pt;
	color: black;
	max-height: 90vh;
	background-color: white;
	border: 1px solid black;
	font-family: "Hack, Inconsolata", "Consolas", "Liberation Sans Regular", "DejaVu Sans Mono", monospace;
}

.tooltip-inner {
    max-width: none;
}
</style><script type="text/javascript" src="https://code.jquery.com/jquery-3.4.1.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/js/bootstrap.bundle.min.js"></script><script type="text/javascript">/*
 * This file is part of GumTree.
 *
 * GumTree is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * GumTree is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with GumTree.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Copyright 2011-2015 Jean-Rémy Falleri <jr.falleri@gmail.com>
 * Copyright 2011-2015 Floréal Morandat <florealm@gmail.com>
 */

$(function(){
    let popoverTriggerList = [].slice.call(document.querySelectorAll('[data-bs-toggle="popover"]'))
    let popoverList = popoverTriggerList.map(function (popoverTriggerEl) {
      return new bootstrap.Popover(popoverTriggerEl)
    })

    $("body").keypress(function (event) {
        switch (event.which) {
            case 116:
                $('html, body').animate({scrollTop: 0}, 100);
                break;
            case 98:
                $("html, body").animate({ scrollTop: $(document).height() }, 100);
                break;
            case 113:
                window.location = "/quit";
                break;
            case 108:
                window.location = "/list";
                break;
        }
    });
});
</script><script type="text/javascript">/*
 * This file is part of GumTree.
 *
 * GumTree is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * GumTree is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with GumTree.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Copyright 2011-2015 Jean-Rémy Falleri <jr.falleri@gmail.com>
 * Copyright 2011-2015 Floréal Morandat <florealm@gmail.com>
 */

currentMapping = 0;

if (typeof String.prototype.startsWith != 'function') {
  String.prototype.startsWith = function (str){
    return this.slice(0, str.length) == str;
  };
}

function getMappedElement(eltId) {
	if (eltId.startsWith("move-src")) {
		return eltId.replace("src","dst");  	 	
  	}
  	else {
  		return eltId.replace("dst","src");
  	}
}

function nextMapping() {
	if (currentMapping == 0) {
		currentMapping = 1;
		return "#mapping-" + currentMapping.toString();
	} else {
		currentMapping++;
		
		if ($("#mapping-" + currentMapping.toString()).length > 0) {
			return "#mapping-" + currentMapping.toString();
		} else {
			currentMapping = 1;
			return "#mapping-" + currentMapping.toString();		
		}		
	}
}

function isSrc(eltId) {
	return eltId.startsWith("move-src");
}

$(function() {
    $("body").keypress(function (event) {
        switch(event.which) {
            case 110:
                const mapping = $(nextMapping());
                const pre = mapping.closest("pre");
                pre.animate({scrollTop: pre.scrollTop() + mapping.position().top - 200}, 100);
                break;
        }
    });

    // highlight
    $("span.mv.token, span.token.upd").click(function(event) {
        if ($(this).hasClass("selected")) {
            $("span.mv.token, span.token.upd").removeClass("selected");
        } else {
            $("span.mv.token, span.token.upd").removeClass("selected");
            const refElt = $("#" + getMappedElement($(this).attr("id")));
            $(this).addClass("selected");
            refElt.addClass("selected");
            const pre = refElt.closest("pre");
            console.log(pre);
            pre.animate({scrollTop: pre.scrollTop() + refElt.position().top - 200}, 100);
        }
        event.stopPropagation();
    });
    
    $("span.add.token, span.token.del").click(function(event) {
        $("span.mv.token, span.token.upd").removeClass("selected");
        event.stopPropagation();
    });

    // tooltip
    $("span.token").hover(
    	function (event) {
    		$(this).tooltip('show');
    		event.stopPropagation();
    	},
    	function (event) {
    		$(this).tooltip('hide');
    		event.stopPropagation();
    	}
    );
});
</script></head><body><div class="container-fluid"><div class="row"><div class="col"><div class="btn-toolbar justify-content-end"><div class="btn-group mr-2"><button class="btn btn-primary btn-sm" id="legend" data-bs-toggle="popover" data-bs-placement="bottom" data-bs-html="true" data-bs-content="<span class='del'>&nbsp;&nbsp;</span> deleted<br><span class='add'>&nbsp;&nbsp;</span> added<br><span class='mv'>&nbsp;&nbsp;</span> moved<br><span class='upd';>&nbsp;&nbsp;</span> updated<br>">Legend</button><button class="btn btn-primary btn-sm" id="shortcuts" data-bs-toggle="popover" data-bs-placement="bottom" data-bs-html="true" data-bs-content="<b>q</b> quit<br><b>l</b> list<br><b>n</b> next<br><b>t</b> top<br><b>b</b> bottom">Shortcuts</button></div><div class="btn-group"><a href="/list" class="btn btn-default btn-sm btn-primary">Back</a><a href="/quit" class="btn btn-default btn-sm btn-danger">Quit</a></div></div></div></div><div class="row"><div class="col-6"><h5>Token_V0.sol</h5><pre class="pre-scrollable">pragma solidity &gt;=0.4.21 &lt;0.6.0;

import "./TokenStorage.sol";
import "./SafeMath.sol";
import "./AddressUtils.sol";
import "./ERC20.sol";
import './Ownable.sol';

/**
* @title Token_V0
* @notice A basic ERC20 token with modular data storage
*/
contract Token_V0 is ERC20, Ownable{
    using SafeMath for uint256;

    string public constant name = 'RoboAi Coin R2R';
    string public constant symbol = 'R2R';
    uint8 public constant decimals = 18;

    event Lock(
        address indexed _of,
        bytes32 indexed _reason,
        uint256 _amount,
        uint256 _validity
    );

    /**
     * @dev Records data of all the tokens unlocked
     */
    event Unlock(
        address indexed _of,
        bytes32 indexed _reason,
        uint256 _amount
    );

    string internal constant ALREADY_LOCKED = "Tokens already locked";
    string internal constant NOT_LOCKED = "No tokens locked";
    string internal constant AMOUNT_ZERO = "Amount can not be 0";

    /** Events */
    event Mint(address indexed to, uint256 value);
    event Burn(address indexed burner, uint256 value);
    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);
    TokenStorage dataStore;
    address dataStoreAddress;

    constructor(address storeAddress) public {
        dataStore = TokenStorage(storeAddress);
        dataStoreAddress = storeAddress;
    }

    /** Modifiers **/

    /** Functions **/

    function totalSupply() public view returns(uint256) {
        return(dataStore.getTotalSupply());
    }

    function balanceOf(address account) public view returns (uint256) {
        return dataStore.getBalance(account);
    }

    function transfer(address recipient, uint256 amount) public returns (bool) {
        _transfer(msg.sender, recipient, amount);
        return true;
    }

    function allowance(address owner, address spender) public view returns (uint256) {
        return dataStore.getAllowance(owner, spender);
    }

    function approve(address spender, uint256 value) public returns (bool) {
        _approve(msg.sender, spender, value);
        return true;
    }

    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {
        require(dataStore.getAllowance(sender, msg.sender) &gt;= amount, "AllowanceError: The spender does not hve the required allowance to spend token holder's tokens");
        _transfer(sender, recipient, amount);
        _approve(sender, msg.sender, dataStore.getAllowance(sender, msg.sender).sub(amount));
        return true;
    }

    function _transfer(address sender, address recipient, uint256 amount) internal {
        require(sender != address(0), "ERC20: transfer from the zero address");
        require(recipient != address(0), "ERC20: transfer to the zero address");
        require(dataStore.getBalance(sender) &gt;= amount, "Insufficient Funds");

        dataStore.subBalance(sender, amount);
        dataStore.addBalance(recipient, amount);
        emit Transfer(sender, recipient, amount);
    }

    function _approve(address owner, address spender, uint256 value) internal {
        require(owner != address(0), "ERC20: approve from the zero address");
        require(spender != address(0), "ERC20: approve to the zero address");

        dataStore.setAllowance(owner, spender, value);
        emit Approval(owner, spender, value);
    }

    // Mintable Functionality
    function mintToken(address recipient, uint256 value) public onlyOwner{
        dataStore.addTotalSupply(value);
        dataStore.addBalance(recipient, value);
        emit Mint(recipient, value);
    }

    function burnToken(uint256 value) public{
        address sender = msg.sender;
        dataStore.subBalance(sender, value);
        dataStore.subTotalSupply(value);
        emit Burn(msg.sender, value);
    }


    // Lockable Functionality according to EIP1132
    /**
    * @dev Locks a specified amount of tokens against an address,
    *      for a specified reason and time
    * @param _reason The reason to lock tokens
    * @param _amount Number of tokens to be locked
    * @param _time Lock time in seconds
    */
    function lock(bytes32 _reason, uint256 _amount, uint256 _time)
    public
    returns (bool)
    {
        uint256 validUntil = block.timestamp.add(_time);

        uint256 tokensAlreadyLocked = dataStore.getLockedTokenAmount(msg.sender, _reason);

        require(tokensAlreadyLocked == 0, ALREADY_LOCKED);
        require(_amount != 0, AMOUNT_ZERO);

        dataStore.addLockReason(msg.sender, _reason);

        _transfer(msg.sender, dataStore, _amount);

        dataStore.addLockedToken(msg.sender, _reason, _amount, validUntil);

        emit Lock(msg.sender, _reason, _amount, validUntil);
        return true;
    }


    /**
     * @dev Transfers and Locks a specified amount of tokens,
     *      for a specified reason and time
     * @param _to adress to which tokens are to be transfered
     * @param _reason The reason to lock tokens
     * @param _amount Number of tokens to be transfered and locked
     * @param _time Lock time in seconds
     */
    function transferWithLock(address _to, bytes32 _reason, uint256 _amount, uint256 _time)
    public
    returns (bool)
    {
        uint256 validUntil = block.timestamp.add(_time);

        uint256 tokensAlreadyLocked = dataStore.getLockedTokenAmount(_to, _reason);

        require(tokensAlreadyLocked == 0, ALREADY_LOCKED);
        require(_amount != 0, AMOUNT_ZERO);
        require(_to != address(0), "ERC20: transfer to the zero address");

        dataStore.addLockReason(_to, _reason);

        _transfer(msg.sender, dataStore, _amount);

        dataStore.addLockedToken(_to, _reason, _amount, validUntil);

        emit Lock(_to, _reason, _amount, validUntil);
        return true;
    }


    /**
    * @dev Returns tokens locked for a specified address for a
    *      specified reason
    *
    * @param _of The address whose tokens are locked
    * @param _reason The reason to query the lock tokens for
    */
    function tokensLocked(address _of, bytes32 _reason)
    public
    view
    returns (uint256 amount)
    {
        return dataStore.getLockedTokenAmount(_of, _reason);
    }


    /**
    * @dev Returns tokens locked for a specified address for a
    *      specified reason at a specific time
    *
    * @param _of The address whose tokens are locked
    * @param _reason The reason to query the lock tokens for
    * @param _time The timestamp to query the lock tokens for
    */
    function tokensLockedAtTime(address _of, bytes32 _reason, uint256 _time)
    public
    view
    returns (uint256 amount)
    {
        amount = dataStore.getLockedTokensAtTime(_of, _reason, _time);
    }


    /**
 * @dev Returns total tokens held by an address (locked + transferable)
 * @param _of The address to query the total balance of
 */
    function totalBalanceOf(address _of)
    public
    view
    returns (uint256 amount)
    {
        amount = balanceOf(_of);
        amount = amount + dataStore.getTotalLockedTokens(_of);
    }


    /**
    * @dev Extends lock for a specified reason and time
    * @param _reason The reason to lock tokens
    * @param _time Lock extension time in seconds
    */
    function extendLock(bytes32 _reason, uint256 _time)
    public
    returns (bool)
    {
        uint256 tokensAlreadyLocked = dataStore.getLockedTokenAmount(msg.sender, _reason);
        require(tokensAlreadyLocked &gt; 0, NOT_LOCKED);

        (uint256 amount, uint256 validity) = dataStore.extendTokenLock(msg.sender, _reason, _time);

        emit Lock(msg.sender, _reason, amount, validity);
        return true;
    }


    /**
  * @dev Increase number of tokens locked for a specified reason
  * @param _reason The reason to lock tokens
  * @param _amount Number of tokens to be increased
  */
    function increaseLockAmount(bytes32 _reason, uint256 _amount)
    public
    returns (bool)
    {
        uint256 tokensAlreadyLocked = dataStore.getLockedTokenAmount(msg.sender, _reason);
        require(tokensAlreadyLocked &gt; 0, NOT_LOCKED);
        _transfer(msg.sender, dataStore, _amount);
        (uint256 amount, uint256 validity) = dataStore.increaseLockAmount(msg.sender, _reason, _amount);

        emit Lock(msg.sender, _reason, amount, validity);
        return true;
    }


    /**
    * @dev Returns unlockable tokens for a specified address for a specified reason
    * @param _of The address to query the the unlockable token count of
    * @param _reason The reason to query the unlockable tokens for
    */
    function tokensUnlockable(address _of, bytes32 _reason)
    public
    view
    returns (uint256 amount)
    {
        return dataStore.getUnlockable(_of, _reason);
    }


    /**
    * @dev Unlocks the unlockable tokens of a specified address
    * @param _of Address of user, claiming back unlockable tokens
    */
    function unlock(address _of)
    public
    returns (uint256 unlockableTokens)
    {
        uint256 lockedTokens;
        uint256 numLockReasons = dataStore.getNumberOfLockReasons(_of);
        for (uint256 i = 0; i &lt; numLockReasons; i++) {
            bytes32 reason = dataStore.getLockReason(_of, i);
            lockedTokens = tokensUnlockable(_of, reason);
            if (lockedTokens &gt; 0) {
                unlockableTokens += lockedTokens;
                dataStore.setClaimed(_of, reason);
                emit Unlock(_of, reason, lockedTokens);
            }
        }

        if (unlockableTokens &gt; 0)
            _transfer(dataStore, _of, unlockableTokens);
    }


    /**
    * @dev Gets the unlockable tokens of a specified address
    * @param _of The address to query the the unlockable token count of
    */
    function getUnlockableTokens(address _of)
    public
    view
    returns (uint256 unlockableTokens)
    {
        uint256 numLockReasons = dataStore.getNumberOfLockReasons(_of);
        for (uint256 i = 0; i &lt; numLockReasons; i++) {
            bytes32 reason = dataStore.getLockReason(_of, i);
            unlockableTokens = unlockableTokens + tokensUnlockable(_of, reason);
        }
    }
}</pre></div><div class="col-6"><h5>Token_V0.sol</h5><pre class="pre-scrollable">pragma solidity &gt;=0.4.21 &lt;0.6.0;

import "./TokenStorage.sol";
import "./SafeMath.sol";
import "./AddressUtils.sol";
import "./ERC20.sol";
import './Ownable.sol';

/**
* @title Token_V0
* @notice A basic ERC20 token with modular data storage
*/
contract Token_V0 is ERC20, Ownable{
    using SafeMath for uint256;

    string public constant name = 'RoboAi Coin R2R';
    string public constant symbol = 'R2R';
    uint8 public constant decimals = 18;

    event Lock(
        address indexed _of,
        bytes32 indexed _reason,
        uint256 _amount,
        uint256 _validity
    );

    /**
     * @dev Records data of all the tokens unlocked
     */
    event Unlock(
        address indexed _of,
        bytes32 indexed _reason,
        uint256 _amount
    );

    string internal constant ALREADY_LOCKED = "Tokens already locked";
    string internal constant NOT_LOCKED = "No tokens locked";
    string internal constant AMOUNT_ZERO = "Amount can not be 0";

    /** Events */
    event Mint(address indexed to, uint256 value);
    event Burn(address indexed burner, uint256 value);
    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);
    TokenStorage dataStore;
    address dataStoreAddress;

    constructor(address storeAddress) public {
        dataStore = TokenStorage(storeAddress);
        dataStoreAddress = storeAddress;
    }

    /** Modifiers **/

    /** Functions **/

    function totalSupply() public view returns(uint256) {
        return(dataStore.getTotalSupply());
    }

    function balanceOf(address account) public view returns (uint256) {
        return dataStore.getBalance(account);
    }

    function transfer(address recipient, uint256 amount) public returns (bool) {
        _transfer(msg.sender, recipient, amount);
        return true;
    }

    function allowance(address owner, address spender) public view returns (uint256) {
        return dataStore.getAllowance(owner, spender);
    }

    function approve(address spender, uint256 value) public returns (bool) {
        _approve(msg.sender, spender, value);
        return true;
    }

    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {
        require(dataStore.getAllowance(sender, msg.sender) &gt;= amount, "AllowanceError: The spender does not hve the required allowance to spend token holder's tokens");
        _transfer(sender, recipient, amount);
        _approve(sender, msg.sender, dataStore.getAllowance(sender, msg.sender).sub(amount));
        return true;
    }

    function _transfer(address sender, address recipient, uint256 amount) internal {
        require(sender != address(0), "ERC20: transfer from the zero address");
        require(recipient != address(0), "ERC20: transfer to the zero address");
        require(dataStore.getBalance(sender) &gt;= amount, "Insufficient Funds");

        dataStore.subBalance(sender, amount);
        dataStore.addBalance(recipient, amount);
        emit Transfer(sender, recipient, amount);
    }

    function _approve(address owner, address spender, uint256 value) internal {
        require(owner != address(0), "ERC20: approve from the zero address");
        require(spender != address(0), "ERC20: approve to the zero address");

        dataStore.setAllowance(owner, spender, value);
        emit Approval(owner, spender, value);
    }

    // Mintable Functionality
    function mintToken(address recipient, uint256 value) public onlyOwner{
        dataStore.addTotalSupply(value);
        dataStore.addBalance(recipient, value);
        emit Mint(recipient, value);
    }

    function burnToken(uint256 value) public{
        address sender = msg.sender;
        dataStore.subBalance(sender, value);
        dataStore.subTotalSupply(value);
        emit Burn(msg.sender, value);
    }


    // Lockable Functionality according to EIP1132
    /**
    * @dev Locks a specified amount of tokens against an address,
    *      for a specified reason and time
    * @param _reason The reason to lock tokens
    * @param _amount Number of tokens to be locked
    * @param _time Lock time in seconds
    */
    function lock(bytes32 _reason, uint256 _amount, uint256 _time)
    public
    returns (bool)
    {
        uint256 validUntil = block.timestamp.add(_time);

        uint256 tokensAlreadyLocked = dataStore.getLockedTokenAmount(msg.sender, _reason);

        require(tokensAlreadyLocked == 0, ALREADY_LOCKED);
        require(_amount != 0, AMOUNT_ZERO);

        dataStore.addLockReason(msg.sender, _reason);

        _transfer(msg.sender, dataStore, _amount);

        dataStore.addLockedToken(msg.sender, _reason, _amount, validUntil);

        emit Lock(msg.sender, _reason, _amount, validUntil);
        return true;
    }


    /**
     * @dev Transfers and Locks a specified amount of tokens,
     *      for a specified reason and time
     * @param _to adress to which tokens are to be transfered
     * @param _reason The reason to lock tokens
     * @param _amount Number of tokens to be transfered and locked
     * @param _time Lock time in seconds
     */
    function transferWithLock(address _to, bytes32 _reason, uint256 _amount, uint256 _time)
    public
    returns (bool)
    {
        uint256 validUntil = block.timestamp.add(_time);

        uint256 tokensAlreadyLocked = dataStore.getLockedTokenAmount(_to, _reason);

        require(tokensAlreadyLocked == 0, ALREADY_LOCKED);
        require(_amount != 0, AMOUNT_ZERO);
        require(_to != address(0), "ERC20: transfer to the zero address");

        dataStore.addLockReason(_to, _reason);

        _transfer(msg.sender, dataStore, _amount);

        dataStore.addLockedToken(_to, _reason, _amount, validUntil);

        emit Lock(_to, _reason, _amount, validUntil);
        return true;
    }


    /**
    * @dev Returns tokens locked for a specified address for a
    *      specified reason
    *
    * @param _of The address whose tokens are locked
    * @param _reason The reason to query the lock tokens for
    */
    function tokensLocked(address _of, bytes32 _reason)
    public
    view
    returns (uint256 amount)
    {
        return dataStore.getLockedTokenAmount(_of, _reason);
    }


    /**
    * @dev Returns tokens locked for a specified address for a
    *      specified reason at a specific time
    *
    * @param _of The address whose tokens are locked
    * @param _reason The reason to query the lock tokens for
    * @param _time The timestamp to query the lock tokens for
    */
    function tokensLockedAtTime(address _of, bytes32 _reason, uint256 _time)
    public
    view
    returns (uint256 amount)
    {
        amount = dataStore.getLockedTokensAtTime(_of, _reason, _time);
    }


    /**
 * @dev Returns total tokens held by an address (locked + transferable)
 * @param _of The address to query the total balance of
 */
    function totalBalanceOf(address _of)
    public
    view
    returns (uint256 amount)
    {
        amount = balanceOf(_of);
        amount = amount + dataStore.getTotalLockedTokens(_of);
    }


    /**
    * @dev Extends lock for a specified reason and time
    * @param _reason The reason to lock tokens
    * @param _time Lock extension time in seconds
    */
    function extendLock(bytes32 _reason, uint256 _time)
    public
    returns (bool)
    {
        uint256 tokensAlreadyLocked = dataStore.getLockedTokenAmount(msg.sender, _reason);
        require(tokensAlreadyLocked &gt; 0, NOT_LOCKED);

        (uint256 amount, uint256 validity) = dataStore.extendTokenLock(msg.sender, _reason, _time);

        emit Lock(msg.sender, _reason, amount, validity);
        return true;
    }


    /**
  * @dev Increase number of tokens locked for a specified reason
  * @param _reason The reason to lock tokens
  * @param _amount Number of tokens to be increased
  */
    function increaseLockAmount(bytes32 _reason, uint256 _amount)
    public
    returns (bool)
    {
        uint256 tokensAlreadyLocked = dataStore.getLockedTokenAmount(msg.sender, _reason);
        require(tokensAlreadyLocked &gt; 0, NOT_LOCKED);
        _transfer(msg.sender, dataStore, _amount);
        (uint256 amount, uint256 validity) = dataStore.increaseLockAmount(msg.sender, _reason, _amount);

        emit Lock(msg.sender, _reason, amount, validity);
        return true;
    }


    /**
    * @dev Returns unlockable tokens for a specified address for a specified reason
    * @param _of The address to query the the unlockable token count of
    * @param _reason The reason to query the unlockable tokens for
    */
    function tokensUnlockable(address _of, bytes32 _reason)
    public
    view
    returns (uint256 amount)
    {
        return dataStore.getUnlockable(_of, _reason);
    }


    /**
    * @dev Unlocks the unlockable tokens of a specified address
    * @param _of Address of user, claiming back unlockable tokens
    */
    function unlock(address _of)
    public
    returns (uint256 unlockableTokens)
    {
        uint256 lockedTokens;
        uint256 numLockReasons = dataStore.getNumberOfLockReasons(_of);
        for (uint256 i = 0; i &lt; numLockReasons; i++) {
            bytes32 reason = dataStore.getLockReason(_of, i);
            lockedTokens = tokensUnlockable(_of, reason);
            if (lockedTokens &gt; 0) {
                unlockableTokens += lockedTokens;
                dataStore.setClaimed(_of, reason);
                emit Unlock(_of, reason, lockedTokens);
            }
        }

        if (unlockableTokens &gt; 0)
            _transfer(dataStore, _of, unlockableTokens);
    }


    /**
    * @dev Gets the unlockable tokens of a specified address
    * @param _of The address to query the the unlockable token count of
    */
    function getUnlockableTokens(address _of)
    public
    view
    returns (uint256 unlockableTokens)
    {
        uint256 numLockReasons = dataStore.getNumberOfLockReasons(_of);
        for (uint256 i = 0; i &lt; numLockReasons; i++) {
            bytes32 reason = dataStore.getLockReason(_of, i);
            unlockableTokens = unlockableTokens + tokensUnlockable(_of, reason);
        }
    }
}</pre></div></div></div></body></html>