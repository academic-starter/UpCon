<html lang="en"><head><meta charset="utf8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>GumTree</title><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css"><style type="text/css">/*
 * This file is part of GumTree.
 *
 * GumTree is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * GumTree is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with GumTree.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Copyright 2011-2015 Jean-Rémy Falleri <jr.falleri@gmail.com>
 * Copyright 2011-2015 Floréal Morandat <florealm@gmail.com>
 */

.add {
	border: 1px solid black;
	background-color: MediumSeaGreen;
}

.del {
	border: 1px solid black;
	background-color: IndianRed;
}

.mv {
	border: 1px solid black;
	background-color: Plum;
}

.upd {
	border: 1px solid black;
	background-color: DarkOrange;
	font-weight: bold;
}

.cupd {
	font-weight: normal;
	color: DimGray;
}

.selected {
	background-color: Gold;
}

.marker {
	margin: 0;
	padding: 0;
}

div {
	margin: 0px;
	padding: 0px;
}

.pre-scrollable {
	margin: 0px;
	padding: 0px;
	font-size: 10pt;
	color: black;
	max-height: 90vh;
	background-color: white;
	border: 1px solid black;
	font-family: "Hack, Inconsolata", "Consolas", "Liberation Sans Regular", "DejaVu Sans Mono", monospace;
}

.tooltip-inner {
    max-width: none;
}
</style><script type="text/javascript" src="https://code.jquery.com/jquery-3.4.1.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/js/bootstrap.bundle.min.js"></script><script type="text/javascript">/*
 * This file is part of GumTree.
 *
 * GumTree is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * GumTree is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with GumTree.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Copyright 2011-2015 Jean-Rémy Falleri <jr.falleri@gmail.com>
 * Copyright 2011-2015 Floréal Morandat <florealm@gmail.com>
 */

$(function(){
    let popoverTriggerList = [].slice.call(document.querySelectorAll('[data-bs-toggle="popover"]'))
    let popoverList = popoverTriggerList.map(function (popoverTriggerEl) {
      return new bootstrap.Popover(popoverTriggerEl)
    })

    $("body").keypress(function (event) {
        switch (event.which) {
            case 116:
                $('html, body').animate({scrollTop: 0}, 100);
                break;
            case 98:
                $("html, body").animate({ scrollTop: $(document).height() }, 100);
                break;
            case 113:
                window.location = "/quit";
                break;
            case 108:
                window.location = "/list";
                break;
        }
    });
});
</script><script type="text/javascript">/*
 * This file is part of GumTree.
 *
 * GumTree is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * GumTree is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with GumTree.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Copyright 2011-2015 Jean-Rémy Falleri <jr.falleri@gmail.com>
 * Copyright 2011-2015 Floréal Morandat <florealm@gmail.com>
 */

currentMapping = 0;

if (typeof String.prototype.startsWith != 'function') {
  String.prototype.startsWith = function (str){
    return this.slice(0, str.length) == str;
  };
}

function getMappedElement(eltId) {
	if (eltId.startsWith("move-src")) {
		return eltId.replace("src","dst");  	 	
  	}
  	else {
  		return eltId.replace("dst","src");
  	}
}

function nextMapping() {
	if (currentMapping == 0) {
		currentMapping = 1;
		return "#mapping-" + currentMapping.toString();
	} else {
		currentMapping++;
		
		if ($("#mapping-" + currentMapping.toString()).length > 0) {
			return "#mapping-" + currentMapping.toString();
		} else {
			currentMapping = 1;
			return "#mapping-" + currentMapping.toString();		
		}		
	}
}

function isSrc(eltId) {
	return eltId.startsWith("move-src");
}

$(function() {
    $("body").keypress(function (event) {
        switch(event.which) {
            case 110:
                const mapping = $(nextMapping());
                const pre = mapping.closest("pre");
                pre.animate({scrollTop: pre.scrollTop() + mapping.position().top - 200}, 100);
                break;
        }
    });

    // highlight
    $("span.mv.token, span.token.upd").click(function(event) {
        if ($(this).hasClass("selected")) {
            $("span.mv.token, span.token.upd").removeClass("selected");
        } else {
            $("span.mv.token, span.token.upd").removeClass("selected");
            const refElt = $("#" + getMappedElement($(this).attr("id")));
            $(this).addClass("selected");
            refElt.addClass("selected");
            const pre = refElt.closest("pre");
            console.log(pre);
            pre.animate({scrollTop: pre.scrollTop() + refElt.position().top - 200}, 100);
        }
        event.stopPropagation();
    });
    
    $("span.add.token, span.token.del").click(function(event) {
        $("span.mv.token, span.token.upd").removeClass("selected");
        event.stopPropagation();
    });

    // tooltip
    $("span.token").hover(
    	function (event) {
    		$(this).tooltip('show');
    		event.stopPropagation();
    	},
    	function (event) {
    		$(this).tooltip('hide');
    		event.stopPropagation();
    	}
    );
});
</script></head><body><div class="container-fluid"><div class="row"><div class="col"><div class="btn-toolbar justify-content-end"><div class="btn-group mr-2"><button class="btn btn-primary btn-sm" id="legend" data-bs-toggle="popover" data-bs-placement="bottom" data-bs-html="true" data-bs-content="<span class='del'>&nbsp;&nbsp;</span> deleted<br><span class='add'>&nbsp;&nbsp;</span> added<br><span class='mv'>&nbsp;&nbsp;</span> moved<br><span class='upd';>&nbsp;&nbsp;</span> updated<br>">Legend</button><button class="btn btn-primary btn-sm" id="shortcuts" data-bs-toggle="popover" data-bs-placement="bottom" data-bs-html="true" data-bs-content="<b>q</b> quit<br><b>l</b> list<br><b>n</b> next<br><b>t</b> top<br><b>b</b> bottom">Shortcuts</button></div><div class="btn-group"><a href="/list" class="btn btn-default btn-sm btn-primary">Back</a><a href="/quit" class="btn btn-default btn-sm btn-danger">Quit</a></div></div></div></div><div class="row"><div class="col-6"><h5>0xcb9a11afdc6bdb92e4a6235959455f28758b34ba.etherscan.io-TrueUSD.sol</h5><pre class="pre-scrollable"><span class="marker" id="mapping-1"></span><span class="token mv" id="move-src-1" data-title="source_file/pragma_directive">pragma solidity ^<span class="marker" id="mapping-2"></span><span class="token upd" id="move-src-2" data-title="solidity_pragma_token/solidity_version"><span class="cupd">0.</span>4.23</span>;</span>

<span class="marker" id="mapping-3"></span><span class="token upd" id="move-src-3" data-title="source_file/comment"><span class="cupd">// File: contracts/TrueC</span><span class="cupd">oinReceiver.sol</span></span>

contract TrueCoinReceiver {
    function tokenFallback( address from, uint256 value ) external;
}

<span class="marker" id="mapping-4"></span><span class="token upd" id="move-src-4" data-title="source_file/comment"><span class="cupd">// File: </span>openzeppelin-solidity/<span class="cupd">contracts/</span>tok<span class="cupd">e</span>n/E<span class="cupd">R</span>C20<span class="cupd">/</span>ERC20B<span class="cupd">a</span>s<span class="cupd">i</span>c<span class="cupd">.sol</span></span>

<span class="marker" id="mapping-5"></span><span class="token upd" id="move-src-5" data-title="source_file/comment"><span class="cupd">/**
 * @title</span> ERC20<span class="cupd">B</span>a<span class="cupd">s</span>i<span class="cupd">c
 * @de</span>v<span class="cupd"> </span><span class="cupd">Simp</span><span class="cupd">l</span><span class="cupd">e</span><span class="cupd">r v</span><span class="cupd">e</span><span class="cupd">r</span><span class="cupd">s</span><span class="cupd">i</span><span class="cupd">o</span><span class="cupd">n</span><span class="cupd"> </span><span class="cupd">o</span>f ERC<span class="cupd">2</span><span class="cupd">0</span><span class="cupd"> i</span><span class="cupd">n</span><span class="cupd">t</span><span class="cupd">e</span><span class="cupd">r</span><span class="cupd">f</span><span class="cupd">a</span><span class="cupd">c</span><span class="cupd">e</span><span class="cupd">
</span> <span class="cupd">*</span><span class="cupd"> @</span><span class="cupd">d</span><span class="cupd">ev</span><span class="cupd"> </span><span class="cupd">s</span><span class="cupd">e</span><span class="cupd">e</span><span class="cupd"> </span>h<span class="cupd">t</span>tps<span class="cupd">:</span><span class="cupd">/</span><span class="cupd">/</span><span class="cupd">g</span><span class="cupd">i</span><span class="cupd">t</span>h<span class="cupd">ub</span><span class="cupd">.</span><span class="cupd">c</span><span class="cupd">o</span><span class="cupd">m</span><span class="cupd">/e</span><span class="cupd">t</span><span class="cupd">h</span><span class="cupd">e</span>reum/<span class="cupd">E</span><span class="cupd">I</span><span class="cupd">P</span><span class="cupd">s</span><span class="cupd">/</span><span class="cupd">i</span><span class="cupd">s</span><span class="cupd">s</span>ues/<span class="cupd">179</span>
 */</span>
<span class="marker" id="mapping-6"></span><span class="token del" data-title="source_file/contract_declaration">contract ERC20Basic <span class="marker" id="mapping-7"></span><span class="token mv" id="move-src-6" data-title="contract_declaration/contract_body">{
  <span class="marker" id="mapping-8"></span><span class="token mv" id="move-src-7" data-title="contract_body/function_definition">function <span class="marker" id="mapping-9"></span><span class="token upd" id="move-src-8" data-title="function_definition/identifier">t<span class="cupd">o</span>t<span class="cupd">al</span>Supply</span>() public view returns (uint256);</span>
  <span class="marker" id="mapping-10"></span><span class="token mv" id="move-src-9" data-title="contract_body/function_definition">function <span class="marker" id="mapping-11"></span><span class="token upd" id="move-src-10" data-title="function_definition/identifier">b<span class="cupd">a</span>lanceOf</span>(<span class="marker" id="mapping-12"></span><span class="token mv" id="move-src-11" data-title="function_definition/parameter">address <span class="marker" id="mapping-13"></span><span class="token upd" id="move-src-12" data-title="parameter/identifier">who</span></span>) public view returns (uint256);</span>
  function <span class="marker" id="mapping-14"></span><span class="token upd" id="move-src-13" data-title="function_definition/identifier">t<span class="cupd">r</span>ansfer</span>(<span class="marker" id="mapping-15"></span><span class="token mv" id="move-src-14" data-title="function_definition/parameter">address to</span>, <span class="marker" id="mapping-16"></span><span class="token del" data-title="parameter/type_name">uint256</span> <span class="marker" id="mapping-17"></span><span class="token upd" id="move-src-15" data-title="parameter/identifier">v<span class="cupd">a</span>lue</span>) <span class="marker" id="mapping-18"></span><span class="token mv" id="move-src-16" data-title="function_definition/visibility">public</span> returns (bool);
  event Transfer(address indexed from, address indexed to, uint256 value);
}</span></span>

<span class="marker" id="mapping-19"></span><span class="token upd" id="move-src-17" data-title="source_file/comment"><span class="cupd">// File: openzeppelin-solidity/contracts/token/ERC20/</span><span class="cupd">ERC20.sol</span></span>

<span class="marker" id="mapping-20"></span><span class="token upd" id="move-src-18" data-title="source_file/comment"><span class="cupd">/**
 * </span><span class="cupd">@</span>t<span class="cupd">i</span>t<span class="cupd">le ERC20</span><span class="cupd"> i</span><span class="cupd">n</span><span class="cupd">t</span>erf<span class="cupd">a</span><span class="cupd">ce
 </span>* <span class="cupd">@</span>d<span class="cupd">e</span>v s<span class="cupd">e</span>e<span class="cupd"> </span>ht<span class="cupd">t</span>ps://<span class="cupd">g</span>ithu<span class="cupd">b</span>.co<span class="cupd">m</span><span class="cupd">/et</span>her<span class="cupd">e</span>um/E<span class="cupd">I</span>Ps/is<span class="cupd">s</span>ue<span class="cupd">s/</span><span class="cupd">20
</span> */</span>
<span class="marker" id="mapping-21"></span><span class="token del" data-title="source_file/contract_declaration">contract ERC20 is <span class="marker" id="mapping-22"></span><span class="token del" data-title="contract_declaration/inheritance_specifier">ERC20Basic</span> <span class="marker" id="mapping-23"></span><span class="token del" data-title="contract_declaration/contract_body">{
  <span class="marker" id="mapping-24"></span><span class="token mv" id="move-src-19" data-title="contract_body/function_definition">function allowance(address owner, address spender) <span class="marker" id="mapping-25"></span><span class="token mv" id="move-src-20" data-title="function_definition/visibility">public</span> view returns (uint256);</span>
  <span class="marker" id="mapping-26"></span><span class="token mv" id="move-src-21" data-title="contract_body/function_definition">function <span class="marker" id="mapping-27"></span><span class="token upd" id="move-src-22" data-title="function_definition/identifier"><span class="cupd">transfer</span>From</span>(<span class="marker" id="mapping-28"></span><span class="token mv" id="move-src-23" data-title="function_definition/parameter">address from</span>, <span class="marker" id="mapping-29"></span><span class="token mv" id="move-src-24" data-title="function_definition/parameter">address to</span><span class="marker" id="mapping-30"></span><span class="token del" data-title="function_definition/,">,</span> <span class="marker" id="mapping-31"></span><span class="token del" data-title="function_definition/parameter">uint256 value</span>) <span class="marker" id="mapping-32"></span><span class="token mv" id="move-src-25" data-title="function_definition/visibility">public</span> returns (bool);</span>
  <span class="marker" id="mapping-33"></span><span class="token mv" id="move-src-26" data-title="contract_body/function_definition">function <span class="marker" id="mapping-34"></span><span class="token upd" id="move-src-27" data-title="function_definition/identifier"><span class="cupd">a</span>pp<span class="cupd">r</span>ove</span>(<span class="marker" id="mapping-35"></span><span class="token mv" id="move-src-28" data-title="function_definition/parameter">address spender</span><span class="marker" id="mapping-36"></span><span class="token del" data-title="function_definition/,">,</span> <span class="marker" id="mapping-37"></span><span class="token mv" id="move-src-29" data-title="function_definition/parameter">uint256 value</span>) public returns (bool);</span>
  <span class="marker" id="mapping-38"></span><span class="token mv" id="move-src-30" data-title="contract_body/event_definition">event Approval(address indexed owner, address indexed spender, uint256 value);</span>
}</span></span>

<span class="marker" id="mapping-39"></span><span class="token upd" id="move-src-31" data-title="source_file/comment"><span class="cupd">// File: </span><span class="cupd">r</span><span class="cupd">e</span><span class="cupd">gistry/contracts/Registry.sol</span></span>

interface RegistryClone {
    function syncAttributeValue(address _who, bytes32 _attribute, uint256 _value) external;
}

contract Registry {
    struct AttributeData {
        uint256 value;
        bytes32 notes;
        address adminAddr;
        uint256 timestamp;
    }
    
    // never remove any storage variables
    address public owner;
    address public pendingOwner;
    bool initialized;

    <span class="marker" id="mapping-40"></span><span class="token upd" id="move-src-32" data-title="contract_body/comment"><span class="cupd">// Stores arbitrary attributes for users. An example use case is an </span><span class="cupd">ERC20</span></span>
    // token that requires its users to go through a KYC/AML check - in this case
    // a validator can set an account's "hasPassedKYC/AML" attribute to 1 to indicate
    // that account can use the token. This mapping stores that value (1, in the
    // example) as well as which validator last set the value and at what time,
    // so that e.g. the check can be renewed at appropriate intervals.
    mapping(address =&gt; mapping(bytes32 =&gt; AttributeData)) attributes;
    // The logic governing who is allowed to set what attributes is abstracted as
    // this accessManager, so that it may be replaced by the owner as needed
    bytes32 constant WRITE_PERMISSION = keccak256("canWriteTo-");
    mapping(bytes32 =&gt; RegistryClone[]) subscribers;

    event OwnershipTransferred(
        address indexed previousOwner,
        address indexed newOwner
    );
    event SetAttribute(address indexed who, bytes32 attribute, uint256 value, bytes32 notes, address indexed adminAddr);
    event SetManager(address indexed oldManager, address indexed newManager);
    event StartSubscription(bytes32 indexed attribute, RegistryClone indexed subscriber);
    event StopSubscription(bytes32 indexed attribute, RegistryClone indexed subscriber);

    // Allows a write if either a) the writer is that Registry's owner, or
    // b) the writer is writing to attribute foo and that writer already has
    // the canWriteTo-foo attribute set (in that same Registry)
    function confirmWrite(bytes32 _attribute, address _admin) internal view returns (bool) {
        return (_admin == owner || <span class="marker" id="mapping-41"></span><span class="token mv" id="move-src-33" data-title="binary_expression/call_expression"><span class="marker" id="mapping-42"></span><span class="token upd" id="move-src-34" data-title="call_expression/identifier">hasAttribute</span>(<span class="marker" id="mapping-43"></span><span class="token mv" id="move-src-35" data-title="call_expression/call_argument">_admin</span><span class="marker" id="mapping-44"></span><span class="token del" data-title="call_expression/,">,</span> <span class="marker" id="mapping-45"></span><span class="token del" data-title="call_expression/identifier">keccak256</span>(WRITE_PERMISSION ^ _attribute))</span>);
    }

    // Writes are allowed only if the accessManager approves
    function setAttribute(address _who, bytes32 _attribute, uint256 _value, bytes32 _notes) public {
        require(confirmWrite(_attribute, msg.sender));
        attributes[_who][_attribute] = AttributeData(_value, _notes, msg.sender, block.timestamp);
        emit SetAttribute(_who, _attribute, _value, _notes, msg.sender);

        RegistryClone[] storage targets = subscribers[_attribute];
        uint256 index = targets.length;
        while (index --&gt; 0) {
            targets[index].syncAttributeValue(_who, _attribute, _value);
        }
    }

    function subscribe(bytes32 _attribute, RegistryClone _syncer) external onlyOwner {
        subscribers[_attribute].push(_syncer);
        emit StartSubscription(_attribute, _syncer);
    }

    function unsubscribe(bytes32 _attribute, uint256 _index) external onlyOwner {
        uint256 length = subscribers[_attribute].length;
        require(_index &lt; length);
        emit StopSubscription(_attribute, subscribers[_attribute][_index]);
        subscribers[_attribute][_index] = subscribers[_attribute][length - 1];
        subscribers[_attribute].length = length - 1;
    }

    function subscriberCount(bytes32 _attribute) public view returns (uint256) {
        return subscribers[_attribute].length;
    }

    function setAttributeValue(address _who, bytes32 _attribute, uint256 _value) public {
        require(confirmWrite(_attribute, msg.sender));
        attributes[_who][_attribute] = AttributeData(_value, "", msg.sender, block.timestamp);
        emit SetAttribute(_who, _attribute, _value, "", msg.sender);
        RegistryClone[] storage targets = subscribers[_attribute];
        uint256 index = targets.length;
        while (index --&gt; 0) {
            targets[index].syncAttributeValue(_who, _attribute, _value);
        }
    }

    // Returns true if the uint256 value stored for this attribute is non-zero
    function hasAttribute(address _who, bytes32 _attribute) public view returns (bool) {
        return attributes[_who][_attribute].value != 0;
    }


    // Returns the exact value of the attribute, as well as its metadata
    function getAttribute(address _who, bytes32 _attribute) public view returns (uint256, bytes32, address, uint256) {
        AttributeData memory data = attributes[_who][_attribute];
        return (data.value, data.notes, data.adminAddr, data.timestamp);
    }

    function getAttributeValue(address _who, bytes32 _attribute) public view returns (uint256) {
        return attributes[_who][_attribute].value;
    }

    function getAttributeAdminAddr(address _who, bytes32 _attribute) public view returns (address) {
        return attributes[_who][_attribute].adminAddr;
    }

    function getAttributeTimestamp(address _who, bytes32 _attribute) public view returns (uint256) {
        return attributes[_who][_attribute].timestamp;
    }

    function syncAttribute(bytes32 _attribute, uint256 _startIndex, address[] _addresses) external {
        RegistryClone[] storage targets = subscribers[_attribute];
        uint256 index = targets.length;
        while (index --&gt; _startIndex) {
            RegistryClone target = targets[index];
            for (uint256 i = _addresses.length; i --&gt; 0; ) {
                address who = _addresses[i];
                target.syncAttributeValue(who, _attribute, attributes[who][_attribute].value);
            }
        }
    }

    function reclaimEther(<span class="marker" id="mapping-46"></span><span class="token mv" id="move-src-36" data-title="function_definition/parameter">address _to</span>) external onlyOwner {
        _to.transfer(address(this).balance);
    }

    function reclaimToken(<span class="marker" id="mapping-47"></span><span class="token upd" id="move-src-37" data-title="user_defined_type/identifier"><span class="cupd">ERC20</span></span> token, address _to) external onlyOwner {
        uint256 balance = token.balanceOf(<span class="marker" id="mapping-48"></span><span class="token mv" id="move-src-38" data-title="call_expression/call_argument">this</span>);
        token.transfer(_to, balance);
    }

   /**
    * @dev Throws if called by any account other than the owner.
    */
    modifier onlyOwner() {
        require(msg.sender == owner, "only Owner");
        _;
    }

    /**
    * @dev Modifier throws if called by any account other than the pendingOwner.
    */
    modifier onlyPendingOwner() {
        require(msg.sender == pendingOwner);
        _;
    }

    /**
    * @dev Allows the current owner to set the pendingOwner address.
    * @param newOwner The address to transfer ownership to.
    */
    function transferOwnership(address newOwner) public onlyOwner {
        pendingOwner = newOwner;
    }

    /**
    * @dev Allows the pendingOwner address to finalize the transfer.
    */
    function claimOwnership() public onlyPendingOwner {
        emit OwnershipTransferred(owner, pendingOwner);
        owner = pendingOwner;
        pendingOwner = address(0);
    }
}

<span class="marker" id="mapping-49"></span><span class="token upd" id="move-src-39" data-title="source_file/comment"><span class="cupd">// File: </span>openzeppelin-solidity/<span class="cupd">contracts/</span>ow<span class="cupd">n</span><span class="cupd">e</span><span class="cupd">r</span><span class="cupd">s</span>h<span class="cupd">i</span>p/<span class="cupd">Ownable.sol</span></span>

<span class="marker" id="mapping-50"></span><span class="token upd" id="move-src-40" data-title="source_file/comment"><span class="cupd">/**
 * @title</span><span class="cupd"> Ownable
 * @dev Th</span><span class="cupd">e Ownable contract has an owner address, and provides basic authorization control
 * functions, this simplifies the implementation of "user permissions".</span>
 */</span>
contract <span class="marker" id="mapping-51"></span><span class="token upd" id="move-src-41" data-title="contract_declaration/identifier"><span class="cupd">Ownable</span></span> {
  address public owner;


  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);


  <span class="marker" id="mapping-52"></span><span class="token upd" id="move-src-42" data-title="contract_body/comment"><span class="cupd">/**
  </span><span class="cupd"> * @dev The</span><span class="cupd"> Ownable constructor sets the original `owner` of the contract to the sender
 </span><span class="cupd">  * account.
</span><span class="cupd">  </span> */</span>
  <span class="marker" id="mapping-53"></span><span class="token del" data-title="contract_body/function_definition">function Ownable() <span class="marker" id="mapping-54"></span><span class="token mv" id="move-src-43" data-title="function_definition/visibility">public</span> <span class="marker" id="mapping-55"></span><span class="token mv" id="move-src-44" data-title="function_definition/function_body">{
    owner = msg.sender;
  }</span></span>

  <span class="marker" id="mapping-56"></span><span class="token upd" id="move-src-45" data-title="contract_body/comment"><span class="cupd">/**
  </span><span class="cupd"> * @dev Throws if called by any account other than the owner.
 </span><span class="cupd">  </span>*/</span>
  modifier onlyOwner() {
    require(msg.sender == owner);
    _;
  }

  <span class="marker" id="mapping-57"></span><span class="token upd" id="move-src-46" data-title="contract_body/comment"><span class="cupd">/**
  </span><span class="cupd"> * @dev Allows the current owner to transfer control of the contract to a newOwner.
 </span><span class="cupd">  * @param newOwner The address to transfer ownership to.
</span><span class="cupd">  </span> */</span>
  function transferOwnership(address newOwner) public onlyOwner {
    require(newOwner != address(0));
    emit OwnershipTransferred(owner, newOwner);
    owner = newOwner;
  }

}

<span class="marker" id="mapping-58"></span><span class="token upd" id="move-src-47" data-title="source_file/comment"><span class="cupd">// File: </span>openzeppelin-solidity/<span class="cupd">contracts/</span>ow<span class="cupd">n</span><span class="cupd">e</span>r<span class="cupd">s</span>hip<span class="cupd">/</span><span class="cupd">C</span><span class="cupd">laimable.sol</span></span>

<span class="marker" id="mapping-59"></span><span class="token upd" id="move-src-48" data-title="source_file/comment"><span class="cupd">/**
 * @title Claimable
 * @dev Extension for th</span><span class="cupd">e Ownable contract, where the ownership needs to be claimed.
 * This allows the new owner to accept the transfer.</span>
 */</span>
contract Claimable is <span class="marker" id="mapping-60"></span><span class="token upd" id="move-src-49" data-title="user_defined_type/identifier"><span class="cupd">Ownable</span></span> {
  address public pendingOwner;

  <span class="marker" id="mapping-61"></span><span class="token upd" id="move-src-50" data-title="contract_body/comment"><span class="cupd">/**
  </span><span class="cupd"> * @dev Modifier throws if called by any account other than the pendingOwner.
 </span><span class="cupd">  </span>*/</span>
  modifier onlyPendingOwner() {
    require(msg.sender == pendingOwner);
    _;
  }

  <span class="marker" id="mapping-62"></span><span class="token upd" id="move-src-51" data-title="contract_body/comment"><span class="cupd">/**
  </span><span class="cupd"> * @dev Allows the current owner to set the pendingOwner address.
 </span><span class="cupd">  * @param newOwner The address to transfer ownership to.
</span><span class="cupd">  </span> */</span>
  <span class="marker" id="mapping-63"></span><span class="token del" data-title="contract_body/function_definition">function transferOwnership(<span class="marker" id="mapping-64"></span><span class="token mv" id="move-src-52" data-title="function_definition/parameter">address <span class="marker" id="mapping-65"></span><span class="token upd" id="move-src-53" data-title="parameter/identifier"><span class="cupd">n</span>ewOwner</span></span>) <span class="marker" id="mapping-66"></span><span class="token mv" id="move-src-54" data-title="function_definition/modifier_invocation">onlyOwner</span> <span class="marker" id="mapping-67"></span><span class="token mv" id="move-src-55" data-title="function_definition/visibility">public</span> <span class="marker" id="mapping-68"></span><span class="token del" data-title="function_definition/function_body">{
    pendingOwner = newOwner;
  }</span></span>

  <span class="marker" id="mapping-69"></span><span class="token upd" id="move-src-56" data-title="contract_body/comment"><span class="cupd">/**
  </span><span class="cupd"> * @dev Allows the pendingOwner address to finalize the transfer.
 </span><span class="cupd">  </span>*/</span>
  <span class="marker" id="mapping-70"></span><span class="token mv" id="move-src-57" data-title="contract_body/function_definition">function <span class="marker" id="mapping-71"></span><span class="token upd" id="move-src-58" data-title="function_definition/identifier">cla<span class="cupd">i</span>mO<span class="cupd">w</span>ne<span class="cupd">r</span>ship</span>() <span class="marker" id="mapping-72"></span><span class="token del" data-title="function_definition/modifier_invocation">onlyPendingOwner</span> <span class="marker" id="mapping-73"></span><span class="token mv" id="move-src-59" data-title="function_definition/visibility">public</span> {
    <span class="marker" id="mapping-74"></span><span class="token del" data-title="function_body/emit_statement">emit OwnershipTransferred(owner, pendingOwner);</span>
    <span class="marker" id="mapping-75"></span><span class="token del" data-title="function_body/expression_statement">owner = pendingOwner;</span>
    <span class="marker" id="mapping-76"></span><span class="token del" data-title="function_body/expression_statement"><span class="marker" id="mapping-77"></span><span class="token del" data-title="expression_statement/assignment_expression">pendingOwner = <span class="marker" id="mapping-78"></span><span class="token mv" id="move-src-60" data-title="assignment_expression/type_cast_expression">address(0)</span></span>;</span>
  }</span>
}

// File: openzeppelin-solidity/contracts/math/SafeMath.sol

<span class="marker" id="mapping-79"></span><span class="token upd" id="move-src-61" data-title="source_file/comment"><span class="cupd">/**
 * </span><span class="cupd">@</span><span class="cupd">ti</span><span class="cupd">t</span><span class="cupd">l</span><span class="cupd">e</span><span class="cupd"> </span><span class="cupd">S</span><span class="cupd">a</span><span class="cupd">f</span>e<span class="cupd">M</span><span class="cupd">a</span><span class="cupd">t</span><span class="cupd">h</span><span class="cupd"></span><span class="cupd">
 </span>*<span class="cupd"> </span><span class="cupd">@</span><span class="cupd">d</span><span class="cupd">e</span><span class="cupd">v Ma</span><span class="cupd">t</span><span class="cupd">h</span><span class="cupd"> operati</span><span class="cupd">o</span><span class="cupd">n</span>s<span class="cupd"> </span><span class="cupd">wi</span><span class="cupd">t</span><span class="cupd">h</span><span class="cupd"> </span><span class="cupd">s</span><span class="cupd">a</span>fe<span class="cupd">t</span><span class="cupd">y che</span><span class="cupd">ck</span>s <span class="cupd">th</span><span class="cupd">a</span><span class="cupd">t</span> <span class="cupd">t</span><span class="cupd">h</span>r<span class="cupd">o</span><span class="cupd">w</span> <span class="cupd">o</span><span class="cupd">n</span> e<span class="cupd">r</span>r<span class="cupd">o</span><span class="cupd">r</span><span class="cupd">
</span> */</span>
library SafeMath {

  <span class="marker" id="mapping-80"></span><span class="token upd" id="move-src-62" data-title="contract_body/comment"><span class="cupd">/**
 </span><span class="cupd"> * @dev</span> <span class="cupd">M</span>u<span class="cupd">l</span><span class="cupd">t</span>ip<span class="cupd">l</span>ie<span class="cupd">s</span><span class="cupd"> two</span><span class="cupd"> </span>num<span class="cupd">b</span><span class="cupd">ers,</span><span class="cupd"> </span>t<span class="cupd">h</span><span class="cupd">ro</span><span class="cupd">ws</span><span class="cupd"> </span><span class="cupd">o</span><span class="cupd">n</span><span class="cupd"> </span><span class="cupd">overflow.
</span><span class="cupd">  </span>*/</span>
  <span class="marker" id="mapping-81"></span><span class="token mv" id="move-src-63" data-title="contract_body/function_definition">function mul(uint256 a, uint256 b) internal pure returns (<span class="marker" id="mapping-82"></span><span class="token mv" id="move-src-64" data-title="parameter/type_name">uint256</span> <span class="marker" id="mapping-83"></span><span class="token del" data-title="parameter/identifier">c</span>) {
    if (a == 0) {
      return 0;
    }
    <span class="marker" id="mapping-84"></span><span class="token del" data-title="function_body/expression_statement"><span class="marker" id="mapping-85"></span><span class="token del" data-title="expression_statement/assignment_expression">c = <span class="marker" id="mapping-86"></span><span class="token mv" id="move-src-65" data-title="assignment_expression/binary_expression">a * b</span></span>;</span>
    <span class="marker" id="mapping-87"></span><span class="token upd" id="move-src-66" data-title="call_expression/identifier">ass<span class="cupd">e</span>rt</span>(c / a == b);
    return c;
  }</span>

  <span class="marker" id="mapping-88"></span><span class="token upd" id="move-src-67" data-title="contract_body/comment"><span class="cupd">/**
 </span><span class="cupd"> * @dev</span> <span class="cupd">I</span><span class="cupd">n</span><span class="cupd">t</span>ege<span class="cupd">r</span> div<span class="cupd">i</span><span class="cupd">sion of two</span><span class="cupd"> </span>num<span class="cupd">b</span><span class="cupd">ers,</span><span class="cupd"> </span><span class="cupd">t</span><span class="cupd">r</span><span class="cupd">u</span>n<span class="cupd">cat</span><span class="cupd">i</span>n<span class="cupd">g </span>t<span class="cupd">h</span><span class="cupd">e</span><span class="cupd"> q</span>uo<span class="cupd">t</span><span class="cupd">i</span><span class="cupd">en</span><span class="cupd">t.
</span><span class="cupd">  </span>*/</span>
  <span class="marker" id="mapping-89"></span><span class="token mv" id="move-src-68" data-title="contract_body/function_definition">function div(uint256 a, uint256 b) internal pure returns (uint256) {
    <span class="marker" id="mapping-90"></span><span class="token upd" id="move-src-69" data-title="function_body/comment"><span class="cupd">// </span>assert(b &gt; 0); // <span class="cupd">Solidity </span><span class="cupd">automatically </span><span class="cupd">t</span>hrow<span class="cupd">s when dividing by 0</span></span>
    <span class="marker" id="mapping-91"></span><span class="token del" data-title="function_body/comment">// uint256 c = a / b;</span>
    // assert(a == b * c + a % b); // There is no case in which this doesn't hold
    return <span class="marker" id="mapping-92"></span><span class="token mv" id="move-src-70" data-title="return_statement/binary_expression">a / b</span>;
  }</span>

  <span class="marker" id="mapping-93"></span><span class="token upd" id="move-src-71" data-title="contract_body/comment"><span class="cupd">/**
 </span><span class="cupd"> * @dev</span> <span class="cupd">S</span><span class="cupd">ubtrac</span>t<span class="cupd">s</span><span class="cupd"> two</span><span class="cupd"> </span>num<span class="cupd">b</span><span class="cupd">ers,</span><span class="cupd"> </span><span class="cupd">t</span>h<span class="cupd">r</span>o<span class="cupd">w</span><span class="cupd">s on</span><span class="cupd"> overflow </span><span class="cupd">(</span>i<span class="cupd">.</span><span class="cupd">e.</span> i<span class="cupd">f</span> <span class="cupd">s</span>u<span class="cupd">b</span><span class="cupd">t</span><span class="cupd">r</span>ahen<span class="cupd">d</span><span class="cupd"> </span><span class="cupd">is</span> <span class="cupd">g</span>r<span class="cupd">ea</span><span class="cupd">t</span><span class="cupd">e</span><span class="cupd">r</span><span class="cupd"> </span>t<span class="cupd">h</span><span class="cupd">an</span> <span class="cupd">m</span><span class="cupd">i</span>n<span class="cupd">u</span>end<span class="cupd">)</span><span class="cupd">.
</span><span class="cupd">  </span>*/</span>
  function sub(uint256 a, uint256 b) internal pure returns (uint256) {
    <span class="marker" id="mapping-94"></span><span class="token upd" id="move-src-72" data-title="call_expression/identifier">ass<span class="cupd">e</span>rt</span>(b &lt;= a);
    return <span class="marker" id="mapping-95"></span><span class="token mv" id="move-src-73" data-title="return_statement/binary_expression">a - b</span>;
  }

  <span class="marker" id="mapping-96"></span><span class="token upd" id="move-src-74" data-title="contract_body/comment"><span class="cupd">/**
 </span><span class="cupd"> * @dev</span> Ad<span class="cupd">ds </span><span class="cupd">two</span><span class="cupd"> </span>num<span class="cupd">b</span><span class="cupd">ers,</span><span class="cupd"> </span>t<span class="cupd">h</span><span class="cupd">ro</span><span class="cupd">ws</span><span class="cupd"> </span><span class="cupd">o</span><span class="cupd">n</span><span class="cupd"> </span><span class="cupd">overflow.
</span><span class="cupd">  </span>*/</span>
  <span class="marker" id="mapping-97"></span><span class="token mv" id="move-src-75" data-title="contract_body/function_definition">function add(uint256 a, uint256 b) internal pure returns (<span class="marker" id="mapping-98"></span><span class="token mv" id="move-src-76" data-title="return_type_definition/parameter">uint256 <span class="marker" id="mapping-99"></span><span class="token upd" id="move-src-77" data-title="parameter/identifier">c</span></span>) {
    <span class="marker" id="mapping-100"></span><span class="token del" data-title="function_body/expression_statement"><span class="marker" id="mapping-101"></span><span class="token del" data-title="expression_statement/assignment_expression">c = <span class="marker" id="mapping-102"></span><span class="token mv" id="move-src-78" data-title="assignment_expression/binary_expression">a + b</span></span>;</span>
    <span class="marker" id="mapping-103"></span><span class="token upd" id="move-src-79" data-title="call_expression/identifier">ass<span class="cupd">e</span>rt</span>(c &gt;= a);
    return c;
  }</span>
}

<span class="marker" id="mapping-104"></span><span class="token upd" id="move-src-80" data-title="source_file/comment"><span class="cupd">// File: contracts/</span><span class="cupd">modularERC20/BalanceSheet.sol</span></span>

// A wrapper around the balanceOf mapping.
contract BalanceSheet is Claimable {
    using SafeMath for uint256;

    mapping (address =&gt; uint256) public balanceOf;

    function addBalance(address _addr, uint256 _value) public onlyOwner {
        balanceOf[_addr] = balanceOf[_addr].add(_value);
    }

    function subBalance(address _addr, uint256 _value) public onlyOwner {
        balanceOf[_addr] = balanceOf[_addr].sub(_value);
    }

    function setBalance(address _addr, uint256 _value) public onlyOwner {
        balanceOf[_addr] = _value;
    }
}

<span class="marker" id="mapping-105"></span><span class="token upd" id="move-src-81" data-title="source_file/comment"><span class="cupd">// File: contracts/</span><span class="cupd">modularERC20/AllowanceSheet.sol</span></span>

// A wrapper around the allowanceOf mapping.
contract AllowanceSheet is Claimable {
    using SafeMath for uint256;

    mapping (address =&gt; mapping (address =&gt; uint256)) public allowanceOf;

    function addAllowance(address _tokenHolder, address _spender, uint256 _value) public onlyOwner {
        allowanceOf[_tokenHolder][_spender] = allowanceOf[_tokenHolder][_spender].add(_value);
    }

    function subAllowance(address _tokenHolder, address _spender, uint256 _value) public onlyOwner {
        allowanceOf[_tokenHolder][_spender] = allowanceOf[_tokenHolder][_spender].sub(_value);
    }

    function setAllowance(address _tokenHolder, address _spender, uint256 _value) public onlyOwner {
        allowanceOf[_tokenHolder][_spender] = _value;
    }
}

<span class="marker" id="mapping-106"></span><span class="token upd" id="move-src-82" data-title="source_file/comment"><span class="cupd">// File: contracts/</span><span class="cupd">ProxyStorage.sol</span></span>

<span class="marker" id="mapping-107"></span><span class="token upd" id="move-src-83" data-title="source_file/comment"><span class="cupd">/*
Defines the storage layout of the token implement</span><span class="cupd">a</span>i<span class="cupd">ton contract. Any newly declared
state variables in future upgrades should be app</span><span class="cupd">ened to the bottom. Never remove state variables
from this list</span>
 */</span>
contract ProxyStorage {
    address public owner;
    address public pendingOwner;

    bool initialized;
    
    BalanceSheet balances_Deprecated;
    AllowanceSheet allowances_Deprecated;

    uint256 totalSupply_;
    
    bool private paused_Deprecated = false;
    address private globalPause_Deprecated;

    uint256 public burnMin = 0;
    uint256 public burnMax = 0;

    Registry public registry;

    string name_Deprecated;
    string symbol_Deprecated;

    uint[] gasRefundPool_Deprecated;
    uint256 private redemptionAddressCount_Deprecated;
    uint256 public minimumGasPriceForFutureRefunds;

    mapping (address =&gt; uint256) _balanceOf;
    mapping (address =&gt; mapping (address =&gt; uint256)) _allowance;
    mapping (bytes32 =&gt; mapping (address =&gt; uint256)) attributes;


    /* Additionally, we have several keccak-based storage locations.
     * If you add more keccak-based storage mappings, such as mappings, you must document them here.
     * If the length of the keccak input is the same as an existing mapping, it is possible there could be a preimage collision.
     * A preimage collision can be used to attack the contract by treating one storage location as another,
     * which would always be a critical issue.
     * Carefully examine future keccak-based storage to ensure there can be no preimage collisions.
     *******************************************************************************************************
     ** length     input                                                         usage
     *******************************************************************************************************
     ** 19         "trueXXX.proxy.owner"                                         Proxy Owner
     ** 27         "trueXXX.pending.proxy.owner"                                 Pending Proxy Owner
     ** 28         "trueXXX.proxy.implementation"                                Proxy Implementation
     ** 32         uint256(11)                                                   gasRefundPool_Deprecated
     ** 64         uint256(address),uint256(14)                                  balanceOf
     ** 64         uint256(address),keccak256(uint256(address),uint256(15))      allowance
     ** 64         uint256(address),keccak256(bytes32,uint256(16))               attributes
    **/
}

<span class="marker" id="mapping-108"></span><span class="token upd" id="move-src-84" data-title="source_file/comment"><span class="cupd">// File: contracts/</span><span class="cupd">HasOwner.sol</span></span>

<span class="marker" id="mapping-109"></span><span class="token upd" id="move-src-85" data-title="source_file/comment"><span class="cupd">/**
 * @title HasOwner
 * @dev The HasOwner contract is a copy of Claimable Contract by Zeppelin.</span> <span class="cupd">
 and provides basic authorization control functions. Inherits storage layout o</span>f<span class="cupd"> 
 ProxyStorage.</span>
 */</span>
contract HasOwner is ProxyStorage {

    event OwnershipTransferred(
        address indexed previousOwner,
        address indexed newOwner
    );

    <span class="marker" id="mapping-110"></span><span class="token upd" id="move-src-86" data-title="contract_body/comment"><span class="cupd">/**
    * @dev sets the original `owner` of the contract to the sender
    * at construction. Must then be reinitialized 
</span> <span class="cupd">  </span> */</span>
    constructor() public {
        owner = msg.sender;
        emit OwnershipTransferred(address(0), owner);
    }

    /**
    * @dev Throws if called by any account other than the owner.
    */
    modifier onlyOwner() {
        require(msg.sender == owner, "only Owner");
        _;
    }

    /**
    * @dev Modifier throws if called by any account other than the pendingOwner.
    */
    modifier onlyPendingOwner() {
        require(msg.sender == pendingOwner);
        _;
    }

    /**
    * @dev Allows the current owner to set the pendingOwner address.
    * @param newOwner The address to transfer ownership to.
    */
    function transferOwnership(address newOwner) public onlyOwner {
        pendingOwner = newOwner;
    }

    /**
    * @dev Allows the pendingOwner address to finalize the transfer.
    */
    function claimOwnership() public onlyPendingOwner {
        emit OwnershipTransferred(owner, pendingOwner);
        owner = pendingOwner;
        pendingOwner = address(0);
    }
}

<span class="marker" id="mapping-111"></span><span class="token upd" id="move-src-87" data-title="source_file/comment"><span class="cupd">// File: contracts/</span><span class="cupd">ReclaimerToken.sol</span></span>

contract ReclaimerToken is HasOwner {
    <span class="marker" id="mapping-112"></span><span class="token upd" id="move-src-88" data-title="contract_body/comment"><span class="cupd">/**  
 </span>  <span class="cupd"> *@dev send all eth balance in the contract to another address
    </span>*/</span>
    function reclaimEther(<span class="marker" id="mapping-113"></span><span class="token mv" id="move-src-89" data-title="function_definition/parameter">address _to</span>) external onlyOwner {
        _to.transfer(address(this).balance);
    }

    <span class="marker" id="mapping-114"></span><span class="token upd" id="move-src-90" data-title="contract_body/comment"><span class="cupd">/**  
 </span>  <span class="cupd"> *@dev send all token balance of an arbitary erc20 token
    in the contract to another address
   </span> */</span>
    function reclaimToken(<span class="marker" id="mapping-115"></span><span class="token upd" id="move-src-91" data-title="user_defined_type/identifier"><span class="cupd">ERC20</span></span> token, address _to) external onlyOwner {
        uint256 balance = token.balanceOf(<span class="marker" id="mapping-116"></span><span class="token mv" id="move-src-92" data-title="call_expression/call_argument">this</span>);
        token.transfer(_to, balance);
    }

    <span class="marker" id="mapping-117"></span><span class="token upd" id="move-src-93" data-title="contract_body/comment"><span class="cupd">/**  
 </span>  <span class="cupd"> *@dev allows owner of the contract to gain ownership of any contract that the contract currently owns
    </span>*/</span>
    function reclaimContract(<span class="marker" id="mapping-118"></span><span class="token upd" id="move-src-94" data-title="user_defined_type/identifier"><span class="cupd">Ownable</span></span> _ownable) external onlyOwner {
        _ownable.transferOwnership(owner);
    }

}

<span class="marker" id="mapping-119"></span><span class="token upd" id="move-src-95" data-title="source_file/comment"><span class="cupd">// File: contracts/</span><span class="cupd">modularERC20/</span>Modu<span class="cupd">l</span><span class="cupd">a</span>rB<span class="cupd">a</span>sicTok<span class="cupd">e</span>n<span class="cupd">.sol</span></span>

// Fork of OpenZeppelin's BasicToken
/**
 * @title Basic token
 * @dev Basic version of StandardToken, with no allowances.
 */
contract ModularBasicToken is HasOwner {
    using SafeMath for uint256;

    event Transfer(address indexed from, address indexed to, uint256 value);

    /**
    * @dev total number of tokens in existence
    */
    function totalSupply() public view returns (uint256) {
        return totalSupply_;
    }

    function balanceOf(address _who) public view returns (uint256) {
        return _getBalance(_who);
    }

    function _getBalance(address _who) internal view returns (uint256) {
        return _balanceOf[_who];
    }

    function _addBalance(address _who, uint256 _value) internal returns (uint256 priorBalance) {
        priorBalance = _balanceOf[_who];
        _balanceOf[_who] = priorBalance.add(_value);
    }

    function _subBalance(address _who, uint256 _value) internal returns (uint256 result) {
        result = _balanceOf[_who].sub(_value);
        _balanceOf[_who] = result;
    }

    function _setBalance(address _who, uint256 _value) internal {
        _balanceOf[_who] = _value;
    }
}

<span class="marker" id="mapping-120"></span><span class="token mv" id="move-src-96" data-title="source_file/comment"><span class="marker" id="mapping-121"></span><span class="token upd" id="move-src-97" data-title="source_file/comment"><span class="cupd">/</span>/<span class="cupd"> </span>F<span class="cupd">i</span><span class="cupd">le</span>:<span class="cupd"> </span><span class="cupd">contract</span><span class="cupd">s</span>/m<span class="cupd">o</span><span class="cupd">d</span>ul<span class="cupd">a</span><span class="cupd">r</span>ERC20/M<span class="cupd">o</span><span class="cupd">d</span><span class="cupd">u</span>l<span class="cupd">a</span><span class="cupd">r</span>S<span class="cupd">t</span><span class="cupd">a</span><span class="cupd">n</span>da<span class="cupd">r</span>dT<span class="cupd">o</span>ke<span class="cupd">n</span>.sol</span></span>

/**
 * @title Standard ERC20 token
 *
 * @dev Implementation of the basic standard token.
 * @dev https://github.com/ethereum/EIPs/issues/20
 * @dev Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol
 */
contract ModularStandardToken is ModularBasicToken {
    using SafeMath for uint256;
    
    event Approval(address indexed owner, address indexed spender, uint256 value);
    
    /**
     * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.
     *
     * Beware that changing an allowance with this method brings the risk that someone may use both the old
     * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this
     * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:
     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
     * @param _spender The address which will spend the funds.
     * @param _value The amount of tokens to be spent.
     */
    function approve(address _spender, uint256 _value) public returns (bool) {
        _approveAllArgs(_spender, _value, msg.sender);
        return true;
    }

    function _approveAllArgs(address _spender, uint256 _value, address _tokenHolder) internal {
        _setAllowance(_tokenHolder, _spender, _value);
        emit Approval(_tokenHolder, _spender, _value);
    }

    /**
     * @dev Increase the amount of tokens that an owner allowed to a spender.
     *
     * approve should be called when allowed[_spender] == 0. To increment
     * allowed value is better to use this function to avoid 2 calls (and wait until
     * the first transaction is mined)
     * From MonolithDAO Token.sol
     * @param _spender The address which will spend the funds.
     * @param _addedValue The amount of tokens to increase the allowance by.
     */
    function <span class="marker" id="mapping-122"></span><span class="token upd" id="move-src-98" data-title="function_definition/identifier"><span class="cupd">increaseA</span>ppr<span class="cupd">o</span>val</span>(address _spender, <span class="marker" id="mapping-123"></span><span class="token mv" id="move-src-99" data-title="function_definition/parameter">uint <span class="marker" id="mapping-124"></span><span class="token del" data-title="parameter/identifier">_addedValue</span></span>) public returns (bool) {
        <span class="marker" id="mapping-125"></span><span class="token upd" id="move-src-100" data-title="call_expression/identifier"><span class="cupd">_increaseA</span>ppr<span class="cupd">o</span>v<span class="cupd">a</span>l<span class="cupd">AllArgs</span></span>(_spender, _addedValue, msg.sender);
        return true;
    }

    function <span class="marker" id="mapping-126"></span><span class="token upd" id="move-src-101" data-title="function_definition/identifier"><span class="cupd">_increaseA</span>ppr<span class="cupd">o</span>v<span class="cupd">a</span>l<span class="cupd">AllArgs</span></span>(address _spender, uint256 _addedValue, address _tokenHolder) internal {
        _addAllowance(_tokenHolder, _spender, _addedValue);
        emit Approval(_tokenHolder, _spender, _getAllowance(_tokenHolder, _spender));
    }

    /**
     * @dev Decrease the amount of tokens that an owner allowed to a spender.
     *
     * approve should be called when allowed[_spender] == 0. To decrement
     * allowed value is better to use this function to avoid 2 calls (and wait until
     * the first transaction is mined)
     * From MonolithDAO Token.sol
     * @param _spender The address which will spend the funds.
     * @param _subtractedValue The amount of tokens to decrease the allowance by.
     */
    function <span class="marker" id="mapping-127"></span><span class="token upd" id="move-src-102" data-title="function_definition/identifier"><span class="cupd">decreaseA</span>ppr<span class="cupd">o</span>val</span>(address _spender, <span class="marker" id="mapping-128"></span><span class="token mv" id="move-src-103" data-title="function_definition/parameter">uint <span class="marker" id="mapping-129"></span><span class="token upd" id="move-src-104" data-title="parameter/identifier">_s<span class="cupd">u</span>btractedValue</span></span>) public returns (bool) {
        <span class="marker" id="mapping-130"></span><span class="token upd" id="move-src-105" data-title="call_expression/identifier"><span class="cupd">_decreaseA</span>ppr<span class="cupd">o</span>v<span class="cupd">a</span>l<span class="cupd">AllArgs</span></span>(_spender, _subtractedValue, msg.sender);
        return true;
    }

    function <span class="marker" id="mapping-131"></span><span class="token upd" id="move-src-106" data-title="function_definition/identifier"><span class="cupd">_decreaseA</span>ppr<span class="cupd">o</span>v<span class="cupd">a</span>l<span class="cupd">AllArgs</span></span>(address _spender, uint256 _subtractedValue, address _tokenHolder) internal {
        uint256 oldValue = _getAllowance(_tokenHolder, _spender);
        uint256 newValue;
        if (_subtractedValue &gt; oldValue) {
            newValue = 0;
        } else {
            newValue = oldValue - _subtractedValue;
        }
        _setAllowance(_tokenHolder, _spender, newValue);
        emit Approval(_tokenHolder,_spender, newValue);
    }

    function allowance(address _who, address _spender) public view returns (uint256) {
        return _getAllowance(_who, _spender);
    }

    function _getAllowance(address _who, address _spender) internal view returns (uint256 value) {
        return _allowance[_who][_spender];
    }

    function _addAllowance(address _who, address _spender, uint256 _value) internal {
        _allowance[_who][_spender] = _allowance[_who][_spender].add(_value);
    }

    function _subAllowance(address _who, address _spender, uint256 _value) internal returns (uint256 newAllowance){
        newAllowance = _allowance[_who][_spender].sub(_value);
        <span class="marker" id="mapping-132"></span><span class="token mv" id="move-src-107" data-title="function_body/expression_statement">_allowance[_who][_spender] = newAllowance;</span>
    }

    function _setAllowance(address _who, address _spender, uint256 _value) internal {
        _allowance[_who][_spender] = _value;
    }
}

<span class="marker" id="mapping-133"></span><span class="token mv" id="move-src-108" data-title="source_file/comment"><span class="marker" id="mapping-134"></span><span class="token upd" id="move-src-109" data-title="source_file/comment"><span class="cupd">// File: contracts/</span><span class="cupd">modularERC20/</span>Modu<span class="cupd">l</span><span class="cupd">a</span>rBurn<span class="cupd">a</span><span class="cupd">ble</span>Token<span class="cupd">.sol</span></span></span>

/**
 * @title Burnable Token
 * @dev Token that can be irreversibly burned (destroyed).
 */
contract ModularBurnableToken is ModularStandardToken {
    event Burn(address indexed burner, uint256 value);
    event Mint(address indexed to, uint256 value);
    uint256 constant CENT = 10 ** 16;

    function burn(uint256 _value) external {
        _burnAllArgs(msg.sender, _value - _value % CENT);
    }

    function _burnAllArgs(address _from, uint256 _value) internal {
        // no need to require value &lt;= totalSupply, since that would imply the
        // sender's balance is greater than the totalSupply, which *should* be an assertion failure
        _subBalance(_from, _value);
        totalSupply_ = totalSupply_.sub(_value);
        emit Burn(_from, _value);
        emit Transfer(_from, address(0), _value);
    }
}

<span class="marker" id="mapping-135"></span><span class="token mv" id="move-src-110" data-title="source_file/comment"><span class="marker" id="mapping-136"></span><span class="token upd" id="move-src-111" data-title="source_file/comment"><span class="cupd">/</span>/<span class="cupd"> </span>F<span class="cupd">i</span><span class="cupd">le</span>:<span class="cupd"> </span><span class="cupd">contract</span>s/Bu<span class="cupd">r</span><span class="cupd">n</span>a<span class="cupd">b</span><span class="cupd">l</span><span class="cupd">e</span><span class="cupd">T</span><span class="cupd">o</span>k<span class="cupd">e</span><span class="cupd">n</span>Wi<span class="cupd">t</span><span class="cupd">h</span>Bou<span class="cupd">n</span>d<span class="cupd">s</span>.sol</span></span>

/**
 * @title Burnable Token WithBounds
 * @dev Burning functions as redeeming money from the system. The platform will keep track of who burns coins,
 * and will send them back the equivalent amount of money (rounded down to the nearest cent).
 */
contract BurnableTokenWithBounds is ModularBurnableToken {

    event SetBurnBounds(uint256 newMin, uint256 newMax);

    function _burnAllArgs(address _burner, uint256 _value) internal {
        require(_value &gt;= burnMin, "below min burn bound");
        require(_value &lt;= burnMax, "exceeds max burn bound");
        super._burnAllArgs(_burner, _value);
    }

    //Change the minimum and maximum amount that can be burned at once. Burning
    //may be disabled by setting both to 0 (this will not be done under normal
    //operation, but we can't add checks to disallow it without losing a lot of
    //flexibility since burning could also be as good as disabled
    //by setting the minimum extremely high, and we don't want to lock
    //in any particular cap for the minimum)
    function setBurnBounds(uint256 _min, uint256 _max) external onlyOwner {
        require(_min &lt;= _max, "min &gt; max");
        burnMin = _min;
        burnMax = _max;
        emit SetBurnBounds(_min, _max);
    }
}

<span class="marker" id="mapping-137"></span><span class="token mv" id="move-src-112" data-title="source_file/comment"><span class="marker" id="mapping-138"></span><span class="token upd" id="move-src-113" data-title="source_file/comment"><span class="cupd">// File: contracts/</span>GasR<span class="cupd">e</span>f<span class="cupd">u</span><span class="cupd">n</span><span class="cupd">d</span><span class="cupd">Token.sol</span></span></span>

<span class="marker" id="mapping-139"></span><span class="token mv" id="move-src-114" data-title="source_file/comment"><span class="marker" id="mapping-140"></span><span class="token upd" id="move-src-115" data-title="source_file/comment"><span class="cupd">/</span>**<span class="cupd"> </span> 
@<span class="cupd">t</span>i<span class="cupd">tl</span><span class="cupd">e</span> Gas Refund <span class="cupd">T</span>ok<span class="cupd">e</span>n
Allow any use<span class="cupd">r</span> to spon<span class="cupd">s</span>or<span class="cupd"> </span><span class="cupd">g</span>a<span class="cupd">s</span><span class="cupd"> </span>r<span class="cupd">e</span>funds <span class="cupd">f</span>or<span class="cupd"> </span>tran<span class="cupd">s</span>fer<span class="cupd"> </span>and<span class="cupd"> </span>mi<span class="cupd">n</span>ts. U<span class="cupd">t</span>ilitzes the<span class="cupd"> </span>ga<span class="cupd">s</span> refund mechanism i<span class="cupd">n</span> <span class="cupd">E</span>VM<span class="cupd"></span>
Ea<span class="cupd">c</span>h ti<span class="cupd">me</span> an non-empty s<span class="cupd">t</span>orage slot is set to 0, e<span class="cupd">v</span>m re<span class="cupd">f</span>und 15,00<span class="cupd">0</span> to<span class="cupd"> </span>the<span class="cupd"> </span>sender
of the <span class="cupd">t</span>ransaction.
*/</span></span>
<span class="marker" id="mapping-141"></span><span class="token mv" id="move-src-116" data-title="source_file/contract_declaration">contract GasRefundToken is ProxyStorage {

    /**
      A buffer of "Sheep" runs from 0xffff...fffe down
      They suicide when you call them, if you are their parent
    */

    function sponsorGas2() external {
        <span class="marker" id="mapping-142"></span><span class="token upd" id="move-src-117" data-title="function_body/comment"><span class="cupd">/**
        Deploy (9 bytes)
          PC Assembly       Opcodes                                       Stack
          00 PUS</span>H1<span class="cupd">(31)      6</span>0<span class="cupd"> 1f                                       </span> <span class="cupd"> 1f
          02 DUP1           80                                         </span> <span class="cupd">  </span>1<span class="cupd">f 1f
          03 PUSH1(9)       60 09                                     </span> <span class="cupd">  </span> <span class="cupd">1f 1f 09
          05 RETURNDATASIZE 3d                                       </span> <span class="cupd">  </span> <span class="cupd"> 1f 1f 09 00
          06 CODECOPY       39                                      </span> <span class="cupd">     1f
          07 RETURNDATASIZE 3d                                     </span> <span class="cupd">      1f 00
          08 RETURN         f3
     </span>  <span class="cupd"> Sheep (31 bytes =</span> <span class="cupd">3 + 20 + 8)
          PC Assembly       Opcodes                                       Stack
          00 RETURNDATASIZE 3d                                 </span><span class="cupd">           0
          01 CALLER         33                                </span><span class="cupd">            0 caller
          02 PUSH20(me)     73 mememememememememememememememe</span><span class="cupd">mememememe   0 caller me</span>
<span class="cupd">          17</span> <span class="cupd">E</span>Q<span class="cupd">             14                              </span><span class="cupd"> </span><span class="cupd">             0 valid</span>
      <span class="cupd">    18</span> P<span class="cupd">U</span>SH<span class="cupd">1(1d) </span>     60 1d                                         0 valid 1d
          1<span class="cupd">a</span> JUMPI          57                                            0
          <span class="cupd">1</span>b<span class="cupd"> DUP1           80                           </span> <span class="cupd">  </span><span class="cupd"> </span>         <span class="cupd"> </span> <span class="cupd"> </span> 0 0
<span class="cupd">         </span> 1<span class="cupd">c</span> REVERT   <span class="cupd"> </span> <span class="cupd">    f</span>d
 <span class="cupd">       </span><span class="cupd"> </span> <span class="cupd">1d JUMPDEST       5b                         </span><span class="cupd">            </span> <span class="cupd">      0
          1e SELFDES</span>TRUCT   ff
        */</span>
        assembly {
            mstore(0, or(<span class="marker" id="mapping-143"></span><span class="token upd" id="move-src-118" data-title="yul_function_call/yul_hex_number"><span class="cupd">0x601</span>f<span class="cupd">8060093d393df33d33730000000000000000000000000000000000000000</span></span>, address))
            mstore(32,   <span class="marker" id="mapping-144"></span><span class="token upd" id="move-src-119" data-title="yul_function_call/yul_hex_number"><span class="cupd">0x1</span>4601d<span class="cupd">5</span>7<span class="cupd">8</span>0fd<span class="cupd">5</span>b<span class="cupd">ff000000000000000000000000000000000000000000000000</span></span>)
            <span class="marker" id="mapping-145"></span><span class="token del" data-title="assembly_statement/yul_variable_declaration">let <span class="marker" id="mapping-146"></span><span class="token del" data-title="yul_variable_declaration/yul_identifier">sheep</span> := <span class="marker" id="mapping-147"></span><span class="token del" data-title="yul_variable_declaration/yul_function_call"><span class="marker" id="mapping-148"></span><span class="token mv" id="move-src-120" data-title="yul_function_call/yul_evm_builtin">create</span>(0, 0, 0x28)</span></span>
            let offset := sload(0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)
            let location := sub(0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe, offset)
            sstore(location, <span class="marker" id="mapping-149"></span><span class="token del" data-title="yul_function_call/yul_path">sheep</span>)
            <span class="marker" id="mapping-150"></span><span class="token del" data-title="assembly_statement/yul_assignment"><span class="marker" id="mapping-151"></span><span class="token del" data-title="yul_assignment/yul_path">sheep</span> := <span class="marker" id="mapping-152"></span><span class="token del" data-title="yul_assignment/yul_function_call"><span class="marker" id="mapping-153"></span><span class="token mv" id="move-src-121" data-title="yul_function_call/yul_evm_builtin">create</span>(0, 0, 0x28)</span></span>
            <span class="marker" id="mapping-154"></span><span class="token mv" id="move-src-122" data-title="assembly_statement/yul_function_call">sstore(<span class="marker" id="mapping-155"></span><span class="token mv" id="move-src-123" data-title="yul_function_call/yul_function_call">sub(location, 1)</span><span class="marker" id="mapping-156"></span><span class="token mv" id="move-src-124" data-title="yul_function_call/,">,</span> <span class="marker" id="mapping-157"></span><span class="token upd" id="move-src-125" data-title="yul_identifier/identifier">sheep</span>)</span>
            <span class="marker" id="mapping-158"></span><span class="token del" data-title="assembly_statement/yul_assignment"><span class="marker" id="mapping-159"></span><span class="token del" data-title="yul_assignment/yul_path">sheep</span> := <span class="marker" id="mapping-160"></span><span class="token del" data-title="yul_assignment/yul_function_call"><span class="marker" id="mapping-161"></span><span class="token mv" id="move-src-126" data-title="yul_function_call/yul_evm_builtin">create</span>(0, 0, 0x28)</span></span>
            sstore(<span class="marker" id="mapping-162"></span><span class="token mv" id="move-src-127" data-title="yul_function_call/yul_function_call"><span class="marker" id="mapping-163"></span><span class="token del" data-title="yul_function_call/yul_evm_builtin">sub</span>(<span class="marker" id="mapping-164"></span><span class="token mv" id="move-src-128" data-title="yul_function_call/yul_path">location</span><span class="marker" id="mapping-165"></span><span class="token mv" id="move-src-129" data-title="yul_function_call/,">,</span> <span class="marker" id="mapping-166"></span><span class="token upd" id="move-src-130" data-title="yul_function_call/yul_decimal_number">2</span>)</span>, <span class="marker" id="mapping-167"></span><span class="token del" data-title="yul_function_call/yul_path">sheep</span>)
            sstore(0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff, add(offset, 3))
        }
    }

    /**
    @dev refund 39,000 gas
    @dev costs slightly more than 16,100 gas
    */
    function gasRefund39() internal {
        assembly {
            let offset := sload(0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)
            if gt(offset, 0) {
              let location := sub(0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff,offset)
              sstore(0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff, sub(offset, 1))
              let sheep := sload(location)
              pop(call(gas, sheep, 0, 0, 0, 0, 0))
              sstore(location, 0)
            }
        }
    }

    function sponsorGas() external {
        uint256 refundPrice = minimumGasPriceForFutureRefunds;
        require(refundPrice &gt; 0);
        assembly {
            let offset := sload(0xfffff)
            let result := add(offset, 9)
            sstore(0xfffff, result)
            let position := add(offset, 0x100000)
            sstore(position, refundPrice)
            position := add(position, 1)
            sstore(position, refundPrice)
            position := add(position, 1)
            sstore(position, refundPrice)
            position := add(position, 1)
            sstore(position, refundPrice)
            position := add(position, 1)
            sstore(position, refundPrice)
            position := add(position, 1)
            sstore(position, refundPrice)
            position := add(position, 1)
            sstore(position, refundPrice)
            position := add(position, 1)
            sstore(position, refundPrice)
            position := add(position, 1)
            sstore(position, refundPrice)
        }
    }

    function minimumGasPriceForRefund() public view returns (uint256 result) {
        assembly {
            let offset := sload(0xfffff)
            let location := add(offset, 0xfffff)
            result := add(sload(location), 1)
        }
    }

    <span class="marker" id="mapping-168"></span><span class="token upd" id="move-src-131" data-title="contract_body/comment"><span class="cupd">/**  
 </span>  <span class="cupd"> @dev refund 30,000 gas
    @dev costs slightly more than 15,400 gas
   </span> */</span>
    function gasRefund30() internal {
        assembly {
            let offset := sload(0xfffff)
            if gt(offset, 1) {
                let location := add(offset, 0xfffff)
                if gt(gasprice,sload(location)) {
                    sstore(location, 0)
                    location := sub(location, 1)
                    sstore(location, 0)
                    sstore(0xfffff, sub(offset, 2))
                }
            }
        }
    }

    <span class="marker" id="mapping-169"></span><span class="token upd" id="move-src-132" data-title="contract_body/comment"><span class="cupd">/**  
 </span>  <span class="cupd"> @dev refund 15,000 gas
    @dev costs slightly more than 10,200 gas
   </span> */</span>
    function gasRefund15() internal {
        assembly {
            let offset := sload(0xfffff)
            if gt(offset, 1) {
                let location := add(offset, 0xfffff)
                if gt(gasprice,sload(location)) {
                    sstore(location, 0)
                    sstore(0xfffff, sub(offset, 1))
                }
            }
        }
    }

    <span class="marker" id="mapping-170"></span><span class="token upd" id="move-src-133" data-title="contract_body/comment"><span class="cupd">/**  
 </span>  <span class="cupd"> *@dev Return the remaining sponsored gas slots
    </span>*/</span>
    function remainingGasRefundPool() public view returns (uint length) {
        assembly {
            length := sload(0xfffff)
        }
    }

    function gasRefundPool(uint256 _index) public view returns (uint256 gasPrice) {
        assembly {
            gasPrice := sload(add(0x100000, _index))
        }
    }

    bytes32 constant CAN_SET_FUTURE_REFUND_MIN_GAS_PRICE = "canSetFutureRefundMinGasPrice";

    function setMinimumGasPriceForFutureRefunds(uint256 _minimumGasPriceForFutureRefunds) public {
        require(registry.hasAttribute(msg.sender, CAN_SET_FUTURE_REFUND_MIN_GAS_PRICE));
        minimumGasPriceForFutureRefunds = _minimumGasPriceForFutureRefunds;
    }
}</span>

<span class="marker" id="mapping-171"></span><span class="token mv" id="move-src-134" data-title="source_file/comment"><span class="marker" id="mapping-172"></span><span class="token upd" id="move-src-135" data-title="source_file/comment"><span class="cupd">// File: contracts/</span><span class="cupd">C</span><span class="cupd">o</span>mp<span class="cupd">l</span>i<span class="cupd">a</span><span class="cupd">n</span>tD<span class="cupd">e</span>posit<span class="cupd">Token</span>WithHook<span class="cupd">.sol</span></span></span>

<span class="marker" id="mapping-173"></span><span class="token mv" id="move-src-136" data-title="source_file/contract_declaration">contract CompliantDepositTokenWithHook is ReclaimerToken, RegistryClone, BurnableTokenWithBounds, GasRefundToken {

    bytes32 constant IS_REGISTERED_CONTRACT = "isRegisteredContract";
    bytes32 constant IS_DEPOSIT_ADDRESS = "isDepositAddress";
    uint256 constant REDEMPTION_ADDRESS_COUNT = 0x100000;
    bytes32 constant IS_BLACKLISTED = "isBlacklisted";

    function canBurn() internal pure returns (bytes32);

    /**
    * @dev transfer token for a specified address
    * @param _to The address to transfer to.
    * @param _value The amount to be transferred.
    */
    function transfer(address _to, uint256 _value) public returns (bool) {
        _transferAllArgs(msg.sender, _to, _value);
        return true;
    }

    /**
     * @dev Transfer tokens from one address to another
     * @param _from address The address which you want to send tokens from
     * @param _to address The address which you want to transfer to
     * @param _value uint256 the amount of tokens to be transferred
     */
    function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {
        _transferFromAllArgs(_from, _to, _value, msg.sender);
        return true;
    }

    function _burnFromAllowanceAllArgs(address _from, address _to, uint256 _value, address _spender) internal {
        _requireCanTransferFrom(_spender, _from, _to);
        _requireOnlyCanBurn(_to);
        require(_value &gt;= burnMin, "below min burn bound");
        require(_value &lt;= burnMax, "exceeds max burn bound");
        if (0 == _subBalance(_from, _value)) {
            if (0 <span class="marker" id="mapping-174"></span><span class="token del" data-title="binary_expression/==">==</span> _subAllowance(_from, _spender, _value)) <span class="marker" id="mapping-175"></span><span class="token del" data-title="if_statement/block_statement">{
                // no refund
            }</span> <span class="marker" id="mapping-176"></span><span class="token del" data-title="if_statement/else">else</span> {
                gasRefund15();
            }
        } else {
            if (0 == _subAllowance(_from, _spender, _value)) {
                gasRefund15();
            } else {
                gasRefund39();
            }
        }
        emit Transfer(_from, _to, _value);
        totalSupply_ = totalSupply_.sub(_value);
        emit Burn(_to, _value);
        emit Transfer(_to, address(0), _value);
    }

    function _burnFromAllArgs(address _from, address _to, uint256 _value) internal {
        _requireCanTransfer(_from, _to);
        _requireOnlyCanBurn(_to);
        require(_value &gt;= burnMin, "below min burn bound");
        require(_value &lt;= burnMax, "exceeds max burn bound");
        if (0 == _subBalance(_from, _value)) {
            gasRefund15();
        } else {
            gasRefund30();
        }
        emit Transfer(_from, _to, _value);
        totalSupply_ = totalSupply_.sub(_value);
        emit Burn(_to, _value);
        emit Transfer(_to, address(0), _value);
    }

    function _transferFromAllArgs(address _from, address _to, uint256 _value, address _spender) internal {
        if (uint256(_to) &lt; REDEMPTION_ADDRESS_COUNT) {
            _value -= _value % CENT;
            _burnFromAllowanceAllArgs(_from, _to, _value, _spender);
        } else {
            bool hasHook;
            address originalTo = _to;
            (_to, hasHook) = _requireCanTransferFrom(_spender, _from, _to);
            if (0 == _addBalance(_to, _value)) {
                if (0 == _subAllowance(_from, _spender, _value)) {
                    if (0 <span class="marker" id="mapping-177"></span><span class="token del" data-title="binary_expression/==">==</span> _subBalance(_from, _value)) <span class="marker" id="mapping-178"></span><span class="token del" data-title="if_statement/block_statement">{
                        // do not refund
                    }</span> <span class="marker" id="mapping-179"></span><span class="token del" data-title="if_statement/else">else</span> {
                        gasRefund30();
                    }
                } else {
                    if (0 == _subBalance(_from, _value)) {
                        gasRefund30();
                    } else {
                        gasRefund39();
                    }
                }
            } else {
                if (0 == _subAllowance(_from, _spender, _value)) {
                    if (0 <span class="marker" id="mapping-180"></span><span class="token del" data-title="binary_expression/==">==</span> _subBalance(_from, _value)) <span class="marker" id="mapping-181"></span><span class="token del" data-title="if_statement/block_statement">{
                        // do not refund
                    }</span> <span class="marker" id="mapping-182"></span><span class="token del" data-title="if_statement/else">else</span> {
                        gasRefund15();
                    }
                } else {
                    if (0 == _subBalance(_from, _value)) {
                        gasRefund15();
                    } else {
                        gasRefund39();
                    }
                }

            }
            emit Transfer(_from, originalTo, _value);
            if (originalTo != _to) {
                emit Transfer(originalTo, _to, _value);
                if (hasHook) {
                    TrueCoinReceiver(_to).tokenFallback(originalTo, _value);
                }
            } else {
                if (hasHook) {
                    TrueCoinReceiver(_to).tokenFallback(_from, _value);
                }
            }
        }
    }

    function _transferAllArgs(address _from, address _to, uint256 _value) internal {
        if (uint256(_to) &lt; REDEMPTION_ADDRESS_COUNT) {
            _value -= _value % CENT;
            _burnFromAllArgs(_from, _to, _value);
        } else {
            bool hasHook;
            address finalTo;
            (finalTo, hasHook) = _requireCanTransfer(_from, _to);
            if (0 == _subBalance(_from, _value)) {
                if (0 == _addBalance(finalTo, _value)) {
                    gasRefund30();
                } <span class="marker" id="mapping-183"></span><span class="token del" data-title="if_statement/else">else</span> <span class="marker" id="mapping-184"></span><span class="token del" data-title="if_statement/block_statement">{
                    // do not refund
                }</span>
            } else {
                if (0 == _addBalance(finalTo, _value)) {
                    gasRefund39();
                } else {
                    gasRefund30();
                }
            }
            emit Transfer(_from, _to, _value);
            if (finalTo != _to) {
                emit Transfer(_to, finalTo, _value);
                if (hasHook) {
                    TrueCoinReceiver(finalTo).tokenFallback(_to, _value);
                }
            } else {
                if (hasHook) {
                    TrueCoinReceiver(finalTo).tokenFallback(_from, _value);
                }
            }
        }
    }

    function mint(address _to, uint256 _value) public onlyOwner {
        require(_to != address(0), "to address cannot be zero");
        bool hasHook;
        address originalTo = _to;
        (_to, hasHook) = _requireCanMint(_to);
        totalSupply_ = totalSupply_.add(_value);
        emit Mint(originalTo, _value);
        emit Transfer(address(0), originalTo, _value);
        if (_to != originalTo) {
            emit Transfer(originalTo, _to, _value);
        }
        _addBalance(_to, _value);
        if (hasHook) {
            if (_to != originalTo) {
                TrueCoinReceiver(_to).tokenFallback(originalTo, _value);
            } else {
                TrueCoinReceiver(_to).tokenFallback(address(0), _value);
            }
        }
    }

    event WipeBlacklistedAccount(address indexed account, uint256 balance);
    event SetRegistry(address indexed registry);

    /**
    * @dev Point to the registry that contains all compliance related data
    @param _registry The address of the registry instance
    */
    function setRegistry(Registry _registry) public onlyOwner {
        registry = _registry;
        emit SetRegistry(<span class="marker" id="mapping-185"></span><span class="token mv" id="move-src-137" data-title="emit_statement/call_argument">registry</span>);
    }

    modifier onlyRegistry {
      require(msg.sender == address(registry));
      _;
    }

    function syncAttributeValue(address _who, bytes32 _attribute, uint256 _value) public onlyRegistry {
        attributes[_attribute][_who] = _value;
    }

    function _burnAllArgs(address _from, uint256 _value) internal {
        _requireCanBurn(_from);
        super._burnAllArgs(_from, _value);
    }

    // Destroy the tokens owned by a blacklisted account
    function wipeBlacklistedAccount(address _account) public onlyOwner {
        require(_isBlacklisted(_account), "_account is not blacklisted");
        uint256 oldValue = _getBalance(_account);
        _setBalance(_account, 0);
        totalSupply_ = totalSupply_.sub(oldValue);
        emit WipeBlacklistedAccount(_account, oldValue);
        emit Transfer(_account, address(0), oldValue);
    }

    function _isBlacklisted(address _account) internal view returns (bool blacklisted) {
        return attributes[IS_BLACKLISTED][_account] != 0;
    }

    function _requireCanTransfer(address _from, address _to) internal view returns (address, bool) {
        uint256 depositAddressValue = attributes[IS_DEPOSIT_ADDRESS][address(uint256(_to) &gt;&gt; 20)];
        if (depositAddressValue != 0) {
            _to = address(depositAddressValue);
        }
        require (attributes[IS_BLACKLISTED][_to] == 0, "blacklisted");
        require (attributes[IS_BLACKLISTED][_from] == 0, "blacklisted");
        return (_to, attributes[IS_REGISTERED_CONTRACT][_to] != 0);
    }

    function _requireCanTransferFrom(address _spender, address _from, address _to) internal view returns (address, bool) {
        require (attributes[IS_BLACKLISTED][_spender] == 0, "blacklisted");
        uint256 depositAddressValue = attributes[IS_DEPOSIT_ADDRESS][address(uint256(_to) &gt;&gt; 20)];
        if (depositAddressValue != 0) {
            _to = address(depositAddressValue);
        }
        require (attributes[IS_BLACKLISTED][_to] == 0, "blacklisted");
        require (attributes[IS_BLACKLISTED][_from] == 0, "blacklisted");
        return (_to, attributes[IS_REGISTERED_CONTRACT][_to] != 0);
    }

    function _requireCanMint(address _to) internal view returns (address, bool) {
        uint256 depositAddressValue = attributes[IS_DEPOSIT_ADDRESS][address(uint256(_to) &gt;&gt; 20)];
        if (depositAddressValue != 0) {
            _to = address(depositAddressValue);
        }
        require (attributes[IS_BLACKLISTED][_to] == 0, "blacklisted");
        return (_to, attributes[IS_REGISTERED_CONTRACT][_to] != 0);
    }

    function _requireOnlyCanBurn(address _from) internal view {
        require (attributes[canBurn()][_from] != 0, "cannot burn from this address");
    }

    function _requireCanBurn(address _from) internal view {
        require (attributes[IS_BLACKLISTED][_from] == 0, "blacklisted");
        require (attributes[canBurn()][_from] != 0, "cannot burn from this address");
    }

    function paused() public pure returns (bool) {
        return false;
    }
}</span>

<span class="marker" id="mapping-186"></span><span class="token mv" id="move-src-138" data-title="source_file/comment"><span class="marker" id="mapping-187"></span><span class="token upd" id="move-src-139" data-title="source_file/comment"><span class="cupd">// File: contracts/</span>D<span class="cupd">e</span><span class="cupd">le</span>ga<span class="cupd">t</span>eERC20<span class="cupd">.sol</span></span></span>

<span class="marker" id="mapping-188"></span><span class="token upd" id="move-src-140" data-title="source_file/comment"><span class="cupd">/</span>**<span class="cupd"> </span>@t<span class="cupd">i</span>t<span class="cupd">le</span><span class="cupd"> </span>DelegateERC20
<span class="cupd">A</span>cce<span class="cupd">p</span>t f<span class="cupd">o</span>r<span class="cupd">w</span>arding deleg<span class="cupd">a</span>tion cal<span class="cupd">l</span>s from the old<span class="cupd"> Tru</span>eUSD (V1) c<span class="cupd">o</span>ntr<span class="cupd">a</span>ct. T<span class="cupd">h</span><span class="cupd">i</span>s <span class="cupd">w</span>ay t<span class="cupd">h</span>e all the ERC20<span class="cupd">
f</span>unctions in the <span class="cupd">o</span>ld<span class="cupd"> </span>contract still w<span class="cupd">o</span>rks<span class="cupd"> </span>(except B<span class="cupd">u</span>rn). 
*/</span>
<span class="marker" id="mapping-189"></span><span class="token mv" id="move-src-141" data-title="source_file/contract_declaration">contract DelegateERC20 is CompliantDepositTokenWithHook {

    address constant DELEGATE_FROM = 0x8dd5fbCe2F6a956C3022bA3663759011Dd51e73E;
    
    modifier onlyDelegateFrom() {
        require(msg.sender == DELEGATE_FROM);
        _;
    }

    function delegateTotalSupply() public view returns (uint256) {
        return totalSupply();
    }

    function delegateBalanceOf(address who) public view returns (uint256) {
        return _getBalance(who);
    }

    function delegateTransfer(address to, uint256 value, address origSender) public onlyDelegateFrom returns (bool) {
        _transferAllArgs(origSender, to, value);
        return true;
    }

    function delegateAllowance(address owner, address spender) public view returns (uint256) {
        return _getAllowance(owner, spender);
    }

    function delegateTransferFrom(address from, address to, uint256 value, address origSender) public onlyDelegateFrom returns (bool) {
        _transferFromAllArgs(from, to, value, origSender);
        return true;
    }

    function delegateApprove(address spender, uint256 value, address origSender) public onlyDelegateFrom returns (bool) {
        _approveAllArgs(spender, value, origSender);
        return true;
    }

    function delegateIncreaseApproval(address spender, uint addedValue, address origSender) public onlyDelegateFrom returns (bool) {
        <span class="marker" id="mapping-190"></span><span class="token upd" id="move-src-142" data-title="call_expression/identifier"><span class="cupd">_increaseA</span>ppr<span class="cupd">o</span>v<span class="cupd">a</span>l<span class="cupd">AllArgs</span></span>(spender, addedValue, origSender);
        return true;
    }

    function delegateDecreaseApproval(address spender, uint subtractedValue, address origSender) public onlyDelegateFrom returns (bool) {
        <span class="marker" id="mapping-191"></span><span class="token upd" id="move-src-143" data-title="call_expression/identifier"><span class="cupd">_decreaseA</span>ppr<span class="cupd">o</span>v<span class="cupd">a</span>l<span class="cupd">AllArgs</span></span>(spender, subtractedValue, origSender);
        return true;
    }
}</span>

<span class="marker" id="mapping-192"></span><span class="token upd" id="move-src-144" data-title="source_file/comment"><span class="cupd">/</span>/<span class="cupd"> </span>F<span class="cupd">i</span><span class="cupd">le</span>:<span class="cupd"> </span>c<span class="cupd">o</span><span class="cupd">n</span><span class="cupd">t</span><span class="cupd">r</span><span class="cupd">a</span><span class="cupd">c</span><span class="cupd">t</span><span class="cupd">s</span>/T<span class="cupd">r</span><span class="cupd">u</span><span class="cupd">e</span>USD.<span class="cupd">s</span>ol</span>

<span class="marker" id="mapping-193"></span><span class="token upd" id="move-src-145" data-title="source_file/comment"><span class="cupd">/</span>**<span class="cupd"> </span>@t<span class="cupd">i</span>t<span class="cupd">le</span><span class="cupd"> </span>TrueUSD
* @dev This is the top-level ERC20<span class="cupd"> contrac</span>t, <span class="cupd">b</span>ut most of t<span class="cupd">h</span>e int<span class="cupd">e</span><span class="cupd">r</span>est<span class="cupd">i</span>ng fu<span class="cupd">n</span>c<span class="cupd">t</span><span class="cupd">i</span>on<span class="cupd">al</span>ity is
*<span class="cupd"> </span>inhe<span class="cupd">r</span><span class="cupd">i</span>ted <span class="cupd">-</span> se<span class="cupd">e</span> the<span class="cupd"> </span>doc<span class="cupd">um</span>ent<span class="cupd">a</span>tion o<span class="cupd">n </span>the<span class="cupd"> </span>cor<span class="cupd">r</span>esponding contracts.
*/</span>
contract TrueUSD is 
<span class="marker" id="mapping-194"></span><span class="token mv" id="move-src-146" data-title="contract_declaration/inheritance_specifier">CompliantDepositTokenWithHook</span>,
DelegateERC20 {
    uint8 constant DECIMALS = 18;
    uint8 constant ROUNDING = 2;

    function decimals() public pure returns (uint8) {
        return DECIMALS;
    }

    function rounding() public pure returns (uint8) {
        return ROUNDING;
    }

    function name() public pure returns (string) {
        return "TrueUSD";
    }

    function symbol() public pure returns (string) {
        return "TUSD";
    }

    function canBurn() internal pure returns (bytes32) {
        return "canBurn";
    }
}</pre></div><div class="col-6"><h5>0x20594f0b1f549d19b5dd81590d93bd131c657e01.etherscan.io-TrueUSD.sol</h5><pre class="pre-scrollable"><span class="marker" id="mapping-195"></span><span class="token upd" id="move-dst-3" data-title="source_file/comment"><span class="cupd">// File: contracts/TrueC</span>urrencies/TrueC<span class="cupd">oinReceiver.sol</span></span>

<span class="marker" id="mapping-196"></span><span class="token add" data-title="source_file/pragma_directive">pragma solidity 0.5.13;</span>

contract TrueCoinReceiver {
    function tokenFallback( address from, uint256 value ) external;
}

<span class="marker" id="mapping-197"></span><span class="token upd" id="move-dst-4" data-title="source_file/comment"><span class="cupd">// File: </span><span class="cupd">contracts/</span>Tru<span class="cupd">e</span><span class="cupd">R</span>eward<span class="cupd">/</span>Fin<span class="cupd">a</span>nc<span class="cupd">i</span>alOpportunity<span class="cupd">.sol</span></span>

<span class="marker" id="mapping-198"></span><span class="token add" data-title="source_file/pragma_directive">pragma solidity 0.5.13;</span>

<span class="marker" id="mapping-199"></span><span class="token upd" id="move-dst-5" data-title="source_file/comment"><span class="cupd">/**
 * @title</span> Fi<span class="cupd">n</span>an<span class="cupd">c</span>ialOpportunit<span class="cupd">y
 * @de</span>v Interface for <span class="cupd">t</span>hird parties to<span class="cupd"> imp</span>lement financial op<span class="cupd">p</span>ortuniti<span class="cupd">e</span>s
 *
 * <span class="cupd">-- </span>Overview --
 * The goal o<span class="cupd">f</span> this cont<span class="cupd">r</span>act<span class="cupd"> </span>is to al<span class="cupd">l</span>ow a<span class="cupd">n</span>y<span class="cupd">o</span>ne to create an opportunity
 * to earn interest on TUSD. deposit() "mints" yTUSD whcih is redeemab<span class="cupd">l</span>e<span class="cupd">
</span> * f<span class="cupd">o</span>r some amount of TUSD. TrueUSD w<span class="cupd">r</span>aps <span class="cupd">th</span>is contractwith T<span class="cupd">r</span>ustToken<span class="cupd">
</span> * Assurance, which provides pro<span class="cupd">t</span>ection fr<span class="cupd">o</span>m bugs and system design flaws
 * T<span class="cupd">U</span>SD is a compli<span class="cupd">a</span>nt st<span class="cupd">a</span>blecoin, <span class="cupd">t</span>herefore we do not allow trans<span class="cupd">fe</span>rs of
 * yTUSD, thus there are no transfer functions
 *
 * -- tokenValue() --
 * This function returns the value in TUSD of 1 yTUSD
 * Th<span class="cupd">i</span>s <span class="cupd">va</span>lu<span class="cupd">e</span> shoul<span class="cupd">d </span>never decrease
 *
 * -- TUSD vs yTU<span class="cupd">S</span>D --
 *<span class="cupd"> </span>yTUSD represent<span class="cupd">s</span> a fixed value which is redeemab<span class="cupd">l</span>e for some amount of TUSD
 * Think of yTUSD like cTUSD, whe<span class="cupd">r</span>e cTokens are<span class="cupd"> </span>minted and increase in value versu<span class="cupd">s</span>
 * the u<span class="cupd">n</span>d<span class="cupd">e</span>rlying asset as interest is accrued
 *
 * -- <span class="cupd">t</span>otal<span class="cupd">S</span>upply() --
 * This function returns the total s<span class="cupd">u</span>pply of<span class="cupd"> y</span>TUSD issued by th<span class="cupd">i</span>s contract
 * It is important to track this v<span class="cupd">a</span>l<span class="cupd">u</span>e a<span class="cupd">c</span>cu<span class="cupd">ra</span>tle<span class="cupd">y</span> <span class="cupd">a</span>nd add/de<span class="cupd">d</span>uct the co<span class="cupd">r</span>re<span class="cupd">c</span>t
 * a<span class="cupd">m</span>ou<span class="cupd">n</span>t on deposi<span class="cupd">t</span>/<span class="cupd">r</span>edemptions
 *
 * <span class="cupd">-</span>- Assumptions --
 * - <span class="cupd">t</span>o<span class="cupd">ken</span>Value can never decrease
 * - total TUSD owed to depositors = tokenValue() * totalSupply()
 */</span>
<span class="marker" id="mapping-200"></span><span class="token add" data-title="source_file/interface_declaration">interface FinancialOpportunity <span class="marker" id="mapping-201"></span><span class="token add" data-title="interface_declaration/contract_body">{

    /**
     * @dev Returns total supply of yTUSD in this contract
     *
     * @return total supply of yTUSD in this contract
    **/
    <span class="marker" id="mapping-202"></span><span class="token add" data-title="contract_body/function_definition">function totalSupply() external view returns (uint);</span>

    /**
     * @dev Exchange rate between TUSD and yTUSD
     *
     * tokenValue should never decrease
     *
     * @return TUSD / yTUSD price ratio
     */
    <span class="marker" id="mapping-203"></span><span class="token add" data-title="contract_body/function_definition">function tokenValue() external view returns(uint);</span>

    /**
     * @dev deposits TrueUSD and returns yTUSD minted
     *
     * We can think of deposit as a minting function which
     * will increase totalSupply of yTUSD based on the deposit
     *
     * @param from account to transferFrom
     * @param amount amount in TUSD to deposit
     * @return yTUSD minted from this deposit
     */
    <span class="marker" id="mapping-204"></span><span class="token add" data-title="contract_body/function_definition">function deposit(<span class="marker" id="mapping-205"></span><span class="token mv" id="move-dst-23" data-title="function_definition/parameter">address from</span>, <span class="marker" id="mapping-206"></span><span class="token add" data-title="function_definition/parameter">uint amount</span>) <span class="marker" id="mapping-207"></span><span class="token add" data-title="function_definition/visibility">external</span> <span class="marker" id="mapping-208"></span><span class="token add" data-title="function_definition/return_type_definition">returns(uint)</span>;</span>

    /**
     * @dev Redeem yTUSD for TUSD and withdraw to account
     *
     * This function should use tokenValue to calculate
     * how much TUSD is owed. This function should burn yTUSD
     * after redemption
     *
     * This function must return value in TUSD
     *
     * @param to account to transfer TUSD for
     * @param amount amount in TUSD to withdraw from finOp
     * @return TUSD amount returned from this transaction
     */
    <span class="marker" id="mapping-209"></span><span class="token add" data-title="contract_body/function_definition">function redeem(<span class="marker" id="mapping-210"></span><span class="token mv" id="move-dst-14" data-title="function_definition/parameter">address to</span>, <span class="marker" id="mapping-211"></span><span class="token add" data-title="function_definition/parameter">uint amount</span>) <span class="marker" id="mapping-212"></span><span class="token add" data-title="function_definition/visibility">external</span> <span class="marker" id="mapping-213"></span><span class="token add" data-title="function_definition/return_type_definition">returns(uint)</span>;</span>
}</span></span>

<span class="marker" id="mapping-214"></span><span class="token upd" id="move-dst-17" data-title="source_file/comment"><span class="cupd">// File: openzeppelin-solidity/contracts/token/ERC20/</span>I<span class="cupd">ERC20.sol</span></span>

<span class="marker" id="mapping-215"></span><span class="token mv" id="move-dst-1" data-title="source_file/pragma_directive">pragma solidity ^<span class="marker" id="mapping-216"></span><span class="token upd" id="move-dst-2" data-title="solidity_pragma_token/solidity_version"><span class="cupd">0.</span>5.0</span>;</span>

<span class="marker" id="mapping-217"></span><span class="token upd" id="move-dst-18" data-title="source_file/comment"><span class="cupd">/**
 * </span>@dev I<span class="cupd">n</span>terface of<span class="cupd"> </span>t<span class="cupd">he ERC20</span> standard as de<span class="cupd">fi</span>ned in<span class="cupd"> </span>t<span class="cupd">h</span>e EIP. Does not i<span class="cupd">n</span>clu<span class="cupd">de
 </span>* <span class="cupd">t</span><span class="cupd">h</span>e option<span class="cupd">a</span>l fu<span class="cupd">n</span>cti<span class="cupd">o</span>ns<span class="cupd">;</span> to<span class="cupd"> </span>a<span class="cupd">c</span>ces<span class="cupd">s t</span><span class="cupd">h</span>e<span class="cupd">m</span><span class="cupd"> </span>see {E<span class="cupd">RC</span>20Detailed<span class="cupd">}.
</span> */</span>
<span class="marker" id="mapping-218"></span><span class="token add" data-title="source_file/interface_declaration">interface IERC20 <span class="marker" id="mapping-219"></span><span class="token mv" id="move-dst-6" data-title="interface_declaration/contract_body">{
    <span class="marker" id="mapping-220"></span><span class="token add" data-title="contract_body/comment">/**
     * @dev Returns the amount of tokens in existence.
     */</span>
    <span class="marker" id="mapping-221"></span><span class="token add" data-title="contract_body/function_definition">function totalSupply() external view returns (uint256);</span>

    <span class="marker" id="mapping-222"></span><span class="token add" data-title="contract_body/comment">/**
     * @dev Returns the amount of tokens owned by `account`.
     */</span>
    <span class="marker" id="mapping-223"></span><span class="token add" data-title="contract_body/function_definition">function balanceOf(address account) external view returns (uint256);</span>

    <span class="marker" id="mapping-224"></span><span class="token add" data-title="contract_body/comment">/**
     * @dev Moves `amount` tokens from the caller's account to `recipient`.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * Emits a {Transfer} event.
     */</span>
    <span class="marker" id="mapping-225"></span><span class="token mv" id="move-dst-21" data-title="contract_body/function_definition">function <span class="marker" id="mapping-226"></span><span class="token upd" id="move-dst-22" data-title="function_definition/identifier"><span class="cupd">transfer</span></span>(<span class="marker" id="mapping-227"></span><span class="token add" data-title="function_definition/parameter">address recipient</span>, <span class="marker" id="mapping-228"></span><span class="token mv" id="move-dst-76" data-title="function_definition/parameter">uint256 <span class="marker" id="mapping-229"></span><span class="token upd" id="move-dst-77" data-title="parameter/identifier">amount</span></span>) <span class="marker" id="mapping-230"></span><span class="token add" data-title="function_definition/visibility">external</span> returns (bool);</span>

    <span class="marker" id="mapping-231"></span><span class="token add" data-title="contract_body/comment">/**
     * @dev Returns the remaining number of tokens that `spender` will be
     * allowed to spend on behalf of `owner` through {transferFrom}. This is
     * zero by default.
     *
     * This value changes when {approve} or {transferFrom} are called.
     */</span>
    <span class="marker" id="mapping-232"></span><span class="token mv" id="move-dst-19" data-title="contract_body/function_definition">function allowance(address owner, address spender) <span class="marker" id="mapping-233"></span><span class="token add" data-title="function_definition/visibility">external</span> view returns (uint256);</span>

    <span class="marker" id="mapping-234"></span><span class="token add" data-title="contract_body/comment">/**
     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * IMPORTANT: Beware that changing an allowance with this method brings the risk
     * that someone may use both the old and the new allowance by unfortunate
     * transaction ordering. One possible solution to mitigate this race
     * condition is to first reduce the spender's allowance to 0 and set the
     * desired value afterwards:
     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
     *
     * Emits an {Approval} event.
     */</span>
    function <span class="marker" id="mapping-235"></span><span class="token upd" id="move-dst-13" data-title="function_definition/identifier">app<span class="cupd">r</span>ove</span>(<span class="marker" id="mapping-236"></span><span class="token mv" id="move-dst-28" data-title="function_definition/parameter">address spender</span>, <span class="marker" id="mapping-237"></span><span class="token mv" id="move-dst-64" data-title="parameter/type_name">uint256</span> <span class="marker" id="mapping-238"></span><span class="token upd" id="move-dst-15" data-title="parameter/identifier"><span class="cupd">a</span>mount</span>) <span class="marker" id="mapping-239"></span><span class="token add" data-title="function_definition/visibility">external</span> returns (bool);

    <span class="marker" id="mapping-240"></span><span class="token add" data-title="contract_body/comment">/**
     * @dev Moves `amount` tokens from `sender` to `recipient` using the
     * allowance mechanism. `amount` is then deducted from the caller's
     * allowance.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * Emits a {Transfer} event.
     */</span>
    <span class="marker" id="mapping-241"></span><span class="token add" data-title="contract_body/function_definition">function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);</span>

    <span class="marker" id="mapping-242"></span><span class="token add" data-title="contract_body/comment">/**
     * @dev Emitted when `value` tokens are moved from one account (`from`) to
     * another (`to`).
     *
     * Note that `value` may be zero.
     */</span>
    event Transfer(address indexed from, address indexed to, uint256 value);

    <span class="marker" id="mapping-243"></span><span class="token add" data-title="contract_body/comment">/**
     * @dev Emitted when the allowance of a `spender` for an `owner` is set by
     * a call to {approve}. `value` is the new allowance.
     */</span>
    <span class="marker" id="mapping-244"></span><span class="token mv" id="move-dst-30" data-title="contract_body/event_definition">event Approval(address indexed owner, address indexed spender, uint256 value);</span>
}</span></span>

<span class="marker" id="mapping-245"></span><span class="token upd" id="move-dst-31" data-title="source_file/comment"><span class="cupd">// File: </span>@t<span class="cupd">r</span>usttok<span class="cupd">e</span>n/re<span class="cupd">gistry/contracts/Registry.sol</span></span>

<span class="marker" id="mapping-246"></span><span class="token add" data-title="source_file/pragma_directive">pragma solidity ^0.5.13;</span>


interface RegistryClone {
    function syncAttributeValue(address _who, bytes32 _attribute, uint256 _value) external;
}

contract Registry {
    struct AttributeData {
        uint256 value;
        bytes32 notes;
        address adminAddr;
        uint256 timestamp;
    }
    
    // never remove any storage variables
    address public owner;
    address public pendingOwner;
    bool initialized;

    <span class="marker" id="mapping-247"></span><span class="token upd" id="move-dst-32" data-title="contract_body/comment"><span class="cupd">// Stores arbitrary attributes for users. An example use case is an </span>I<span class="cupd">ERC20</span></span>
    // token that requires its users to go through a KYC/AML check - in this case
    // a validator can set an account's "hasPassedKYC/AML" attribute to 1 to indicate
    // that account can use the token. This mapping stores that value (1, in the
    // example) as well as which validator last set the value and at what time,
    // so that e.g. the check can be renewed at appropriate intervals.
    mapping(address =&gt; mapping(bytes32 =&gt; AttributeData)) attributes;
    // The logic governing who is allowed to set what attributes is abstracted as
    // this accessManager, so that it may be replaced by the owner as needed
    bytes32 constant WRITE_PERMISSION = keccak256("canWriteTo-");
    mapping(bytes32 =&gt; RegistryClone[]) subscribers;

    event OwnershipTransferred(
        address indexed previousOwner,
        address indexed newOwner
    );
    event SetAttribute(address indexed who, bytes32 attribute, uint256 value, bytes32 notes, address indexed adminAddr);
    event SetManager(address indexed oldManager, address indexed newManager);
    event StartSubscription(bytes32 indexed attribute, RegistryClone indexed subscriber);
    event StopSubscription(bytes32 indexed attribute, RegistryClone indexed subscriber);

    // Allows a write if either a) the writer is that Registry's owner, or
    // b) the writer is writing to attribute foo and that writer already has
    // the canWriteTo-foo attribute set (in that same Registry)
    function confirmWrite(bytes32 _attribute, address _admin) internal view returns (bool) {
        return (_admin == owner || <span class="marker" id="mapping-248"></span><span class="token add" data-title="binary_expression/call_expression">hasAttribute(<span class="marker" id="mapping-249"></span><span class="token mv" id="move-dst-35" data-title="call_expression/call_argument">_admin</span>, <span class="marker" id="mapping-250"></span><span class="token add" data-title="call_expression/call_argument"><span class="marker" id="mapping-251"></span><span class="token mv" id="move-dst-33" data-title="call_argument/call_expression"><span class="marker" id="mapping-252"></span><span class="token upd" id="move-dst-34" data-title="call_expression/identifier">keccak256</span>(<span class="marker" id="mapping-253"></span><span class="token add" data-title="call_expression/member_expression">abi.encodePacked</span>(WRITE_PERMISSION ^ _attribute))</span></span>)</span>);
    }

    // Writes are allowed only if the accessManager approves
    function setAttribute(address _who, bytes32 _attribute, uint256 _value, bytes32 _notes) public {
        require(confirmWrite(_attribute, msg.sender));
        attributes[_who][_attribute] = AttributeData(_value, _notes, msg.sender, block.timestamp);
        emit SetAttribute(_who, _attribute, _value, _notes, msg.sender);

        RegistryClone[] storage targets = subscribers[_attribute];
        uint256 index = targets.length;
        while (index --&gt; 0) {
            targets[index].syncAttributeValue(_who, _attribute, _value);
        }
    }

    function subscribe(bytes32 _attribute, RegistryClone _syncer) external onlyOwner {
        subscribers[_attribute].push(_syncer);
        emit StartSubscription(_attribute, _syncer);
    }

    function unsubscribe(bytes32 _attribute, uint256 _index) external onlyOwner {
        uint256 length = subscribers[_attribute].length;
        require(_index &lt; length);
        emit StopSubscription(_attribute, subscribers[_attribute][_index]);
        subscribers[_attribute][_index] = subscribers[_attribute][length - 1];
        subscribers[_attribute].length = length - 1;
    }

    function subscriberCount(bytes32 _attribute) public view returns (uint256) {
        return subscribers[_attribute].length;
    }

    function setAttributeValue(address _who, bytes32 _attribute, uint256 _value) public {
        require(confirmWrite(_attribute, msg.sender));
        attributes[_who][_attribute] = AttributeData(_value, "", msg.sender, block.timestamp);
        emit SetAttribute(_who, _attribute, _value, "", msg.sender);
        RegistryClone[] storage targets = subscribers[_attribute];
        uint256 index = targets.length;
        while (index --&gt; 0) {
            targets[index].syncAttributeValue(_who, _attribute, _value);
        }
    }

    // Returns true if the uint256 value stored for this attribute is non-zero
    function hasAttribute(address _who, bytes32 _attribute) public view returns (bool) {
        return attributes[_who][_attribute].value != 0;
    }


    // Returns the exact value of the attribute, as well as its metadata
    function getAttribute(address _who, bytes32 _attribute) public view returns (uint256, bytes32, address, uint256) {
        AttributeData memory data = attributes[_who][_attribute];
        return (data.value, data.notes, data.adminAddr, data.timestamp);
    }

    function getAttributeValue(address _who, bytes32 _attribute) public view returns (uint256) {
        return attributes[_who][_attribute].value;
    }

    function getAttributeAdminAddr(address _who, bytes32 _attribute) public view returns (address) {
        return attributes[_who][_attribute].adminAddr;
    }

    function getAttributeTimestamp(address _who, bytes32 _attribute) public view returns (uint256) {
        return attributes[_who][_attribute].timestamp;
    }

    function syncAttribute(bytes32 _attribute, uint256 _startIndex, address[] <span class="marker" id="mapping-254"></span><span class="token add" data-title="parameter/calldata">calldata</span> _addresses) external {
        RegistryClone[] storage targets = subscribers[_attribute];
        uint256 index = targets.length;
        while (index --&gt; _startIndex) {
            RegistryClone target = targets[index];
            for (uint256 i = _addresses.length; i --&gt; 0; ) {
                address who = _addresses[i];
                target.syncAttributeValue(who, _attribute, attributes[who][_attribute].value);
            }
        }
    }

    function reclaimEther(<span class="marker" id="mapping-255"></span><span class="token add" data-title="function_definition/parameter">address payable _to</span>) external onlyOwner {
        _to.transfer(address(this).balance);
    }

    function reclaimToken(<span class="marker" id="mapping-256"></span><span class="token upd" id="move-dst-37" data-title="user_defined_type/identifier">I<span class="cupd">ERC20</span></span> token, address _to) external onlyOwner {
        uint256 balance = token.balanceOf(<span class="marker" id="mapping-257"></span><span class="token add" data-title="call_expression/call_argument"><span class="marker" id="mapping-258"></span><span class="token add" data-title="call_argument/type_cast_expression"><span class="marker" id="mapping-259"></span><span class="token add" data-title="type_cast_expression/primitive_type">address</span>(<span class="marker" id="mapping-260"></span><span class="token mv" id="move-dst-92" data-title="type_cast_expression/call_argument">this</span>)</span></span>);
        token.transfer(_to, balance);
    }

   /**
    * @dev Throws if called by any account other than the owner.
    */
    modifier onlyOwner() {
        require(msg.sender == owner, "only Owner");
        _;
    }

    /**
    * @dev Modifier throws if called by any account other than the pendingOwner.
    */
    modifier onlyPendingOwner() {
        require(msg.sender == pendingOwner);
        _;
    }

    /**
    * @dev Allows the current owner to set the pendingOwner address.
    * @param newOwner The address to transfer ownership to.
    */
    function transferOwnership(address newOwner) public onlyOwner {
        pendingOwner = newOwner;
    }

    /**
    * @dev Allows the pendingOwner address to finalize the transfer.
    */
    function claimOwnership() public onlyPendingOwner {
        emit OwnershipTransferred(owner, pendingOwner);
        owner = pendingOwner;
        pendingOwner = address(0);
    }
}

<span class="marker" id="mapping-261"></span><span class="token upd" id="move-dst-39" data-title="source_file/comment"><span class="cupd">// File: </span><span class="cupd">contracts/</span>TrueCurre<span class="cupd">n</span>ci<span class="cupd">e</span>s/modula<span class="cupd">r</span>ERC20/In<span class="cupd">s</span>tant<span class="cupd">i</span>atable<span class="cupd">Ownable.sol</span></span>

<span class="marker" id="mapping-262"></span><span class="token add" data-title="source_file/pragma_directive">pragma solidity 0.5.13;</span>


<span class="marker" id="mapping-263"></span><span class="token upd" id="move-dst-40" data-title="source_file/comment"><span class="cupd">/**
 * @title</span> Instantiatabl<span class="cupd">eOwnable
 * @dev Th</span>e Instantiatab<span class="cupd">leOwnable contract has an owner address, and provides basic authorization control
 * functions, this simplifies the implementation of "user permissions".</span>
 */</span>
contract <span class="marker" id="mapping-264"></span><span class="token upd" id="move-dst-41" data-title="contract_declaration/identifier">Instantiatable<span class="cupd">Ownable</span></span> {
    address public owner;

    event OwnershipTransferred(
        address indexed previousOwner,
        address indexed newOwner
    );

    <span class="marker" id="mapping-265"></span><span class="token upd" id="move-dst-42" data-title="contract_body/comment"><span class="cupd">/**
  </span>  <span class="cupd"> * @dev The</span> Instantiatabl<span class="cupd">eOwnable constructor sets the original `owner` of the contract to the sender
 </span>  <span class="cupd">  * account.
</span>  <span class="cupd">  </span> */</span>
    <span class="marker" id="mapping-266"></span><span class="token add" data-title="contract_body/constructor_definition">constructor() public <span class="marker" id="mapping-267"></span><span class="token mv" id="move-dst-44" data-title="constructor_definition/function_body">{
        owner = msg.sender;
    }</span></span>

    <span class="marker" id="mapping-268"></span><span class="token upd" id="move-dst-45" data-title="contract_body/comment"><span class="cupd">/**
  </span>  <span class="cupd"> * @dev Throws if called by any account other than the owner.
 </span>  <span class="cupd">  </span>*/</span>
    modifier onlyOwner() {
        require(msg.sender == owner);
        _;
    }

    <span class="marker" id="mapping-269"></span><span class="token upd" id="move-dst-46" data-title="contract_body/comment"><span class="cupd">/**
  </span>  <span class="cupd"> * @dev Allows the current owner to transfer control of the contract to a newOwner.
 </span>  <span class="cupd">  * @param newOwner The address to transfer ownership to.
</span>  <span class="cupd">  </span> */</span>
    function transferOwnership(address newOwner) public onlyOwner {
        require(newOwner != address(0));
        emit OwnershipTransferred(owner, newOwner);
        owner = newOwner;
    }
}

<span class="marker" id="mapping-270"></span><span class="token upd" id="move-dst-47" data-title="source_file/comment"><span class="cupd">// File: </span><span class="cupd">contracts/</span>TrueCurre<span class="cupd">n</span>ci<span class="cupd">e</span><span class="cupd">s</span><span class="cupd">/</span>modularER<span class="cupd">C</span>20/C<span class="cupd">laimable.sol</span></span>

<span class="marker" id="mapping-271"></span><span class="token add" data-title="source_file/pragma_directive">pragma solidity 0.5.13;</span>



<span class="marker" id="mapping-272"></span><span class="token upd" id="move-dst-48" data-title="source_file/comment"><span class="cupd">/**
 * @title Claimable
 * @dev Extension for th</span>e Instantiatab<span class="cupd">leOwnable contract, where the ownership needs to be claimed.
 * This allows the new owner to accept the transfer.</span>
 */</span>
contract Claimable is <span class="marker" id="mapping-273"></span><span class="token upd" id="move-dst-49" data-title="user_defined_type/identifier">Instantiatable<span class="cupd">Ownable</span></span> {
    address public pendingOwner;

    <span class="marker" id="mapping-274"></span><span class="token upd" id="move-dst-50" data-title="contract_body/comment"><span class="cupd">/**
  </span>  <span class="cupd"> * @dev Modifier throws if called by any account other than the pendingOwner.
 </span>  <span class="cupd">  </span>*/</span>
    modifier onlyPendingOwner() {
        require(msg.sender == pendingOwner);
        _;
    }

    <span class="marker" id="mapping-275"></span><span class="token upd" id="move-dst-51" data-title="contract_body/comment"><span class="cupd">/**
  </span>  <span class="cupd"> * @dev Allows the current owner to set the pendingOwner address.
 </span>  <span class="cupd">  * @param newOwner The address to transfer ownership to.
</span>  <span class="cupd">  </span> */</span>
    <span class="marker" id="mapping-276"></span><span class="token add" data-title="contract_body/function_definition">function transferOwnership(address newOwner) public onlyOwner {
        pendingOwner = newOwner;
    }</span>

    <span class="marker" id="mapping-277"></span><span class="token upd" id="move-dst-56" data-title="contract_body/comment"><span class="cupd">/**
  </span>  <span class="cupd"> * @dev Allows the pendingOwner address to finalize the transfer.
 </span>  <span class="cupd">  </span>*/</span>
    <span class="marker" id="mapping-278"></span><span class="token add" data-title="contract_body/function_definition">function claimOwnership() public onlyPendingOwner {
        emit OwnershipTransferred(owner, pendingOwner);
        owner = pendingOwner;
        pendingOwner = address(0);
    }</span>
}

// File: openzeppelin-solidity/contracts/math/SafeMath.sol

<span class="marker" id="mapping-279"></span><span class="token add" data-title="source_file/pragma_directive">pragma solidity ^0.5.0;</span>

<span class="marker" id="mapping-280"></span><span class="token upd" id="move-dst-61" data-title="source_file/comment"><span class="cupd">/**
 * </span>@dev Wrappers over Solid<span class="cupd">i</span>ty's a<span class="cupd">ri</span>thmetic operations with added over<span class="cupd">f</span>low
 * <span class="cupd">c</span>heck<span class="cupd">s</span>.
 *
 * Arithmetic operations<span class="cupd"> </span>in Solidit<span class="cupd">y</span> wrap on <span class="cupd">o</span>verflow. This <span class="cupd">c</span><span class="cupd">a</span>n easily r<span class="cupd">e</span>sult
 * in bugs, because programmers usually ass<span class="cupd">u</span>me<span class="cupd"> </span>th<span class="cupd">a</span>t an overflow raises<span class="cupd"> a</span>n
 * error, which is th<span class="cupd">e</span> stan<span class="cupd">d</span>ar<span class="cupd">d</span> be<span class="cupd">h</span>avior in high level programming languages.
 <span class="cupd">* `S</span>a<span class="cupd">f</span>eMat<span class="cupd">h</span>` restores this intuition by reverting the transaction when <span class="cupd">an
 * o</span>peration <span class="cupd">o</span>v<span class="cupd">e</span>rflows.<span class="cupd">
</span> *<span class="cupd">
 </span>* <span class="cupd">U</span>sing this <span class="cupd">l</span>ib<span class="cupd">r</span>ary<span class="cupd"> </span>ins<span class="cupd">t</span><span class="cupd">e</span>ad<span class="cupd"> of t</span>he unchecked<span class="cupd"> o</span>perati<span class="cupd">on</span>s <span class="cupd">e</span>limin<span class="cupd">a</span>t<span class="cupd">e</span>s an entire<span class="cupd"></span>
<span class="cupd"> </span>* class<span class="cupd"> </span><span class="cupd">o</span>f bugs<span class="cupd">,</span> <span class="cupd">s</span>o it's <span class="cupd">r</span>ec<span class="cupd">o</span>mmended to use i<span class="cupd">t </span>always.
 */</span>
library SafeMath {
    <span class="marker" id="mapping-281"></span><span class="token upd" id="move-dst-62" data-title="contract_body/comment"><span class="cupd">/**
 </span>   <span class="cupd"> * @dev</span> Re<span class="cupd">t</span>urns<span class="cupd"> </span>the ad<span class="cupd">d</span>i<span class="cupd">t</span>io<span class="cupd">n</span> of<span class="cupd"> two</span> <span class="cupd">u</span>nsig<span class="cupd">n</span>ed integ<span class="cupd">ers,</span> reve<span class="cupd">r</span>ting on
     * o<span class="cupd">v</span>er<span class="cupd">fl</span>ow.
     *
     * Counterpart to Solid<span class="cupd">it</span>y's <span class="cupd">`</span>+` operator.
     *
     * Req<span class="cupd">u</span>ire<span class="cupd">m</span>ents:
     * -<span class="cupd"> </span>Addition c<span class="cupd">annot overf</span>low<span class="cupd">.</span>
     */</span>
    <span class="marker" id="mapping-282"></span><span class="token mv" id="move-dst-75" data-title="contract_body/function_definition">function add(uint256 a, uint256 b) internal pure returns (<span class="marker" id="mapping-283"></span><span class="token add" data-title="return_type_definition/parameter">uint256</span>) {
        <span class="marker" id="mapping-284"></span><span class="token add" data-title="function_body/variable_declaration_statement"><span class="marker" id="mapping-285"></span><span class="token add" data-title="variable_declaration_statement/variable_declaration">uint256 c</span> = <span class="marker" id="mapping-286"></span><span class="token mv" id="move-dst-78" data-title="variable_declaration_statement/binary_expression">a + b</span>;</span>
        <span class="marker" id="mapping-287"></span><span class="token upd" id="move-dst-79" data-title="call_expression/identifier">r<span class="cupd">e</span>quire</span>(c &gt;= a<span class="marker" id="mapping-288"></span><span class="token add" data-title="call_expression/,">,</span> <span class="marker" id="mapping-289"></span><span class="token add" data-title="call_expression/call_argument">"SafeMath: addition overflow"</span>);

        return c;
    }</span>

    <span class="marker" id="mapping-290"></span><span class="token upd" id="move-dst-67" data-title="contract_body/comment"><span class="cupd">/**
 </span>   <span class="cupd"> * @dev</span> Retu<span class="cupd">r</span>ns<span class="cupd"> </span>t<span class="cupd">h</span><span class="cupd">e</span><span class="cupd"> </span>subtrac<span class="cupd">tion of two</span> <span class="cupd">u</span>nsig<span class="cupd">n</span>ed integ<span class="cupd">ers,</span> reve<span class="cupd">r</span>ting on
     * o<span class="cupd">v</span>erflow (when the r<span class="cupd">e</span>sult i<span class="cupd">s</span> n<span class="cupd">ega</span>tive).
     *
     *<span class="cupd"> </span>Counter<span class="cupd">pa</span>rt to Solidity's `-<span class="cupd">`</span> opera<span class="cupd">t</span>or.
     *
   <span class="cupd">  </span><span class="cupd">*</span> <span class="cupd">R</span>eq<span class="cupd">ui</span>rements:
     * - Subtraction cannot o<span class="cupd">verf</span>low<span class="cupd">.</span>
     */</span>
    <span class="marker" id="mapping-291"></span><span class="token add" data-title="contract_body/function_definition">function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        return sub(a, b, "SafeMath: subtraction overflow");
    }</span>

    <span class="marker" id="mapping-292"></span><span class="token upd" id="move-dst-71" data-title="contract_body/comment"><span class="cupd">/**
 </span>   <span class="cupd"> * @dev</span> Re<span class="cupd">t</span>urns the s<span class="cupd">ubtrac</span>tio<span class="cupd">n</span> of<span class="cupd"> two</span> <span class="cupd">u</span>nsig<span class="cupd">n</span>ed integ<span class="cupd">ers,</span> reve<span class="cupd">r</span>ting wi<span class="cupd">t</span>h cus<span class="cupd">t</span>om m<span class="cupd">e</span>ssag<span class="cupd">e on</span>
     <span class="cupd">* overflow</span> (when the resul<span class="cupd">t</span> is<span class="cupd"> </span>negativ<span class="cupd">e)</span><span class="cupd">.</span>
     *
     <span class="cupd">*</span> <span class="cupd">C</span>o<span class="cupd">u</span>n<span class="cupd">t</span>er<span class="cupd">p</span>art to<span class="cupd"> </span>Solid<span class="cupd">it</span>y's `-`<span class="cupd"> </span><span class="cupd">op</span>erator.
     *
  <span class="cupd"> </span>  *<span class="cupd"> </span>Require<span class="cupd">m</span>ents:
     <span class="cupd">*</span> <span class="cupd">-</span> Sub<span class="cupd">tr</span>action cannot overflow.
     *
  <span class="cupd"> </span>  * _Ava<span class="cupd">i</span>l<span class="cupd">a</span>ble<span class="cupd"> </span>since<span class="cupd"> v2</span>.4.<span class="cupd">0.</span>_
     */</span>
    function sub(uint256 a, uint256 b<span class="marker" id="mapping-293"></span><span class="token add" data-title="function_definition/,">,</span> <span class="marker" id="mapping-294"></span><span class="token add" data-title="function_definition/parameter">string memory errorMessage</span>) internal pure returns (uint256) {
        <span class="marker" id="mapping-295"></span><span class="token upd" id="move-dst-72" data-title="call_expression/identifier">r<span class="cupd">e</span>quire</span>(b &lt;= a<span class="marker" id="mapping-296"></span><span class="token add" data-title="call_expression/,">,</span> <span class="marker" id="mapping-297"></span><span class="token add" data-title="call_expression/call_argument">errorMessage</span>);
        <span class="marker" id="mapping-298"></span><span class="token add" data-title="function_body/variable_declaration_statement"><span class="marker" id="mapping-299"></span><span class="token add" data-title="variable_declaration_statement/variable_declaration">uint256 c</span> = <span class="marker" id="mapping-300"></span><span class="token mv" id="move-dst-73" data-title="variable_declaration_statement/binary_expression">a - b</span>;</span>

        return <span class="marker" id="mapping-301"></span><span class="token add" data-title="return_statement/identifier">c</span>;
    }

    <span class="marker" id="mapping-302"></span><span class="token upd" id="move-dst-74" data-title="contract_body/comment"><span class="cupd">/**
 </span>   <span class="cupd"> * @dev</span> Retur<span class="cupd">ns </span>the multiplication of <span class="cupd">two</span> <span class="cupd">u</span>nsig<span class="cupd">n</span>ed integ<span class="cupd">ers,</span> reve<span class="cupd">r</span>ting on
     * o<span class="cupd">v</span>er<span class="cupd">fl</span>ow.
     *
     * Counterpart to Solid<span class="cupd">it</span>y's <span class="cupd">`</span>*` operator.
     *
     * Req<span class="cupd">u</span>ire<span class="cupd">m</span>ents:
     * - Multi<span class="cupd">p</span>lication c<span class="cupd">annot overf</span>low<span class="cupd">.</span>
     */</span>
    <span class="marker" id="mapping-303"></span><span class="token mv" id="move-dst-63" data-title="contract_body/function_definition">function mul(uint256 a, uint256 b) internal pure returns (<span class="marker" id="mapping-304"></span><span class="token add" data-title="parameter/type_name">uint256</span>) {
        <span class="marker" id="mapping-305"></span><span class="token add" data-title="function_body/comment">// Gas optimization: this is cheaper than requiring 'a' not being zero, but the</span>
        <span class="marker" id="mapping-306"></span><span class="token add" data-title="function_body/comment">// benefit is lost if 'b' is also tested.</span>
        <span class="marker" id="mapping-307"></span><span class="token add" data-title="function_body/comment">// See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522</span>
        if (a == 0) {
            return 0;
        }

        <span class="marker" id="mapping-308"></span><span class="token add" data-title="function_body/variable_declaration_statement"><span class="marker" id="mapping-309"></span><span class="token add" data-title="variable_declaration_statement/variable_declaration">uint256 c</span> = <span class="marker" id="mapping-310"></span><span class="token mv" id="move-dst-65" data-title="variable_declaration_statement/binary_expression">a * b</span>;</span>
        <span class="marker" id="mapping-311"></span><span class="token upd" id="move-dst-66" data-title="call_expression/identifier">r<span class="cupd">e</span>quire</span>(c / a == b<span class="marker" id="mapping-312"></span><span class="token add" data-title="call_expression/,">,</span> <span class="marker" id="mapping-313"></span><span class="token add" data-title="call_expression/call_argument">"SafeMath: multiplication overflow"</span>);

        return c;
    }</span>

    <span class="marker" id="mapping-314"></span><span class="token add" data-title="contract_body/comment">/**
     * @dev Returns the integer division of two unsigned integers. Reverts on
     * division by zero. The result is rounded towards zero.
     *
     * Counterpart to Solidity's `/` operator. Note: this function uses a
     * `revert` opcode (which leaves remaining gas untouched) while Solidity
     * uses an invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     * - The divisor cannot be zero.
     */</span>
    <span class="marker" id="mapping-315"></span><span class="token add" data-title="contract_body/function_definition">function div(uint256 a, uint256 b) internal pure returns (uint256) {
        return div(a, b, "SafeMath: division by zero");
    }</span>

    <span class="marker" id="mapping-316"></span><span class="token add" data-title="contract_body/comment">/**
     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on
     * division by zero. The result is rounded towards zero.
     *
     * Counterpart to Solidity's `/` operator. Note: this function uses a
     * `revert` opcode (which leaves remaining gas untouched) while Solidity
     * uses an invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     * - The divisor cannot be zero.
     *
     * _Available since v2.4.0._
     */</span>
    <span class="marker" id="mapping-317"></span><span class="token mv" id="move-dst-68" data-title="contract_body/function_definition">function div(uint256 a, uint256 b<span class="marker" id="mapping-318"></span><span class="token add" data-title="function_definition/,">,</span> <span class="marker" id="mapping-319"></span><span class="token add" data-title="function_definition/parameter">string memory errorMessage</span>) internal pure returns (uint256) {
        <span class="marker" id="mapping-320"></span><span class="token upd" id="move-dst-69" data-title="function_body/comment"><span class="cupd">// </span><span class="cupd">Solidity </span>only <span class="cupd">automatically </span>asser<span class="cupd">t</span><span class="cupd">s when dividing by 0</span></span>
        <span class="marker" id="mapping-321"></span><span class="token add" data-title="function_body/expression_statement">require(b &gt; 0, errorMessage);</span>
        <span class="marker" id="mapping-322"></span><span class="token add" data-title="function_body/variable_declaration_statement"><span class="marker" id="mapping-323"></span><span class="token add" data-title="variable_declaration_statement/variable_declaration">uint256 c</span> = <span class="marker" id="mapping-324"></span><span class="token mv" id="move-dst-70" data-title="variable_declaration_statement/binary_expression">a / b</span>;</span>
        // assert(a == b * c + a % b); // There is no case in which this doesn't hold

        return <span class="marker" id="mapping-325"></span><span class="token add" data-title="return_statement/identifier">c</span>;
    }</span>

    <span class="marker" id="mapping-326"></span><span class="token add" data-title="contract_body/comment">/**
     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),
     * Reverts when dividing by zero.
     *
     * Counterpart to Solidity's `%` operator. This function uses a `revert`
     * opcode (which leaves remaining gas untouched) while Solidity uses an
     * invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     * - The divisor cannot be zero.
     */</span>
    <span class="marker" id="mapping-327"></span><span class="token add" data-title="contract_body/function_definition">function mod(uint256 a, uint256 b) internal pure returns (uint256) {
        return mod(a, b, "SafeMath: modulo by zero");
    }</span>

    <span class="marker" id="mapping-328"></span><span class="token add" data-title="contract_body/comment">/**
     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),
     * Reverts with custom message when dividing by zero.
     *
     * Counterpart to Solidity's `%` operator. This function uses a `revert`
     * opcode (which leaves remaining gas untouched) while Solidity uses an
     * invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     * - The divisor cannot be zero.
     *
     * _Available since v2.4.0._
     */</span>
    <span class="marker" id="mapping-329"></span><span class="token add" data-title="contract_body/function_definition">function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
        require(b != 0, errorMessage);
        return a % b;
    }</span>
}

<span class="marker" id="mapping-330"></span><span class="token upd" id="move-dst-80" data-title="source_file/comment"><span class="cupd">// File: contracts/</span>TrueCurrencies/<span class="cupd">modularERC20/BalanceSheet.sol</span></span>

<span class="marker" id="mapping-331"></span><span class="token add" data-title="source_file/pragma_directive">pragma solidity 0.5.13;</span>



// A wrapper around the balanceOf mapping.
contract BalanceSheet is Claimable {
    using SafeMath for uint256;

    mapping (address =&gt; uint256) public balanceOf;

    function addBalance(address _addr, uint256 _value) public onlyOwner {
        balanceOf[_addr] = balanceOf[_addr].add(_value);
    }

    function subBalance(address _addr, uint256 _value) public onlyOwner {
        balanceOf[_addr] = balanceOf[_addr].sub(_value);
    }

    function setBalance(address _addr, uint256 _value) public onlyOwner {
        balanceOf[_addr] = _value;
    }
}

<span class="marker" id="mapping-332"></span><span class="token upd" id="move-dst-81" data-title="source_file/comment"><span class="cupd">// File: contracts/</span>TrueCurrencies/<span class="cupd">modularERC20/AllowanceSheet.sol</span></span>

<span class="marker" id="mapping-333"></span><span class="token add" data-title="source_file/pragma_directive">pragma solidity 0.5.13;</span>



// A wrapper around the allowanceOf mapping.
contract AllowanceSheet is Claimable {
    using SafeMath for uint256;

    mapping (address =&gt; mapping (address =&gt; uint256)) public allowanceOf;

    function addAllowance(address _tokenHolder, address _spender, uint256 _value) public onlyOwner {
        allowanceOf[_tokenHolder][_spender] = allowanceOf[_tokenHolder][_spender].add(_value);
    }

    function subAllowance(address _tokenHolder, address _spender, uint256 _value) public onlyOwner {
        allowanceOf[_tokenHolder][_spender] = allowanceOf[_tokenHolder][_spender].sub(_value);
    }

    function setAllowance(address _tokenHolder, address _spender, uint256 _value) public onlyOwner {
        allowanceOf[_tokenHolder][_spender] = _value;
    }
}

<span class="marker" id="mapping-334"></span><span class="token upd" id="move-dst-82" data-title="source_file/comment"><span class="cupd">// File: contracts/</span>TrueCurrencies/<span class="cupd">ProxyStorage.sol</span></span>

<span class="marker" id="mapping-335"></span><span class="token add" data-title="source_file/pragma_directive">pragma solidity 0.5.13;</span>





<span class="marker" id="mapping-336"></span><span class="token upd" id="move-dst-83" data-title="source_file/comment"><span class="cupd">/*
Defines the storage layout of the token implement</span>a<span class="cupd">t</span><span class="cupd">ion contract. Any newly declared
state variables in future upgrades should be app</span>e<span class="cupd">nded to the bottom. Never remove state variables
from this list</span>
 */</span>
contract ProxyStorage {
    address public owner;
    address public pendingOwner;

    bool initialized;

    BalanceSheet balances_Deprecated;
    AllowanceSheet allowances_Deprecated;

    uint256 totalSupply_;

    bool private paused_Deprecated = false;
    address private globalPause_Deprecated;

    uint256 public burnMin = 0;
    uint256 public burnMax = 0;

    Registry public registry;

    string name_Deprecated;
    string symbol_Deprecated;

    uint[] gasRefundPool_Deprecated;
    uint256 private redemptionAddressCount_Deprecated;
    uint256 public minimumGasPriceForFutureRefunds;

    mapping (address =&gt; uint256) _balanceOf;
    mapping (address =&gt; mapping (address =&gt; uint256)) _allowance;
    mapping (bytes32 =&gt; mapping (address =&gt; uint256)) attributes;

    <span class="marker" id="mapping-337"></span><span class="token add" data-title="contract_body/comment">// reward token storage</span>
    <span class="marker" id="mapping-338"></span><span class="token add" data-title="contract_body/state_variable_declaration">mapping(address =&gt; FinancialOpportunity) finOps;</span>
    <span class="marker" id="mapping-339"></span><span class="token add" data-title="contract_body/state_variable_declaration">mapping(address =&gt; mapping(address =&gt; uint256)) finOpBalances;</span>
    <span class="marker" id="mapping-340"></span><span class="token add" data-title="contract_body/state_variable_declaration">mapping(address =&gt; uint256) finOpSupply;</span>

    <span class="marker" id="mapping-341"></span><span class="token add" data-title="contract_body/comment">// true reward allocation</span>
    <span class="marker" id="mapping-342"></span><span class="token add" data-title="contract_body/comment">// proportion: 1000 = 100%</span>
    <span class="marker" id="mapping-343"></span><span class="token add" data-title="contract_body/struct_declaration">struct RewardAllocation { uint proportion; address finOp; }</span>
    <span class="marker" id="mapping-344"></span><span class="token add" data-title="contract_body/state_variable_declaration">mapping(address =&gt; RewardAllocation[]) _rewardDistribution;</span>
    <span class="marker" id="mapping-345"></span><span class="token add" data-title="contract_body/state_variable_declaration">uint256 maxRewardProportion = 1000;</span>

    /* Additionally, we have several keccak-based storage locations.
     * If you add more keccak-based storage mappings, such as mappings, you must document them here.
     * If the length of the keccak input is the same as an existing mapping, it is possible there could be a preimage collision.
     * A preimage collision can be used to attack the contract by treating one storage location as another,
     * which would always be a critical issue.
     * Carefully examine future keccak-based storage to ensure there can be no preimage collisions.
     *******************************************************************************************************
     ** length     input                                                         usage
     *******************************************************************************************************
     ** 19         "trueXXX.proxy.owner"                                         Proxy Owner
     ** 27         "trueXXX.pending.proxy.owner"                                 Pending Proxy Owner
     ** 28         "trueXXX.proxy.implementation"                                Proxy Implementation
     ** 32         uint256(11)                                                   gasRefundPool_Deprecated
     ** 64         uint256(address),uint256(14)                                  balanceOf
     ** 64         uint256(address),keccak256(uint256(address),uint256(15))      allowance
     ** 64         uint256(address),keccak256(bytes32,uint256(16))               attributes
    **/
}

<span class="marker" id="mapping-346"></span><span class="token upd" id="move-dst-84" data-title="source_file/comment"><span class="cupd">// File: contracts/</span>TrueCurrencies/<span class="cupd">HasOwner.sol</span></span>

<span class="marker" id="mapping-347"></span><span class="token add" data-title="source_file/pragma_directive">pragma solidity 0.5.13;</span>


<span class="marker" id="mapping-348"></span><span class="token upd" id="move-dst-85" data-title="source_file/comment"><span class="cupd">/**
 * @title HasOwner
 * @dev The HasOwner contract is a copy of Claimable Contract by Zeppelin.</span><span class="cupd">
 and provides basic authorization control functions. Inherits storage layout o</span><span class="cupd">f
 ProxyStorage.</span>
 */</span>
contract HasOwner is ProxyStorage {

    event OwnershipTransferred(
        address indexed previousOwner,
        address indexed newOwner
    );

    <span class="marker" id="mapping-349"></span><span class="token upd" id="move-dst-86" data-title="contract_body/comment"><span class="cupd">/**
    * @dev sets the original `owner` of the contract to the sender
    * at construction. Must then be reinitialized
 </span><span class="cupd">  </span> */</span>
    constructor() public {
        owner = msg.sender;
        emit OwnershipTransferred(address(0), owner);
    }

    /**
    * @dev Throws if called by any account other than the owner.
    */
    modifier onlyOwner() {
        require(msg.sender == owner, "only Owner");
        _;
    }

    /**
    * @dev Modifier throws if called by any account other than the pendingOwner.
    */
    modifier onlyPendingOwner() {
        require(msg.sender == pendingOwner);
        _;
    }

    /**
    * @dev Allows the current owner to set the pendingOwner address.
    * @param newOwner The address to transfer ownership to.
    */
    function transferOwnership(address newOwner) public onlyOwner {
        pendingOwner = newOwner;
    }

    /**
    * @dev Allows the pendingOwner address to finalize the transfer.
    */
    function claimOwnership() public onlyPendingOwner {
        emit OwnershipTransferred(owner, pendingOwner);
        owner = pendingOwner;
        pendingOwner = address(0);
    }
}

<span class="marker" id="mapping-350"></span><span class="token upd" id="move-dst-87" data-title="source_file/comment"><span class="cupd">// File: contracts/</span>TrueCurrencies/<span class="cupd">ReclaimerToken.sol</span></span>

<span class="marker" id="mapping-351"></span><span class="token add" data-title="source_file/pragma_directive">pragma solidity 0.5.13;</span>


contract ReclaimerToken is HasOwner {
    <span class="marker" id="mapping-352"></span><span class="token upd" id="move-dst-88" data-title="contract_body/comment"><span class="cupd">/**
   </span><span class="cupd"> *@dev send all eth balance in the contract to another address
    </span>*/</span>
    function reclaimEther(<span class="marker" id="mapping-353"></span><span class="token add" data-title="function_definition/parameter">address payable _to</span>) external onlyOwner {
        _to.transfer(address(this).balance);
    }

    <span class="marker" id="mapping-354"></span><span class="token upd" id="move-dst-90" data-title="contract_body/comment"><span class="cupd">/**
   </span><span class="cupd"> *@dev send all token balance of an arbitary erc20 token
    in the contract to another address
   </span> */</span>
    function reclaimToken(<span class="marker" id="mapping-355"></span><span class="token upd" id="move-dst-91" data-title="user_defined_type/identifier">I<span class="cupd">ERC20</span></span> token, address _to) external onlyOwner {
        uint256 balance = token.balanceOf(<span class="marker" id="mapping-356"></span><span class="token add" data-title="call_expression/call_argument"><span class="marker" id="mapping-357"></span><span class="token add" data-title="call_argument/type_cast_expression"><span class="marker" id="mapping-358"></span><span class="token add" data-title="type_cast_expression/primitive_type">address</span>(<span class="marker" id="mapping-359"></span><span class="token mv" id="move-dst-38" data-title="type_cast_expression/call_argument">this</span>)</span></span>);
        token.transfer(_to, balance);
    }

    <span class="marker" id="mapping-360"></span><span class="token upd" id="move-dst-93" data-title="contract_body/comment"><span class="cupd">/**
   </span><span class="cupd"> *@dev allows owner of the contract to gain ownership of any contract that the contract currently owns
    </span>*/</span>
    function reclaimContract(<span class="marker" id="mapping-361"></span><span class="token upd" id="move-dst-94" data-title="user_defined_type/identifier">Instantiatable<span class="cupd">Ownable</span></span> _ownable) external onlyOwner {
        _ownable.transferOwnership(owner);
    }
}

<span class="marker" id="mapping-362"></span><span class="token upd" id="move-dst-95" data-title="source_file/comment"><span class="cupd">// File: contracts/</span>TrueCurrencies/<span class="cupd">modularERC20/</span>Initia<span class="cupd">l</span>iz<span class="cupd">a</span>bleOwn<span class="cupd">a</span>bl<span class="cupd">e</span><span class="cupd">.sol</span></span>

<span class="marker" id="mapping-363"></span><span class="token add" data-title="source_file/pragma_directive">pragma solidity 0.5.13;</span>


<span class="marker" id="mapping-364"></span><span class="token mv" id="move-dst-97" data-title="source_file/comment"><span class="marker" id="mapping-365"></span><span class="token upd" id="move-dst-97" data-title="source_file/comment"><span class="cupd">/</span>**<span class="cupd"></span>
 * @<span class="cupd">t</span>i<span class="cupd">tl</span><span class="cupd">e</span> InitializableOwnable
 * @dev The InitializableOwnabl<span class="cupd">e contra</span>ct <span class="cupd">h</span>as a<span class="cupd">n</span> owner<span class="cupd"> </span>address<span class="cupd">,</span> and<span class="cupd"> </span><span class="cupd">p</span>ro<span class="cupd">v</span>ides basic<span class="cupd"> </span>author<span class="cupd">i</span>zation co<span class="cupd">n</span>trol
 * f<span class="cupd">u</span>nctions, this simplifies the implem<span class="cupd">e</span>nta<span class="cupd">t</span>ion of "<span class="cupd">u</span>ser permi<span class="cupd">s</span><span class="cupd">s</span>ions".
 */</span></span>
<span class="marker" id="mapping-366"></span><span class="token add" data-title="source_file/contract_declaration">contract InitializableOwnable {
    address public owner;
    bool configured = false;

    event OwnershipTransferred(
        address indexed previousOwner,
        address indexed newOwner
    );

    /**
     * @dev The InitializableOwnable constructor sets the original `owner` of the contract to the sender
     * account.
     */
    function _configure() internal {
        require(!configured);
        owner = msg.sender;
        configured = true;
    }

    /**
     * @dev Throws if called by any account other than the owner.
     */
    modifier onlyOwner() {
        require(msg.sender == owner);
        _;
    }

    /**
     * @dev Allows the current owner to transfer control of the contract to a newOwner.
     * @param newOwner The address to transfer ownership to.
     */
    function transferOwnership(address newOwner) public onlyOwner {
        require(newOwner != address(0));
        emit OwnershipTransferred(owner, newOwner);
        owner = newOwner;
    }
}</span>

<span class="marker" id="mapping-367"></span><span class="token mv" id="move-dst-109" data-title="source_file/comment"><span class="marker" id="mapping-368"></span><span class="token upd" id="move-dst-109" data-title="source_file/comment"><span class="cupd">// File: contracts/</span>TrueCurrencies/<span class="cupd">modularERC20/</span>Initia<span class="cupd">l</span>iz<span class="cupd">a</span>bleCl<span class="cupd">a</span>ima<span class="cupd">ble</span><span class="cupd">.sol</span></span></span>

<span class="marker" id="mapping-369"></span><span class="token add" data-title="source_file/pragma_directive">pragma solidity 0.5.13;</span>



<span class="marker" id="mapping-370"></span><span class="token mv" id="move-dst-111" data-title="source_file/comment"><span class="marker" id="mapping-371"></span><span class="token upd" id="move-dst-111" data-title="source_file/comment"><span class="cupd">/</span>**<span class="cupd"></span>
 * @<span class="cupd">t</span>i<span class="cupd">tl</span><span class="cupd">e</span> InitializableOwnable
 * @dev Extension for the InstantiatableOwnabl<span class="cupd">e contra</span>ct, w<span class="cupd">h</span>ere the <span class="cupd">o</span>wnership needs t<span class="cupd">o</span> be<span class="cupd"> </span>cla<span class="cupd">i</span>med.
<span class="cupd"> </span>* This <span class="cupd">a</span>llows<span class="cupd"> </span>t<span class="cupd">h</span>e new own<span class="cupd">e</span>r to accep<span class="cupd">t</span> the <span class="cupd">t</span><span class="cupd">r</span>ansfer.
 */</span></span>
<span class="marker" id="mapping-372"></span><span class="token add" data-title="source_file/contract_declaration">contract InitializableClaimable is InitializableOwnable {
    address public pendingOwner;

    /**
     * @dev Modifier throws if called by any account other than the pendingOwner.
     */
    modifier onlyPendingOwner() {
        require(msg.sender == pendingOwner);
        _;
    }

    /**
     * @dev Allows the current owner to set the pendingOwner address.
     * @param newOwner The address to transfer ownership to.
     */
    function transferOwnership(address newOwner) public onlyOwner {
        pendingOwner = newOwner;
    }

    /**
     * @dev Allows the pendingOwner address to finalize the transfer.
     */
    function claimOwnership() public onlyPendingOwner {
        emit OwnershipTransferred(owner, pendingOwner);
        owner = pendingOwner;
        pendingOwner = address(0);
    }
}</span>

<span class="marker" id="mapping-373"></span><span class="token mv" id="move-dst-113" data-title="source_file/comment"><span class="marker" id="mapping-374"></span><span class="token upd" id="move-dst-113" data-title="source_file/comment"><span class="cupd">// File: contracts/</span>Tru<span class="cupd">e</span>C<span class="cupd">u</span>rre<span class="cupd">n</span>cies/mo<span class="cupd">d</span>ularERC20/ModularBasic<span class="cupd">Token.sol</span></span></span>

<span class="marker" id="mapping-375"></span><span class="token add" data-title="source_file/pragma_directive">pragma solidity 0.5.13;</span>





// Fork of OpenZeppelin's BasicToken
/**
 * @title Basic token
 * @dev Basic version of StandardToken, with no allowances.
 */
contract ModularBasicToken is HasOwner {
    using SafeMath for uint256;

    event Transfer(address indexed from, address indexed to, uint256 value);

    /**
    * @dev total number of tokens in existence
    */
    function totalSupply() public view returns (uint256) {
        return totalSupply_;
    }

    function balanceOf(address _who) public view returns (uint256) {
        return _getBalance(_who);
    }

    function _getBalance(address _who) internal view returns (uint256) {
        return _balanceOf[_who];
    }

    function _addBalance(address _who, uint256 _value) internal returns (uint256 priorBalance) {
        priorBalance = _balanceOf[_who];
        _balanceOf[_who] = priorBalance.add(_value);
    }

    function _subBalance(address _who, uint256 _value) internal returns (uint256 result) {
        result = _balanceOf[_who].sub(_value);
        _balanceOf[_who] = result;
    }

    function _setBalance(address _who, uint256 _value) internal {
        _balanceOf[_who] = _value;
    }
}

<span class="marker" id="mapping-376"></span><span class="token mv" id="move-dst-115" data-title="source_file/comment"><span class="marker" id="mapping-377"></span><span class="token upd" id="move-dst-115" data-title="source_file/comment"><span class="cupd">/</span>/<span class="cupd"> </span>F<span class="cupd">i</span><span class="cupd">le</span>:<span class="cupd"> </span>c<span class="cupd">o</span><span class="cupd">n</span><span class="cupd">t</span><span class="cupd">r</span><span class="cupd">a</span>ct<span class="cupd">s</span>/T<span class="cupd">r</span>u<span class="cupd">e</span>C<span class="cupd">u</span><span class="cupd">r</span><span class="cupd">r</span><span class="cupd">e</span><span class="cupd">n</span>c<span class="cupd">i</span>e<span class="cupd">s</span>/modu<span class="cupd">l</span><span class="cupd">a</span><span class="cupd">r</span><span class="cupd">E</span>RC20/<span class="cupd">M</span>odul<span class="cupd">a</span>rS<span class="cupd">t</span><span class="cupd">an</span>d<span class="cupd">a</span><span class="cupd">r</span><span class="cupd">d</span>T<span class="cupd">o</span>k<span class="cupd">e</span><span class="cupd">n</span>.<span class="cupd">s</span>ol</span></span>

<span class="marker" id="mapping-378"></span><span class="token add" data-title="source_file/pragma_directive">pragma solidity 0.5.13;</span>




/**
 * @title Standard ERC20 token
 *
 * @dev Implementation of the basic standard token.
 * @dev https://github.com/ethereum/EIPs/issues/20
 * @dev Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol
 */
contract ModularStandardToken is ModularBasicToken {
    using SafeMath for uint256;

    event Approval(
        address indexed owner,
        address indexed spender,
        uint256 value
    );

    <span class="marker" id="mapping-379"></span><span class="token add" data-title="contract_body/state_variable_declaration">uint256 constant INFINITE_ALLOWANCE = 0xfe00000000000000000000000000000000000000000000000000000000000000;</span>

    /**
     * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.
     *
     * Beware that changing an allowance with this method brings the risk that someone may use both the old
     * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this
     * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:
     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
     * @param _spender The address which will spend the funds.
     * @param _value The amount of tokens to be spent.
     */
    function approve(address _spender, uint256 _value) public returns (bool) {
        _approveAllArgs(_spender, _value, msg.sender);
        return true;
    }

    function _approveAllArgs(
        address _spender,
        uint256 _value,
        address _tokenHolder
    ) internal {
        _setAllowance(_tokenHolder, _spender, _value);
        emit Approval(_tokenHolder, _spender, _value);
    }

    /**
     * @dev Increase the amount of tokens that an owner allowed to a spender.
     *
     * approve should be called when allowed[_spender] == 0. To increment
     * allowed value is better to use this function to avoid 2 calls (and wait until
     * the first transaction is mined)
     * From MonolithDAO Token.sol
     * @param _spender The address which will spend the funds.
     * @param _addedValue The amount of tokens to increase the allowance by.
     */
    function <span class="marker" id="mapping-380"></span><span class="token upd" id="move-dst-98" data-title="function_definition/identifier"><span class="cupd">increaseA</span>ll<span class="cupd">o</span>wance</span>(address _spender, <span class="marker" id="mapping-381"></span><span class="token add" data-title="function_definition/parameter">uint256 _addedValue</span>)
        public
        returns (bool)
    {
        <span class="marker" id="mapping-382"></span><span class="token upd" id="move-dst-100" data-title="call_expression/identifier"><span class="cupd">_increaseA</span>ll<span class="cupd">o</span>w<span class="cupd">a</span>nce<span class="cupd">AllArgs</span></span>(_spender, _addedValue, msg.sender);
        return true;
    }

    function <span class="marker" id="mapping-383"></span><span class="token upd" id="move-dst-101" data-title="function_definition/identifier"><span class="cupd">_increaseA</span>ll<span class="cupd">o</span>w<span class="cupd">a</span>nce<span class="cupd">AllArgs</span></span>(
        address _spender,
        uint256 _addedValue,
        address _tokenHolder
    ) internal {
        _addAllowance(_tokenHolder, _spender, _addedValue);
        emit Approval(
            _tokenHolder,
            _spender,
            _getAllowance(_tokenHolder, _spender)
        );
    }

    /**
     * @dev Decrease the amount of tokens that an owner allowed to a spender.
     *
     * approve should be called when allowed[_spender] == 0. To decrement
     * allowed value is better to use this function to avoid 2 calls (and wait until
     * the first transaction is mined)
     * From MonolithDAO Token.sol
     * @param _spender The address which will spend the funds.
     * @param _subtractedValue The amount of tokens to decrease the allowance by.
     */
    function <span class="marker" id="mapping-384"></span><span class="token upd" id="move-dst-102" data-title="function_definition/identifier"><span class="cupd">decreaseA</span>ll<span class="cupd">o</span>wance</span>(address _spender, <span class="marker" id="mapping-385"></span><span class="token add" data-title="function_definition/parameter">uint256 _subtractedValue</span>)
        public
        returns (bool)
    {
        <span class="marker" id="mapping-386"></span><span class="token upd" id="move-dst-105" data-title="call_expression/identifier"><span class="cupd">_decreaseA</span>ll<span class="cupd">o</span>w<span class="cupd">a</span>nce<span class="cupd">AllArgs</span></span>(_spender, _subtractedValue, msg.sender);
        return true;
    }

    function <span class="marker" id="mapping-387"></span><span class="token upd" id="move-dst-106" data-title="function_definition/identifier"><span class="cupd">_decreaseA</span>ll<span class="cupd">o</span>w<span class="cupd">a</span>nce<span class="cupd">AllArgs</span></span>(
        address _spender,
        uint256 _subtractedValue,
        address _tokenHolder
    ) internal {
        uint256 oldValue = _getAllowance(_tokenHolder, _spender);
        uint256 newValue;
        if (_subtractedValue &gt; oldValue) {
            newValue = 0;
        } else {
            newValue = oldValue - _subtractedValue;
        }
        _setAllowance(_tokenHolder, _spender, newValue);
        emit Approval(_tokenHolder, _spender, newValue);
    }

    function allowance(address _who, address _spender)
        public
        view
        returns (uint256)
    {
        return _getAllowance(_who, _spender);
    }

    function _getAllowance(address _who, address _spender)
        internal
        view
        returns (uint256 value)
    {
        return _allowance[_who][_spender];
    }

    function _addAllowance(address _who, address _spender, uint256 _value)
        internal
    {
        _allowance[_who][_spender] = _allowance[_who][_spender].add(_value);
    }

    function _subAllowance(address _who, address _spender, uint256 _value)
        internal
        returns (uint256 newAllowance)
    {
        newAllowance = _allowance[_who][_spender].sub(_value);
        <span class="marker" id="mapping-388"></span><span class="token add" data-title="function_body/if_statement">if (<span class="marker" id="mapping-389"></span><span class="token add" data-title="if_statement/binary_expression">newAllowance &lt; INFINITE_ALLOWANCE</span>) <span class="marker" id="mapping-390"></span><span class="token add" data-title="if_statement/block_statement">{
            <span class="marker" id="mapping-391"></span><span class="token mv" id="move-dst-107" data-title="block_statement/expression_statement">_allowance[_who][_spender] = newAllowance;</span>
        }</span></span>
    }

    function _setAllowance(address _who, address _spender, uint256 _value)
        internal
    {
        _allowance[_who][_spender] = _value;
    }
}

<span class="marker" id="mapping-392"></span><span class="token mv" id="move-dst-135" data-title="source_file/comment"><span class="marker" id="mapping-393"></span><span class="token upd" id="move-dst-135" data-title="source_file/comment"><span class="cupd">// File: contracts/</span>True<span class="cupd">C</span>urrencies/m<span class="cupd">o</span>du<span class="cupd">l</span><span class="cupd">a</span>rERC20/ModularBur<span class="cupd">n</span>abl<span class="cupd">e</span><span class="cupd">Token</span><span class="cupd">.sol</span></span></span>

<span class="marker" id="mapping-394"></span><span class="token add" data-title="source_file/pragma_directive">pragma solidity 0.5.13;</span>


/**
 * @title Burnable Token
 * @dev Token that can be irreversibly burned (destroyed).
 */
contract ModularBurnableToken is ModularStandardToken {
    event Burn(address indexed burner, uint256 value);
    event Mint(address indexed to, uint256 value);
    uint256 constant CENT = 10 ** 16;

    function burn(uint256 _value) external {
        _burnAllArgs(msg.sender, _value - _value % CENT);
    }

    function _burnAllArgs(address _from, uint256 _value) internal {
        // no need to require value &lt;= totalSupply, since that would imply the
        // sender's balance is greater than the totalSupply, which *should* be an assertion failure
        _subBalance(_from, _value);
        totalSupply_ = totalSupply_.sub(_value);
        emit Burn(_from, _value);
        emit Transfer(_from, address(0), _value);
    }
}

<span class="marker" id="mapping-395"></span><span class="token mv" id="move-dst-139" data-title="source_file/comment"><span class="marker" id="mapping-396"></span><span class="token upd" id="move-dst-139" data-title="source_file/comment"><span class="cupd">// File: contracts/</span>Tru<span class="cupd">e</span>Currencies/Burnab<span class="cupd">le</span>TokenWi<span class="cupd">t</span>hBounds<span class="cupd">.sol</span></span></span>

<span class="marker" id="mapping-397"></span><span class="token add" data-title="source_file/pragma_directive">pragma solidity 0.5.13;</span>


/**
 * @title Burnable Token WithBounds
 * @dev Burning functions as redeeming money from the system. The platform will keep track of who burns coins,
 * and will send them back the equivalent amount of money (rounded down to the nearest cent).
 */
contract BurnableTokenWithBounds is ModularBurnableToken {

    event SetBurnBounds(uint256 newMin, uint256 newMax);

    function _burnAllArgs(address _burner, uint256 _value) internal {
        require(_value &gt;= burnMin, "below min burn bound");
        require(_value &lt;= burnMax, "exceeds max burn bound");
        super._burnAllArgs(_burner, _value);
    }

    //Change the minimum and maximum amount that can be burned at once. Burning
    //may be disabled by setting both to 0 (this will not be done under normal
    //operation, but we can't add checks to disallow it without losing a lot of
    //flexibility since burning could also be as good as disabled
    //by setting the minimum extremely high, and we don't want to lock
    //in any particular cap for the minimum)
    function setBurnBounds(uint256 _min, uint256 _max) external onlyOwner {
        require(_min &lt;= _max, "min &gt; max");
        burnMin = _min;
        burnMax = _max;
        emit SetBurnBounds(_min, _max);
    }
}

<span class="marker" id="mapping-398"></span><span class="token upd" id="move-dst-140" data-title="source_file/comment"><span class="cupd">/</span>/<span class="cupd"> </span>F<span class="cupd">i</span><span class="cupd">le</span>:<span class="cupd"> </span><span class="cupd">c</span>on<span class="cupd">t</span><span class="cupd">r</span><span class="cupd">a</span>c<span class="cupd">t</span><span class="cupd">s</span>/<span class="cupd">True</span>Curre<span class="cupd">n</span><span class="cupd">c</span><span class="cupd">i</span>e<span class="cupd">s</span>/G<span class="cupd">a</span>sR<span class="cupd">e</span><span class="cupd">fun</span><span class="cupd">d</span>T<span class="cupd">o</span><span class="cupd">k</span><span class="cupd">e</span><span class="cupd">n</span>.sol</span>

<span class="marker" id="mapping-399"></span><span class="token add" data-title="source_file/pragma_directive">pragma solidity 0.5.13;</span>


<span class="marker" id="mapping-400"></span><span class="token upd" id="move-dst-144" data-title="source_file/comment"><span class="cupd">/</span>**<span class="cupd"></span>
@<span class="cupd">t</span>i<span class="cupd">tl</span><span class="cupd">e</span> Gas Refund <span class="cupd">T</span>ok<span class="cupd">e</span>n
Allow any use<span class="cupd">r</span> to spon<span class="cupd">s</span>or<span class="cupd"> </span>gas refunds for transfer and mints. Utilitzes the gas refund <span class="cupd">m</span>echanism in EVM
Ea<span class="cupd">c</span>h time an non-emp<span class="cupd">t</span>y <span class="cupd">s</span>torage slot is set to 0, evm <span class="cupd">r</span>efund 15,000 to<span class="cupd"> </span>t<span class="cupd">h</span>e sender
of the transaction.
*/</span>
<span class="marker" id="mapping-401"></span><span class="token mv" id="move-dst-116" data-title="source_file/contract_declaration">contract GasRefundToken is ProxyStorage {

    /**
      A buffer of "Sheep" runs from 0xffff...fffe down
      They suicide when you call them, if you are their parent
    */

    function sponsorGas2() external {
        <span class="marker" id="mapping-402"></span><span class="token upd" id="move-dst-117" data-title="function_body/comment"><span class="cupd">/**
        Deploy (9 bytes)
          PC Assembly       Opcodes                                       Stack
          00 PUS</span>H1<span class="cupd">(27)      6</span>0<span class="cupd"> 1b                                       </span> <span class="cupd"> 1b
          02 DUP1           80                                         </span> <span class="cupd">  </span>1<span class="cupd">b 1b
          03 PUSH1(9)       60 09                                     </span> <span class="cupd">  </span> <span class="cupd">1b 1b 09
          05 RETURNDATASIZE 3d                                       </span> <span class="cupd">  </span> <span class="cupd"> 1b 1b 09 00
          06 CODECOPY       39                                      </span> <span class="cupd">     1b
          07 RETURNDATASIZE 3d                                     </span> <span class="cupd">      1b 00
          08 RETURN         f3
     </span>  <span class="cupd"> Sheep (27 bytes =</span> <span class="cupd">3 + 20 + 4)
          PC Assembly       Opcodes                                       Stack
          00 RETURNDATASIZE 3d                                 </span> <span class="cupd">          00
          01 CALLER         33                                </span> <span class="cupd">           00 caller
          02 PUSH20(me)     73 mememememememememememememememe</span>m<span class="cupd">ememememe   00 caller me</span>
 <span class="cupd">         17 </span><span class="cupd">X</span>O<span class="cupd">R            18                              </span> <span class="cupd"> </span>  <span class="cupd">          00 invalid</span><span class="cupd">
     </span><span class="cupd"> </span><span class="cupd">    18</span><span class="cupd"> </span><span class="cupd">P</span><span class="cupd">C             58                             </span><span class="cupd">  </span>       <span class="cupd"> </span><span class="cupd"> </span> <span class="cupd"> </span><span class="cupd">  00 inva</span><span class="cupd">l</span><span class="cupd">i</span>d<span class="cupd"> 18
</span> <span class="cupd">       </span>  1<span class="cupd">9</span> <span class="cupd">JUMPI          57                            </span> <span class="cupd">            </span> <span class="cupd">  00
          1a SELFDESTRU</span>CT   ff
        */</span>
        assembly {
            mstore(0, or(<span class="marker" id="mapping-403"></span><span class="token upd" id="move-dst-118" data-title="yul_function_call/yul_hex_number"><span class="cupd">0x601</span>b<span class="cupd">8060093d393df33d33730000000000000000000000000000000000000000</span></span>, address))
            mstore(32,   <span class="marker" id="mapping-404"></span><span class="token upd" id="move-dst-119" data-title="yul_function_call/yul_hex_number"><span class="cupd">0x1</span>8<span class="cupd">5</span><span class="cupd">8</span><span class="cupd">5</span>7<span class="cupd">ff000000000000000000000000000000000000000000000000</span>00000000</span>)
            let offset := sload(0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)
            let location := sub(0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe, offset)
            sstore(location, <span class="marker" id="mapping-405"></span><span class="token add" data-title="yul_function_call/yul_function_call"><span class="marker" id="mapping-406"></span><span class="token mv" id="move-dst-120" data-title="yul_function_call/yul_evm_builtin">create</span>(0, 0, 0x24)</span>)
            <span class="marker" id="mapping-407"></span><span class="token add" data-title="assembly_statement/yul_assignment">location := sub(location, 1)</span>
            sstore(<span class="marker" id="mapping-408"></span><span class="token mv" id="move-dst-128" data-title="yul_function_call/yul_path">location</span>, <span class="marker" id="mapping-409"></span><span class="token mv" id="move-dst-127" data-title="yul_function_call/yul_function_call"><span class="marker" id="mapping-410"></span><span class="token mv" id="move-dst-121" data-title="yul_function_call/yul_evm_builtin">create</span>(<span class="marker" id="mapping-411"></span><span class="token upd" id="move-dst-130" data-title="yul_function_call/yul_decimal_number">0</span><span class="marker" id="mapping-412"></span><span class="token mv" id="move-dst-129" data-title="yul_function_call/,">,</span> <span class="marker" id="mapping-413"></span><span class="token add" data-title="yul_function_call/yul_decimal_number">0</span><span class="marker" id="mapping-414"></span><span class="token add" data-title="yul_function_call/,">,</span> <span class="marker" id="mapping-415"></span><span class="token add" data-title="yul_function_call/yul_hex_number">0x24</span>)</span>)
            <span class="marker" id="mapping-416"></span><span class="token add" data-title="assembly_statement/yul_assignment"><span class="marker" id="mapping-417"></span><span class="token add" data-title="yul_assignment/yul_path">location</span> := <span class="marker" id="mapping-418"></span><span class="token mv" id="move-dst-123" data-title="yul_assignment/yul_function_call">sub(location, 1)</span></span>
            <span class="marker" id="mapping-419"></span><span class="token mv" id="move-dst-122" data-title="assembly_statement/yul_function_call">sstore(<span class="marker" id="mapping-420"></span><span class="token upd" id="move-dst-125" data-title="yul_identifier/identifier">location</span><span class="marker" id="mapping-421"></span><span class="token mv" id="move-dst-124" data-title="yul_function_call/,">,</span> <span class="marker" id="mapping-422"></span><span class="token add" data-title="yul_function_call/yul_function_call"><span class="marker" id="mapping-423"></span><span class="token mv" id="move-dst-126" data-title="yul_function_call/yul_evm_builtin">create</span>(0, 0, 0x24)</span>)</span>
            sstore(0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff, add(offset, 3))
        }
    }

    /**
    @dev refund 39,000 gas
    @dev costs slightly more than 16,100 gas
    */
    function gasRefund39() internal {
        assembly {
            let offset := sload(0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)
            if gt(offset, 0) {
              let location := sub(0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff,offset)
              sstore(0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff, sub(offset, 1))
              let sheep := sload(location)
              pop(call(gas, sheep, 0, 0, 0, 0, 0))
              sstore(location, 0)
            }
        }
    }

    function sponsorGas() external {
        uint256 refundPrice = minimumGasPriceForFutureRefunds;
        require(refundPrice &gt; 0);
        assembly {
            let offset := sload(0xfffff)
            let result := add(offset, 9)
            sstore(0xfffff, result)
            let position := add(offset, 0x100000)
            sstore(position, refundPrice)
            position := add(position, 1)
            sstore(position, refundPrice)
            position := add(position, 1)
            sstore(position, refundPrice)
            position := add(position, 1)
            sstore(position, refundPrice)
            position := add(position, 1)
            sstore(position, refundPrice)
            position := add(position, 1)
            sstore(position, refundPrice)
            position := add(position, 1)
            sstore(position, refundPrice)
            position := add(position, 1)
            sstore(position, refundPrice)
            position := add(position, 1)
            sstore(position, refundPrice)
        }
    }

    function minimumGasPriceForRefund() public view returns (uint256 result) {
        assembly {
            let offset := sload(0xfffff)
            let location := add(offset, 0xfffff)
            result := add(sload(location), 1)
        }
    }

    <span class="marker" id="mapping-424"></span><span class="token upd" id="move-dst-131" data-title="contract_body/comment"><span class="cupd">/**
   </span><span class="cupd"> @dev refund 30,000 gas
    @dev costs slightly more than 15,400 gas
   </span> */</span>
    function gasRefund30() internal {
        assembly {
            let offset := sload(0xfffff)
            if gt(offset, 1) {
                let location := add(offset, 0xfffff)
                if gt(gasprice,sload(location)) {
                    sstore(location, 0)
                    location := sub(location, 1)
                    sstore(location, 0)
                    sstore(0xfffff, sub(offset, 2))
                }
            }
        }
    }

    <span class="marker" id="mapping-425"></span><span class="token upd" id="move-dst-132" data-title="contract_body/comment"><span class="cupd">/**
   </span><span class="cupd"> @dev refund 15,000 gas
    @dev costs slightly more than 10,200 gas
   </span> */</span>
    function gasRefund15() internal {
        assembly {
            let offset := sload(0xfffff)
            if gt(offset, 1) {
                let location := add(offset, 0xfffff)
                if gt(gasprice,sload(location)) {
                    sstore(location, 0)
                    sstore(0xfffff, sub(offset, 1))
                }
            }
        }
    }

    <span class="marker" id="mapping-426"></span><span class="token upd" id="move-dst-133" data-title="contract_body/comment"><span class="cupd">/**
   </span><span class="cupd"> *@dev Return the remaining sponsored gas slots
    </span>*/</span>
    function remainingGasRefundPool() public view returns (uint length) {
        assembly {
            length := sload(0xfffff)
        }
    }

    function gasRefundPool(uint256 _index) public view returns (uint256 gasPrice) {
        assembly {
            gasPrice := sload(add(0x100000, _index))
        }
    }

    bytes32 constant CAN_SET_FUTURE_REFUND_MIN_GAS_PRICE = "canSetFutureRefundMinGasPrice";

    function setMinimumGasPriceForFutureRefunds(uint256 _minimumGasPriceForFutureRefunds) public {
        require(registry.hasAttribute(msg.sender, CAN_SET_FUTURE_REFUND_MIN_GAS_PRICE));
        minimumGasPriceForFutureRefunds = _minimumGasPriceForFutureRefunds;
    }
}</span>

<span class="marker" id="mapping-427"></span><span class="token upd" id="move-dst-145" data-title="source_file/comment"><span class="cupd">/</span>/<span class="cupd"> </span>F<span class="cupd">i</span><span class="cupd">le</span>:<span class="cupd"> </span><span class="cupd">contract</span>s/Tr<span class="cupd">u</span><span class="cupd">e</span>Cu<span class="cupd">r</span>r<span class="cupd">e</span><span class="cupd">n</span><span class="cupd">c</span><span class="cupd">i</span>es/C<span class="cupd">o</span>mp<span class="cupd">li</span>a<span class="cupd">n</span><span class="cupd">t</span>D<span class="cupd">e</span>po<span class="cupd">s</span>i<span class="cupd">t</span>T<span class="cupd">o</span>k<span class="cupd">en</span>W<span class="cupd">i</span><span class="cupd">th</span>H<span class="cupd">o</span>ok.<span class="cupd">s</span>ol</span>

<span class="marker" id="mapping-428"></span><span class="token add" data-title="source_file/pragma_directive">pragma solidity 0.5.13;</span>







<span class="marker" id="mapping-429"></span><span class="token mv" id="move-dst-136" data-title="source_file/contract_declaration">contract CompliantDepositTokenWithHook is ReclaimerToken, RegistryClone, BurnableTokenWithBounds, GasRefundToken {

    bytes32 constant IS_REGISTERED_CONTRACT = "isRegisteredContract";
    bytes32 constant IS_DEPOSIT_ADDRESS = "isDepositAddress";
    uint256 constant REDEMPTION_ADDRESS_COUNT = 0x100000;
    bytes32 constant IS_BLACKLISTED = "isBlacklisted";

    function canBurn() internal pure returns (bytes32);

    /**
    * @dev transfer token for a specified address
    * @param _to The address to transfer to.
    * @param _value The amount to be transferred.
    */
    function transfer(address _to, uint256 _value) public returns (bool) {
        _transferAllArgs(msg.sender, _to, _value);
        return true;
    }

    /**
     * @dev Transfer tokens from one address to another
     * @param _from address The address which you want to send tokens from
     * @param _to address The address which you want to transfer to
     * @param _value uint256 the amount of tokens to be transferred
     */
    function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {
        _transferFromAllArgs(_from, _to, _value, msg.sender);
        return true;
    }

    function _burnFromAllowanceAllArgs(address _from, address _to, uint256 _value, address _spender) internal {
        _requireCanTransferFrom(_spender, _from, _to);
        _requireOnlyCanBurn(_to);
        require(_value &gt;= burnMin, "below min burn bound");
        require(_value &lt;= burnMax, "exceeds max burn bound");
        if (0 == _subBalance(_from, _value)) {
            if (0 <span class="marker" id="mapping-430"></span><span class="token add" data-title="binary_expression/!=">!=</span> _subAllowance(_from, _spender, _value)) {
                gasRefund15();
            }
            <span class="marker" id="mapping-431"></span><span class="token add" data-title="block_statement/comment">// else no refund</span>
        } else {
            if (0 == _subAllowance(_from, _spender, _value)) {
                gasRefund15();
            } else {
                gasRefund39();
            }
        }
        emit Transfer(_from, _to, _value);
        totalSupply_ = totalSupply_.sub(_value);
        emit Burn(_to, _value);
        emit Transfer(_to, address(0), _value);
    }

    function _burnFromAllArgs(address _from, address _to, uint256 _value) internal {
        _requireCanTransfer(_from, _to);
        _requireOnlyCanBurn(_to);
        require(_value &gt;= burnMin, "below min burn bound");
        require(_value &lt;= burnMax, "exceeds max burn bound");
        if (0 == _subBalance(_from, _value)) {
            gasRefund15();
        } else {
            gasRefund30();
        }
        emit Transfer(_from, _to, _value);
        totalSupply_ = totalSupply_.sub(_value);
        emit Burn(_to, _value);
        emit Transfer(_to, address(0), _value);
    }

    function _transferFromAllArgs(address _from, address _to, uint256 _value, address _spender) internal {
        if (uint256(_to) &lt; REDEMPTION_ADDRESS_COUNT) {
            _value -= _value % CENT;
            _burnFromAllowanceAllArgs(_from, _to, _value, _spender);
        } else {
            bool hasHook;
            address originalTo = _to;
            (_to, hasHook) = _requireCanTransferFrom(_spender, _from, _to);
            if (0 == _addBalance(_to, _value)) {
                if (0 == _subAllowance(_from, _spender, _value)) {
                    if (0 <span class="marker" id="mapping-432"></span><span class="token add" data-title="binary_expression/!=">!=</span> _subBalance(_from, _value)) {
                        gasRefund30();
                    }
                    <span class="marker" id="mapping-433"></span><span class="token add" data-title="block_statement/comment">// else do not refund</span>
                } else {
                    if (0 == _subBalance(_from, _value)) {
                        gasRefund30();
                    } else {
                        gasRefund39();
                    }
                }
            } else {
                if (0 == _subAllowance(_from, _spender, _value)) {
                    if (0 <span class="marker" id="mapping-434"></span><span class="token add" data-title="binary_expression/!=">!=</span> _subBalance(_from, _value)) {
                        gasRefund15();
                    }
                    <span class="marker" id="mapping-435"></span><span class="token add" data-title="block_statement/comment">// else do not refund</span>
                } else {
                    if (0 == _subBalance(_from, _value)) {
                        gasRefund15();
                    } else {
                        gasRefund39();
                    }
                }

            }
            emit Transfer(_from, originalTo, _value);
            if (originalTo != _to) {
                emit Transfer(originalTo, _to, _value);
                if (hasHook) {
                    TrueCoinReceiver(_to).tokenFallback(originalTo, _value);
                }
            } else {
                if (hasHook) {
                    TrueCoinReceiver(_to).tokenFallback(_from, _value);
                }
            }
        }
    }

    function _transferAllArgs(address _from, address _to, uint256 _value) internal {
        if (uint256(_to) &lt; REDEMPTION_ADDRESS_COUNT) {
            _value -= _value % CENT;
            _burnFromAllArgs(_from, _to, _value);
        } else {
            bool hasHook;
            address finalTo;
            (finalTo, hasHook) = _requireCanTransfer(_from, _to);
            if (0 == _subBalance(_from, _value)) {
                if (0 == _addBalance(finalTo, _value)) {
                    gasRefund30();
                }
                <span class="marker" id="mapping-436"></span><span class="token add" data-title="block_statement/comment">// else do not refund</span>
            } else {
                if (0 == _addBalance(finalTo, _value)) {
                    gasRefund39();
                } else {
                    gasRefund30();
                }
            }
            emit Transfer(_from, _to, _value);
            if (finalTo != _to) {
                emit Transfer(_to, finalTo, _value);
                if (hasHook) {
                    TrueCoinReceiver(finalTo).tokenFallback(_to, _value);
                }
            } else {
                if (hasHook) {
                    TrueCoinReceiver(finalTo).tokenFallback(_from, _value);
                }
            }
        }
    }

    function mint(address _to, uint256 _value) public onlyOwner {
        require(_to != address(0), "to address cannot be zero");
        bool hasHook;
        address originalTo = _to;
        (_to, hasHook) = _requireCanMint(_to);
        totalSupply_ = totalSupply_.add(_value);
        emit Mint(originalTo, _value);
        emit Transfer(address(0), originalTo, _value);
        if (_to != originalTo) {
            emit Transfer(originalTo, _to, _value);
        }
        _addBalance(_to, _value);
        if (hasHook) {
            if (_to != originalTo) {
                TrueCoinReceiver(_to).tokenFallback(originalTo, _value);
            } else {
                TrueCoinReceiver(_to).tokenFallback(address(0), _value);
            }
        }
    }

    event WipeBlacklistedAccount(address indexed account, uint256 balance);
    event SetRegistry(address indexed registry);

    /**
    * @dev Point to the registry that contains all compliance related data
    @param _registry The address of the registry instance
    */
    function setRegistry(Registry _registry) public onlyOwner {
        registry = _registry;
        emit SetRegistry(<span class="marker" id="mapping-437"></span><span class="token add" data-title="emit_statement/call_argument"><span class="marker" id="mapping-438"></span><span class="token add" data-title="call_argument/type_cast_expression"><span class="marker" id="mapping-439"></span><span class="token add" data-title="type_cast_expression/primitive_type">address</span>(<span class="marker" id="mapping-440"></span><span class="token mv" id="move-dst-137" data-title="type_cast_expression/call_argument">registry</span>)</span></span>);
    }

    modifier onlyRegistry {
        require(msg.sender == address(registry));
        _;
    }

    function syncAttributeValue(address _who, bytes32 _attribute, uint256 _value) public onlyRegistry {
        attributes[_attribute][_who] = _value;
    }

    function _burnAllArgs(address _from, uint256 _value) internal {
        _requireCanBurn(_from);
        super._burnAllArgs(_from, _value);
    }

    // Destroy the tokens owned by a blacklisted account
    function wipeBlacklistedAccount(address _account) public onlyOwner {
        require(_isBlacklisted(_account), "_account is not blacklisted");
        uint256 oldValue = _getBalance(_account);
        _setBalance(_account, 0);
        totalSupply_ = totalSupply_.sub(oldValue);
        emit WipeBlacklistedAccount(_account, oldValue);
        emit Transfer(_account, address(0), oldValue);
    }

    function _isBlacklisted(address _account) internal view returns (bool blacklisted) {
        return attributes[IS_BLACKLISTED][_account] != 0;
    }

    function _requireCanTransfer(address _from, address _to) internal view returns (address, bool) {
        uint256 depositAddressValue = attributes[IS_DEPOSIT_ADDRESS][address(uint256(_to) &gt;&gt; 20)];
        if (depositAddressValue != 0) {
            _to = address(depositAddressValue);
        }
        require (attributes[IS_BLACKLISTED][_to] == 0, "blacklisted");
        require (attributes[IS_BLACKLISTED][_from] == 0, "blacklisted");
        return (_to, attributes[IS_REGISTERED_CONTRACT][_to] != 0);
    }

    function _requireCanTransferFrom(address _spender, address _from, address _to) internal view returns (address, bool) {
        require (attributes[IS_BLACKLISTED][_spender] == 0, "blacklisted");
        uint256 depositAddressValue = attributes[IS_DEPOSIT_ADDRESS][address(uint256(_to) &gt;&gt; 20)];
        if (depositAddressValue != 0) {
            _to = address(depositAddressValue);
        }
        require (attributes[IS_BLACKLISTED][_to] == 0, "blacklisted");
        require (attributes[IS_BLACKLISTED][_from] == 0, "blacklisted");
        return (_to, attributes[IS_REGISTERED_CONTRACT][_to] != 0);
    }

    function _requireCanMint(address _to) internal view returns (address, bool) {
        uint256 depositAddressValue = attributes[IS_DEPOSIT_ADDRESS][address(uint256(_to) &gt;&gt; 20)];
        if (depositAddressValue != 0) {
            _to = address(depositAddressValue);
        }
        require (attributes[IS_BLACKLISTED][_to] == 0, "blacklisted");
        return (_to, attributes[IS_REGISTERED_CONTRACT][_to] != 0);
    }

    function _requireOnlyCanBurn(address _from) internal view {
        require (attributes[canBurn()][_from] != 0, "cannot burn from this address");
    }

    function _requireCanBurn(address _from) internal view {
        require (attributes[IS_BLACKLISTED][_from] == 0, "blacklisted");
        require (attributes[canBurn()][_from] != 0, "cannot burn from this address");
    }

    function paused() public pure returns (bool) {
        return false;
    }
}</span>

<span class="marker" id="mapping-441"></span><span class="token add" data-title="source_file/comment">// File: contracts/TrueCurrencies/RewardToken.sol</span>

<span class="marker" id="mapping-442"></span><span class="token add" data-title="source_file/pragma_directive">pragma solidity 0.5.13;</span>



<span class="marker" id="mapping-443"></span><span class="token add" data-title="source_file/comment">/**
 * @title RewardToken
 * @dev Non-transferrable token meant to represent
 * RewardTokens are TrueCurrencies owed by a financial opportunity
 *
 * -- Overview --
 * RewardTokens are redeemable for an underlying Token.
 * RewardTokens are non-transferrable for compliance reasons
 * The caller of depositor is responsible for exchanging their
 * tokens, rather just keep accounting of user rewardToken balances
 *
 * -- Financial Opportunity --
 * RewardTokens are backed by an underlying financial opportunity
 * Each financial opportunity can accept Token deposits for
 * See FinancialOpportunity.sol
 *
 * -- Mint/Redeem/Burn --
 * To create rewardTokens, we call mintRewardToken with some amount of TUSD
 * To redeem rewardTokens we call redeemRewardToken and recieve TUSD
 * Only the account that has rewardTokens can burn reward tokens. The only
 * time we would want to burn rewardTokens is if the underlying opportunity
 * is no longer redeemable, and we want to wipe the debt.
 *
 */</span>
<span class="marker" id="mapping-444"></span><span class="token add" data-title="source_file/contract_declaration">contract RewardToken is <span class="marker" id="mapping-445"></span><span class="token mv" id="move-dst-146" data-title="contract_declaration/inheritance_specifier">CompliantDepositTokenWithHook</span> <span class="marker" id="mapping-446"></span><span class="token add" data-title="contract_declaration/contract_body">{

    /* variables in proxy storage
    mapping(address =&gt; FinancialOpportunity) finOps;
    mapping(address =&gt; mapping(address =&gt; uint256)) finOpBalances;
    mapping(address =&gt; uint256) finOpSupply;
    */

    <span class="marker" id="mapping-447"></span><span class="token add" data-title="contract_body/event_definition">event MintRewardToken(address account, uint256 amount, address finOp);</span>
    <span class="marker" id="mapping-448"></span><span class="token add" data-title="contract_body/event_definition">event RedeemRewardToken(address account, uint256 amount, address finOp);</span>
    <span class="marker" id="mapping-449"></span><span class="token add" data-title="contract_body/event_definition">event BurnRewardToken(address account, uint256 amount, address finOp);</span>

    /**
     * @dev Only addresses registered in this contract's mapping are valid
     *
     * @param finOp reverts if this finOp is not registered
     */
    <span class="marker" id="mapping-450"></span><span class="token add" data-title="contract_body/modifier_definition">modifier validFinOp(address finOp) {
        require(finOp != address(0), "invalid opportunity");
        _;
    }</span>

    /**
     * @dev get debt balance of account in rewardToken
     *
     * @param finOp financial opportunity
     */
    <span class="marker" id="mapping-451"></span><span class="token mv" id="move-dst-9" data-title="contract_body/function_definition">function <span class="marker" id="mapping-452"></span><span class="token upd" id="move-dst-10" data-title="function_definition/identifier">rew<span class="cupd">a</span>rdTokenSupply</span>(
        <span class="marker" id="mapping-453"></span><span class="token mv" id="move-dst-52" data-title="function_definition/parameter">address <span class="marker" id="mapping-454"></span><span class="token upd" id="move-dst-53" data-title="parameter/identifier">fi<span class="cupd">n</span>Op</span></span>
    ) public view <span class="marker" id="mapping-455"></span><span class="token add" data-title="function_definition/modifier_invocation">validFinOp(finOp)</span> returns (uint256) <span class="marker" id="mapping-456"></span><span class="token add" data-title="function_definition/function_body">{
        return finOpSupply[finOp];
    }</span></span>

    /**
     * @dev get debt balance of account in rewardToken
     *
     * @param account account to get rewardToken balance of
     * @param finOp financial opportunity
     */
    <span class="marker" id="mapping-457"></span><span class="token mv" id="move-dst-7" data-title="contract_body/function_definition">function <span class="marker" id="mapping-458"></span><span class="token upd" id="move-dst-8" data-title="function_definition/identifier">rewardT<span class="cupd">o</span>kenB<span class="cupd">al</span>ance</span>(
        <span class="marker" id="mapping-459"></span><span class="token mv" id="move-dst-11" data-title="function_definition/parameter">address <span class="marker" id="mapping-460"></span><span class="token upd" id="move-dst-12" data-title="parameter/identifier">account</span></span><span class="marker" id="mapping-461"></span><span class="token add" data-title="function_definition/,">,</span>
        <span class="marker" id="mapping-462"></span><span class="token add" data-title="function_definition/parameter">address finOp</span>
    ) public view <span class="marker" id="mapping-463"></span><span class="token add" data-title="function_definition/modifier_invocation">validFinOp(finOp)</span> returns (uint256) <span class="marker" id="mapping-464"></span><span class="token add" data-title="function_definition/function_body">{
        return finOpBalances[finOp][account];
    }</span></span>

    /**
     * @dev mint rewardToken for financial opportunity
     *
     * For valid finOp, deposit Token into finOp
     * Update finOpSupply &amp; finOpBalance for account
     * Emit mintRewardToken event on success
     *
     * @param account account to mint rewardToken for
     * @param amount amount of depositToken to mint
     * @param finOp financial opportunity address
     */
    <span class="marker" id="mapping-465"></span><span class="token add" data-title="contract_body/function_definition">function mintRewardToken(
        address account,
        uint256 amount,
        address finOp
    ) internal validFinOp(finOp) returns (uint256) {
        // require sufficient balance
        require(super.balanceOf(account) &gt;= amount, "insufficient token balance");

        // approve finOp can spend Token
        _setAllowance(account, finOp, amount);

        // deposit into finOp
        uint256 rewardAmount = _getFinOp(finOp).deposit(account, amount);

        // increase finOp rewardToken supply
        finOpSupply[finOp] = finOpSupply[finOp].add(rewardAmount);

        // increase account rewardToken balance
        _addRewardBalance(account, rewardAmount, finOp);

        // emit mint event
        emit MintRewardToken(account, amount, finOp);

        return rewardAmount;
    }</span>

    /**
     * @dev redeem rewardToken balance for depositToken
     *
     * For valid finOp, deposit Token into finOp
     * Update finOpSupply &amp; finOpBalance for account
     * Emit mintRewardToken event on success
     *
     * @param account account to redeem rewardToken for
     * @param amount depositToken amount to redeem
     * @param finOp financial opportunitu address
     */
    <span class="marker" id="mapping-466"></span><span class="token add" data-title="contract_body/function_definition">function redeemRewardToken(
        address account,
        uint256 amount,
        address finOp
    ) internal validFinOp(finOp) returns (uint256) {
        // require sufficient balance
        require(rewardTokenBalance(account, finOp) &gt;= amount, "insufficient reward balance");

        // withdraw from finOp, giving TUSD to account
        uint256 tokenAmount = _getFinOp(finOp).redeem(account, amount);

        // decrease finOp rewardToken supply
        finOpSupply[finOp] = finOpSupply[finOp].sub(amount);

        // decrease account rewardToken balance
        _subRewardBalance(account, amount, finOp);

        // emit mint event
        emit RedeemRewardToken(account, tokenAmount, finOp);

        return tokenAmount;
    }</span>

    /**
     * @dev burn rewardToken without redeeming
     *
     * Burn rewardToken for finOp
     *
     * @param account account to burn rewardToken for
     * @param amount depositToken amount to burn
     * @param finOp financial opportunity address
     */
    <span class="marker" id="mapping-467"></span><span class="token add" data-title="contract_body/function_definition">function burnRewardToken(
        address account,
        uint256 amount,
        address finOp
    )
        internal
        validFinOp(finOp)
    {
        // burn call must come from sender
        require(msg.sender == account);

        // sender must have rewardToken amount to burn
        require(rewardTokenBalance(account, finOp) &gt;= amount);

        // subtract reward balance from
        _subRewardBalance(account, amount, finOp);

        // reduce total supply
        finOpSupply[finOp].sub(amount);

        // burn event
        emit BurnRewardToken(account, amount, finOp);
    }</span>

    /**
     * @dev add rewardToken balance to account
     *
     * @param account account to add to
     * @param amount rewardToken amount to add
     * @param finOp financial opportunity to add reward tokens to
     */
    <span class="marker" id="mapping-468"></span><span class="token add" data-title="contract_body/function_definition">function _addRewardBalance(address account, uint256 amount, address finOp) internal {
        finOpBalances[finOp][account] = finOpBalances[finOp][account].add(amount);
    }</span>

    /**
     * @dev subtract rewardToken balance from account
     *
     * @param account account to subtract from
     * @param amount rewardToken ammount to subtract
     * @param finOp financial opportunity
     */
    <span class="marker" id="mapping-469"></span><span class="token add" data-title="contract_body/function_definition">function _subRewardBalance(address account, uint256 amount, address finOp) internal {
        finOpBalances[finOp][account] = finOpBalances[finOp][account].sub(amount);
    }</span>

    /**
     * @dev Utility to convert depositToken value to rewardToken value
     *
     * @param amount depositToken amount to convert to rewardToken
     * @param finOp financial opportunity address
     */
    <span class="marker" id="mapping-470"></span><span class="token add" data-title="contract_body/function_definition">function _toRewardToken(uint256 amount, address finOp) internal view returns (uint256) {
        uint256 ratio = _getFinOp(finOp).tokenValue();
        return amount.mul(10 ** 18).div(ratio);
    }</span>

    /**
     * @dev Utility to convert rewardToken value to depositToken value
     *
     * @param amount rewardToken amount to convert to depositToken
     * @param finOp financial opportunity address
     */
    <span class="marker" id="mapping-471"></span><span class="token add" data-title="contract_body/function_definition">function _toToken(<span class="marker" id="mapping-472"></span><span class="token mv" id="move-dst-103" data-title="function_definition/parameter">uint <span class="marker" id="mapping-473"></span><span class="token upd" id="move-dst-104" data-title="parameter/identifier">amo<span class="cupd">u</span>nt</span></span>, <span class="marker" id="mapping-474"></span><span class="token add" data-title="function_definition/parameter">address finOp</span>) <span class="marker" id="mapping-475"></span><span class="token add" data-title="function_definition/visibility">internal</span> <span class="marker" id="mapping-476"></span><span class="token add" data-title="function_definition/state_mutability">view</span> <span class="marker" id="mapping-477"></span><span class="token add" data-title="function_definition/return_type_definition">returns (uint256)</span> <span class="marker" id="mapping-478"></span><span class="token add" data-title="function_definition/function_body">{
        uint256 ratio = _getFinOp(finOp).tokenValue();
        return ratio.mul(amount).div(10 ** 18);
    }</span></span>

    /**
     * @dev utility to get FinancialOpportunity for address
     *
     * @param finOp financial opportunity to get
     */
    <span class="marker" id="mapping-479"></span><span class="token add" data-title="contract_body/function_definition">function _getFinOp(address finOp) internal view returns (FinancialOpportunity) {
        return FinancialOpportunity(finOp);
    }</span>
}</span></span>

<span class="marker" id="mapping-480"></span><span class="token add" data-title="source_file/comment">// File: contracts/TrueCurrencies/RewardTokenWithReserve.sol</span>

<span class="marker" id="mapping-481"></span><span class="token add" data-title="source_file/pragma_directive">pragma solidity 0.5.13;</span>


<span class="marker" id="mapping-482"></span><span class="token add" data-title="source_file/comment">/**
 * @title RewardTokenWithReserve
 * @dev Provides a reserve to swap rewardTokens for gas savings
 *
 * -- Overview --
 * The Reserve holds Tokens and RewardTokens
 * Because gas costs can be high for depositing/redeeming in financial
 * opportunities, we use this contract to keep a reserve of tokens
 * to provide swap opportunities
 *
 */</span>
<span class="marker" id="mapping-483"></span><span class="token add" data-title="source_file/contract_declaration">contract RewardTokenWithReserve is <span class="marker" id="mapping-484"></span><span class="token add" data-title="contract_declaration/inheritance_specifier">RewardToken</span> <span class="marker" id="mapping-485"></span><span class="token add" data-title="contract_declaration/contract_body">{

    // Reserve is an address which nobody has the private key to
    // Reserves of TUSD and TrueRewardBackedToken are held at this addess
    <span class="marker" id="mapping-486"></span><span class="token add" data-title="contract_body/state_variable_declaration">address public constant RESERVE = 0xf000000000000000000000000000000000000000;</span>

    <span class="marker" id="mapping-487"></span><span class="token add" data-title="contract_body/event_definition">event SwapRewardForToken(address account, address receiver, uint256 amount, address finOp);</span>
    <span class="marker" id="mapping-488"></span><span class="token add" data-title="contract_body/event_definition">event SwapTokenForReward(address account, address receiver, uint256 amount, address finOp);</span>

    /**
     * @dev get reserve token balance
     *
     * @return token balance of reserve
     */
    <span class="marker" id="mapping-489"></span><span class="token add" data-title="contract_body/function_definition">function reserveBalance() <span class="marker" id="mapping-490"></span><span class="token mv" id="move-dst-59" data-title="function_definition/visibility">public</span> <span class="marker" id="mapping-491"></span><span class="token add" data-title="function_definition/state_mutability">view</span> <span class="marker" id="mapping-492"></span><span class="token add" data-title="function_definition/return_type_definition">returns (uint256)</span> <span class="marker" id="mapping-493"></span><span class="token add" data-title="function_definition/function_body">{
        return super.balanceOf(RESERVE);
    }</span></span>

    /**
     * @dev Get rewardToken reserve balance
     *
     * @param finOp address of financial opportunity
     * @return rewardToken balance of reserve for finOp
     */
    <span class="marker" id="mapping-494"></span><span class="token add" data-title="contract_body/function_definition">function reserveRewardBalance(<span class="marker" id="mapping-495"></span><span class="token add" data-title="function_definition/parameter">address finOp</span>) <span class="marker" id="mapping-496"></span><span class="token mv" id="move-dst-55" data-title="function_definition/visibility">public</span> <span class="marker" id="mapping-497"></span><span class="token add" data-title="function_definition/state_mutability">view</span> <span class="marker" id="mapping-498"></span><span class="token add" data-title="function_definition/return_type_definition">returns (<span class="marker" id="mapping-499"></span><span class="token mv" id="move-dst-99" data-title="return_type_definition/parameter">uint</span>)</span> <span class="marker" id="mapping-500"></span><span class="token add" data-title="function_definition/function_body">{
        return rewardTokenBalance(RESERVE, finOp);
    }</span></span>

    /**
     * @dev Withdraw Token from reserve through transferAll
     *
     * @param to address to withdraw to
     * @param value amount to withdraw
     */
    <span class="marker" id="mapping-501"></span><span class="token add" data-title="contract_body/function_definition">function reserveWithdraw(<span class="marker" id="mapping-502"></span><span class="token mv" id="move-dst-24" data-title="function_definition/parameter">address to</span>, <span class="marker" id="mapping-503"></span><span class="token mv" id="move-dst-29" data-title="function_definition/parameter">uint256 value</span>) <span class="marker" id="mapping-504"></span><span class="token add" data-title="function_definition/visibility">external</span> <span class="marker" id="mapping-505"></span><span class="token mv" id="move-dst-54" data-title="function_definition/modifier_invocation">onlyOwner</span> <span class="marker" id="mapping-506"></span><span class="token add" data-title="function_definition/function_body">{
        _transferAllArgs(RESERVE, to, value);
    }</span></span>

    /**
     * @dev Allow this contract to rebalance currency reserves
     * This is called when there is too much money in an opportunity and we want
     * to get more TrueCurrency.
     * This allows us to reduct the cost of transfers 5-10x in/out of opportunities
     *
     * @param amount amount of rewardTokens to redeem
     * @param finOp financial opportunity to redeem from
     */
    <span class="marker" id="mapping-507"></span><span class="token add" data-title="contract_body/function_definition">function reserveRedeem(uint256 amount, address finOp) internal {
        redeemRewardToken(RESERVE, amount, finOp);
    }</span>

    /**
     * @dev Allow this contract to rebalance currency reserves
     * This is called when there is not enough rewardToken for an
     * opportunity and we want to add rewardTokens to the reserve
     *
     * @param amount amount of Token to redeem for rewardToken
     * @param finOp financial opportunity to redeem for
     */
    <span class="marker" id="mapping-508"></span><span class="token add" data-title="contract_body/function_definition">function reserveMint(uint256 amount, address finOp) internal {
        mintRewardToken(RESERVE, amount, finOp);
    }</span>

    /**
     * @dev Use reserve to swap Token for rewardToken between accounts
     *
     * @param sender account to deduct token from
     * @param receiver account to add rewardToken to
     * @param amount Token amount to exchange for rewardToken
     * @param finOp financial opportunity to swap tokens for
     */
    <span class="marker" id="mapping-509"></span><span class="token add" data-title="contract_body/function_definition">function swapTokenForReward(
        address sender,
        address receiver,
        uint256 amount,
        address finOp
    ) internal validFinOp(finOp) {
        // require sender has sufficient balance
        require(balanceOf(sender) &gt;= amount, "insufficient balance");

        // calculate rewardToken value for depositToken amount
        uint256 rewardAmount = _toRewardToken(amount, finOp);

        // require reserve
        require(rewardTokenBalance(RESERVE, finOp) &gt;= rewardAmount, "not enough rewardToken in reserve");

        // sub from sender and add to reserve for depositToken
        _subBalance(sender, amount);
        _addBalance(RESERVE, amount);

        // sub from reserve and add to sender for rewardToken
        _subRewardBalance(RESERVE, rewardAmount, finOp);
        _addRewardBalance(receiver, rewardAmount, finOp);

        // emit event
        emit SwapTokenForReward(sender, receiver, amount, finOp);
    }</span>

    /**
     * @dev Use reserve to swap rewardToken for Token between accounts
     *
     * @param sender account to swap rewardToken from
     * @param receiver account to add Token to
     * @param tokenAmount token amount to receive for Token
     * @param finOp financial opportunity
     */
    <span class="marker" id="mapping-510"></span><span class="token add" data-title="contract_body/function_definition">function swapRewardForToken(
        address sender,
        address receiver,
        uint256 tokenAmount,
        address finOp
    ) internal validFinOp(finOp) {
        // ensure reserve has enough balance
        require(balanceOf(RESERVE) &gt;= tokenAmount, "not enough depositToken in reserve");

        uint256 rewardAmount = _toRewardToken(tokenAmount, finOp);

        // require sufficient balance
        require (rewardTokenBalance(sender, finOp) &gt;= rewardAmount, "insufficient rewardToken balance");

        // sub account and add reserve for rewardToken
        _subRewardBalance(sender, rewardAmount, finOp);
        _addRewardBalance(RESERVE, rewardAmount, finOp);

        // sub account and add reserve for Token
        _subBalance(RESERVE, tokenAmount);
        _addBalance(receiver, tokenAmount);

        // emit event
        emit SwapRewardForToken(sender, receiver, rewardAmount, finOp);
    }</span>
}</span></span>

<span class="marker" id="mapping-511"></span><span class="token add" data-title="source_file/comment">// File: contracts/TrueCurrencies/TrueRewardBackedToken.sol</span>

<span class="marker" id="mapping-512"></span><span class="token add" data-title="source_file/pragma_directive">pragma solidity 0.5.13;</span>




<span class="marker" id="mapping-513"></span><span class="token add" data-title="source_file/comment">/**
 * @title TrueRewardBackedToken
 * @dev TrueRewardBackedToken is TrueCurrency backed by debt
 *
 * -- Overview --
 * Enabling TrueRewards deposits TrueCurrency into a financial opportunity
 * Financial opportunities provide awards over time
 * Awards are reflected in the wallet balance updated block-by-block
 *
 * -- rewardToken vs yToken --
 * rewardToken represents an amount of ASSURED TrueCurrency owed to the rewardToken holder
 * yToken represents an amount of NON-ASSURED TrueCurrency owed to a yToken holder
 * For this contract, we only handle rewardToken (Assured Opportunities)
 *
 * -- Calculating rewardToken --
 * TrueCurrency Value = rewardToken * financial opportunity tokenValue()
 *
 * -- rewardToken Assumptions --
 * We assume tokenValue never decreases for assured financial opportunities
 * rewardToken is not transferrable in that the token itself is never tranferred
 * Rather, we override our transfer functions to account for user balances
 *
 * -- Reserve --
 * This contract uses a reserve holding of TrueCurrency and rewardToken to save on gas costs
 * because calling the financial opportunity deposit() and redeem() everytime
 * can be expensive
 * See RewardTokenWithReserve.sol
 *
 * -- Future Upgrades to Financial Opportunity --
 * Currently, we only have a single financial opportunity
 * We plan on upgrading this contract to support a multiple financial opportunity,
 * so some of the code is built to support this
 *
 */</span>
<span class="marker" id="mapping-514"></span><span class="token add" data-title="source_file/contract_declaration">contract TrueRewardBackedToken is <span class="marker" id="mapping-515"></span><span class="token add" data-title="contract_declaration/inheritance_specifier">RewardTokenWithReserve</span> <span class="marker" id="mapping-516"></span><span class="token add" data-title="contract_declaration/contract_body">{

    /* variables in Proxy Storage:
    mapping(address =&gt; FinancialOpportunity) finOps;
    mapping(address =&gt; mapping(address =&gt; uint256)) finOpBalances;
    mapping(address =&gt; uint256) finOpSupply;
    uint256 maxRewardProportion = 1000;
    */

    // registry attribute for whitelist
    // 0x6973547275655265776172647357686974656c69737465640000000000000000
    <span class="marker" id="mapping-517"></span><span class="token add" data-title="contract_body/state_variable_declaration">bytes32 constant IS_TRUEREWARDS_WHITELISTED = "isTrueRewardsWhitelisted";</span>

    // financial opportunity address
    <span class="marker" id="mapping-518"></span><span class="token add" data-title="contract_body/state_variable_declaration">address public opportunity_;</span>

    <span class="marker" id="mapping-519"></span><span class="token add" data-title="contract_body/event_definition">event TrueRewardEnabled(address _account);</span>
    <span class="marker" id="mapping-520"></span><span class="token add" data-title="contract_body/event_definition">event TrueRewardDisabled(address _account);</span>

    /** @dev return true if TrueReward is enabled for a given address */
    <span class="marker" id="mapping-521"></span><span class="token mv" id="move-dst-26" data-title="contract_body/function_definition">function <span class="marker" id="mapping-522"></span><span class="token upd" id="move-dst-27" data-title="function_definition/identifier">trueRew<span class="cupd">a</span><span class="cupd">r</span>dEnabled</span>(<span class="marker" id="mapping-523"></span><span class="token add" data-title="function_definition/parameter">address _address</span>) public <span class="marker" id="mapping-524"></span><span class="token add" data-title="function_definition/state_mutability">view</span> returns (bool) <span class="marker" id="mapping-525"></span><span class="token add" data-title="function_definition/function_body">{
        return _rewardDistribution[_address].length != 0;
    }</span></span>

    /**
     * @dev Get total supply of all TrueCurrency
     * Equal to deposit backed TrueCurrency plus debt backed TrueCurrency
     * @return total supply in trueCurrency
     */
    <span class="marker" id="mapping-526"></span><span class="token add" data-title="contract_body/function_definition">function totalSupply() <span class="marker" id="mapping-527"></span><span class="token mv" id="move-dst-43" data-title="function_definition/visibility">public</span> <span class="marker" id="mapping-528"></span><span class="token add" data-title="function_definition/state_mutability">view</span> <span class="marker" id="mapping-529"></span><span class="token add" data-title="function_definition/return_type_definition">returns (uint256)</span> <span class="marker" id="mapping-530"></span><span class="token add" data-title="function_definition/function_body">{
        // if supply in opportunity finOp, return supply of deposits + debt
        // otherwise call super to return normal totalSupply
        if (opportunityRewardSupply() != 0) {
            return totalSupply_.add(opportunityTotalSupply());
        }
        return totalSupply_;
    }</span></span>

    /**
     * @dev get total supply of TrueCurrency backed by fiat deposits
     * @return supply of fiat backed TrueCurrency
     */
    <span class="marker" id="mapping-531"></span><span class="token add" data-title="contract_body/function_definition">function depositBackedSupply() <span class="marker" id="mapping-532"></span><span class="token mv" id="move-dst-25" data-title="function_definition/visibility">public</span> <span class="marker" id="mapping-533"></span><span class="token add" data-title="function_definition/state_mutability">view</span> <span class="marker" id="mapping-534"></span><span class="token add" data-title="function_definition/return_type_definition">returns (uint256)</span> <span class="marker" id="mapping-535"></span><span class="token add" data-title="function_definition/function_body">{
        return totalSupply_;
    }</span></span>

    /**
     * @dev get total supply of TrueCurrency backed by debt
     * @return supply of debt backed TrueCurrency
     */
    <span class="marker" id="mapping-536"></span><span class="token add" data-title="contract_body/function_definition">function debtBackedSupply() <span class="marker" id="mapping-537"></span><span class="token mv" id="move-dst-20" data-title="function_definition/visibility">public</span> <span class="marker" id="mapping-538"></span><span class="token add" data-title="function_definition/state_mutability">view</span> <span class="marker" id="mapping-539"></span><span class="token add" data-title="function_definition/return_type_definition">returns (uint256)</span> <span class="marker" id="mapping-540"></span><span class="token add" data-title="function_definition/function_body">{
        return totalSupply().sub(totalSupply_);
    }</span></span>

    /**
     * @dev Get balance of TrueCurrency including rewards for an address
     *
     * @param _who address of account to get balanceOf for
     * @return balance total balance of address including rewards
     */
    <span class="marker" id="mapping-541"></span><span class="token add" data-title="contract_body/function_definition">function balanceOf(<span class="marker" id="mapping-542"></span><span class="token add" data-title="function_definition/parameter">address _who</span>) <span class="marker" id="mapping-543"></span><span class="token mv" id="move-dst-16" data-title="function_definition/visibility">public</span> <span class="marker" id="mapping-544"></span><span class="token add" data-title="function_definition/state_mutability">view</span> <span class="marker" id="mapping-545"></span><span class="token add" data-title="function_definition/return_type_definition">returns (uint256)</span> <span class="marker" id="mapping-546"></span><span class="token add" data-title="function_definition/function_body">{
        // if trueReward enabled, return token value of reward balance
        // otherwise call token balanceOf
        if (trueRewardEnabled(_who)) {
            return _toToken(rewardTokenBalance(_who, opportunity()), opportunity());
        }
        return super.balanceOf(_who);
    }</span></span>

    /**
     * @dev Enable TrueReward and deposit user balance into opportunity.
     * Currently supports a single financial opportunity
     */
    <span class="marker" id="mapping-547"></span><span class="token add" data-title="contract_body/function_definition">function enableTrueReward() external {
        // require TrueReward is not enabled
        require(registry.hasAttribute(msg.sender, IS_TRUEREWARDS_WHITELISTED), "must be whitelisted to enable TrueRewards");
        require(!trueRewardEnabled(msg.sender), "TrueReward already enabled");

        // get sender balance
        uint balance = _getBalance(msg.sender);

        if (balance != 0) {
            // mint reward token
            mintRewardToken(msg.sender, balance, opportunity());
        }

        // set reward distribution
        // we set max distribution since we only have one opportunity
        _setDistribution(maxRewardProportion, opportunity());

        // emit enable event
        emit TrueRewardEnabled(msg.sender);
        //emit Transfer(address(0), msg.sender, balance);
    }</span>

    /**
     * @dev Disable TrueReward and withdraw user balance from opportunity.
     */
    <span class="marker" id="mapping-548"></span><span class="token add" data-title="contract_body/function_definition">function disableTrueReward() external {
        // require TrueReward is enabled
        require(trueRewardEnabled(msg.sender), "TrueReward already disabled");
        // get balance
        uint rewardBalance = rewardTokenBalance(msg.sender, opportunity());

        // remove reward distribution
        _removeDistribution(opportunity());

        if (rewardBalance &gt; 0) {
            // redeem for token
            redeemRewardToken(msg.sender, rewardBalance, opportunity());
        }

        // emit disable event
        emit TrueRewardDisabled(msg.sender);
        // emit Transfer(msg.sender, address(0), zTrueCurrency);
    }</span>

    /**
     * @dev mint function for TrueRewardBackedToken
     * Mints TrueCurrency backed by debt
     * When we add multiple opportunities, this needs to work for mutliple interfaces
     */
    <span class="marker" id="mapping-549"></span><span class="token add" data-title="contract_body/function_definition">function mint(<span class="marker" id="mapping-550"></span><span class="token mv" id="move-dst-89" data-title="function_definition/parameter">address _to</span>, <span class="marker" id="mapping-551"></span><span class="token add" data-title="function_definition/parameter">uint256 _value</span>) <span class="marker" id="mapping-552"></span><span class="token add" data-title="function_definition/visibility">public</span> <span class="marker" id="mapping-553"></span><span class="token add" data-title="function_definition/modifier_invocation">onlyOwner</span> <span class="marker" id="mapping-554"></span><span class="token add" data-title="function_definition/function_body">{
        // check if to address is enabled
        bool toEnabled = trueRewardEnabled(_to);

        // if to enabled, mint to this contract and deposit into finOp
        if (toEnabled) {
            // mint to this contract
            super.mint(address(this), _value);
            // transfer minted amount to target receiver
            _transferAllArgs(address(this), _to, _value);
        }
        // otherwise call normal mint process
        else {
            super.mint(_to, _value);
        }
    }</span></span>

    /**
     * @dev redeem reserve rewardTokens for Token given a rewardToken amount
     * This is called by the TokenController to balance the reserve
     * @param _value amount of Token to deposit for rewardTokens
     */
    <span class="marker" id="mapping-555"></span><span class="token add" data-title="contract_body/function_definition">function opportunityReserveRedeem(uint256 _value) external onlyOwner {
        reserveRedeem(_value, opportunity());
    }</span>

    /**
     * @dev mint reserve rewardTokens for opportunity given a Token deposit
     * This is called by the TokenController to balance the reserve
     * @param _value amount of Token to deposit for rewardTokens
     */
    <span class="marker" id="mapping-556"></span><span class="token add" data-title="contract_body/function_definition">function opportunityReserveMint(uint256 _value) external onlyOwner {
        reserveMint(_value, opportunity());
    }</span>

    /**
     * @dev set a new opportunity financial opportunity address
     * @param _opportunity new opportunity to set
     */
    <span class="marker" id="mapping-557"></span><span class="token add" data-title="contract_body/function_definition">function setOpportunityAddress(address _opportunity) external onlyOwner {
        opportunity_ = _opportunity;
    }</span>

    /**
     * @dev Get (assured) financial opportunity address
     * @return address financial opportunity address
     */
    <span class="marker" id="mapping-558"></span><span class="token add" data-title="contract_body/function_definition">function opportunity() public view returns (address) {
        return opportunity_;
    }</span>

    /**
     * @dev Get total supply of opportunity rewardToken
     * @return total supply of opportunity rewardToken
     */
    <span class="marker" id="mapping-559"></span><span class="token mv" id="move-dst-57" data-title="contract_body/function_definition">function <span class="marker" id="mapping-560"></span><span class="token upd" id="move-dst-58" data-title="function_definition/identifier">opportun<span class="cupd">i</span>tyRe<span class="cupd">w</span>a<span class="cupd">r</span>dSupply</span>() <span class="marker" id="mapping-561"></span><span class="token add" data-title="function_definition/visibility">internal</span> <span class="marker" id="mapping-562"></span><span class="token add" data-title="function_definition/state_mutability">view</span> <span class="marker" id="mapping-563"></span><span class="token add" data-title="function_definition/return_type_definition">returns (uint256)</span> {
        <span class="marker" id="mapping-564"></span><span class="token add" data-title="function_body/if_statement">if (<span class="marker" id="mapping-565"></span><span class="token add" data-title="if_statement/binary_expression"><span class="marker" id="mapping-566"></span><span class="token add" data-title="binary_expression/call_expression">opportunity()</span> == <span class="marker" id="mapping-567"></span><span class="token mv" id="move-dst-60" data-title="binary_expression/type_cast_expression">address(0)</span></span>) <span class="marker" id="mapping-568"></span><span class="token add" data-title="if_statement/block_statement">{
            return 0;
        }</span></span>
        <span class="marker" id="mapping-569"></span><span class="token add" data-title="function_body/return_statement">return rewardTokenSupply(opportunity());</span>
    }</span>

    /**
     * @dev Get total supply of TrueCurrency in opportunity
     * @return total supply of TrueCurrency in opportunity
     */
    <span class="marker" id="mapping-570"></span><span class="token add" data-title="contract_body/function_definition">function opportunityTotalSupply() internal view returns (uint256) {
        return _toToken(opportunityRewardSupply(), opportunity());
    }</span>

    /**
     * @dev Transfer helper for accounts with rewardToken balances
     * Uses reserve float to save gas costs for transactions with value &lt; reserve balance
     * Case #2 and #3 use reserve balances
     *
     * There are 6 transfer cases
     *  1. Both sender and receiver are disabled (see _transferAllArgs)
     *  2. Sender enabled, receiver disabled, value &lt; reserve TrueCurrency balance
     *  3. Sender disabled, receiver enabled, value &lt; reserve rewardToken balance (in TrueCurrency)
     *  4. Both sender and receiver are enabled
     *  5. Sender enabled, receiver disabled, value &gt; reserve TrueCurrency balance
     *  6. Sender disabled, receiver enabled, value &gt; reserve rewardToken balance (in TrueCurrency)
     *
     * @param _from account to transfer from
     * @param _to account to transfer to
     * @param _value value in Token to transfer
     * @return actual value transferred
     */
    <span class="marker" id="mapping-571"></span><span class="token add" data-title="contract_body/function_definition">function _transferWithRewards(
        address _from,
        address _to,
        uint256 _value
    ) internal returns (uint256) {
        // get enable stat
        bool fromEnabled = trueRewardEnabled(_from);
        bool toEnabled = trueRewardEnabled(_to);

        // get opportunity address
        address finOp = opportunity();

        // calculate rewardToken balance
        uint rewardAmount = _toRewardToken(_value, finOp);

        // 2. Sender enabled, receiver disabled, value &lt; reserve TrueCurrency balance
        // Swap rewardToken for Token through reserve
        if (fromEnabled &amp;&amp; !toEnabled &amp;&amp; _value &lt;= reserveBalance()) {
            swapRewardForToken(_from, _to, _value, finOp);
        }
        // 3. Sender disabled, receiver enabled, value &lt; reserve rewardToken balance
        // Swap Token for rewardToken through reserve
        else if (!fromEnabled &amp;&amp; toEnabled &amp;&amp; rewardAmount &lt;= rewardTokenBalance(RESERVE, finOp)) {
            swapTokenForReward(_from, _to, _value, finOp);
        }
        // 4. Sender and receiver are enabled
        // Here we simply transfer rewardToken from the sender to the receiver
        else if (fromEnabled &amp;&amp; toEnabled) {
            _subRewardBalance(_from, rewardAmount, finOp);
            _addRewardBalance(_to, rewardAmount, finOp);
        }
        // 5. Sender enabled, receiver disabled, value &gt; reserve TrueCurrency balance
        // Recalculate value based on redeem value returned and give value to receiver
        else if (fromEnabled &amp;&amp; !toEnabled) {
            _getFinOp(finOp).redeem(_to, rewardAmount);

            // decrease finOp rewardToken supply
            finOpSupply[finOp] = finOpSupply[finOp].sub(rewardAmount);

            // decrease account rewardToken balance
            _subRewardBalance(_from, rewardAmount, finOp);
        }
        // 6. Sender disabled, receiver enabled, value &gt; reserve rewardToken balance
        // Transfer Token value between accounts and mint reward token for receiver
        else if (!fromEnabled &amp;&amp; toEnabled) {
            // deposit into finOp
            _approveAllArgs(finOp, _value, _from);
            uint256 depositedAmount = _getFinOp(finOp).deposit(_from, _value);

            // increase finOp rewardToken supply
            finOpSupply[finOp] = finOpSupply[finOp].add(depositedAmount);

            // increase account rewardToken balance
            _addRewardBalance(_to, depositedAmount, finOp);
        }
        return _value;
    }</span>

    /**
     * @dev Transfer helper function for TrueRewardBackedToken
     */
    <span class="marker" id="mapping-572"></span><span class="token add" data-title="contract_body/function_definition">function _transferAllArgs(<span class="marker" id="mapping-573"></span><span class="token add" data-title="function_definition/parameter">address _from</span>, <span class="marker" id="mapping-574"></span><span class="token mv" id="move-dst-36" data-title="function_definition/parameter">address _to</span>, <span class="marker" id="mapping-575"></span><span class="token add" data-title="function_definition/parameter">uint256 _value</span>) <span class="marker" id="mapping-576"></span><span class="token add" data-title="function_definition/visibility">internal</span> <span class="marker" id="mapping-577"></span><span class="token add" data-title="function_definition/function_body">{
        // 1. Both sender and receiver are disabled
        // Exchange is in TrueCurrency -&gt; call the normal transfer function
        if (!trueRewardEnabled(_from) &amp;&amp; !trueRewardEnabled(_to)) {
            // sender not enabled receiver not enabled
            super._transferAllArgs(_from, _to, _value);
            return;
        }
        require(balanceOf(_from) &gt;= _value, "not enough balance");

        // require account is not blacklisted and check if hook is registered
        (address finalTo, bool hasHook) = _requireCanTransfer(_from, _to);

        _value = _transferWithRewards(_from, finalTo, _value);

        // emit transfer event for from
        emit Transfer(_from, _to, _value);
        if (finalTo != _to) {
            emit Transfer(_to, finalTo, _value);
            if (hasHook) {
                TrueCoinReceiver(finalTo).tokenFallback(_to, _value);
            }
        } else {
            if (hasHook) {
                TrueCoinReceiver(finalTo).tokenFallback(_from, _value);
            }
        }
    }</span></span>

    /**
     * @dev TransferFromAll helper function for TrueRewardBackedToken
     */
    <span class="marker" id="mapping-578"></span><span class="token add" data-title="contract_body/function_definition">function _transferFromAllArgs(
        address _from,
        address _to,
        uint256 _value,
        address _spender
    ) internal {
        // 1. Both sender and receiver are disabled -&gt; normal transfer
        if (!trueRewardEnabled(_from) &amp;&amp; !trueRewardEnabled(_to)) {
            super._transferFromAllArgs(_from, _to, _value, _spender);
            return;
        }

        // check balance
        require(balanceOf(_from) &gt;= _value, "not enough balance");

        (address finalTo, bool hasHook) = _requireCanTransferFrom(_spender, _from, _to);

        // call transfer helper
        _value = _transferWithRewards(_from, finalTo, _value);

        // sub allowance of spender
        _subAllowance(_from, _spender, _value);

        // emit transfer event. For hook emit second transfer event
        // call fallback function for valid hook
        emit Transfer(_from, _to, _value);
        if (finalTo != _to) {
            emit Transfer(_to, finalTo, _value);
            if (hasHook) {
                TrueCoinReceiver(finalTo).tokenFallback(_to, _value);
            }
        } else {
            if (hasHook) {
                TrueCoinReceiver(finalTo).tokenFallback(_from, _value);
            }
        }
    }</span>

    /**
     * @dev Set reward distribution for an opportunity
     *
     * @param proportion to set
     * @param finOp financial opportunity to set proportion for
     */
    <span class="marker" id="mapping-579"></span><span class="token add" data-title="contract_body/function_definition">function _setDistribution(uint256 proportion, address finOp) internal {
        require(proportion &lt;= maxRewardProportion, "exceeds maximum proportion");
        require(_rewardDistribution[msg.sender].length == 0, "already enabled");
        _rewardDistribution[msg.sender].push(
            RewardAllocation(proportion, finOp));
    }</span>

    /**
     * @dev Remove reward distribution for a financial opportunity
     * Remove
     */
    <span class="marker" id="mapping-580"></span><span class="token add" data-title="contract_body/function_definition">function _removeDistribution(address finOp) internal {
        delete _rewardDistribution[msg.sender][0];
        _rewardDistribution[msg.sender].length--;
    }</span>
}</span></span>

<span class="marker" id="mapping-581"></span><span class="token add" data-title="source_file/comment">// File: contracts/TrueCurrencies/DelegateERC20.sol</span>

<span class="marker" id="mapping-582"></span><span class="token add" data-title="source_file/pragma_directive">pragma solidity 0.5.13;</span>


<span class="marker" id="mapping-583"></span><span class="token add" data-title="source_file/comment">/** @title DelegateERC20
Accept forwarding delegation calls from the old TrueUSD (V1) contract. This way the all the ERC20
functions in the old contract still works (except Burn).
*/</span>
<span class="marker" id="mapping-584"></span><span class="token mv" id="move-dst-141" data-title="source_file/contract_declaration">contract DelegateERC20 is CompliantDepositTokenWithHook {

    address constant DELEGATE_FROM = 0x8dd5fbCe2F6a956C3022bA3663759011Dd51e73E;

    modifier onlyDelegateFrom() {
        require(msg.sender == DELEGATE_FROM);
        _;
    }

    function delegateTotalSupply() public view returns (uint256) {
        return totalSupply();
    }

    function delegateBalanceOf(address who) public view returns (uint256) {
        return _getBalance(who);
    }

    function delegateTransfer(address to, uint256 value, address origSender) public onlyDelegateFrom returns (bool) {
        _transferAllArgs(origSender, to, value);
        return true;
    }

    function delegateAllowance(address owner, address spender) public view returns (uint256) {
        return _getAllowance(owner, spender);
    }

    function delegateTransferFrom(address from, address to, uint256 value, address origSender) public onlyDelegateFrom returns (bool) {
        _transferFromAllArgs(from, to, value, origSender);
        return true;
    }

    function delegateApprove(address spender, uint256 value, address origSender) public onlyDelegateFrom returns (bool) {
        _approveAllArgs(spender, value, origSender);
        return true;
    }

    function delegateIncreaseApproval(address spender, uint addedValue, address origSender) public onlyDelegateFrom returns (bool) {
        <span class="marker" id="mapping-585"></span><span class="token upd" id="move-dst-142" data-title="call_expression/identifier"><span class="cupd">_increaseA</span>ll<span class="cupd">o</span>w<span class="cupd">a</span>nce<span class="cupd">AllArgs</span></span>(spender, addedValue, origSender);
        return true;
    }

    function delegateDecreaseApproval(address spender, uint subtractedValue, address origSender) public onlyDelegateFrom returns (bool) {
        <span class="marker" id="mapping-586"></span><span class="token upd" id="move-dst-143" data-title="call_expression/identifier"><span class="cupd">_decreaseA</span>ll<span class="cupd">o</span>w<span class="cupd">a</span>nce<span class="cupd">AllArgs</span></span>(spender, subtractedValue, origSender);
        return true;
    }
}</span>

<span class="marker" id="mapping-587"></span><span class="token add" data-title="source_file/comment">// File: contracts/TrueCurrencies/TrueUSD.sol</span>

<span class="marker" id="mapping-588"></span><span class="token add" data-title="source_file/pragma_directive">pragma solidity 0.5.13;</span>





<span class="marker" id="mapping-589"></span><span class="token add" data-title="source_file/comment">/** @title TrueUSD
 * @dev This is the top-level ERC20 contract, but most of the interesting functionality is
 * inherited - see the documentation on the corresponding contracts.
 */</span>
contract TrueUSD is <span class="marker" id="mapping-590"></span><span class="token add" data-title="contract_declaration/inheritance_specifier">TrueRewardBackedToken</span>, DelegateERC20 {
    uint8 constant DECIMALS = 18;
    uint8 constant ROUNDING = 2;

    function decimals() public pure returns (uint8) {
        return DECIMALS;
    }

    function rounding() public pure returns (uint8) {
        return ROUNDING;
    }

    function name() public pure returns (string <span class="marker" id="mapping-591"></span><span class="token add" data-title="parameter/memory">memory</span>) {
        return "TrueUSD";
    }

    function symbol() public pure returns (string <span class="marker" id="mapping-592"></span><span class="token add" data-title="parameter/memory">memory</span>) {
        return "TUSD";
    }

    function canBurn() internal pure returns (bytes32) {
        return "canBurn";
    }
}</pre></div></div></div></body></html>