<html lang="en"><head><meta charset="utf8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>GumTree</title><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css"><style type="text/css">/*
 * This file is part of GumTree.
 *
 * GumTree is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * GumTree is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with GumTree.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Copyright 2011-2015 Jean-Rémy Falleri <jr.falleri@gmail.com>
 * Copyright 2011-2015 Floréal Morandat <florealm@gmail.com>
 */

.add {
	border: 1px solid black;
	background-color: MediumSeaGreen;
}

.del {
	border: 1px solid black;
	background-color: IndianRed;
}

.mv {
	border: 1px solid black;
	background-color: Plum;
}

.upd {
	border: 1px solid black;
	background-color: DarkOrange;
	font-weight: bold;
}

.cupd {
	font-weight: normal;
	color: DimGray;
}

.selected {
	background-color: Gold;
}

.marker {
	margin: 0;
	padding: 0;
}

div {
	margin: 0px;
	padding: 0px;
}

.pre-scrollable {
	margin: 0px;
	padding: 0px;
	font-size: 10pt;
	color: black;
	max-height: 90vh;
	background-color: white;
	border: 1px solid black;
	font-family: "Hack, Inconsolata", "Consolas", "Liberation Sans Regular", "DejaVu Sans Mono", monospace;
}

.tooltip-inner {
    max-width: none;
}
</style><script type="text/javascript" src="https://code.jquery.com/jquery-3.4.1.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/js/bootstrap.bundle.min.js"></script><script type="text/javascript">/*
 * This file is part of GumTree.
 *
 * GumTree is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * GumTree is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with GumTree.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Copyright 2011-2015 Jean-Rémy Falleri <jr.falleri@gmail.com>
 * Copyright 2011-2015 Floréal Morandat <florealm@gmail.com>
 */

$(function(){
    let popoverTriggerList = [].slice.call(document.querySelectorAll('[data-bs-toggle="popover"]'))
    let popoverList = popoverTriggerList.map(function (popoverTriggerEl) {
      return new bootstrap.Popover(popoverTriggerEl)
    })

    $("body").keypress(function (event) {
        switch (event.which) {
            case 116:
                $('html, body').animate({scrollTop: 0}, 100);
                break;
            case 98:
                $("html, body").animate({ scrollTop: $(document).height() }, 100);
                break;
            case 113:
                window.location = "/quit";
                break;
            case 108:
                window.location = "/list";
                break;
        }
    });
});
</script><script type="text/javascript">/*
 * This file is part of GumTree.
 *
 * GumTree is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * GumTree is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with GumTree.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Copyright 2011-2015 Jean-Rémy Falleri <jr.falleri@gmail.com>
 * Copyright 2011-2015 Floréal Morandat <florealm@gmail.com>
 */

currentMapping = 0;

if (typeof String.prototype.startsWith != 'function') {
  String.prototype.startsWith = function (str){
    return this.slice(0, str.length) == str;
  };
}

function getMappedElement(eltId) {
	if (eltId.startsWith("move-src")) {
		return eltId.replace("src","dst");  	 	
  	}
  	else {
  		return eltId.replace("dst","src");
  	}
}

function nextMapping() {
	if (currentMapping == 0) {
		currentMapping = 1;
		return "#mapping-" + currentMapping.toString();
	} else {
		currentMapping++;
		
		if ($("#mapping-" + currentMapping.toString()).length > 0) {
			return "#mapping-" + currentMapping.toString();
		} else {
			currentMapping = 1;
			return "#mapping-" + currentMapping.toString();		
		}		
	}
}

function isSrc(eltId) {
	return eltId.startsWith("move-src");
}

$(function() {
    $("body").keypress(function (event) {
        switch(event.which) {
            case 110:
                const mapping = $(nextMapping());
                const pre = mapping.closest("pre");
                pre.animate({scrollTop: pre.scrollTop() + mapping.position().top - 200}, 100);
                break;
        }
    });

    // highlight
    $("span.mv.token, span.token.upd").click(function(event) {
        if ($(this).hasClass("selected")) {
            $("span.mv.token, span.token.upd").removeClass("selected");
        } else {
            $("span.mv.token, span.token.upd").removeClass("selected");
            const refElt = $("#" + getMappedElement($(this).attr("id")));
            $(this).addClass("selected");
            refElt.addClass("selected");
            const pre = refElt.closest("pre");
            console.log(pre);
            pre.animate({scrollTop: pre.scrollTop() + refElt.position().top - 200}, 100);
        }
        event.stopPropagation();
    });
    
    $("span.add.token, span.token.del").click(function(event) {
        $("span.mv.token, span.token.upd").removeClass("selected");
        event.stopPropagation();
    });

    // tooltip
    $("span.token").hover(
    	function (event) {
    		$(this).tooltip('show');
    		event.stopPropagation();
    	},
    	function (event) {
    		$(this).tooltip('hide');
    		event.stopPropagation();
    	}
    );
});
</script></head><body><div class="container-fluid"><div class="row"><div class="col"><div class="btn-toolbar justify-content-end"><div class="btn-group mr-2"><button class="btn btn-primary btn-sm" id="legend" data-bs-toggle="popover" data-bs-placement="bottom" data-bs-html="true" data-bs-content="<span class='del'>&nbsp;&nbsp;</span> deleted<br><span class='add'>&nbsp;&nbsp;</span> added<br><span class='mv'>&nbsp;&nbsp;</span> moved<br><span class='upd';>&nbsp;&nbsp;</span> updated<br>">Legend</button><button class="btn btn-primary btn-sm" id="shortcuts" data-bs-toggle="popover" data-bs-placement="bottom" data-bs-html="true" data-bs-content="<b>q</b> quit<br><b>l</b> list<br><b>n</b> next<br><b>t</b> top<br><b>b</b> bottom">Shortcuts</button></div><div class="btn-group"><a href="/list" class="btn btn-default btn-sm btn-primary">Back</a><a href="/quit" class="btn btn-default btn-sm btn-danger">Quit</a></div></div></div></div><div class="row"><div class="col-6"><h5>0xbae5d387f2142617b15b8fe70e45743059b5672e.etherscan.io-ShardingDAOMiningDelegate.sol</h5><pre class="pre-scrollable">// File: interfaces/DelegatorInterface.sol

pragma solidity 0.6.12;
pragma experimental ABIEncoderV2;

contract DelegationStorage {
    /**
     * @notice Implementation address for this contract
     */
    address public implementation;
}

abstract contract DelegatorInterface is DelegationStorage {
    /**
     * @notice Emitted when implementation is changed
     */
    event NewImplementation(
        address oldImplementation,
        address newImplementation
    );

    /**
     * @notice Called by the admin to update the implementation of the delegator
     * @param implementation_ The address of the new implementation for delegation
     * @param allowResign Flag to indicate whether to call _resignImplementation on the old implementation
     * @param becomeImplementationData The encoded bytes data to be passed to _becomeImplementation
     */
    function _setImplementation(
        address implementation_,
        bool allowResign,
        bytes memory becomeImplementationData
    ) public virtual;
}

abstract contract DelegateInterface is DelegationStorage {
    /**
     * @notice Called by the delegator on a delegate to initialize it for duty
     * @dev Should revert if any issues arise which make it unfit for delegation
     * @param data The encoded bytes data for any initialization
     */
    function _becomeImplementation(bytes memory data) public virtual;

    /**
     * @notice Called by the delegator on a delegate to forfeit its responsibility
     */
    function _resignImplementation() public virtual;
}

// File: @openzeppelin/contracts/token/ERC20/IERC20.sol



pragma solidity &gt;=0.6.0 &lt;0.8.0;

/**
 * @dev Interface of the ERC20 standard as defined in the EIP.
 */
interface IERC20 {
    /**
     * @dev Returns the amount of tokens in existence.
     */
    function totalSupply() external view returns (uint256);

    /**
     * @dev Returns the amount of tokens owned by `account`.
     */
    function balanceOf(address account) external view returns (uint256);

    /**
     * @dev Moves `amount` tokens from the caller's account to `recipient`.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * Emits a {Transfer} event.
     */
    function transfer(address recipient, uint256 amount) external returns (bool);

    /**
     * @dev Returns the remaining number of tokens that `spender` will be
     * allowed to spend on behalf of `owner` through {transferFrom}. This is
     * zero by default.
     *
     * This value changes when {approve} or {transferFrom} are called.
     */
    function allowance(address owner, address spender) external view returns (uint256);

    /**
     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * IMPORTANT: Beware that changing an allowance with this method brings the risk
     * that someone may use both the old and the new allowance by unfortunate
     * transaction ordering. One possible solution to mitigate this race
     * condition is to first reduce the spender's allowance to 0 and set the
     * desired value afterwards:
     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
     *
     * Emits an {Approval} event.
     */
    function approve(address spender, uint256 amount) external returns (bool);

    /**
     * @dev Moves `amount` tokens from `sender` to `recipient` using the
     * allowance mechanism. `amount` is then deducted from the caller's
     * allowance.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * Emits a {Transfer} event.
     */
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);

    /**
     * @dev Emitted when `value` tokens are moved from one account (`from`) to
     * another (`to`).
     *
     * Note that `value` may be zero.
     */
    event Transfer(address indexed from, address indexed to, uint256 value);

    /**
     * @dev Emitted when the allowance of a `spender` for an `owner` is set by
     * a call to {approve}. `value` is the new allowance.
     */
    event Approval(address indexed owner, address indexed spender, uint256 value);
}

// File: @openzeppelin/contracts/math/SafeMath.sol



pragma solidity &gt;=0.6.0 &lt;0.8.0;

/**
 * @dev Wrappers over Solidity's arithmetic operations with added overflow
 * checks.
 *
 * Arithmetic operations in Solidity wrap on overflow. This can easily result
 * in bugs, because programmers usually assume that an overflow raises an
 * error, which is the standard behavior in high level programming languages.
 * `SafeMath` restores this intuition by reverting the transaction when an
 * operation overflows.
 *
 * Using this library instead of the unchecked operations eliminates an entire
 * class of bugs, so it's recommended to use it always.
 */
library SafeMath {
    /**
     * @dev Returns the addition of two unsigned integers, with an overflow flag.
     *
     * _Available since v3.4._
     */
    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {
        uint256 c = a + b;
        if (c &lt; a) return (false, 0);
        return (true, c);
    }

    /**
     * @dev Returns the substraction of two unsigned integers, with an overflow flag.
     *
     * _Available since v3.4._
     */
    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {
        if (b &gt; a) return (false, 0);
        return (true, a - b);
    }

    /**
     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.
     *
     * _Available since v3.4._
     */
    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {
        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the
        // benefit is lost if 'b' is also tested.
        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522
        if (a == 0) return (true, 0);
        uint256 c = a * b;
        if (c / a != b) return (false, 0);
        return (true, c);
    }

    /**
     * @dev Returns the division of two unsigned integers, with a division by zero flag.
     *
     * _Available since v3.4._
     */
    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {
        if (b == 0) return (false, 0);
        return (true, a / b);
    }

    /**
     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.
     *
     * _Available since v3.4._
     */
    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {
        if (b == 0) return (false, 0);
        return (true, a % b);
    }

    /**
     * @dev Returns the addition of two unsigned integers, reverting on
     * overflow.
     *
     * Counterpart to Solidity's `+` operator.
     *
     * Requirements:
     *
     * - Addition cannot overflow.
     */
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c &gt;= a, "SafeMath: addition overflow");
        return c;
    }

    /**
     * @dev Returns the subtraction of two unsigned integers, reverting on
     * overflow (when the result is negative).
     *
     * Counterpart to Solidity's `-` operator.
     *
     * Requirements:
     *
     * - Subtraction cannot overflow.
     */
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b &lt;= a, "SafeMath: subtraction overflow");
        return a - b;
    }

    /**
     * @dev Returns the multiplication of two unsigned integers, reverting on
     * overflow.
     *
     * Counterpart to Solidity's `*` operator.
     *
     * Requirements:
     *
     * - Multiplication cannot overflow.
     */
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        if (a == 0) return 0;
        uint256 c = a * b;
        require(c / a == b, "SafeMath: multiplication overflow");
        return c;
    }

    /**
     * @dev Returns the integer division of two unsigned integers, reverting on
     * division by zero. The result is rounded towards zero.
     *
     * Counterpart to Solidity's `/` operator. Note: this function uses a
     * `revert` opcode (which leaves remaining gas untouched) while Solidity
     * uses an invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     *
     * - The divisor cannot be zero.
     */
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b &gt; 0, "SafeMath: division by zero");
        return a / b;
    }

    /**
     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),
     * reverting when dividing by zero.
     *
     * Counterpart to Solidity's `%` operator. This function uses a `revert`
     * opcode (which leaves remaining gas untouched) while Solidity uses an
     * invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     *
     * - The divisor cannot be zero.
     */
    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b &gt; 0, "SafeMath: modulo by zero");
        return a % b;
    }

    /**
     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on
     * overflow (when the result is negative).
     *
     * CAUTION: This function is deprecated because it requires allocating memory for the error
     * message unnecessarily. For custom revert reasons use {trySub}.
     *
     * Counterpart to Solidity's `-` operator.
     *
     * Requirements:
     *
     * - Subtraction cannot overflow.
     */
    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
        require(b &lt;= a, errorMessage);
        return a - b;
    }

    /**
     * @dev Returns the integer division of two unsigned integers, reverting with custom message on
     * division by zero. The result is rounded towards zero.
     *
     * CAUTION: This function is deprecated because it requires allocating memory for the error
     * message unnecessarily. For custom revert reasons use {tryDiv}.
     *
     * Counterpart to Solidity's `/` operator. Note: this function uses a
     * `revert` opcode (which leaves remaining gas untouched) while Solidity
     * uses an invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     *
     * - The divisor cannot be zero.
     */
    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
        require(b &gt; 0, errorMessage);
        return a / b;
    }

    /**
     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),
     * reverting with custom message when dividing by zero.
     *
     * CAUTION: This function is deprecated because it requires allocating memory for the error
     * message unnecessarily. For custom revert reasons use {tryMod}.
     *
     * Counterpart to Solidity's `%` operator. This function uses a `revert`
     * opcode (which leaves remaining gas untouched) while Solidity uses an
     * invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     *
     * - The divisor cannot be zero.
     */
    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
        require(b &gt; 0, errorMessage);
        return a % b;
    }
}

// File: @openzeppelin/contracts/utils/Address.sol



pragma solidity &gt;=0.6.2 &lt;0.8.0;

/**
 * @dev Collection of functions related to the address type
 */
library Address {
    /**
     * @dev Returns true if `account` is a contract.
     *
     * [IMPORTANT]
     * ====
     * It is unsafe to assume that an address for which this function returns
     * false is an externally-owned account (EOA) and not a contract.
     *
     * Among others, `isContract` will return false for the following
     * types of addresses:
     *
     *  - an externally-owned account
     *  - a contract in construction
     *  - an address where a contract will be created
     *  - an address where a contract lived, but was destroyed
     * ====
     */
    function isContract(address account) internal view returns (bool) {
        // This method relies on extcodesize, which returns 0 for contracts in
        // construction, since the code is only stored at the end of the
        // constructor execution.

        uint256 size;
        // solhint-disable-next-line no-inline-assembly
        assembly { size := extcodesize(account) }
        return size &gt; 0;
    }

    /**
     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to
     * `recipient`, forwarding all available gas and reverting on errors.
     *
     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost
     * of certain opcodes, possibly making contracts go over the 2300 gas limit
     * imposed by `transfer`, making them unable to receive funds via
     * `transfer`. {sendValue} removes this limitation.
     *
     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].
     *
     * IMPORTANT: because control is transferred to `recipient`, care must be
     * taken to not create reentrancy vulnerabilities. Consider using
     * {ReentrancyGuard} or the
     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].
     */
    function sendValue(address payable recipient, uint256 amount) internal {
        require(address(this).balance &gt;= amount, "Address: insufficient balance");

        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value
        (bool success, ) = recipient.call{ value: amount }("");
        require(success, "Address: unable to send value, recipient may have reverted");
    }

    /**
     * @dev Performs a Solidity function call using a low level `call`. A
     * plain`call` is an unsafe replacement for a function call: use this
     * function instead.
     *
     * If `target` reverts with a revert reason, it is bubbled up by this
     * function (like regular Solidity function calls).
     *
     * Returns the raw returned data. To convert to the expected return value,
     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].
     *
     * Requirements:
     *
     * - `target` must be a contract.
     * - calling `target` with `data` must not revert.
     *
     * _Available since v3.1._
     */
    function functionCall(address target, bytes memory data) internal returns (bytes memory) {
      return functionCall(target, data, "Address: low-level call failed");
    }

    /**
     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with
     * `errorMessage` as a fallback revert reason when `target` reverts.
     *
     * _Available since v3.1._
     */
    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {
        return functionCallWithValue(target, data, 0, errorMessage);
    }

    /**
     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],
     * but also transferring `value` wei to `target`.
     *
     * Requirements:
     *
     * - the calling contract must have an ETH balance of at least `value`.
     * - the called Solidity function must be `payable`.
     *
     * _Available since v3.1._
     */
    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {
        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");
    }

    /**
     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but
     * with `errorMessage` as a fallback revert reason when `target` reverts.
     *
     * _Available since v3.1._
     */
    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {
        require(address(this).balance &gt;= value, "Address: insufficient balance for call");
        require(isContract(target), "Address: call to non-contract");

        // solhint-disable-next-line avoid-low-level-calls
        (bool success, bytes memory returndata) = target.call{ value: value }(data);
        return _verifyCallResult(success, returndata, errorMessage);
    }

    /**
     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],
     * but performing a static call.
     *
     * _Available since v3.3._
     */
    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {
        return functionStaticCall(target, data, "Address: low-level static call failed");
    }

    /**
     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],
     * but performing a static call.
     *
     * _Available since v3.3._
     */
    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {
        require(isContract(target), "Address: static call to non-contract");

        // solhint-disable-next-line avoid-low-level-calls
        (bool success, bytes memory returndata) = target.staticcall(data);
        return _verifyCallResult(success, returndata, errorMessage);
    }

    /**
     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],
     * but performing a delegate call.
     *
     * _Available since v3.4._
     */
    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {
        return functionDelegateCall(target, data, "Address: low-level delegate call failed");
    }

    /**
     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],
     * but performing a delegate call.
     *
     * _Available since v3.4._
     */
    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {
        require(isContract(target), "Address: delegate call to non-contract");

        // solhint-disable-next-line avoid-low-level-calls
        (bool success, bytes memory returndata) = target.delegatecall(data);
        return _verifyCallResult(success, returndata, errorMessage);
    }

    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {
        if (success) {
            return returndata;
        } else {
            // Look for revert reason and bubble it up if present
            if (returndata.length &gt; 0) {
                // The easiest way to bubble the revert reason is using memory via assembly

                // solhint-disable-next-line no-inline-assembly
                assembly {
                    let returndata_size := mload(returndata)
                    revert(add(32, returndata), returndata_size)
                }
            } else {
                revert(errorMessage);
            }
        }
    }
}

// File: @openzeppelin/contracts/token/ERC20/SafeERC20.sol



pragma solidity &gt;=0.6.0 &lt;0.8.0;




/**
 * @title SafeERC20
 * @dev Wrappers around ERC20 operations that throw on failure (when the token
 * contract returns false). Tokens that return no value (and instead revert or
 * throw on failure) are also supported, non-reverting calls are assumed to be
 * successful.
 * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,
 * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.
 */
library SafeERC20 {
    using SafeMath for uint256;
    using Address for address;

    function safeTransfer(IERC20 token, address to, uint256 value) internal {
        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));
    }

    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {
        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));
    }

    /**
     * @dev Deprecated. This function has issues similar to the ones found in
     * {IERC20-approve}, and its usage is discouraged.
     *
     * Whenever possible, use {safeIncreaseAllowance} and
     * {safeDecreaseAllowance} instead.
     */
    function safeApprove(IERC20 token, address spender, uint256 value) internal {
        // safeApprove should only be called when setting an initial allowance,
        // or when resetting it to zero. To increase and decrease it, use
        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'
        // solhint-disable-next-line max-line-length
        require((value == 0) || (token.allowance(address(this), spender) == 0),
            "SafeERC20: approve from non-zero to non-zero allowance"
        );
        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));
    }

    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {
        uint256 newAllowance = token.allowance(address(this), spender).add(value);
        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));
    }

    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {
        uint256 newAllowance = token.allowance(address(this), spender).sub(value, "SafeERC20: decreased allowance below zero");
        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));
    }

    /**
     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement
     * on the return value: the return value is optional (but if data is returned, it must not be false).
     * @param token The token targeted by the call.
     * @param data The call data (encoded using abi.encode or one of its variants).
     */
    function _callOptionalReturn(IERC20 token, bytes memory data) private {
        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since
        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that
        // the target address contains contract code and also asserts for success in the low-level call.

        bytes memory returndata = address(token).functionCall(data, "SafeERC20: low-level call failed");
        if (returndata.length &gt; 0) { // Return data is optional
            // solhint-disable-next-line max-line-length
            require(abi.decode(returndata, (bool)), "SafeERC20: ERC20 operation did not succeed");
        }
    }
}

// File: @openzeppelin/contracts/utils/Context.sol



pragma solidity &gt;=0.6.0 &lt;0.8.0;

/*
 * @dev Provides information about the current execution context, including the
 * sender of the transaction and its data. While these are generally available
 * via msg.sender and msg.data, they should not be accessed in such a direct
 * manner, since when dealing with GSN meta-transactions the account sending and
 * paying for execution may not be the actual sender (as far as an application
 * is concerned).
 *
 * This contract is only required for intermediate, library-like contracts.
 */
abstract contract Context {
    function _msgSender() internal view virtual returns (address payable) {
        return msg.sender;
    }

    function _msgData() internal view virtual returns (bytes memory) {
        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691
        return msg.data;
    }
}

// File: @openzeppelin/contracts/access/Ownable.sol



pragma solidity &gt;=0.6.0 &lt;0.8.0;

/**
 * @dev Contract module which provides a basic access control mechanism, where
 * there is an account (an owner) that can be granted exclusive access to
 * specific functions.
 *
 * By default, the owner account will be the one that deploys the contract. This
 * can later be changed with {transferOwnership}.
 *
 * This module is used through inheritance. It will make available the modifier
 * `onlyOwner`, which can be applied to your functions to restrict their use to
 * the owner.
 */
abstract contract Ownable is Context {
    address private _owner;

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    /**
     * @dev Initializes the contract setting the deployer as the initial owner.
     */
    constructor () internal {
        address msgSender = _msgSender();
        _owner = msgSender;
        emit OwnershipTransferred(address(0), msgSender);
    }

    /**
     * @dev Returns the address of the current owner.
     */
    function owner() public view virtual returns (address) {
        return _owner;
    }

    /**
     * @dev Throws if called by any account other than the owner.
     */
    modifier onlyOwner() {
        require(owner() == _msgSender(), "Ownable: caller is not the owner");
        _;
    }

    /**
     * @dev Leaves the contract without owner. It will not be possible to call
     * `onlyOwner` functions anymore. Can only be called by the current owner.
     *
     * NOTE: Renouncing ownership will leave the contract without an owner,
     * thereby removing any functionality that is only available to the owner.
     */
    function renounceOwnership() public virtual onlyOwner {
        emit OwnershipTransferred(_owner, address(0));
        _owner = address(0);
    }

    /**
     * @dev Transfers ownership of the contract to a new account (`newOwner`).
     * Can only be called by the current owner.
     */
    function transferOwnership(address newOwner) public virtual onlyOwner {
        require(newOwner != address(0), "Ownable: new owner is the zero address");
        emit OwnershipTransferred(_owner, newOwner);
        _owner = newOwner;
    }
}

// File: @uniswap/lib/contracts/libraries/FullMath.sol

pragma solidity &gt;=0.4.0;

// taken from https://medium.com/coinmonks/math-in-solidity-part-3-percents-and-proportions-4db014e080b1
// license is CC-BY-4.0
library FullMath {
    function fullMul(uint256 x, uint256 y) internal pure returns (uint256 l, uint256 h) {
        uint256 mm = mulmod(x, y, uint256(-1));
        l = x * y;
        h = mm - l;
        if (mm &lt; l) h -= 1;
    }

    function fullDiv(
        uint256 l,
        uint256 h,
        uint256 d
    ) private pure returns (uint256) {
        uint256 pow2 = d &amp; -d;
        d /= pow2;
        l /= pow2;
        l += h * ((-pow2) / pow2 + 1);
        uint256 r = 1;
        r *= 2 - d * r;
        r *= 2 - d * r;
        r *= 2 - d * r;
        r *= 2 - d * r;
        r *= 2 - d * r;
        r *= 2 - d * r;
        r *= 2 - d * r;
        r *= 2 - d * r;
        return l * r;
    }

    function mulDiv(
        uint256 x,
        uint256 y,
        uint256 d
    ) internal pure returns (uint256) {
        (uint256 l, uint256 h) = fullMul(x, y);

        uint256 mm = mulmod(x, y, d);
        if (mm &gt; l) h -= 1;
        l -= mm;

        if (h == 0) return l / d;

        require(h &lt; d, 'FullMath: FULLDIV_OVERFLOW');
        return fullDiv(l, h, d);
    }
}

// File: @uniswap/lib/contracts/libraries/Babylonian.sol


pragma solidity &gt;=0.4.0;

// computes square roots using the babylonian method
// https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method
library Babylonian {
    // credit for this implementation goes to
    // https://github.com/abdk-consulting/abdk-libraries-solidity/blob/master/ABDKMath64x64.sol#L687
    function sqrt(uint256 x) internal pure returns (uint256) {
        if (x == 0) return 0;
        // this block is equivalent to r = uint256(1) &lt;&lt; (BitMath.mostSignificantBit(x) / 2);
        // however that code costs significantly more gas
        uint256 xx = x;
        uint256 r = 1;
        if (xx &gt;= 0x100000000000000000000000000000000) {
            xx &gt;&gt;= 128;
            r &lt;&lt;= 64;
        }
        if (xx &gt;= 0x10000000000000000) {
            xx &gt;&gt;= 64;
            r &lt;&lt;= 32;
        }
        if (xx &gt;= 0x100000000) {
            xx &gt;&gt;= 32;
            r &lt;&lt;= 16;
        }
        if (xx &gt;= 0x10000) {
            xx &gt;&gt;= 16;
            r &lt;&lt;= 8;
        }
        if (xx &gt;= 0x100) {
            xx &gt;&gt;= 8;
            r &lt;&lt;= 4;
        }
        if (xx &gt;= 0x10) {
            xx &gt;&gt;= 4;
            r &lt;&lt;= 2;
        }
        if (xx &gt;= 0x8) {
            r &lt;&lt;= 1;
        }
        r = (r + x / r) &gt;&gt; 1;
        r = (r + x / r) &gt;&gt; 1;
        r = (r + x / r) &gt;&gt; 1;
        r = (r + x / r) &gt;&gt; 1;
        r = (r + x / r) &gt;&gt; 1;
        r = (r + x / r) &gt;&gt; 1;
        r = (r + x / r) &gt;&gt; 1; // Seven iterations should be enough
        uint256 r1 = x / r;
        return (r &lt; r1 ? r : r1);
    }
}

// File: @uniswap/lib/contracts/libraries/BitMath.sol

pragma solidity &gt;=0.5.0;

library BitMath {
    // returns the 0 indexed position of the most significant bit of the input x
    // s.t. x &gt;= 2**msb and x &lt; 2**(msb+1)
    function mostSignificantBit(uint256 x) internal pure returns (uint8 r) {
        require(x &gt; 0, 'BitMath::mostSignificantBit: zero');

        if (x &gt;= 0x100000000000000000000000000000000) {
            x &gt;&gt;= 128;
            r += 128;
        }
        if (x &gt;= 0x10000000000000000) {
            x &gt;&gt;= 64;
            r += 64;
        }
        if (x &gt;= 0x100000000) {
            x &gt;&gt;= 32;
            r += 32;
        }
        if (x &gt;= 0x10000) {
            x &gt;&gt;= 16;
            r += 16;
        }
        if (x &gt;= 0x100) {
            x &gt;&gt;= 8;
            r += 8;
        }
        if (x &gt;= 0x10) {
            x &gt;&gt;= 4;
            r += 4;
        }
        if (x &gt;= 0x4) {
            x &gt;&gt;= 2;
            r += 2;
        }
        if (x &gt;= 0x2) r += 1;
    }

    // returns the 0 indexed position of the least significant bit of the input x
    // s.t. (x &amp; 2**lsb) != 0 and (x &amp; (2**(lsb) - 1)) == 0)
    // i.e. the bit at the index is set and the mask of all lower bits is 0
    function leastSignificantBit(uint256 x) internal pure returns (uint8 r) {
        require(x &gt; 0, 'BitMath::leastSignificantBit: zero');

        r = 255;
        if (x &amp; uint128(-1) &gt; 0) {
            r -= 128;
        } else {
            x &gt;&gt;= 128;
        }
        if (x &amp; uint64(-1) &gt; 0) {
            r -= 64;
        } else {
            x &gt;&gt;= 64;
        }
        if (x &amp; uint32(-1) &gt; 0) {
            r -= 32;
        } else {
            x &gt;&gt;= 32;
        }
        if (x &amp; uint16(-1) &gt; 0) {
            r -= 16;
        } else {
            x &gt;&gt;= 16;
        }
        if (x &amp; uint8(-1) &gt; 0) {
            r -= 8;
        } else {
            x &gt;&gt;= 8;
        }
        if (x &amp; 0xf &gt; 0) {
            r -= 4;
        } else {
            x &gt;&gt;= 4;
        }
        if (x &amp; 0x3 &gt; 0) {
            r -= 2;
        } else {
            x &gt;&gt;= 2;
        }
        if (x &amp; 0x1 &gt; 0) r -= 1;
    }
}

// File: @uniswap/lib/contracts/libraries/FixedPoint.sol

pragma solidity &gt;=0.4.0;




// a library for handling binary fixed point numbers (https://en.wikipedia.org/wiki/Q_(number_format))
library FixedPoint {
    // range: [0, 2**112 - 1]
    // resolution: 1 / 2**112
    struct uq112x112 {
        uint224 _x;
    }

    // range: [0, 2**144 - 1]
    // resolution: 1 / 2**112
    struct uq144x112 {
        uint256 _x;
    }

    uint8 public constant RESOLUTION = 112;
    uint256 public constant Q112 = 0x10000000000000000000000000000; // 2**112
    uint256 private constant Q224 = 0x100000000000000000000000000000000000000000000000000000000; // 2**224
    uint256 private constant LOWER_MASK = 0xffffffffffffffffffffffffffff; // decimal of UQ*x112 (lower 112 bits)

    // encode a uint112 as a UQ112x112
    function encode(uint112 x) internal pure returns (uq112x112 memory) {
        return uq112x112(uint224(x) &lt;&lt; RESOLUTION);
    }

    // encodes a uint144 as a UQ144x112
    function encode144(uint144 x) internal pure returns (uq144x112 memory) {
        return uq144x112(uint256(x) &lt;&lt; RESOLUTION);
    }

    // decode a UQ112x112 into a uint112 by truncating after the radix point
    function decode(uq112x112 memory self) internal pure returns (uint112) {
        return uint112(self._x &gt;&gt; RESOLUTION);
    }

    // decode a UQ144x112 into a uint144 by truncating after the radix point
    function decode144(uq144x112 memory self) internal pure returns (uint144) {
        return uint144(self._x &gt;&gt; RESOLUTION);
    }

    // multiply a UQ112x112 by a uint, returning a UQ144x112
    // reverts on overflow
    function mul(uq112x112 memory self, uint256 y) internal pure returns (uq144x112 memory) {
        uint256 z = 0;
        require(y == 0 || (z = self._x * y) / y == self._x, 'FixedPoint::mul: overflow');
        return uq144x112(z);
    }

    // multiply a UQ112x112 by an int and decode, returning an int
    // reverts on overflow
    function muli(uq112x112 memory self, int256 y) internal pure returns (int256) {
        uint256 z = FullMath.mulDiv(self._x, uint256(y &lt; 0 ? -y : y), Q112);
        require(z &lt; 2**255, 'FixedPoint::muli: overflow');
        return y &lt; 0 ? -int256(z) : int256(z);
    }

    // multiply a UQ112x112 by a UQ112x112, returning a UQ112x112
    // lossy
    function muluq(uq112x112 memory self, uq112x112 memory other) internal pure returns (uq112x112 memory) {
        if (self._x == 0 || other._x == 0) {
            return uq112x112(0);
        }
        uint112 upper_self = uint112(self._x &gt;&gt; RESOLUTION); // * 2^0
        uint112 lower_self = uint112(self._x &amp; LOWER_MASK); // * 2^-112
        uint112 upper_other = uint112(other._x &gt;&gt; RESOLUTION); // * 2^0
        uint112 lower_other = uint112(other._x &amp; LOWER_MASK); // * 2^-112

        // partial products
        uint224 upper = uint224(upper_self) * upper_other; // * 2^0
        uint224 lower = uint224(lower_self) * lower_other; // * 2^-224
        uint224 uppers_lowero = uint224(upper_self) * lower_other; // * 2^-112
        uint224 uppero_lowers = uint224(upper_other) * lower_self; // * 2^-112

        // so the bit shift does not overflow
        require(upper &lt;= uint112(-1), 'FixedPoint::muluq: upper overflow');

        // this cannot exceed 256 bits, all values are 224 bits
        uint256 sum = uint256(upper &lt;&lt; RESOLUTION) + uppers_lowero + uppero_lowers + (lower &gt;&gt; RESOLUTION);

        // so the cast does not overflow
        require(sum &lt;= uint224(-1), 'FixedPoint::muluq: sum overflow');

        return uq112x112(uint224(sum));
    }

    // divide a UQ112x112 by a UQ112x112, returning a UQ112x112
    function divuq(uq112x112 memory self, uq112x112 memory other) internal pure returns (uq112x112 memory) {
        require(other._x &gt; 0, 'FixedPoint::divuq: division by zero');
        if (self._x == other._x) {
            return uq112x112(uint224(Q112));
        }
        if (self._x &lt;= uint144(-1)) {
            uint256 value = (uint256(self._x) &lt;&lt; RESOLUTION) / other._x;
            require(value &lt;= uint224(-1), 'FixedPoint::divuq: overflow');
            return uq112x112(uint224(value));
        }

        uint256 result = FullMath.mulDiv(Q112, self._x, other._x);
        require(result &lt;= uint224(-1), 'FixedPoint::divuq: overflow');
        return uq112x112(uint224(result));
    }

    // returns a UQ112x112 which represents the ratio of the numerator to the denominator
    // can be lossy
    function fraction(uint256 numerator, uint256 denominator) internal pure returns (uq112x112 memory) {
        require(denominator &gt; 0, 'FixedPoint::fraction: division by zero');
        if (numerator == 0) return FixedPoint.uq112x112(0);

        if (numerator &lt;= uint144(-1)) {
            uint256 result = (numerator &lt;&lt; RESOLUTION) / denominator;
            require(result &lt;= uint224(-1), 'FixedPoint::fraction: overflow');
            return uq112x112(uint224(result));
        } else {
            uint256 result = FullMath.mulDiv(numerator, Q112, denominator);
            require(result &lt;= uint224(-1), 'FixedPoint::fraction: overflow');
            return uq112x112(uint224(result));
        }
    }

    // take the reciprocal of a UQ112x112
    // reverts on overflow
    // lossy
    function reciprocal(uq112x112 memory self) internal pure returns (uq112x112 memory) {
        require(self._x != 0, 'FixedPoint::reciprocal: reciprocal of zero');
        require(self._x != 1, 'FixedPoint::reciprocal: overflow');
        return uq112x112(uint224(Q224 / self._x));
    }

    // square root of a UQ112x112
    // lossy between 0/1 and 40 bits
    function sqrt(uq112x112 memory self) internal pure returns (uq112x112 memory) {
        if (self._x &lt;= uint144(-1)) {
            return uq112x112(uint224(Babylonian.sqrt(uint256(self._x) &lt;&lt; 112)));
        }

        uint8 safeShiftBits = 255 - BitMath.mostSignificantBit(self._x);
        safeShiftBits -= safeShiftBits % 2;
        return uq112x112(uint224(Babylonian.sqrt(uint256(self._x) &lt;&lt; safeShiftBits) &lt;&lt; ((112 - safeShiftBits) / 2)));
    }
}

// File: @uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol

pragma solidity &gt;=0.5.0;

interface IUniswapV2Pair {
    event Approval(address indexed owner, address indexed spender, uint value);
    event Transfer(address indexed from, address indexed to, uint value);

    function name() external pure returns (string memory);
    function symbol() external pure returns (string memory);
    function decimals() external pure returns (uint8);
    function totalSupply() external view returns (uint);
    function balanceOf(address owner) external view returns (uint);
    function allowance(address owner, address spender) external view returns (uint);

    function approve(address spender, uint value) external returns (bool);
    function transfer(address to, uint value) external returns (bool);
    function transferFrom(address from, address to, uint value) external returns (bool);

    function DOMAIN_SEPARATOR() external view returns (bytes32);
    function PERMIT_TYPEHASH() external pure returns (bytes32);
    function nonces(address owner) external view returns (uint);

    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;

    event Mint(address indexed sender, uint amount0, uint amount1);
    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);
    event Swap(
        address indexed sender,
        uint amount0In,
        uint amount1In,
        uint amount0Out,
        uint amount1Out,
        address indexed to
    );
    event Sync(uint112 reserve0, uint112 reserve1);

    function MINIMUM_LIQUIDITY() external pure returns (uint);
    function factory() external view returns (address);
    function token0() external view returns (address);
    function token1() external view returns (address);
    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);
    function price0CumulativeLast() external view returns (uint);
    function price1CumulativeLast() external view returns (uint);
    function kLast() external view returns (uint);

    function mint(address to) external returns (uint liquidity);
    function burn(address to) external returns (uint amount0, uint amount1);
    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;
    function skim(address to) external;
    function sync() external;

    function initialize(address, address) external;
}

// File: @uniswap/v2-periphery/contracts/libraries/UniswapV2OracleLibrary.sol

pragma solidity &gt;=0.5.0;



// library with helper methods for oracles that are concerned with computing average prices
library UniswapV2OracleLibrary {
    using FixedPoint for *;

    // helper function that returns the current block timestamp within the range of uint32, i.e. [0, 2**32 - 1]
    function currentBlockTimestamp() internal view returns (uint32) {
        return uint32(block.timestamp % 2 ** 32);
    }

    // produces the cumulative price using counterfactuals to save gas and avoid a call to sync.
    function currentCumulativePrices(
        address pair
    ) internal view returns (uint price0Cumulative, uint price1Cumulative, uint32 blockTimestamp) {
        blockTimestamp = currentBlockTimestamp();
        price0Cumulative = IUniswapV2Pair(pair).price0CumulativeLast();
        price1Cumulative = IUniswapV2Pair(pair).price1CumulativeLast();

        // if time has elapsed since the last update on the pair, mock the accumulated price values
        (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast) = IUniswapV2Pair(pair).getReserves();
        if (blockTimestampLast != blockTimestamp) {
            // subtraction overflow is desired
            uint32 timeElapsed = blockTimestamp - blockTimestampLast;
            // addition overflow is desired
            // counterfactual
            price0Cumulative += uint(FixedPoint.fraction(reserve1, reserve0)._x) * timeElapsed;
            // counterfactual
            price1Cumulative += uint(FixedPoint.fraction(reserve0, reserve1)._x) * timeElapsed;
        }
    }
}

// File: interfaces/IInvitation.sol

pragma solidity 0.6.12;

interface IInvitation{

    function acceptInvitation(address _invitor) external;

    function getInvitation(address _sender) external view returns(address _invitor, address[] memory _invitees, bool _isWithdrawn);
    
}

// File: contracts/ActivityBase.sol


pragma solidity 0.6.12;



contract ActivityBase is Ownable{
    using SafeMath for uint256;

    address public admin;
    
    address public marketingFund;
    // token as the unit of measurement
    address public WETHToken;
    // invitee's supply 5% deposit weight to its invitor
    uint256 public constant INVITEE_WEIGHT = 20; 
    // invitee's supply 10% deposit weight to its invitor
    uint256 public constant INVITOR_WEIGHT = 10;

    // The block number when SHARD mining starts.
    uint256 public startBlock;

    // dev fund
    uint256 public userDividendWeight;
    uint256 public devDividendWeight;
    address public developerDAOFund;

    // deposit limit
    uint256 public amountFeeRateNumerator;
    uint256 public amountfeeRateDenominator;

    // contract sender fee rate
    uint256 public contractFeeRateNumerator;
    uint256 public contractFeeRateDenominator;

    // Info of each user is Contract sender
    mapping (uint256 =&gt; mapping (address =&gt; bool)) <span class="marker" id="mapping-1"></span><span class="token del" data-title="visibility/public">public</span> isUserContractSender;
    mapping (uint256 =&gt; uint256) public poolTokenAmountLimit;

    function setDividendWeight(uint256 _userDividendWeight, uint256 _devDividendWeight) external virtual{
        checkAdmin();
        require(
            _userDividendWeight != 0 &amp;&amp; _devDividendWeight != 0,
            "invalid input"
        );
        userDividendWeight = _userDividendWeight;
        devDividendWeight = _devDividendWeight;
    }

    function setDeveloperDAOFund(address _developerDAOFund) external virtual onlyOwner {
        developerDAOFund = _developerDAOFund;
    }

    function setTokenAmountLimit(uint256 _pid, uint256 _tokenAmountLimit) external virtual {
        checkAdmin();
        poolTokenAmountLimit[_pid] = _tokenAmountLimit;
    }

    function setTokenAmountLimitFeeRate(uint256 _feeRateNumerator, uint256 _feeRateDenominator) external virtual {
        checkAdmin();
        require(
            _feeRateDenominator &gt;= _feeRateNumerator, "invalid input"
        );
        amountFeeRateNumerator = _feeRateNumerator;
        amountfeeRateDenominator = _feeRateDenominator;
    }

    function setContracSenderFeeRate(uint256 _feeRateNumerator, uint256 _feeRateDenominator) external virtual {
        checkAdmin();
        require(
            _feeRateDenominator &gt;= _feeRateNumerator, "invalid input"
        );
        contractFeeRateNumerator = _feeRateNumerator;
        contractFeeRateDenominator = _feeRateDenominator;
    }

    function setStartBlock(uint256 _startBlock) external virtual onlyOwner { 
        require(startBlock &gt; block.number, "invalid start block");
        startBlock = _startBlock;
        updateAfterModifyStartBlock(_startBlock);
    }

    function transferAdmin(address _admin) external virtual {
        checkAdmin();
        admin = _admin;
    }

    function setMarketingFund(address _marketingFund) external virtual onlyOwner {
        marketingFund = _marketingFund;
    }

    function updateAfterModifyStartBlock(uint256 _newStartBlock) internal virtual{
    }

    function calculateDividend(uint256 _pending, uint256 _pid, uint256 _userAmount, bool _isContractSender) internal view returns (uint256 _marketingFundDividend, uint256 _devDividend, uint256 _userDividend){
        uint256 fee = 0;
        if(_isContractSender &amp;&amp; contractFeeRateDenominator &gt; 0){
            fee = _pending.mul(contractFeeRateNumerator).div(contractFeeRateDenominator);
            _marketingFundDividend = _marketingFundDividend.add(fee);
            _pending = _pending.sub(fee);
        }
        if(poolTokenAmountLimit[_pid] &gt; 0 &amp;&amp; amountfeeRateDenominator &gt; 0 &amp;&amp; _userAmount &gt;= poolTokenAmountLimit[_pid]){
            fee = _pending.mul(amountFeeRateNumerator).div(amountfeeRateDenominator);
            _marketingFundDividend =_marketingFundDividend.add(fee);
            _pending = _pending.sub(fee);
        }
        <span class="marker" id="mapping-2"></span><span class="token mv" id="move-src-1" data-title="function_body/if_statement">if(devDividendWeight &gt; 0){
            fee = _pending.mul(devDividendWeight).div(devDividendWeight.add(userDividendWeight));
            _devDividend = _devDividend.add(fee);
            _pending = _pending.sub(fee);
        }</span>
        _userDividend = _pending;
    }

    function judgeContractSender(uint256 _pid) internal {
        if(msg.sender != tx.origin){
            isUserContractSender[_pid][msg.sender] = true;
        }
    }

    function checkAdmin() internal view {
        require(admin == msg.sender, "invalid authorized");
    }
}

// File: @openzeppelin/contracts/GSN/Context.sol



pragma solidity &gt;=0.6.0 &lt;0.8.0;

// File: @openzeppelin/contracts/token/ERC20/ERC20.sol



pragma solidity &gt;=0.6.0 &lt;0.8.0;




/**
 * @dev Implementation of the {IERC20} interface.
 *
 * This implementation is agnostic to the way tokens are created. This means
 * that a supply mechanism has to be added in a derived contract using {_mint}.
 * For a generic mechanism see {ERC20PresetMinterPauser}.
 *
 * TIP: For a detailed writeup see our guide
 * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How
 * to implement supply mechanisms].
 *
 * We have followed general OpenZeppelin guidelines: functions revert instead
 * of returning `false` on failure. This behavior is nonetheless conventional
 * and does not conflict with the expectations of ERC20 applications.
 *
 * Additionally, an {Approval} event is emitted on calls to {transferFrom}.
 * This allows applications to reconstruct the allowance for all accounts just
 * by listening to said events. Other implementations of the EIP may not emit
 * these events, as it isn't required by the specification.
 *
 * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}
 * functions have been added to mitigate the well-known issues around setting
 * allowances. See {IERC20-approve}.
 */
contract ERC20 is Context, IERC20 {
    using SafeMath for uint256;

    mapping (address =&gt; uint256) private _balances;

    mapping (address =&gt; mapping (address =&gt; uint256)) private _allowances;

    uint256 private _totalSupply;

    string private _name;
    string private _symbol;
    uint8 private _decimals;

    /**
     * @dev Sets the values for {name} and {symbol}, initializes {decimals} with
     * a default value of 18.
     *
     * To select a different value for {decimals}, use {_setupDecimals}.
     *
     * All three of these values are immutable: they can only be set once during
     * construction.
     */
    constructor (string memory name_, string memory symbol_) public {
        _name = name_;
        _symbol = symbol_;
        _decimals = 18;
    }

    /**
     * @dev Returns the name of the token.
     */
    function name() public view virtual returns (string memory) {
        return _name;
    }

    /**
     * @dev Returns the symbol of the token, usually a shorter version of the
     * name.
     */
    function symbol() public view virtual returns (string memory) {
        return _symbol;
    }

    /**
     * @dev Returns the number of decimals used to get its user representation.
     * For example, if `decimals` equals `2`, a balance of `505` tokens should
     * be displayed to a user as `5,05` (`505 / 10 ** 2`).
     *
     * Tokens usually opt for a value of 18, imitating the relationship between
     * Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is
     * called.
     *
     * NOTE: This information is only used for _display_ purposes: it in
     * no way affects any of the arithmetic of the contract, including
     * {IERC20-balanceOf} and {IERC20-transfer}.
     */
    function decimals() public view virtual returns (uint8) {
        return _decimals;
    }

    /**
     * @dev See {IERC20-totalSupply}.
     */
    function totalSupply() public view virtual override returns (uint256) {
        return _totalSupply;
    }

    /**
     * @dev See {IERC20-balanceOf}.
     */
    function balanceOf(address account) public view virtual override returns (uint256) {
        return _balances[account];
    }

    /**
     * @dev See {IERC20-transfer}.
     *
     * Requirements:
     *
     * - `recipient` cannot be the zero address.
     * - the caller must have a balance of at least `amount`.
     */
    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {
        _transfer(_msgSender(), recipient, amount);
        return true;
    }

    /**
     * @dev See {IERC20-allowance}.
     */
    function allowance(address owner, address spender) public view virtual override returns (uint256) {
        return _allowances[owner][spender];
    }

    /**
     * @dev See {IERC20-approve}.
     *
     * Requirements:
     *
     * - `spender` cannot be the zero address.
     */
    function approve(address spender, uint256 amount) public virtual override returns (bool) {
        _approve(_msgSender(), spender, amount);
        return true;
    }

    /**
     * @dev See {IERC20-transferFrom}.
     *
     * Emits an {Approval} event indicating the updated allowance. This is not
     * required by the EIP. See the note at the beginning of {ERC20}.
     *
     * Requirements:
     *
     * - `sender` and `recipient` cannot be the zero address.
     * - `sender` must have a balance of at least `amount`.
     * - the caller must have allowance for ``sender``'s tokens of at least
     * `amount`.
     */
    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {
        _transfer(sender, recipient, amount);
        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, "ERC20: transfer amount exceeds allowance"));
        return true;
    }

    /**
     * @dev Atomically increases the allowance granted to `spender` by the caller.
     *
     * This is an alternative to {approve} that can be used as a mitigation for
     * problems described in {IERC20-approve}.
     *
     * Emits an {Approval} event indicating the updated allowance.
     *
     * Requirements:
     *
     * - `spender` cannot be the zero address.
     */
    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {
        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));
        return true;
    }

    /**
     * @dev Atomically decreases the allowance granted to `spender` by the caller.
     *
     * This is an alternative to {approve} that can be used as a mitigation for
     * problems described in {IERC20-approve}.
     *
     * Emits an {Approval} event indicating the updated allowance.
     *
     * Requirements:
     *
     * - `spender` cannot be the zero address.
     * - `spender` must have allowance for the caller of at least
     * `subtractedValue`.
     */
    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {
        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, "ERC20: decreased allowance below zero"));
        return true;
    }

    /**
     * @dev Moves tokens `amount` from `sender` to `recipient`.
     *
     * This is internal function is equivalent to {transfer}, and can be used to
     * e.g. implement automatic token fees, slashing mechanisms, etc.
     *
     * Emits a {Transfer} event.
     *
     * Requirements:
     *
     * - `sender` cannot be the zero address.
     * - `recipient` cannot be the zero address.
     * - `sender` must have a balance of at least `amount`.
     */
    function _transfer(address sender, address recipient, uint256 amount) internal virtual {
        require(sender != address(0), "ERC20: transfer from the zero address");
        require(recipient != address(0), "ERC20: transfer to the zero address");

        _beforeTokenTransfer(sender, recipient, amount);

        _balances[sender] = _balances[sender].sub(amount, "ERC20: transfer amount exceeds balance");
        _balances[recipient] = _balances[recipient].add(amount);
        emit Transfer(sender, recipient, amount);
    }

    /** @dev Creates `amount` tokens and assigns them to `account`, increasing
     * the total supply.
     *
     * Emits a {Transfer} event with `from` set to the zero address.
     *
     * Requirements:
     *
     * - `to` cannot be the zero address.
     */
    function _mint(address account, uint256 amount) internal virtual {
        require(account != address(0), "ERC20: mint to the zero address");

        _beforeTokenTransfer(address(0), account, amount);

        _totalSupply = _totalSupply.add(amount);
        _balances[account] = _balances[account].add(amount);
        emit Transfer(address(0), account, amount);
    }

    /**
     * @dev Destroys `amount` tokens from `account`, reducing the
     * total supply.
     *
     * Emits a {Transfer} event with `to` set to the zero address.
     *
     * Requirements:
     *
     * - `account` cannot be the zero address.
     * - `account` must have at least `amount` tokens.
     */
    function _burn(address account, uint256 amount) internal virtual {
        require(account != address(0), "ERC20: burn from the zero address");

        _beforeTokenTransfer(account, address(0), amount);

        _balances[account] = _balances[account].sub(amount, "ERC20: burn amount exceeds balance");
        _totalSupply = _totalSupply.sub(amount);
        emit Transfer(account, address(0), amount);
    }

    /**
     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.
     *
     * This internal function is equivalent to `approve`, and can be used to
     * e.g. set automatic allowances for certain subsystems, etc.
     *
     * Emits an {Approval} event.
     *
     * Requirements:
     *
     * - `owner` cannot be the zero address.
     * - `spender` cannot be the zero address.
     */
    function _approve(address owner, address spender, uint256 amount) internal virtual {
        require(owner != address(0), "ERC20: approve from the zero address");
        require(spender != address(0), "ERC20: approve to the zero address");

        _allowances[owner][spender] = amount;
        emit Approval(owner, spender, amount);
    }

    /**
     * @dev Sets {decimals} to a value other than the default one of 18.
     *
     * WARNING: This function should only be called from the constructor. Most
     * applications that interact with token contracts will not expect
     * {decimals} to ever change, and may work incorrectly if it does.
     */
    function _setupDecimals(uint8 decimals_) internal virtual {
        _decimals = decimals_;
    }

    /**
     * @dev Hook that is called before any transfer of tokens. This includes
     * minting and burning.
     *
     * Calling conditions:
     *
     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens
     * will be to transferred to `to`.
     * - when `from` is zero, `amount` tokens will be minted for `to`.
     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.
     * - `from` and `to` are never both zero.
     *
     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].
     */
    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }
}

// File: contracts/SHDToken.sol


pragma solidity 0.6.12;






// SHDToken with Governance.
contract SHDToken is ERC20("ShardingDAO", "SHD"), Ownable {
    // cross chain
    mapping(address =&gt; bool) public minters;

    struct Checkpoint {
        uint256 fromBlock;
        uint256 votes;
    }
    /// @notice A record of votes checkpoints for each account, by index
    mapping(address =&gt; mapping(uint256 =&gt; Checkpoint)) public checkpoints;

    /// @notice The number of checkpoints for each account
    mapping(address =&gt; uint256) public numCheckpoints;
    event VotesBalanceChanged(
        address indexed user,
        uint256 previousBalance,
        uint256 newBalance
    );

    /// @notice Creates `_amount` token to `_to`. Must only be called by the owner (MasterChef).
    function mint(address _to, uint256 _amount) public {
        require(minters[msg.sender] == true, "SHD : You are not the miner");
        _mint(_to, _amount);
    }

    function burn(uint256 _amount) public {
        _burn(msg.sender, _amount);
    }

    function addMiner(address _miner) external onlyOwner {
        minters[_miner] = true;
    }

    function removeMiner(address _miner) external onlyOwner {
        minters[_miner] = false;
    }

    function getPriorVotes(address account, uint256 blockNumber)
        public
        view
        returns (uint256)
    {
        require(
            blockNumber &lt; block.number,
            "getPriorVotes: not yet determined"
        );

        uint256 nCheckpoints = numCheckpoints[account];
        if (nCheckpoints == 0) {
            return 0;
        }

        // First check most recent balance
        if (checkpoints[account][nCheckpoints - 1].fromBlock &lt;= blockNumber) {
            return checkpoints[account][nCheckpoints - 1].votes;
        }

        // Next check implicit zero balance
        if (checkpoints[account][0].fromBlock &gt; blockNumber) {
            return 0;
        }

        uint256 lower = 0;
        uint256 upper = nCheckpoints - 1;
        while (upper &gt; lower) {
            uint256 center = upper - (upper - lower) / 2; // ceil, avoiding overflow
            Checkpoint memory cp = checkpoints[account][center];
            if (cp.fromBlock == blockNumber) {
                return cp.votes;
            } else if (cp.fromBlock &lt; blockNumber) {
                lower = center;
            } else {
                upper = center - 1;
            }
        }
        return checkpoints[account][lower].votes;
    }

    function _voteTransfer(
        address from,
        address to,
        uint256 amount
    ) internal {
        if (from != to &amp;&amp; amount &gt; 0) {
            if (from != address(0)) {
                uint256 fromNum = numCheckpoints[from];
                uint256 fromOld =
                    fromNum &gt; 0 ? checkpoints[from][fromNum - 1].votes : 0;
                uint256 fromNew = fromOld.sub(amount);
                _writeCheckpoint(from, fromNum, fromOld, fromNew);
            }

            if (to != address(0)) {
                uint256 toNum = numCheckpoints[to];
                uint256 toOld =
                    toNum &gt; 0 ? checkpoints[to][toNum - 1].votes : 0;
                uint256 toNew = toOld.add(amount);
                _writeCheckpoint(to, toNum, toOld, toNew);
            }
        }
    }

    function _writeCheckpoint(
        address user,
        uint256 nCheckpoints,
        uint256 oldVotes,
        uint256 newVotes
    ) internal {
        uint256 blockNumber = block.number;
        if (
            nCheckpoints &gt; 0 &amp;&amp;
            checkpoints[user][nCheckpoints - 1].fromBlock == blockNumber
        ) {
            checkpoints[user][nCheckpoints - 1].votes = newVotes;
        } else {
            checkpoints[user][nCheckpoints] = Checkpoint(blockNumber, newVotes);
            numCheckpoints[user] = nCheckpoints + 1;
        }

        emit VotesBalanceChanged(user, oldVotes, newVotes);
    }

    function _beforeTokenTransfer(
        address from,
        address to,
        uint256 amount
    ) internal override {
        _voteTransfer(from, to, amount);
    }
}

// File: contracts/ShardingDAOMining.sol


pragma solidity 0.6.12;











contract ShardingDAOMining is IInvitation, ActivityBase {
    using SafeMath for uint256;
    using SafeERC20 for IERC20; 
    using FixedPoint for *;

    // Info of each user.
    struct UserInfo {
        uint256 amount; // How much LP token the user has provided.
        uint256 originWeight; //initial weight
        uint256 inviteeWeight; // invitees' weight
        uint256 endBlock;
        bool isCalculateInvitation;
    }

    // Info of each pool.
    struct PoolInfo {
        uint256 nftPoolId;
        address lpTokenSwap; // uniswapPair contract address
        uint256 accumulativeDividend;
        uint256 usersTotalWeight; // user's sum weight
        uint256 lpTokenAmount; // lock amount
        uint256 oracleWeight; // eth value
        uint256 lastDividendHeight; // last dividend block height
        TokenPairInfo tokenToEthPairInfo;
        bool isFirstTokenShard;
    }

    struct TokenPairInfo{
        IUniswapV2Pair tokenToEthSwap; 
        FixedPoint.uq112x112 price; 
        bool isFirstTokenEth;
        uint256 priceCumulativeLast;
        uint32  blockTimestampLast;
        uint256 lastPriceUpdateHeight;
    }

    struct InvitationInfo {
        address invitor;
        address[] invitees;
        bool isUsed;
        bool isWithdrawn;
        mapping(address =&gt; uint256) inviteeIndexMap;
    }

    // black list
    struct EvilPoolInfo {
        uint256 pid;
        string description;
    }

    // The SHD TOKEN!
    SHDToken public SHD;
    // Info of each pool.
    uint256[] <span class="marker" id="mapping-3"></span><span class="token del" data-title="visibility/public">public</span> rankPoolIndex;
    // indicates whether the pool is in the rank
    mapping(uint256 =&gt; uint256) <span class="marker" id="mapping-4"></span><span class="token del" data-title="visibility/public">public</span> rankPoolIndexMap;
    // relationship info about invitation
    mapping(address =&gt; InvitationInfo) <span class="marker" id="mapping-5"></span><span class="token del" data-title="visibility/public">public</span> usersRelationshipInfo;
    // Info of each user that stakes LP tokens.
    mapping(uint256 =&gt; mapping(address =&gt; UserInfo)) <span class="marker" id="mapping-6"></span><span class="token del" data-title="visibility/public">public</span> userInfo;
    // Info of each pool.
    PoolInfo[] private poolInfo;
    // Total allocation poitns. Must be the sum of all allocation points in all pools.
    uint256 public maxRankNumber = 10;
    // Last block number that SHARDs distribution occurs.
    uint256 public lastRewardBlock;
    // produced blocks per day
    uint256 public constant produceBlocksPerDay = 6496;
    // produced blocks per month
    uint256 public constant produceBlocksPerMonth = produceBlocksPerDay * 30;
    // SHD tokens created per block.
    uint256 public SHDPerBlock = 104994 * (1e13);
    // after each term, mine half SHD token
    uint256 public constant MINT_DECREASE_TERM = 9500000;
    // used to caculate user deposit weight
    uint256[] private depositTimeWeight;
    // max lock time in stage two
    uint256 private constant MAX_MONTH = 36;
    // add pool automatically in nft shard
    address public nftShard;
    // oracle token price update term
    uint256 public updateTokenPriceTerm = 120;
    // to mint token cross chain
    uint256 <span class="marker" id="mapping-7"></span><span class="token del" data-title="visibility/public">public</span> shardMintWeight = 1;
    uint256 <span class="marker" id="mapping-8"></span><span class="token del" data-title="visibility/public">public</span> reserveMintWeight = 0;
    uint256 <span class="marker" id="mapping-9"></span><span class="token del" data-title="visibility/public">public</span> reserveToMint;
    // black list
    EvilPoolInfo[] <span class="marker" id="mapping-10"></span><span class="token mv" id="move-src-2" data-title="state_variable_declaration/visibility">public</span> blackList;
    mapping(uint256 =&gt; uint256) <span class="marker" id="mapping-11"></span><span class="token mv" id="move-src-3" data-title="state_variable_declaration/visibility">public</span> blackListMap;
    // undividend shard
    uint256 public unDividendShard;
    // 20% shard =&gt; SHD - ETH pool
    uint256 public shardPoolDividendWeight = 2;
    // 80% shard =&gt; SHD - ETH pool
    uint256 public otherPoolDividendWeight = 8;

    event Deposit(
        address indexed user,
        uint256 indexed pid,
        uint256 amount,
        uint256 weight
    );
    event Withdraw(address indexed user, uint256 indexed pid, uint256 amount);
    event Replace(
        address indexed user,
        uint256 indexed rankIndex,
        uint256 newPid
    );

    event AddToBlacklist(
        uint256 indexed pid
    );

    event RemoveFromBlacklist(
        uint256 indexed pid
    );
    event AddPool(uint256 indexed pid, uint256 nftId, address tokenAddress);

    function initialize(
        SHDToken _SHD,
        address _wethToken,
        address _developerDAOFund,
        address _marketingFund,
        uint256 _maxRankNumber,
        uint256 _startBlock
    ) <span class="marker" id="mapping-12"></span><span class="token del" data-title="function_definition/visibility">public</span> <span class="marker" id="mapping-13"></span><span class="token del" data-title="function_definition/virtual">virtual</span> onlyOwner{
        require(WETHToken == address(0), "already initialized");
        SHD = _SHD;
        maxRankNumber = _maxRankNumber;
        if (_startBlock &lt; block.number) {
            startBlock = block.number;
        } else {
            startBlock = _startBlock;
        }
        lastRewardBlock = startBlock.sub(1);
        WETHToken = _wethToken;
        <span class="marker" id="mapping-14"></span><span class="token del" data-title="function_body/expression_statement">initializeTimeWeight();</span>
        developerDAOFund = _developerDAOFund;
        marketingFund = _marketingFund;
        InvitationInfo storage initialInvitor =
            usersRelationshipInfo[address(this)];

        userDividendWeight = 8;
        devDividendWeight = 2;

        amountFeeRateNumerator = 0;
        amountfeeRateDenominator = 0;

        contractFeeRateNumerator = 1;
        contractFeeRateDenominator = 5;
        <span class="marker" id="mapping-15"></span><span class="token mv" id="move-src-4" data-title="function_body/expression_statement">initialInvitor.isUsed = true;</span>
    }

    <span class="marker" id="mapping-16"></span><span class="token del" data-title="contract_body/function_definition">function initializeTimeWeight() <span class="marker" id="mapping-17"></span><span class="token del" data-title="function_definition/visibility">private</span> <span class="marker" id="mapping-18"></span><span class="token del" data-title="function_definition/function_body">{
        <span class="marker" id="mapping-19"></span><span class="token mv" id="move-src-5" data-title="function_body/expression_statement">depositTimeWeight = [
            1238,
            1383,
            1495,
            1587,
            1665,
            1732,
            1790,
            1842,
            1888,
            1929,
            1966,
            2000,
            2031,
            2059,
            2085,
            2108,
            2131,
            2152,
            2171,
            2189,
            2206,
            2221,
            2236,
            2250,
            2263,
            2276,
            2287,
            2298,
            2309,
            2319,
            2328,
            2337,
            2346,
            2355,
            2363,
            2370
        ];</span>
    }</span></span>

    function setNftShard(address _nftShard) external virtual {
        checkAdmin();
        nftShard = _nftShard;
    }

    // Add a new lp to the pool. Can only be called by the nft shard contract.
    // if _lpTokenSwap contains tokenA instead of eth, then _tokenToEthSwap should consist of token A and eth
    function add(
        uint256 _nftPoolId,
        IUniswapV2Pair _lpTokenSwap,
        IUniswapV2Pair _tokenToEthSwap
    ) external virtual {
        require(msg.sender == nftShard || msg.sender == admin, "invalid sender");
        TokenPairInfo memory tokenToEthInfo;
        uint256 lastDividendHeight = 0;
        if(poolInfo.length == 0){
            _nftPoolId = 0;
            lastDividendHeight = lastRewardBlock;
        }
        bool isFirstTokenShard;
        if (address(_tokenToEthSwap) != address(0)) {
            (address token0, address token1, uint256 targetTokenPosition) =
                getTargetTokenInSwap(_tokenToEthSwap, WETHToken);
            address wantToken;
            bool isFirstTokenEthToken;
            if (targetTokenPosition == 0) {
                isFirstTokenEthToken = true;
                wantToken = token1;
            } else {
                isFirstTokenEthToken = false;
                wantToken = token0;
            }
            (, , targetTokenPosition) = getTargetTokenInSwap(
                _lpTokenSwap,
                wantToken
            );
            if (targetTokenPosition == 0) {
                isFirstTokenShard = false;
            } else {
                isFirstTokenShard = true;
            }
            tokenToEthInfo = generateOrcaleInfo(
                _tokenToEthSwap,
                isFirstTokenEthToken
            );
        } else {
            (, , uint256 targetTokenPosition) =
                getTargetTokenInSwap(_lpTokenSwap, WETHToken);
            if (targetTokenPosition == 0) {
                isFirstTokenShard = false;
            } else {
                isFirstTokenShard = true;
            }
            tokenToEthInfo = generateOrcaleInfo(
                _lpTokenSwap,
                !isFirstTokenShard
            );
        }
        poolInfo.push(
            PoolInfo({
                nftPoolId: _nftPoolId,
                lpTokenSwap: address(_lpTokenSwap),
                lpTokenAmount: 0,
                usersTotalWeight: 0,
                accumulativeDividend: 0,
                oracleWeight: 0,
                lastDividendHeight: lastDividendHeight,
                tokenToEthPairInfo: tokenToEthInfo,
                isFirstTokenShard: isFirstTokenShard
            })
        );
        emit AddPool(poolInfo.length.sub(1), _nftPoolId, address(_lpTokenSwap));
    }

    function setPriceUpdateTerm(uint256 _term) external virtual onlyOwner{
        updateTokenPriceTerm = _term;
    }

    function kickEvilPoolByPid(uint256 _pid, string calldata description)
        external
        virtual
        onlyOwner
    {
        <span class="marker" id="mapping-20"></span><span class="token mv" id="move-src-6" data-title="function_body/variable_declaration_statement"><span class="marker" id="mapping-21"></span><span class="token del" data-title="variable_declaration/type_name">bool</span> <span class="marker" id="mapping-22"></span><span class="token upd" id="move-src-7" data-title="variable_declaration/identifier">isD<span class="cupd">e</span>scriptionLeagal</span> = <span class="marker" id="mapping-23"></span><span class="token del" data-title="variable_declaration_statement/call_expression">verifyDescription(description)</span>;</span>
        <span class="marker" id="mapping-24"></span><span class="token del" data-title="function_body/expression_statement">require(isDescriptionLeagal, "invalid description, just ASCII code is allowed");</span>
        require(_pid &gt; 0, "invalid pid");
        uint256 poolRankIndex = rankPoolIndexMap[_pid];
        if (poolRankIndex &gt; 0) {
            <span class="marker" id="mapping-25"></span><span class="token mv" id="move-src-8" data-title="block_statement/expression_statement">massUpdatePools();</span>
            uint256 <span class="marker" id="mapping-26"></span><span class="token upd" id="move-src-9" data-title="variable_declaration/identifier">_r<span class="cupd">a</span><span class="cupd">n</span>kIn<span class="cupd">d</span>ex</span> = <span class="marker" id="mapping-27"></span><span class="token mv" id="move-src-10" data-title="variable_declaration_statement/call_expression">poolRankIndex.sub(1)</span>;
            <span class="marker" id="mapping-28"></span><span class="token mv" id="move-src-11" data-title="variable_declaration_statement/variable_declaration">uint256 <span class="marker" id="mapping-29"></span><span class="token upd" id="move-src-12" data-title="variable_declaration/identifier">curr<span class="cupd">en</span>tRankLastIndex</span></span> = <span class="marker" id="mapping-30"></span><span class="token mv" id="move-src-13" data-title="variable_declaration_statement/call_expression">rankPoolIndex.length.sub(1)</span>;
            <span class="marker" id="mapping-31"></span><span class="token del" data-title="block_statement/variable_declaration_statement"><span class="marker" id="mapping-32"></span><span class="token mv" id="move-src-14" data-title="variable_declaration_statement/variable_declaration">uint256 lastPidInRank</span> = <span class="marker" id="mapping-33"></span><span class="token del" data-title="variable_declaration_statement/array_access">rankPoolIndex[currentRankLastIndex]</span>;</span>
            <span class="marker" id="mapping-34"></span><span class="token del" data-title="block_statement/expression_statement">rankPoolIndex[_rankIndex] = lastPidInRank;</span>
            rankPoolIndexMap[lastPidInRank] = poolRankIndex;
            delete rankPoolIndexMap[_pid];
            rankPoolIndex.pop();
        }
        <span class="marker" id="mapping-35"></span><span class="token del" data-title="function_body/expression_statement">addInBlackList(_pid, description);</span>
        <span class="marker" id="mapping-36"></span><span class="token del" data-title="function_body/expression_statement"><span class="marker" id="mapping-37"></span><span class="token del" data-title="expression_statement/call_expression">dealEvilPoolDiviend(<span class="marker" id="mapping-38"></span><span class="token mv" id="move-src-15" data-title="call_expression/call_argument">_pid</span>)</span>;</span>
        emit AddToBlacklist(_pid);
    }

    <span class="marker" id="mapping-39"></span><span class="token del" data-title="contract_body/function_definition">function addInBlackList(<span class="marker" id="mapping-40"></span><span class="token del" data-title="function_definition/parameter">uint256 _pid</span>, <span class="marker" id="mapping-41"></span><span class="token del" data-title="function_definition/parameter">string calldata description</span>) <span class="marker" id="mapping-42"></span><span class="token del" data-title="function_definition/visibility">private</span> <span class="marker" id="mapping-43"></span><span class="token del" data-title="function_definition/function_body">{
        <span class="marker" id="mapping-44"></span><span class="token del" data-title="function_body/if_statement">if (blackListMap[_pid] &gt; 0) {
            return;
        }</span>
        <span class="marker" id="mapping-45"></span><span class="token mv" id="move-src-16" data-title="function_body/expression_statement">blackList.push(EvilPoolInfo({pid: _pid, description: description}));</span>
        <span class="marker" id="mapping-46"></span><span class="token mv" id="move-src-17" data-title="function_body/expression_statement">blackListMap[_pid] = blackList.length;</span>
    }</span></span>

    function resetEvilPool(uint256 _pid) external virtual onlyOwner {
        uint256 poolPosition = blackListMap[_pid];
        if (poolPosition == 0) {
            return;
        }
        uint256 poolIndex = poolPosition.sub(1);
        uint256 lastIndex = blackList.length.sub(1);
        EvilPoolInfo storage lastEvilInBlackList = blackList[lastIndex];
        uint256 lastPidInBlackList = lastEvilInBlackList.pid;
        blackListMap[lastPidInBlackList] = poolPosition;
        blackList[poolIndex] = blackList[lastIndex];
        delete blackListMap[_pid];
        blackList.pop();
        emit RemoveFromBlacklist(_pid);
    }

    function dealEvilPoolDiviend(uint256 _pid) private {
        PoolInfo storage pool = poolInfo[_pid];
        <span class="marker" id="mapping-47"></span><span class="token del" data-title="function_body/variable_declaration_statement"><span class="marker" id="mapping-48"></span><span class="token del" data-title="variable_declaration_statement/variable_declaration"><span class="marker" id="mapping-49"></span><span class="token mv" id="move-src-18" data-title="variable_declaration/type_name">uint256</span> undistributeDividend</span> = <span class="marker" id="mapping-50"></span><span class="token mv" id="move-src-19" data-title="variable_declaration_statement/member_expression">pool.accumulativeDividend</span>;</span>
        if (<span class="marker" id="mapping-51"></span><span class="token upd" id="move-src-20" data-title="binary_expression/identifier"><span class="cupd">undistributeDividend</span></span> == 0) {
            return;
        }
        uint256 currentRankCount = rankPoolIndex.length;
        if (currentRankCount &gt; 0) {
            uint256 averageDividend =
                <span class="marker" id="mapping-52"></span><span class="token upd" id="move-src-21" data-title="member_expression/identifier"><span class="cupd">undistributeDividend</span></span>.div(currentRankCount);
            for (uint256 i = 0; i &lt; currentRankCount; i++) {
                PoolInfo storage poolInRank = poolInfo[<span class="marker" id="mapping-53"></span><span class="token mv" id="move-src-22" data-title="array_access/array_access">rankPoolIndex[i]</span>];
                <span class="marker" id="mapping-54"></span><span class="token del" data-title="block_statement/if_statement">if (<span class="marker" id="mapping-55"></span><span class="token mv" id="move-src-23" data-title="if_statement/binary_expression">i &lt; currentRankCount - 1</span>) <span class="marker" id="mapping-56"></span><span class="token del" data-title="if_statement/block_statement">{
                    <span class="marker" id="mapping-57"></span><span class="token del" data-title="block_statement/expression_statement">poolInRank.accumulativeDividend = poolInRank
                        .accumulativeDividend
                        .add(averageDividend);</span>
                    <span class="marker" id="mapping-58"></span><span class="token del" data-title="block_statement/expression_statement"><span class="marker" id="mapping-59"></span><span class="token del" data-title="expression_statement/assignment_expression">undistributeDividend = <span class="marker" id="mapping-60"></span><span class="token del" data-title="assignment_expression/call_expression"><span class="marker" id="mapping-61"></span><span class="token del" data-title="call_expression/member_expression">undistributeDividend.sub</span>(
                        <span class="marker" id="mapping-62"></span><span class="token mv" id="move-src-24" data-title="call_expression/call_argument">averageDividend</span>
                    )</span></span>;</span>
                }</span> else <span class="marker" id="mapping-63"></span><span class="token del" data-title="if_statement/block_statement">{
                    <span class="marker" id="mapping-64"></span><span class="token mv" id="move-src-25" data-title="block_statement/expression_statement">poolInRank.accumulativeDividend = poolInRank
                        .accumulativeDividend
                        .add(<span class="marker" id="mapping-65"></span><span class="token upd" id="move-src-26" data-title="call_argument/identifier">un<span class="cupd">d</span>istribute<span class="cupd">Dividend</span></span>);</span>
                }</span></span>
            }
        } else {
            unDividendShard = unDividendShard.add(<span class="marker" id="mapping-66"></span><span class="token upd" id="move-src-27" data-title="call_argument/identifier"><span class="cupd">undistributeDividend</span></span>);
        }
        pool.accumulativeDividend = <span class="marker" id="mapping-67"></span><span class="token del" data-title="assignment_expression/number_literal">0</span>;
    }

    <span class="marker" id="mapping-68"></span><span class="token del" data-title="contract_body/function_definition">function setMintCoefficient(
        <span class="marker" id="mapping-69"></span><span class="token del" data-title="function_definition/parameter"><span class="marker" id="mapping-70"></span><span class="token mv" id="move-src-28" data-title="parameter/type_name">uint256</span> _shardMintWeight</span>,
        <span class="marker" id="mapping-71"></span><span class="token mv" id="move-src-29" data-title="function_definition/parameter">uint256 <span class="marker" id="mapping-72"></span><span class="token upd" id="move-src-30" data-title="parameter/identifier"><span class="cupd">_</span>re<span class="cupd">s</span>e<span class="cupd">r</span>veM<span class="cupd">i</span>n<span class="cupd">t</span>W<span class="cupd">e</span>ight</span></span>
    ) <span class="marker" id="mapping-73"></span><span class="token mv" id="move-src-31" data-title="function_definition/visibility">external</span> virtual <span class="marker" id="mapping-74"></span><span class="token del" data-title="function_definition/function_body">{
        checkAdmin();
        require(
            _shardMintWeight != 0 &amp;&amp; _reserveMintWeight != 0,
            "invalid input"
        );
        massUpdatePools();
        shardMintWeight = _shardMintWeight;
        reserveMintWeight = _reserveMintWeight;
    }</span></span>

    function setShardPoolDividendWeight(
        uint256 _shardPoolWeight,
        uint256 _otherPoolWeight
    ) external virtual {
        checkAdmin();
        require(
            _shardPoolWeight != 0 &amp;&amp; _otherPoolWeight != 0,
            "invalid input"
        );
        massUpdatePools();
        shardPoolDividendWeight = _shardPoolWeight;
        otherPoolDividendWeight = _otherPoolWeight;
    }

    function setSHDPerBlock(uint256 _SHDPerBlock, bool _withUpdate) external virtual {
        checkAdmin();
        if (_withUpdate) {
            massUpdatePools();
        }
        SHDPerBlock = _SHDPerBlock;
    }

    function massUpdatePools() public virtual {
        uint256 poolCountInRank = rankPoolIndex.length;
        uint256 farmMintShard = mintSHARD(address(this), block.number);
        updateSHARDPoolAccumulativeDividend(block.number);
        if(poolCountInRank == 0){
            farmMintShard = farmMintShard.mul(otherPoolDividendWeight)
                                     .div(shardPoolDividendWeight.add(otherPoolDividendWeight));
            if(farmMintShard &gt; 0){
                unDividendShard = unDividendShard.add(farmMintShard);
            }
        }
        for (uint256 i = 0; i &lt; poolCountInRank; i++) {
            updatePoolAccumulativeDividend(
                rankPoolIndex[i],
                poolCountInRank,
                block.number
            );
        }
    }

    // update reward vairables for a pool
    function updatePoolDividend(uint256 _pid) public virtual {
        if(_pid == 0){
            updateSHARDPoolAccumulativeDividend(block.number);
            return;
        }
        <span class="marker" id="mapping-75"></span><span class="token mv" id="move-src-32" data-title="function_body/if_statement">if (rankPoolIndexMap[_pid] == 0) {
            return;
        }</span>
        updatePoolAccumulativeDividend(
            _pid,
            rankPoolIndex.length,
            block.number
        );
    }

    function mintSHARD(address _address, uint256 _toBlock) private returns (uint256){
        uint256 recentlyRewardBlock = lastRewardBlock;
        if (recentlyRewardBlock &gt;= _toBlock) {
            return 0;
        }
        uint256 totalReward =
            getRewardToken(recentlyRewardBlock.add(1), _toBlock);
        <span class="marker" id="mapping-76"></span><span class="token del" data-title="function_body/variable_declaration_statement"><span class="marker" id="mapping-77"></span><span class="token mv" id="move-src-33" data-title="variable_declaration_statement/variable_declaration">uint256 <span class="marker" id="mapping-78"></span><span class="token upd" id="move-src-34" data-title="variable_declaration/identifier">f<span class="cupd">a</span>r<span class="cupd">m</span>M<span class="cupd">i</span>nt</span></span> =
            <span class="marker" id="mapping-79"></span><span class="token del" data-title="variable_declaration_statement/call_expression">totalReward.mul(shardMintWeight).div(
                reserveMintWeight.add(shardMintWeight)
            )</span>;</span>
        <span class="marker" id="mapping-80"></span><span class="token mv" id="move-src-35" data-title="function_body/variable_declaration_statement">uint256 <span class="marker" id="mapping-81"></span><span class="token upd" id="move-src-36" data-title="variable_declaration/identifier">r<span class="cupd">e</span>s<span class="cupd">er</span>ve</span> = <span class="marker" id="mapping-82"></span><span class="token del" data-title="variable_declaration_statement/call_expression">totalReward.sub(farmMint)</span>;</span>
        if (totalReward &gt; 0) {
            SHD.mint(_address, <span class="marker" id="mapping-83"></span><span class="token upd" id="move-src-37" data-title="call_argument/identifier">f<span class="cupd">a</span>rmMint</span>);
            <span class="marker" id="mapping-84"></span><span class="token del" data-title="block_statement/if_statement">if (reserve &gt; 0) {
                reserveToMint = reserveToMint.add(reserve);
            }</span>
            lastRewardBlock = _toBlock;
        }
        return <span class="marker" id="mapping-85"></span><span class="token upd" id="move-src-38" data-title="return_statement/identifier">f<span class="cupd">a</span>rmMint</span>;
    }

    function updatePoolAccumulativeDividend(
        uint256 _pid,
        uint256 _validRankPoolCount,
        uint256 _toBlock
    ) private {
        PoolInfo storage pool = poolInfo[_pid];
        if (pool.lastDividendHeight &gt;= _toBlock) return;
        uint256 poolReward =
            <span class="marker" id="mapping-86"></span><span class="token upd" id="move-src-39" data-title="call_expression/identifier"><span class="cupd">get</span>Modified<span class="cupd">RewardToken</span></span>(pool.lastDividendHeight.add(1), _toBlock)
                                    .mul(otherPoolDividendWeight)
                                    .div(shardPoolDividendWeight.add(otherPoolDividendWeight));

        uint256 otherPoolReward = poolReward.div(_validRankPoolCount);                            
        pool.lastDividendHeight = _toBlock;
        <span class="marker" id="mapping-87"></span><span class="token mv" id="move-src-40" data-title="function_body/variable_declaration_statement">uint256 existedDividend = pool.accumulativeDividend;</span>
        <span class="marker" id="mapping-88"></span><span class="token mv" id="move-src-41" data-title="assignment_expression/member_expression">pool.accumulativeDividend</span> = existedDividend.add(otherPoolReward);
    }

    function updateSHARDPoolAccumulativeDividend (uint256 _toBlock) private{
        PoolInfo storage pool = poolInfo[0];
        if (pool.lastDividendHeight &gt;= _toBlock) return;
        uint256 poolReward =
            <span class="marker" id="mapping-89"></span><span class="token upd" id="move-src-42" data-title="call_expression/identifier"><span class="cupd">get</span>Modified<span class="cupd">RewardToken</span></span>(pool.lastDividendHeight.add(1), _toBlock);

        uint256 shardPoolDividend = poolReward.mul(shardPoolDividendWeight)
                                               .div(shardPoolDividendWeight.add(otherPoolDividendWeight));                              
        pool.lastDividendHeight = _toBlock;
        <span class="marker" id="mapping-90"></span><span class="token mv" id="move-src-43" data-title="function_body/variable_declaration_statement">uint256 existedDividend = pool.accumulativeDividend;</span>
        <span class="marker" id="mapping-91"></span><span class="token mv" id="move-src-44" data-title="assignment_expression/member_expression">pool.accumulativeDividend</span> = existedDividend.add(shardPoolDividend);
    }

    // deposit LP tokens to MasterChef for SHD allocation.
    // ignore lockTime in stage one
    function deposit(
        uint256 _pid,
        uint256 _amount,
        uint256 _lockTime
    ) external virtual {
        require(_amount &gt; 0, "invalid deposit amount");
        InvitationInfo storage senderInfo = usersRelationshipInfo[msg.sender];
        require(senderInfo.isUsed, "must accept an invitation firstly");
        require(_lockTime &gt; 0 &amp;&amp; _lockTime &lt;= 36, "invalid lock time"); // less than 36 months
        PoolInfo storage pool = poolInfo[_pid];
        uint256 lpTokenAmount = pool.lpTokenAmount.add(_amount);
        UserInfo storage user = userInfo[_pid][msg.sender];
        uint256 newOriginWeight = user.originWeight;
        <span class="marker" id="mapping-92"></span><span class="token mv" id="move-src-45" data-title="variable_declaration_statement/variable_declaration">uint256 <span class="marker" id="mapping-93"></span><span class="token upd" id="move-src-46" data-title="variable_declaration/identifier">ex<span class="cupd">i</span>s<span class="cupd">t</span><span class="cupd">e</span>dAmount</span></span> <span class="marker" id="mapping-94"></span><span class="token del" data-title="variable_declaration_statement/=">=</span> <span class="marker" id="mapping-95"></span><span class="token mv" id="move-src-47" data-title="variable_declaration_statement/member_expression">user.amount</span>;
        uint256 endBlock = user.endBlock;
        uint256 newEndBlock =
            block.number.add(produceBlocksPerMonth.mul(_lockTime));
        if (<span class="marker" id="mapping-96"></span><span class="token del" data-title="binary_expression/identifier">existedAmount</span> &gt; 0) {
            if(newEndBlock &lt; endBlock){
                newOriginWeight = newOriginWeight.add(getDepositWeight(
                    _amount,
                    endBlock.sub(block.number).div(produceBlocksPerMonth)
                ));
                newEndBlock = endBlock;
            }
            else{
                newOriginWeight = newOriginWeight.add(getDepositWeight(
                    _amount,
                    _lockTime
                ));
                newOriginWeight = newOriginWeight.add(getDepositWeight(
                    <span class="marker" id="mapping-97"></span><span class="token del" data-title="call_argument/identifier">existedAmount</span>,
                    newEndBlock.sub(endBlock).div(produceBlocksPerMonth)
                ));
            }
        } else {
            judgeContractSender(_pid);
            newOriginWeight = getDepositWeight(_amount, _lockTime);
        }
        <span class="marker" id="mapping-98"></span><span class="token del" data-title="function_body/expression_statement"><span class="marker" id="mapping-99"></span><span class="token del" data-title="expression_statement/call_expression">modifyWeightByInvitation(
            <span class="marker" id="mapping-100"></span><span class="token mv" id="move-src-48" data-title="call_expression/call_argument">_pid</span>,
            <span class="marker" id="mapping-101"></span><span class="token del" data-title="call_expression/call_argument">msg.sender</span>,
            <span class="marker" id="mapping-102"></span><span class="token mv" id="move-src-49" data-title="call_expression/call_argument">user.originWeight</span>,
            <span class="marker" id="mapping-103"></span><span class="token del" data-title="call_expression/call_argument">newOriginWeight</span>,
            <span class="marker" id="mapping-104"></span><span class="token mv" id="move-src-50" data-title="call_expression/call_argument">user.inviteeWeight</span>,
            <span class="marker" id="mapping-105"></span><span class="token del" data-title="call_expression/call_argument">existedAmount</span>
        )</span>;</span>   
        <span class="marker" id="mapping-106"></span><span class="token del" data-title="function_body/expression_statement"><span class="marker" id="mapping-107"></span><span class="token del" data-title="expression_statement/call_expression">updateUserInfo(
            <span class="marker" id="mapping-108"></span><span class="token del" data-title="call_expression/call_argument">user</span>,
            <span class="marker" id="mapping-109"></span><span class="token del" data-title="call_expression/call_argument"><span class="marker" id="mapping-110"></span><span class="token del" data-title="call_argument/call_expression"><span class="marker" id="mapping-111"></span><span class="token del" data-title="call_expression/member_expression">existedAmount.add</span>(<span class="marker" id="mapping-112"></span><span class="token mv" id="move-src-51" data-title="call_expression/call_argument">_amount</span>)</span></span>,
            <span class="marker" id="mapping-113"></span><span class="token del" data-title="call_expression/call_argument">newOriginWeight</span>,
            <span class="marker" id="mapping-114"></span><span class="token del" data-title="call_expression/call_argument">newEndBlock</span>
        )</span>;</span>
        IERC20(pool.lpTokenSwap).safeTransferFrom(
            address(msg.sender),
            address(this),
            _amount
        );
        pool.oracleWeight =  <span class="marker" id="mapping-115"></span><span class="token upd" id="move-src-52" data-title="call_expression/identifier">g<span class="cupd">e</span>t<span class="cupd">OracleWeight</span></span>(pool, lpTokenAmount);
        pool.lpTokenAmount = lpTokenAmount;
        if (
            rankPoolIndexMap[_pid] == 0 &amp;&amp;
            rankPoolIndex.length &lt; maxRankNumber &amp;&amp;
            blackListMap[_pid] == 0
        ) {
            addToRank(pool, _pid);
        }
        emit Deposit(msg.sender, _pid, _amount, newOriginWeight);
    }

    // Withdraw LP tokens from MasterChef.
    function withdraw(uint256 _pid) external virtual {
        UserInfo storage user = userInfo[_pid][msg.sender];
        uint256 amount = user.amount;
        require(amount &gt; 0, "user is not existed");
        require(user.endBlock &lt; block.number, "token is still locked");
        mintSHARD(address(this), block.number);
        updatePoolDividend(_pid);
        uint256 originWeight = user.originWeight;
        PoolInfo storage pool = poolInfo[_pid];
        <span class="marker" id="mapping-116"></span><span class="token mv" id="move-src-53" data-title="function_body/variable_declaration_statement">uint256 <span class="marker" id="mapping-117"></span><span class="token upd" id="move-src-54" data-title="variable_declaration/identifier">us<span class="cupd">er</span>sTotal<span class="cupd">Weight</span></span> = <span class="marker" id="mapping-118"></span><span class="token mv" id="move-src-55" data-title="variable_declaration_statement/member_expression">pool.usersTotalWeight</span>;</span>
        uint256 userWeight = user.inviteeWeight.add(originWeight);
        if(user.isCalculateInvitation){
            userWeight = userWeight.add(originWeight.div(INVITOR_WEIGHT));
        }
        if (<span class="marker" id="mapping-119"></span><span class="token del" data-title="if_statement/binary_expression"><span class="marker" id="mapping-120"></span><span class="token mv" id="move-src-56" data-title="binary_expression/member_expression">pool.accumulativeDividend</span> &gt; 0</span>) {
            <span class="marker" id="mapping-121"></span><span class="token mv" id="move-src-57" data-title="block_statement/variable_declaration_statement">uint256 pending = <span class="marker" id="mapping-122"></span><span class="token mv" id="move-src-58" data-title="variable_declaration_statement/call_expression">pool.accumulativeDividend.mul(<span class="marker" id="mapping-123"></span><span class="token mv" id="move-src-59" data-title="call_expression/call_argument">userWeight</span>).div(<span class="marker" id="mapping-124"></span><span class="token del" data-title="call_argument/identifier">usersTotalWeight</span>)</span>;</span>
            pool.accumulativeDividend = pool.accumulativeDividend.sub(pending);
            <span class="marker" id="mapping-125"></span><span class="token mv" id="move-src-60" data-title="block_statement/variable_declaration_statement">uint256 treasruyDividend;</span>
            <span class="marker" id="mapping-126"></span><span class="token mv" id="move-src-61" data-title="block_statement/variable_declaration_statement">uint256 devDividend;</span>
            <span class="marker" id="mapping-127"></span><span class="token del" data-title="expression_statement/assignment_expression"><span class="marker" id="mapping-128"></span><span class="token del" data-title="assignment_expression/tuple_expression">(treasruyDividend, devDividend, pending)</span> = <span class="marker" id="mapping-129"></span><span class="token mv" id="move-src-62" data-title="assignment_expression/call_expression"><span class="marker" id="mapping-130"></span><span class="token upd" id="move-src-63" data-title="call_expression/identifier">calculateD<span class="cupd">ividend</span></span>(<span class="marker" id="mapping-131"></span><span class="token mv" id="move-src-64" data-title="call_expression/call_argument">pending</span><span class="marker" id="mapping-132"></span><span class="token mv" id="move-src-65" data-title="call_expression/,">,</span> _pid, amount, isUserContractSender[_pid][msg.sender])</span></span>;
            <span class="marker" id="mapping-133"></span><span class="token mv" id="move-src-66" data-title="block_statement/if_statement">if(treasruyDividend &gt; 0){
                safeSHARDTransfer(marketingFund, treasruyDividend);
            }</span>
            <span class="marker" id="mapping-134"></span><span class="token mv" id="move-src-67" data-title="block_statement/if_statement">if(devDividend &gt; 0){
                safeSHARDTransfer(developerDAOFund, devDividend);
            }</span>
            <span class="marker" id="mapping-135"></span><span class="token mv" id="move-src-68" data-title="block_statement/if_statement">if(<span class="marker" id="mapping-136"></span><span class="token mv" id="move-src-69" data-title="if_statement/binary_expression">pending &gt; 0</span>){
                safeSHARDTransfer(msg.sender, <span class="marker" id="mapping-137"></span><span class="token mv" id="move-src-70" data-title="call_expression/call_argument">pending</span>);
            }</span>
        }
        pool.usersTotalWeight = <span class="marker" id="mapping-138"></span><span class="token del" data-title="member_expression/identifier">usersTotalWeight</span>.sub(userWeight);
        user.amount = 0;
        user.originWeight = 0;
        user.endBlock = 0;
        IERC20(pool.lpTokenSwap).safeTransfer(address(msg.sender), amount);
        pool.lpTokenAmount = pool.lpTokenAmount.sub(amount);
        if (pool.lpTokenAmount == 0) pool.oracleWeight = 0;
        else {
            pool.oracleWeight = <span class="marker" id="mapping-139"></span><span class="token upd" id="move-src-71" data-title="call_expression/identifier">g<span class="cupd">e</span>t<span class="cupd">OracleWeight</span></span>(pool, pool.lpTokenAmount);
        }
        resetInvitationRelationship(_pid, msg.sender, originWeight);
        emit Withdraw(msg.sender, _pid, amount);
    }

    function addToRank(
        PoolInfo storage _pool,
        uint256 _pid
    ) private {
        if(_pid == 0){
            return;
        }
        massUpdatePools();
        _pool.lastDividendHeight = block.number;
        rankPoolIndex.push(_pid);
        rankPoolIndexMap[_pid] = rankPoolIndex.length;
        if(unDividendShard &gt; 0){
            _pool.accumulativeDividend = _pool.accumulativeDividend.add(unDividendShard);
            unDividendShard = 0;
        }
        emit Replace(msg.sender, rankPoolIndex.length.sub(1), _pid);
        return;
    }

    //_poolIndexInRank is the index in rank
    //_pid is the index in poolInfo
    function tryToReplacePoolInRank(uint256 _poolIndexInRank, uint256 _pid)
        external
        virtual
    {
        if(_pid == 0){
            return;
        }
        PoolInfo storage pool = poolInfo[_pid];
        require(pool.lpTokenAmount &gt; 0, "there is not any lp token depsoited");
        require(blackListMap[_pid] == 0, "pool is in the black list");
        if (rankPoolIndexMap[_pid] &gt; 0) {
            return;
        }
        uint256 currentPoolCountInRank = rankPoolIndex.length;
        require(currentPoolCountInRank == maxRankNumber, "invalid operation");
        uint256 targetPid = rankPoolIndex[_poolIndexInRank];
        PoolInfo storage targetPool = poolInfo[targetPid];
        <span class="marker" id="mapping-140"></span><span class="token mv" id="move-src-72" data-title="function_body/variable_declaration_statement">uint256 <span class="marker" id="mapping-141"></span><span class="token upd" id="move-src-73" data-title="variable_declaration/identifier"><span class="cupd">t</span>a<span class="cupd">r</span>getP<span class="cupd">o</span>olOracl<span class="cupd">e</span><span class="cupd">Weight</span></span> = <span class="marker" id="mapping-142"></span><span class="token mv" id="move-src-74" data-title="variable_declaration_statement/call_expression"><span class="marker" id="mapping-143"></span><span class="token upd" id="move-src-75" data-title="call_expression/identifier">g<span class="cupd">e</span>t<span class="cupd">OracleWeight</span></span>(targetPool, targetPool.lpTokenAmount)</span>;</span>
        <span class="marker" id="mapping-144"></span><span class="token mv" id="move-src-76" data-title="function_body/variable_declaration_statement">uint256 <span class="marker" id="mapping-145"></span><span class="token upd" id="move-src-77" data-title="variable_declaration/identifier">chall<span class="cupd">en</span>g<span class="cupd">er</span>Oracl<span class="cupd">e</span>Weight</span> <span class="marker" id="mapping-146"></span><span class="token del" data-title="variable_declaration_statement/=">=</span> <span class="marker" id="mapping-147"></span><span class="token mv" id="move-src-78" data-title="variable_declaration_statement/call_expression"><span class="marker" id="mapping-148"></span><span class="token upd" id="move-src-79" data-title="call_expression/identifier">g<span class="cupd">e</span>t<span class="cupd">OracleWeight</span></span>(pool, pool.lpTokenAmount)</span>;</span>
        if (<span class="marker" id="mapping-149"></span><span class="token del" data-title="binary_expression/identifier">challengerOracleWeight</span> &lt;= <span class="marker" id="mapping-150"></span><span class="token del" data-title="binary_expression/identifier">targetPoolOracleWeight</span>) {
            return;
        }
        updatePoolDividend(targetPid);
        rankPoolIndex[_poolIndexInRank] = _pid;
        delete rankPoolIndexMap[targetPid];
        rankPoolIndexMap[_pid] = _poolIndexInRank.add(1);
        pool.lastDividendHeight = block.number;
        emit Replace(msg.sender, _poolIndexInRank, _pid);
    }

    function acceptInvitation(<span class="marker" id="mapping-151"></span><span class="token del" data-title="function_definition/parameter">address _invitor</span>) external virtual override {
        require(_invitor != msg.sender, "invitee should not be invitor");
        <span class="marker" id="mapping-152"></span><span class="token del" data-title="call_expression/identifier">buildInvitation</span>(<span class="marker" id="mapping-153"></span><span class="token del" data-title="call_expression/call_argument">_invitor</span><span class="marker" id="mapping-154"></span><span class="token del" data-title="call_expression/,">,</span> msg.sender);
    }

    <span class="marker" id="mapping-155"></span><span class="token del" data-title="contract_body/function_definition">function buildInvitation(<span class="marker" id="mapping-156"></span><span class="token mv" id="move-src-80" data-title="function_definition/parameter">address _invitor</span>, <span class="marker" id="mapping-157"></span><span class="token del" data-title="function_definition/parameter"><span class="marker" id="mapping-158"></span><span class="token mv" id="move-src-81" data-title="parameter/type_name">address</span> _invitee</span>) <span class="marker" id="mapping-159"></span><span class="token del" data-title="function_definition/visibility">private</span> <span class="marker" id="mapping-160"></span><span class="token del" data-title="function_definition/function_body">{
        <span class="marker" id="mapping-161"></span><span class="token mv" id="move-src-82" data-title="function_body/variable_declaration_statement">InvitationInfo storage invitee = usersRelationshipInfo[<span class="marker" id="mapping-162"></span><span class="token del" data-title="array_access/identifier">_invitee</span>];</span>
        <span class="marker" id="mapping-163"></span><span class="token mv" id="move-src-83" data-title="function_body/expression_statement">require(!invitee.isUsed, "has accepted invitation");</span>
        <span class="marker" id="mapping-164"></span><span class="token mv" id="move-src-84" data-title="function_body/expression_statement">invitee.isUsed = true;</span>
        <span class="marker" id="mapping-165"></span><span class="token mv" id="move-src-85" data-title="function_body/variable_declaration_statement">InvitationInfo storage invitor = usersRelationshipInfo[_invitor];</span>
        <span class="marker" id="mapping-166"></span><span class="token mv" id="move-src-86" data-title="function_body/expression_statement">require(invitor.isUsed, "invitor has not acceptted invitation");</span>
        <span class="marker" id="mapping-167"></span><span class="token mv" id="move-src-87" data-title="function_body/expression_statement">invitee.invitor = _invitor;</span>
        <span class="marker" id="mapping-168"></span><span class="token del" data-title="function_body/expression_statement"><span class="marker" id="mapping-169"></span><span class="token del" data-title="expression_statement/call_expression"><span class="marker" id="mapping-170"></span><span class="token mv" id="move-src-88" data-title="call_expression/member_expression">invitor.invitees.push</span>(<span class="marker" id="mapping-171"></span><span class="token del" data-title="call_expression/call_argument">_invitee</span>)</span>;</span>
        <span class="marker" id="mapping-172"></span><span class="token mv" id="move-src-89" data-title="function_body/expression_statement">invitor.inviteeIndexMap[<span class="marker" id="mapping-173"></span><span class="token del" data-title="array_access/identifier">_invitee</span>] = invitor.invitees.length.sub(1);</span>
    }</span></span>

    function setMaxRankNumber(uint256 _count) external virtual {
        checkAdmin();
        require(_count &gt; 0, "invalid count");
        if (maxRankNumber == _count) return;
        massUpdatePools();
        maxRankNumber = _count;
        uint256 currentPoolCountInRank = rankPoolIndex.length;
        if (_count &gt;= currentPoolCountInRank) {
            return;
        }
        uint256 sparePoolCount = currentPoolCountInRank.sub(_count);
        uint256 lastPoolIndex = currentPoolCountInRank.sub(1);
        while (sparePoolCount &gt; 0) {
            delete rankPoolIndexMap[rankPoolIndex[lastPoolIndex]];
            rankPoolIndex.pop();
            lastPoolIndex--;
            sparePoolCount--;
        }
    }

    <span class="marker" id="mapping-174"></span><span class="token del" data-title="contract_body/function_definition">function getModifiedRewardToken(<span class="marker" id="mapping-175"></span><span class="token del" data-title="function_definition/parameter"><span class="marker" id="mapping-176"></span><span class="token mv" id="move-src-90" data-title="parameter/type_name">uint256</span> _fromBlock</span>, <span class="marker" id="mapping-177"></span><span class="token del" data-title="function_definition/parameter">uint256 _toBlock</span>)
        <span class="marker" id="mapping-178"></span><span class="token del" data-title="function_definition/visibility">private</span>
        <span class="marker" id="mapping-179"></span><span class="token del" data-title="function_definition/state_mutability">view</span>
        <span class="marker" id="mapping-180"></span><span class="token del" data-title="function_definition/return_type_definition">returns (uint256)</span>
    <span class="marker" id="mapping-181"></span><span class="token del" data-title="function_definition/function_body">{
        return
            getRewardToken(_fromBlock, _toBlock).mul(shardMintWeight).div(
                reserveMintWeight.add(shardMintWeight)
            );
    }</span></span>

    // View function to see pending SHARDs on frontend.
    function pendingSHARDByPids(uint256[] memory _pids, address _user)
        external
        view
        virtual
        returns (uint256[] memory _pending, uint256[] memory _potential, uint256 _blockNumber)
    {
         uint256 poolCount = _pids.length;
        _pending = new uint256[](poolCount);
        _potential = new uint256[](poolCount);
        _blockNumber = block.number;
        for(uint i = 0; i &lt; poolCount; i ++){
            (_pending[i], _potential[i]) = calculatePendingSHARD(_pids[i], _user);
        }
    }

    function calculatePendingSHARD(uint256 _pid, address _user) private view returns (uint256 _pending, uint256 _potential){
        PoolInfo storage pool = poolInfo[_pid];
        UserInfo storage user = userInfo[_pid][_user];
        if (user.amount == 0) {
            return (0, 0);
        }
        uint256 userModifiedWeight = getUserModifiedWeight(_pid, _user);
        <span class="marker" id="mapping-182"></span><span class="token del" data-title="function_body/expression_statement"><span class="marker" id="mapping-183"></span><span class="token del" data-title="expression_statement/assignment_expression">_pending = <span class="marker" id="mapping-184"></span><span class="token del" data-title="assignment_expression/call_expression"><span class="marker" id="mapping-185"></span><span class="token del" data-title="call_expression/member_expression">pool.accumulativeDividend.mul</span>(<span class="marker" id="mapping-186"></span><span class="token mv" id="move-src-91" data-title="call_expression/call_argument">userModifiedWeight</span>)</span></span>;</span>
        <span class="marker" id="mapping-187"></span><span class="token mv" id="move-src-92" data-title="function_body/expression_statement"><span class="marker" id="mapping-188"></span><span class="token upd" id="move-src-93" data-title="assignment_expression/identifier">_p<span class="cupd">e</span>nd<span class="cupd">i</span>ng</span> = <span class="marker" id="mapping-189"></span><span class="token del" data-title="member_expression/identifier">_pending</span>.div(pool.usersTotalWeight);</span>
        bool isContractSender = isUserContractSender[_pid][_user];
        (,,_pending) = calculateDividend(_pending, _pid, user.amount, isContractSender);
        if (pool.lastDividendHeight &gt;= block.number) {
            return (_pending, 0);
        }
        if (_pid != 0 &amp;&amp; (rankPoolIndex.length == 0 || rankPoolIndexMap[_pid] == 0)) {
            return (_pending, 0);
        }
        uint256 poolReward = <span class="marker" id="mapping-190"></span><span class="token upd" id="move-src-94" data-title="call_expression/identifier"><span class="cupd">get</span>Modified<span class="cupd">RewardToken</span></span>(pool.lastDividendHeight.add(1), block.number);
        <span class="marker" id="mapping-191"></span><span class="token mv" id="move-src-95" data-title="function_body/variable_declaration_statement">uint256 <span class="marker" id="mapping-192"></span><span class="token upd" id="move-src-96" data-title="variable_declaration/identifier">n<span class="cupd">um</span><span class="cupd">er</span>ator</span>;</span>
        uint256 <span class="marker" id="mapping-193"></span><span class="token upd" id="move-src-97" data-title="variable_declaration/identifier"><span class="cupd">den</span>ominator</span> = <span class="marker" id="mapping-194"></span><span class="token mv" id="move-src-98" data-title="member_expression/identifier"><span class="marker" id="mapping-195"></span><span class="token upd" id="move-src-99" data-title="member_expression/identifier">otherPoolD<span class="cupd">iv</span>idendWeight</span></span>.<span class="marker" id="mapping-196"></span><span class="token del" data-title="member_expression/identifier">add</span>(<span class="marker" id="mapping-197"></span><span class="token mv" id="move-src-100" data-title="call_expression/call_argument">shardPoolDividendWeight</span>);
        <span class="marker" id="mapping-198"></span><span class="token mv" id="move-src-101" data-title="function_body/if_statement">if(<span class="marker" id="mapping-199"></span><span class="token del" data-title="binary_expression/identifier">_pid</span> <span class="marker" id="mapping-200"></span><span class="token del" data-title="binary_expression/==">==</span> 0)<span class="marker" id="mapping-201"></span><span class="token del" data-title="if_statement/block_statement">{
            numerator = shardPoolDividendWeight;
        }</span>
        <span class="marker" id="mapping-202"></span><span class="token del" data-title="if_statement/else">else</span><span class="marker" id="mapping-203"></span><span class="token del" data-title="if_statement/block_statement">{
            numerator = otherPoolDividendWeight;
        }</span></span>
        <span class="marker" id="mapping-204"></span><span class="token del" data-title="function_body/expression_statement"><span class="marker" id="mapping-205"></span><span class="token del" data-title="expression_statement/assignment_expression">poolReward = <span class="marker" id="mapping-206"></span><span class="token del" data-title="assignment_expression/call_expression"><span class="marker" id="mapping-207"></span><span class="token del" data-title="call_expression/member_expression"><span class="marker" id="mapping-208"></span><span class="token mv" id="move-src-102" data-title="member_expression/call_expression">poolReward       
            .mul(<span class="marker" id="mapping-209"></span><span class="token del" data-title="call_expression/call_argument">numerator</span>)</span>
            .div</span>(<span class="marker" id="mapping-210"></span><span class="token del" data-title="call_expression/call_argument">denominator</span>)</span></span>;</span>
        if(_pid <span class="marker" id="mapping-211"></span><span class="token del" data-title="binary_expression/!=">!=</span> 0){
            <span class="marker" id="mapping-212"></span><span class="token upd" id="move-src-103" data-title="assignment_expression/identifier">p<span class="cupd">o</span>olR<span class="cupd">e</span>ward</span> = <span class="marker" id="mapping-213"></span><span class="token del" data-title="member_expression/identifier">poolReward</span>.div(rankPoolIndex.length);
        }                          
        _potential = <span class="marker" id="mapping-214"></span><span class="token upd" id="move-src-104" data-title="member_expression/identifier">p<span class="cupd">o</span>olR<span class="cupd">e</span>ward</span>
            .mul(userModifiedWeight)
            .div(pool.usersTotalWeight);
        (,,_potential) = calculateDividend(_potential, _pid, user.amount, isContractSender);
    }

    //calculate the weight and end block when users deposit
    function getDepositWeight(uint256 _lockAmount, uint256 _lockTime)
        private
        view
        returns (uint256)
    {
        if (_lockTime == 0) return 0;
        if (_lockTime.div(MAX_MONTH) &gt; 1) _lockTime = MAX_MONTH;
        return depositTimeWeight[_lockTime.sub(1)].sub(500).mul(_lockAmount);
    }

    function getPoolLength() external view virtual returns (uint256) {
        return poolInfo.length;
    }

    <span class="marker" id="mapping-215"></span><span class="token del" data-title="contract_body/function_definition">function getPagePoolInfo(<span class="marker" id="mapping-216"></span><span class="token del" data-title="function_definition/parameter">uint256 _fromIndex</span>, <span class="marker" id="mapping-217"></span><span class="token del" data-title="function_definition/parameter">uint256 _toIndex</span>)
        <span class="marker" id="mapping-218"></span><span class="token del" data-title="function_definition/visibility">external</span>
        <span class="marker" id="mapping-219"></span><span class="token del" data-title="function_definition/state_mutability">view</span>
        virtual
        <span class="marker" id="mapping-220"></span><span class="token del" data-title="function_definition/return_type_definition">returns (
            uint256[] memory _nftPoolId,
            uint256[] memory _accumulativeDividend,
            uint256[] memory _usersTotalWeight,
            uint256[] memory _lpTokenAmount,
            uint256[] memory _oracleWeight,
            address[] memory _swapAddress
        )</span>
    <span class="marker" id="mapping-221"></span><span class="token del" data-title="function_definition/function_body">{
        <span class="marker" id="mapping-222"></span><span class="token del" data-title="function_body/variable_declaration_statement">uint256 poolCount = _toIndex.sub(_fromIndex).add(1);</span>
        <span class="marker" id="mapping-223"></span><span class="token del" data-title="function_body/expression_statement">_nftPoolId = new uint256[](poolCount);</span>
        <span class="marker" id="mapping-224"></span><span class="token del" data-title="function_body/expression_statement">_accumulativeDividend = new uint256[](poolCount);</span>
        <span class="marker" id="mapping-225"></span><span class="token del" data-title="function_body/expression_statement">_usersTotalWeight = new uint256[](poolCount);</span>
        <span class="marker" id="mapping-226"></span><span class="token del" data-title="function_body/expression_statement">_lpTokenAmount = new uint256[](poolCount);</span>
        <span class="marker" id="mapping-227"></span><span class="token del" data-title="function_body/expression_statement">_oracleWeight = new uint256[](poolCount);</span>
        <span class="marker" id="mapping-228"></span><span class="token del" data-title="function_body/expression_statement">_swapAddress = new address[](poolCount);</span>
        <span class="marker" id="mapping-229"></span><span class="token del" data-title="function_body/variable_declaration_statement">uint256 startIndex = 0;</span>
        <span class="marker" id="mapping-230"></span><span class="token del" data-title="function_body/for_statement">for (<span class="marker" id="mapping-231"></span><span class="token del" data-title="for_statement/variable_declaration_statement">uint256 i = _fromIndex;</span> <span class="marker" id="mapping-232"></span><span class="token del" data-title="for_statement/expression_statement">i &lt;= _toIndex;</span> <span class="marker" id="mapping-233"></span><span class="token del" data-title="for_statement/update_expression">i++</span>) <span class="marker" id="mapping-234"></span><span class="token del" data-title="for_statement/block_statement">{
            <span class="marker" id="mapping-235"></span><span class="token del" data-title="block_statement/variable_declaration_statement">PoolInfo storage pool = poolInfo[i];</span>
            <span class="marker" id="mapping-236"></span><span class="token del" data-title="block_statement/expression_statement">_nftPoolId[startIndex] = pool.nftPoolId;</span>
            <span class="marker" id="mapping-237"></span><span class="token del" data-title="block_statement/expression_statement">_accumulativeDividend[startIndex] = pool.accumulativeDividend;</span>
            <span class="marker" id="mapping-238"></span><span class="token del" data-title="block_statement/expression_statement">_usersTotalWeight[startIndex] = pool.usersTotalWeight;</span>
            <span class="marker" id="mapping-239"></span><span class="token del" data-title="block_statement/expression_statement">_lpTokenAmount[startIndex] = pool.lpTokenAmount;</span>
            <span class="marker" id="mapping-240"></span><span class="token mv" id="move-src-105" data-title="block_statement/expression_statement"><span class="marker" id="mapping-241"></span><span class="token del" data-title="assignment_expression/array_access">_oracleWeight[startIndex]</span> <span class="marker" id="mapping-242"></span><span class="token mv" id="move-src-106" data-title="assignment_expression/=">=</span> pool.oracleWeight;</span>
            <span class="marker" id="mapping-243"></span><span class="token del" data-title="block_statement/expression_statement">_swapAddress[startIndex] = pool.lpTokenSwap;</span>
            <span class="marker" id="mapping-244"></span><span class="token del" data-title="block_statement/expression_statement">startIndex++;</span>
        }</span></span>
    }</span></span>

    function getInstantPagePoolInfo(uint256 _fromIndex, uint256 _toIndex)
    external
    virtual
    returns (
        uint256[] memory _nftPoolId,
        uint256[] memory _accumulativeDividend,
        uint256[] memory _usersTotalWeight,
        uint256[] memory _lpTokenAmount,
        uint256[] memory _oracleWeight,
        address[] memory _swapAddress
    )
    {
        uint256 poolCount = _toIndex.sub(_fromIndex).add(1);
        _nftPoolId = new uint256[](poolCount);
        _accumulativeDividend = new uint256[](poolCount);
        _usersTotalWeight = new uint256[](poolCount);
        _lpTokenAmount = new uint256[](poolCount);
        _oracleWeight = new uint256[](poolCount);
        _swapAddress = new address[](poolCount);
        uint256 startIndex = 0;
        for (uint256 i = _fromIndex; i &lt;= _toIndex; i++) {
            PoolInfo storage pool = poolInfo[i];
            _nftPoolId[startIndex] = pool.nftPoolId;
            _accumulativeDividend[startIndex] = pool.accumulativeDividend;
            _usersTotalWeight[startIndex] = pool.usersTotalWeight;
            _lpTokenAmount[startIndex] = pool.lpTokenAmount;
            _oracleWeight[startIndex] = <span class="marker" id="mapping-245"></span><span class="token upd" id="move-src-107" data-title="call_expression/identifier">g<span class="cupd">e</span>t<span class="cupd">OracleWeight</span></span>(pool, <span class="marker" id="mapping-246"></span><span class="token del" data-title="call_argument/array_access">_lpTokenAmount[startIndex]</span>);
            _swapAddress[startIndex] = pool.lpTokenSwap;
            startIndex++;
        }
    }

    function getRankList() external view virtual returns (uint256[] memory) {
        uint256[] memory rankIdList = rankPoolIndex;
        return rankIdList;
    }

    function getBlackList()
        external
        view
        virtual
        returns (EvilPoolInfo[] memory _blackList)
    {
        _blackList = blackList;
    }

    function getInvitation(address _sender)
        external
        view
        virtual
        override
        returns (
            address _invitor,
            address[] memory _invitees,
            bool _isWithdrawn
        )
    {
        InvitationInfo storage invitation = usersRelationshipInfo[_sender];
        _invitees = invitation.invitees;
        _invitor = invitation.invitor;
        _isWithdrawn = invitation.isWithdrawn;
    }

    <span class="marker" id="mapping-247"></span><span class="token del" data-title="contract_body/function_definition">function getUserInfo(<span class="marker" id="mapping-248"></span><span class="token mv" id="move-src-108" data-title="function_definition/parameter">uint256 _pid</span>, <span class="marker" id="mapping-249"></span><span class="token mv" id="move-src-109" data-title="function_definition/parameter">address _user</span>)
        <span class="marker" id="mapping-250"></span><span class="token mv" id="move-src-110" data-title="function_definition/visibility">private</span>
        <span class="marker" id="mapping-251"></span><span class="token del" data-title="function_definition/state_mutability">view</span>
        <span class="marker" id="mapping-252"></span><span class="token del" data-title="function_definition/return_type_definition">returns (
            <span class="marker" id="mapping-253"></span><span class="token del" data-title="return_type_definition/parameter">uint256 _amount</span>,
            <span class="marker" id="mapping-254"></span><span class="token del" data-title="return_type_definition/parameter">uint256 _originWeight</span>,
            <span class="marker" id="mapping-255"></span><span class="token del" data-title="return_type_definition/parameter"><span class="marker" id="mapping-256"></span><span class="token mv" id="move-src-111" data-title="parameter/type_name">uint256</span> _modifiedWeight</span>,
            <span class="marker" id="mapping-257"></span><span class="token del" data-title="return_type_definition/parameter">uint256 _endBlock</span>
        )</span>
    <span class="marker" id="mapping-258"></span><span class="token del" data-title="function_definition/function_body">{
        <span class="marker" id="mapping-259"></span><span class="token del" data-title="function_body/variable_declaration_statement">UserInfo storage user = userInfo[_pid][_user];</span>
        <span class="marker" id="mapping-260"></span><span class="token mv" id="move-src-112" data-title="function_body/expression_statement"><span class="marker" id="mapping-261"></span><span class="token del" data-title="assignment_expression/identifier">_amount</span> = user.amount;</span>
        <span class="marker" id="mapping-262"></span><span class="token mv" id="move-src-113" data-title="function_body/expression_statement"><span class="marker" id="mapping-263"></span><span class="token mv" id="move-src-114" data-title="assignment_expression/identifier"><span class="marker" id="mapping-264"></span><span class="token upd" id="move-src-115" data-title="assignment_expression/identifier">_o<span class="cupd">riginWeight</span></span></span> <span class="marker" id="mapping-265"></span><span class="token mv" id="move-src-116" data-title="assignment_expression/=">=</span> user.originWeight;</span>
        <span class="marker" id="mapping-266"></span><span class="token del" data-title="function_body/expression_statement"><span class="marker" id="mapping-267"></span><span class="token del" data-title="expression_statement/assignment_expression">_modifiedWeight = <span class="marker" id="mapping-268"></span><span class="token del" data-title="assignment_expression/call_expression">getUserModifiedWeight(<span class="marker" id="mapping-269"></span><span class="token mv" id="move-src-117" data-title="call_expression/call_argument">_pid</span>, <span class="marker" id="mapping-270"></span><span class="token mv" id="move-src-118" data-title="call_expression/call_argument">_user</span>)</span></span>;</span>
        <span class="marker" id="mapping-271"></span><span class="token mv" id="move-src-119" data-title="function_body/expression_statement"><span class="marker" id="mapping-272"></span><span class="token mv" id="move-src-120" data-title="assignment_expression/identifier"><span class="marker" id="mapping-273"></span><span class="token upd" id="move-src-121" data-title="assignment_expression/identifier">_<span class="cupd">e</span><span class="cupd">ndBlock</span></span></span> <span class="marker" id="mapping-274"></span><span class="token mv" id="move-src-122" data-title="assignment_expression/=">=</span> user.endBlock;</span>
    }</span></span>

    function getUserInfoByPids(uint256[] memory _pids, address _user)
        external
        view
        virtual
        returns (
            uint256[] memory _amount,
            uint256[] memory _originWeight,
            uint256[] memory _modifiedWeight,
            uint256[] memory _endBlock
        )
    {
        uint256 poolCount = _pids.length;
        _amount = new uint256[](poolCount);
        _originWeight = new uint256[](poolCount);
        _modifiedWeight = new uint256[](poolCount);
        _endBlock = new uint256[](poolCount);
        for(uint i = 0; i &lt; poolCount; i ++){
            <span class="marker" id="mapping-275"></span><span class="token del" data-title="assignment_expression/tuple_expression">(<span class="marker" id="mapping-276"></span><span class="token mv" id="move-src-123" data-title="tuple_expression/array_access">_amount[i]</span>, <span class="marker" id="mapping-277"></span><span class="token mv" id="move-src-124" data-title="tuple_expression/array_access">_originWeight[i]</span>, <span class="marker" id="mapping-278"></span><span class="token mv" id="move-src-125" data-title="tuple_expression/array_access">_modifiedWeight[i]</span>, <span class="marker" id="mapping-279"></span><span class="token mv" id="move-src-126" data-title="tuple_expression/array_access">_endBlock[i]</span>)</span> = <span class="marker" id="mapping-280"></span><span class="token upd" id="move-src-127" data-title="call_expression/identifier"><span class="cupd">getUser</span>Info</span>(_pids[i], _user);
        }
    }

    // Safe SHD transfer function, just in case if rounding error causes pool to not have enough SHARDs.
    function safeSHARDTransfer(address _to, uint256 _amount) internal {
        uint256 SHARDBal = SHD.balanceOf(address(this));
        if (_amount &gt; SHARDBal) {
            SHD.transfer(_to, SHARDBal);
        } else {
            SHD.transfer(_to, _amount);
        }
    }

    <span class="marker" id="mapping-281"></span><span class="token del" data-title="contract_body/function_definition">function updateUserInfo(
        <span class="marker" id="mapping-282"></span><span class="token del" data-title="function_definition/parameter"><span class="marker" id="mapping-283"></span><span class="token mv" id="move-src-128" data-title="parameter/type_name">UserInfo</span> storage _user</span>,
        <span class="marker" id="mapping-284"></span><span class="token mv" id="move-src-129" data-title="function_definition/parameter">uint256 _amount</span>,
        <span class="marker" id="mapping-285"></span><span class="token del" data-title="function_definition/parameter">uint256 _originWeight</span>,
        <span class="marker" id="mapping-286"></span><span class="token del" data-title="function_definition/parameter"><span class="marker" id="mapping-287"></span><span class="token mv" id="move-src-130" data-title="parameter/type_name">uint256</span> _endBlock</span>
    ) <span class="marker" id="mapping-288"></span><span class="token mv" id="move-src-131" data-title="function_definition/visibility">private</span> <span class="marker" id="mapping-289"></span><span class="token del" data-title="function_definition/function_body">{
        _user.amount = _amount;
        _user.originWeight = _originWeight;
        _user.endBlock = _endBlock;
    }</span></span>

    <span class="marker" id="mapping-290"></span><span class="token del" data-title="contract_body/function_definition">function getOracleWeight(
        <span class="marker" id="mapping-291"></span><span class="token del" data-title="function_definition/parameter">PoolInfo storage _pool</span>,
        <span class="marker" id="mapping-292"></span><span class="token del" data-title="function_definition/parameter">uint256 _amount</span>
    ) <span class="marker" id="mapping-293"></span><span class="token del" data-title="function_definition/visibility">private</span> <span class="marker" id="mapping-294"></span><span class="token del" data-title="function_definition/return_type_definition">returns (uint256 _oracleWeight)</span> <span class="marker" id="mapping-295"></span><span class="token del" data-title="function_definition/function_body">{
        <span class="marker" id="mapping-296"></span><span class="token del" data-title="function_body/expression_statement"><span class="marker" id="mapping-297"></span><span class="token del" data-title="expression_statement/assignment_expression">_oracleWeight = <span class="marker" id="mapping-298"></span><span class="token del" data-title="assignment_expression/call_expression">calculateOracleWeight(<span class="marker" id="mapping-299"></span><span class="token del" data-title="call_expression/call_argument">_pool</span>, <span class="marker" id="mapping-300"></span><span class="token mv" id="move-src-132" data-title="call_expression/call_argument">_amount</span>)</span></span>;</span>
        <span class="marker" id="mapping-301"></span><span class="token del" data-title="function_body/expression_statement">_pool.oracleWeight = _oracleWeight;</span>
    }</span></span>

    function calculateOracleWeight(PoolInfo storage _pool, uint256 _amount)
        private
        returns (uint256 _oracleWeight)
    {
        uint256 lpTokenTotalSupply =
            IUniswapV2Pair(_pool.lpTokenSwap).totalSupply();
        (uint112 shardReserve, uint112 wantTokenReserve, ) =
            IUniswapV2Pair(_pool.lpTokenSwap).getReserves();
        if (_amount == 0) {
            _amount = _pool.lpTokenAmount;
            if (_amount == 0) {
                return 0;
            }
        }
        if (!_pool.isFirstTokenShard) {
            uint112 wantToken = wantTokenReserve;
            wantTokenReserve = shardReserve;
            shardReserve = wantToken;
        }
        FixedPoint.uq112x112 memory price;
        if(_pool.tokenToEthPairInfo.blockTimestampLast == 0){
            price = initializeTokenOracle(_pool.tokenToEthPairInfo);
        }
        else{
            price = updateTokenOracle(_pool.tokenToEthPairInfo);
        }
        if (
            address(_pool.tokenToEthPairInfo.tokenToEthSwap) ==
            _pool.lpTokenSwap
        ) {
            _oracleWeight = uint256(price.mul(shardReserve).decode144())
                .mul(2)
                .mul(_amount)
                .div(lpTokenTotalSupply);
        } else {
            _oracleWeight = uint256(price.mul(wantTokenReserve).decode144())
                .mul(2)
                .mul(_amount)
                .div(lpTokenTotalSupply);
        }
    }

    function resetInvitationRelationship(
        uint256 _pid,
        <span class="marker" id="mapping-302"></span><span class="token mv" id="move-src-133" data-title="function_definition/parameter">address _user</span>,
        uint256 _originWeight
    ) <span class="marker" id="mapping-303"></span><span class="token mv" id="move-src-134" data-title="function_definition/visibility">private</span> {
        InvitationInfo storage senderRelationshipInfo =
            usersRelationshipInfo[_user];
        if (!senderRelationshipInfo.isWithdrawn){
            <span class="marker" id="mapping-304"></span><span class="token mv" id="move-src-135" data-title="block_statement/expression_statement">senderRelationshipInfo.isWithdrawn = true;</span>
            <span class="marker" id="mapping-305"></span><span class="token mv" id="move-src-136" data-title="block_statement/variable_declaration_statement">InvitationInfo storage invitorRelationshipInfo =
            usersRelationshipInfo[senderRelationshipInfo.invitor];</span>
            <span class="marker" id="mapping-306"></span><span class="token mv" id="move-src-137" data-title="block_statement/variable_declaration_statement">uint256 targetIndex = invitorRelationshipInfo.inviteeIndexMap[_user];</span>
            <span class="marker" id="mapping-307"></span><span class="token mv" id="move-src-138" data-title="block_statement/variable_declaration_statement">uint256 inviteesCount = invitorRelationshipInfo.invitees.length;</span>
            <span class="marker" id="mapping-308"></span><span class="token mv" id="move-src-139" data-title="block_statement/variable_declaration_statement">address lastInvitee =
            invitorRelationshipInfo.invitees[inviteesCount.sub(1)];</span>
            <span class="marker" id="mapping-309"></span><span class="token mv" id="move-src-140" data-title="block_statement/expression_statement">invitorRelationshipInfo.inviteeIndexMap[lastInvitee] = targetIndex;</span>
            <span class="marker" id="mapping-310"></span><span class="token mv" id="move-src-141" data-title="block_statement/expression_statement">invitorRelationshipInfo.invitees[targetIndex] = lastInvitee;</span>
            <span class="marker" id="mapping-311"></span><span class="token mv" id="move-src-142" data-title="block_statement/expression_statement">delete invitorRelationshipInfo.inviteeIndexMap[_user];</span>
            <span class="marker" id="mapping-312"></span><span class="token mv" id="move-src-143" data-title="block_statement/expression_statement">invitorRelationshipInfo.invitees.pop();</span>
        }
        
        UserInfo storage invitorInfo =
            userInfo[_pid][senderRelationshipInfo.invitor];
        UserInfo storage user =
            userInfo[_pid][_user];
        if(!user.isCalculateInvitation){
            return;
        }
        user.isCalculateInvitation = false;
        uint256 inviteeToSubWeight = _originWeight.div(INVITEE_WEIGHT);
        invitorInfo.inviteeWeight = invitorInfo.inviteeWeight.sub(inviteeToSubWeight);
        if (invitorInfo.amount == 0){
            return;
        }
        PoolInfo storage pool = poolInfo[_pid];
        pool.usersTotalWeight = pool.usersTotalWeight.sub(inviteeToSubWeight);
    }

    function modifyWeightByInvitation(
        <span class="marker" id="mapping-313"></span><span class="token del" data-title="function_definition/parameter">uint256 _pid</span><span class="marker" id="mapping-314"></span><span class="token del" data-title="function_definition/,">,</span>
        <span class="marker" id="mapping-315"></span><span class="token del" data-title="function_definition/parameter">address _user</span><span class="marker" id="mapping-316"></span><span class="token del" data-title="function_definition/,">,</span>
        <span class="marker" id="mapping-317"></span><span class="token del" data-title="function_definition/parameter"><span class="marker" id="mapping-318"></span><span class="token mv" id="move-src-144" data-title="parameter/type_name">uint256</span> _oldOriginWeight</span><span class="marker" id="mapping-319"></span><span class="token del" data-title="function_definition/,">,</span>
        <span class="marker" id="mapping-320"></span><span class="token del" data-title="function_definition/parameter"><span class="marker" id="mapping-321"></span><span class="token mv" id="move-src-145" data-title="parameter/type_name">uint256</span> _newOriginWeight</span><span class="marker" id="mapping-322"></span><span class="token del" data-title="function_definition/,">,</span>
        <span class="marker" id="mapping-323"></span><span class="token del" data-title="function_definition/parameter"><span class="marker" id="mapping-324"></span><span class="token mv" id="move-src-146" data-title="parameter/type_name">uint256</span> _inviteeWeight</span><span class="marker" id="mapping-325"></span><span class="token del" data-title="function_definition/,">,</span>
        <span class="marker" id="mapping-326"></span><span class="token del" data-title="function_definition/parameter"><span class="marker" id="mapping-327"></span><span class="token mv" id="move-src-147" data-title="parameter/type_name">uint256</span> _existedAmount</span>
    ) private{
        <span class="marker" id="mapping-328"></span><span class="token mv" id="move-src-148" data-title="function_body/variable_declaration_statement">PoolInfo storage pool = poolInfo[_pid];</span>
        InvitationInfo storage senderInfo = usersRelationshipInfo[<span class="marker" id="mapping-329"></span><span class="token del" data-title="array_access/identifier">_user</span>];
        uint256 poolTotalWeight = <span class="marker" id="mapping-330"></span><span class="token mv" id="move-src-149" data-title="variable_declaration_statement/member_expression">pool.usersTotalWeight</span>;
        <span class="marker" id="mapping-331"></span><span class="token del" data-title="function_body/expression_statement">poolTotalWeight = poolTotalWeight.sub(_oldOriginWeight).add(_newOriginWeight);</span>
        if(<span class="marker" id="mapping-332"></span><span class="token del" data-title="binary_expression/identifier">_existedAmount</span> == 0){
            poolTotalWeight = poolTotalWeight.add(<span class="marker" id="mapping-333"></span><span class="token del" data-title="call_expression/call_argument">_inviteeWeight</span>);
        }     
        <span class="marker" id="mapping-334"></span><span class="token del" data-title="function_body/variable_declaration_statement">UserInfo storage user = userInfo[_pid][_user];</span>
        if (!senderInfo.isWithdrawn || (<span class="marker" id="mapping-335"></span><span class="token del" data-title="binary_expression/identifier">_existedAmount</span> &gt; 0 &amp;&amp; user.isCalculateInvitation)) {
            UserInfo storage invitorInfo = userInfo[<span class="marker" id="mapping-336"></span><span class="token del" data-title="array_access/identifier">_pid</span>][senderInfo.invitor];
            user.isCalculateInvitation = true;
            <span class="marker" id="mapping-337"></span><span class="token del" data-title="block_statement/variable_declaration_statement"><span class="marker" id="mapping-338"></span><span class="token mv" id="move-src-150" data-title="variable_declaration_statement/variable_declaration">uint256 <span class="marker" id="mapping-339"></span><span class="token upd" id="move-src-151" data-title="variable_declaration/identifier">addI<span class="cupd">nvit</span><span class="cupd">e</span>e<span class="cupd">Weight</span></span></span> =
                    <span class="marker" id="mapping-340"></span><span class="token del" data-title="variable_declaration_statement/call_expression"><span class="marker" id="mapping-341"></span><span class="token del" data-title="call_expression/member_expression"><span class="marker" id="mapping-342"></span><span class="token del" data-title="member_expression/call_expression"><span class="marker" id="mapping-343"></span><span class="token del" data-title="call_expression/member_expression">_newOriginWeight.div</span>(<span class="marker" id="mapping-344"></span><span class="token mv" id="move-src-152" data-title="call_expression/call_argument">INVITEE_WEIGHT</span>)</span>.sub</span>(
                        <span class="marker" id="mapping-345"></span><span class="token del" data-title="call_expression/call_argument"><span class="marker" id="mapping-346"></span><span class="token del" data-title="call_argument/call_expression"><span class="marker" id="mapping-347"></span><span class="token del" data-title="call_expression/member_expression">_oldOriginWeight.div</span>(<span class="marker" id="mapping-348"></span><span class="token mv" id="move-src-153" data-title="call_expression/call_argument">INVITEE_WEIGHT</span>)</span></span>
                    )</span>;</span>
            invitorInfo.inviteeWeight = invitorInfo.inviteeWeight.add(
                <span class="marker" id="mapping-349"></span><span class="token del" data-title="call_argument/identifier">addInviteeWeight</span>
            );
            <span class="marker" id="mapping-350"></span><span class="token del" data-title="block_statement/variable_declaration_statement"><span class="marker" id="mapping-351"></span><span class="token mv" id="move-src-154" data-title="variable_declaration_statement/variable_declaration">uint256 <span class="marker" id="mapping-352"></span><span class="token upd" id="move-src-155" data-title="variable_declaration/identifier">addI<span class="cupd">nvitor</span>W<span class="cupd">e</span>ight</span></span> = 
                    <span class="marker" id="mapping-353"></span><span class="token del" data-title="variable_declaration_statement/call_expression"><span class="marker" id="mapping-354"></span><span class="token del" data-title="call_expression/member_expression"><span class="marker" id="mapping-355"></span><span class="token del" data-title="member_expression/call_expression"><span class="marker" id="mapping-356"></span><span class="token del" data-title="call_expression/member_expression">_newOriginWeight.div</span>(<span class="marker" id="mapping-357"></span><span class="token mv" id="move-src-156" data-title="call_expression/call_argument">INVITOR_WEIGHT</span>)</span>.sub</span>(
                        <span class="marker" id="mapping-358"></span><span class="token del" data-title="call_expression/call_argument"><span class="marker" id="mapping-359"></span><span class="token del" data-title="call_argument/call_expression"><span class="marker" id="mapping-360"></span><span class="token del" data-title="call_expression/member_expression">_oldOriginWeight.div</span>(<span class="marker" id="mapping-361"></span><span class="token mv" id="move-src-157" data-title="call_expression/call_argument">INVITOR_WEIGHT</span>)</span></span>
                    )</span>;</span>
            
            poolTotalWeight = poolTotalWeight.add(<span class="marker" id="mapping-362"></span><span class="token del" data-title="call_argument/identifier">addInvitorWeight</span>);
            if (invitorInfo.amount &gt; 0) {
                poolTotalWeight = poolTotalWeight.add(<span class="marker" id="mapping-363"></span><span class="token del" data-title="call_argument/identifier">addInviteeWeight</span>);
            } 
        }
        pool.usersTotalWeight = poolTotalWeight;
    }

    <span class="marker" id="mapping-364"></span><span class="token del" data-title="contract_body/function_definition">function verifyDescription(<span class="marker" id="mapping-365"></span><span class="token del" data-title="function_definition/parameter">string memory description</span>)
        <span class="marker" id="mapping-366"></span><span class="token mv" id="move-src-158" data-title="function_definition/visibility">internal</span>
        <span class="marker" id="mapping-367"></span><span class="token del" data-title="function_definition/state_mutability">pure</span>
        <span class="marker" id="mapping-368"></span><span class="token del" data-title="function_definition/return_type_definition">returns (<span class="marker" id="mapping-369"></span><span class="token mv" id="move-src-159" data-title="return_type_definition/parameter">bool <span class="marker" id="mapping-370"></span><span class="token upd" id="move-src-160" data-title="parameter/identifier"><span class="cupd">s</span>uccess</span></span>)</span>
    <span class="marker" id="mapping-371"></span><span class="token del" data-title="function_definition/function_body">{
        <span class="marker" id="mapping-372"></span><span class="token del" data-title="function_body/variable_declaration_statement">bytes memory nameBytes = bytes(description);</span>
        <span class="marker" id="mapping-373"></span><span class="token mv" id="move-src-161" data-title="function_body/variable_declaration_statement">uint256 <span class="marker" id="mapping-374"></span><span class="token upd" id="move-src-162" data-title="variable_declaration/identifier"><span class="cupd">n</span><span class="cupd">a</span>m<span class="cupd">e</span>Len<span class="cupd">g</span>th</span> = <span class="marker" id="mapping-375"></span><span class="token del" data-title="variable_declaration_statement/member_expression">nameBytes.length</span>;</span>
        <span class="marker" id="mapping-376"></span><span class="token del" data-title="function_body/expression_statement">require(nameLength &gt; 0, "INVALID INPUT");</span>
        <span class="marker" id="mapping-377"></span><span class="token del" data-title="function_body/expression_statement">success = true;</span>
        <span class="marker" id="mapping-378"></span><span class="token del" data-title="function_body/variable_declaration_statement">bool n7;</span>
        <span class="marker" id="mapping-379"></span><span class="token del" data-title="function_body/for_statement">for (uint256 i = 0; i &lt;= nameLength - 1; i++) {
            n7 = (nameBytes[i] &amp; 0x80) == 0x80 ? true : false;
            if (n7) {
                success = false;
                break;
            }
        }</span>
    }</span></span>

    function getUserModifiedWeight(uint256 _pid, address _user) private view returns (uint256){
        UserInfo storage user =  userInfo[_pid][_user];
        uint256 originWeight = user.originWeight;
        uint256 modifiedWeight = originWeight.add(user.inviteeWeight);
        if(user.isCalculateInvitation){
            modifiedWeight = modifiedWeight.add(originWeight.div(INVITOR_WEIGHT));
        }
        return modifiedWeight;
    }

        // get how much token will be mined from _toBlock to _toBlock.
    function getRewardToken(uint256 _fromBlock, uint256 _toBlock) public view virtual returns (uint256){
        return calculateRewardToken(MINT_DECREASE_TERM, SHDPerBlock, startBlock, _fromBlock, _toBlock);
    }

    function calculateRewardToken(uint _term, uint256 _initialBlock, uint256 _startBlock, uint256 _fromBlock, uint256 _toBlock) private pure returns (uint256){
        if(_fromBlock &gt; _toBlock || _startBlock &gt; _toBlock)
            return 0;
        if(_startBlock &gt; _fromBlock)
            _fromBlock = _startBlock;
        uint256 totalReward = 0;
        uint256 blockPeriod = _fromBlock.sub(_startBlock).add(1);
        uint256 yearPeriod = blockPeriod.div(_term);  // produce 5760 blocks per day, 2102400 blocks per year.
        for (uint256 i = 0; i &lt; yearPeriod; i++){
            _initialBlock = _initialBlock.div(2);
        }
        uint256 termStartIndex = yearPeriod.add(1).mul(_term).add(_startBlock);
        uint256 beforeCalculateIndex = _fromBlock.sub(1);
        while(_toBlock &gt;= termStartIndex &amp;&amp; _initialBlock &gt; 0){
            totalReward = totalReward.add(termStartIndex.sub(beforeCalculateIndex).mul(_initialBlock));
            beforeCalculateIndex = termStartIndex.add(1);
            _initialBlock = _initialBlock.div(2);
            termStartIndex = termStartIndex.add(_term);
        }
        if(_toBlock &gt; beforeCalculateIndex){
            totalReward = totalReward.add(_toBlock.sub(beforeCalculateIndex).mul(_initialBlock));
        }
        return totalReward;
    }

    function getTargetTokenInSwap(IUniswapV2Pair _lpTokenSwap, address _targetToken) internal view returns (address, address, uint256){
        address token0 = _lpTokenSwap.token0();
        address token1 = _lpTokenSwap.token1();
        if(token0 == _targetToken){
            return(token0, token1, 0);
        }
        if(token1 == _targetToken){
            return(token0, token1, 1);
        }
        require(false, "invalid uniswap");
    }

    function generateOrcaleInfo(IUniswapV2Pair _pairSwap, bool _isFirstTokenEth) internal view returns(TokenPairInfo memory){
        uint256 priceTokenCumulativeLast = _isFirstTokenEth? _pairSwap.price1CumulativeLast(): _pairSwap.price0CumulativeLast();
        uint32 tokenBlockTimestampLast = 0;
        if(priceTokenCumulativeLast != 0){
            (, , tokenBlockTimestampLast) = _pairSwap.getReserves();
        }
        TokenPairInfo memory tokenBInfo = TokenPairInfo({
            tokenToEthSwap: _pairSwap,
            isFirstTokenEth: _isFirstTokenEth,
            priceCumulativeLast: priceTokenCumulativeLast,
            blockTimestampLast: tokenBlockTimestampLast,
            price: FixedPoint.uq112x112(0),
            lastPriceUpdateHeight: block.number
        });
        return tokenBInfo;
    }

    function initializeTokenOracle(TokenPairInfo storage _pairInfo) internal returns (FixedPoint.uq112x112 memory _price){
        uint32 blockTimestamp = uint32(block.timestamp % 2 ** 32);
        uint32 timeElapsed;
        uint256 initialPriceCumulative;
        (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast) = IUniswapV2Pair(_pairInfo.tokenToEthSwap).getReserves();
        if(_pairInfo.isFirstTokenEth){
            _price = FixedPoint.fraction(reserve0, reserve1);
            initialPriceCumulative = IUniswapV2Pair(_pairInfo.tokenToEthSwap).price1CumulativeLast();
        }
        else{
            _price = FixedPoint.fraction(reserve1, reserve0);
            initialPriceCumulative = IUniswapV2Pair(_pairInfo.tokenToEthSwap).price0CumulativeLast();
        }
        _pairInfo.price = _price;
        timeElapsed = blockTimestamp - blockTimestampLast;
        initialPriceCumulative = initialPriceCumulative.add(uint(_price._x).mul(timeElapsed));
        _pairInfo.priceCumulativeLast = initialPriceCumulative;
        _pairInfo.lastPriceUpdateHeight = block.number;
        _pairInfo.blockTimestampLast = blockTimestamp;
        return _price;
    }

    function updateTokenOracle(TokenPairInfo storage _pairInfo) internal returns (FixedPoint.uq112x112 memory _price) {
        FixedPoint.uq112x112 memory cachedPrice = _pairInfo.price;
        if(cachedPrice._x &gt; 0 &amp;&amp; block.number.sub(_pairInfo.lastPriceUpdateHeight) &lt;= updateTokenPriceTerm){
            return cachedPrice;
        }
        (uint price0Cumulative, uint price1Cumulative, uint32 blockTimestamp) =
            UniswapV2OracleLibrary.currentCumulativePrices(address(_pairInfo.tokenToEthSwap));
        uint32 timeElapsed = blockTimestamp - _pairInfo.blockTimestampLast; // overflow is desired
        // overflow is desired, casting never truncates
        // cumulative price is in (uq112x112 price * seconds) units so we simply wrap it after division by time elapsed
        if(_pairInfo.isFirstTokenEth){
            _price = FixedPoint.uq112x112(uint224(price1Cumulative.sub(_pairInfo.priceCumulativeLast).div(timeElapsed)));
            _pairInfo.priceCumulativeLast = price1Cumulative;
        }     
        else{
            _price = FixedPoint.uq112x112(uint224(price0Cumulative.sub(_pairInfo.priceCumulativeLast).div(timeElapsed)));
            _pairInfo.priceCumulativeLast = price0Cumulative;
        }
        _pairInfo.price = _price;
        _pairInfo.lastPriceUpdateHeight = block.number;
        _pairInfo.blockTimestampLast = blockTimestamp;
    }

    function updateAfterModifyStartBlock(uint256 _newStartBlock) internal override{
        lastRewardBlock = _newStartBlock.sub(1);
        if(poolInfo.length &gt; 0){
            PoolInfo storage shdPool = poolInfo[0];
            shdPool.lastDividendHeight = lastRewardBlock;
        }
    }
}

// File: contracts/ShardingDAOMiningDelegate.sol


pragma solidity 0.6.12;



contract ShardingDAOMiningDelegate is DelegateInterface, ShardingDAOMining {
    /**
     * @notice Construct an empty delegate
     */
    constructor() public {}

    /**
     * @notice Called by the delegator on a delegate to initialize it for duty
     * @param data The encoded bytes data for any initialization
     */
    function _becomeImplementation(bytes memory data)
        public
        override
    {
        checkAdmin();
        // Shh -- currently unused
        data;

        // Shh -- we don't ever want this hook to be marked pure
        if (false) {
            implementation = address(0);
        }
    }

    /**
     * @notice Called by the delegator on a delegate to forfeit its responsibility
     */
    function _resignImplementation() public override {
        checkAdmin();
        // Shh -- we don't ever want this hook to be marked pure
        if (false) {
            implementation = address(0);
        }
    }
}</pre></div><div class="col-6"><h5>0x5cb8a52bb5191be839bbdb69bd0b24b8cbb72540.etherscan.io-ShardingDAOMiningDelegate.sol</h5><pre class="pre-scrollable">// File: interfaces/DelegatorInterface.sol

pragma solidity 0.6.12;
pragma experimental ABIEncoderV2;

contract DelegationStorage {
    /**
     * @notice Implementation address for this contract
     */
    address public implementation;
}

abstract contract DelegatorInterface is DelegationStorage {
    /**
     * @notice Emitted when implementation is changed
     */
    event NewImplementation(
        address oldImplementation,
        address newImplementation
    );

    /**
     * @notice Called by the admin to update the implementation of the delegator
     * @param implementation_ The address of the new implementation for delegation
     * @param allowResign Flag to indicate whether to call _resignImplementation on the old implementation
     * @param becomeImplementationData The encoded bytes data to be passed to _becomeImplementation
     */
    function _setImplementation(
        address implementation_,
        bool allowResign,
        bytes memory becomeImplementationData
    ) public virtual;
}

abstract contract DelegateInterface is DelegationStorage {
    /**
     * @notice Called by the delegator on a delegate to initialize it for duty
     * @dev Should revert if any issues arise which make it unfit for delegation
     * @param data The encoded bytes data for any initialization
     */
    function _becomeImplementation(bytes memory data) public virtual;

    /**
     * @notice Called by the delegator on a delegate to forfeit its responsibility
     */
    function _resignImplementation() public virtual;
}

// File: @openzeppelin/contracts/token/ERC20/IERC20.sol



pragma solidity &gt;=0.6.0 &lt;0.8.0;

/**
 * @dev Interface of the ERC20 standard as defined in the EIP.
 */
interface IERC20 {
    /**
     * @dev Returns the amount of tokens in existence.
     */
    function totalSupply() external view returns (uint256);

    /**
     * @dev Returns the amount of tokens owned by `account`.
     */
    function balanceOf(address account) external view returns (uint256);

    /**
     * @dev Moves `amount` tokens from the caller's account to `recipient`.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * Emits a {Transfer} event.
     */
    function transfer(address recipient, uint256 amount) external returns (bool);

    /**
     * @dev Returns the remaining number of tokens that `spender` will be
     * allowed to spend on behalf of `owner` through {transferFrom}. This is
     * zero by default.
     *
     * This value changes when {approve} or {transferFrom} are called.
     */
    function allowance(address owner, address spender) external view returns (uint256);

    /**
     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * IMPORTANT: Beware that changing an allowance with this method brings the risk
     * that someone may use both the old and the new allowance by unfortunate
     * transaction ordering. One possible solution to mitigate this race
     * condition is to first reduce the spender's allowance to 0 and set the
     * desired value afterwards:
     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
     *
     * Emits an {Approval} event.
     */
    function approve(address spender, uint256 amount) external returns (bool);

    /**
     * @dev Moves `amount` tokens from `sender` to `recipient` using the
     * allowance mechanism. `amount` is then deducted from the caller's
     * allowance.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * Emits a {Transfer} event.
     */
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);

    /**
     * @dev Emitted when `value` tokens are moved from one account (`from`) to
     * another (`to`).
     *
     * Note that `value` may be zero.
     */
    event Transfer(address indexed from, address indexed to, uint256 value);

    /**
     * @dev Emitted when the allowance of a `spender` for an `owner` is set by
     * a call to {approve}. `value` is the new allowance.
     */
    event Approval(address indexed owner, address indexed spender, uint256 value);
}

// File: @openzeppelin/contracts/math/SafeMath.sol



pragma solidity &gt;=0.6.0 &lt;0.8.0;

/**
 * @dev Wrappers over Solidity's arithmetic operations with added overflow
 * checks.
 *
 * Arithmetic operations in Solidity wrap on overflow. This can easily result
 * in bugs, because programmers usually assume that an overflow raises an
 * error, which is the standard behavior in high level programming languages.
 * `SafeMath` restores this intuition by reverting the transaction when an
 * operation overflows.
 *
 * Using this library instead of the unchecked operations eliminates an entire
 * class of bugs, so it's recommended to use it always.
 */
library SafeMath {
    /**
     * @dev Returns the addition of two unsigned integers, with an overflow flag.
     *
     * _Available since v3.4._
     */
    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {
        uint256 c = a + b;
        if (c &lt; a) return (false, 0);
        return (true, c);
    }

    /**
     * @dev Returns the substraction of two unsigned integers, with an overflow flag.
     *
     * _Available since v3.4._
     */
    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {
        if (b &gt; a) return (false, 0);
        return (true, a - b);
    }

    /**
     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.
     *
     * _Available since v3.4._
     */
    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {
        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the
        // benefit is lost if 'b' is also tested.
        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522
        if (a == 0) return (true, 0);
        uint256 c = a * b;
        if (c / a != b) return (false, 0);
        return (true, c);
    }

    /**
     * @dev Returns the division of two unsigned integers, with a division by zero flag.
     *
     * _Available since v3.4._
     */
    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {
        if (b == 0) return (false, 0);
        return (true, a / b);
    }

    /**
     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.
     *
     * _Available since v3.4._
     */
    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {
        if (b == 0) return (false, 0);
        return (true, a % b);
    }

    /**
     * @dev Returns the addition of two unsigned integers, reverting on
     * overflow.
     *
     * Counterpart to Solidity's `+` operator.
     *
     * Requirements:
     *
     * - Addition cannot overflow.
     */
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c &gt;= a, "SafeMath: addition overflow");
        return c;
    }

    /**
     * @dev Returns the subtraction of two unsigned integers, reverting on
     * overflow (when the result is negative).
     *
     * Counterpart to Solidity's `-` operator.
     *
     * Requirements:
     *
     * - Subtraction cannot overflow.
     */
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b &lt;= a, "SafeMath: subtraction overflow");
        return a - b;
    }

    /**
     * @dev Returns the multiplication of two unsigned integers, reverting on
     * overflow.
     *
     * Counterpart to Solidity's `*` operator.
     *
     * Requirements:
     *
     * - Multiplication cannot overflow.
     */
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        if (a == 0) return 0;
        uint256 c = a * b;
        require(c / a == b, "SafeMath: multiplication overflow");
        return c;
    }

    /**
     * @dev Returns the integer division of two unsigned integers, reverting on
     * division by zero. The result is rounded towards zero.
     *
     * Counterpart to Solidity's `/` operator. Note: this function uses a
     * `revert` opcode (which leaves remaining gas untouched) while Solidity
     * uses an invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     *
     * - The divisor cannot be zero.
     */
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b &gt; 0, "SafeMath: division by zero");
        return a / b;
    }

    /**
     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),
     * reverting when dividing by zero.
     *
     * Counterpart to Solidity's `%` operator. This function uses a `revert`
     * opcode (which leaves remaining gas untouched) while Solidity uses an
     * invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     *
     * - The divisor cannot be zero.
     */
    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b &gt; 0, "SafeMath: modulo by zero");
        return a % b;
    }

    /**
     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on
     * overflow (when the result is negative).
     *
     * CAUTION: This function is deprecated because it requires allocating memory for the error
     * message unnecessarily. For custom revert reasons use {trySub}.
     *
     * Counterpart to Solidity's `-` operator.
     *
     * Requirements:
     *
     * - Subtraction cannot overflow.
     */
    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
        require(b &lt;= a, errorMessage);
        return a - b;
    }

    /**
     * @dev Returns the integer division of two unsigned integers, reverting with custom message on
     * division by zero. The result is rounded towards zero.
     *
     * CAUTION: This function is deprecated because it requires allocating memory for the error
     * message unnecessarily. For custom revert reasons use {tryDiv}.
     *
     * Counterpart to Solidity's `/` operator. Note: this function uses a
     * `revert` opcode (which leaves remaining gas untouched) while Solidity
     * uses an invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     *
     * - The divisor cannot be zero.
     */
    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
        require(b &gt; 0, errorMessage);
        return a / b;
    }

    /**
     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),
     * reverting with custom message when dividing by zero.
     *
     * CAUTION: This function is deprecated because it requires allocating memory for the error
     * message unnecessarily. For custom revert reasons use {tryMod}.
     *
     * Counterpart to Solidity's `%` operator. This function uses a `revert`
     * opcode (which leaves remaining gas untouched) while Solidity uses an
     * invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     *
     * - The divisor cannot be zero.
     */
    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
        require(b &gt; 0, errorMessage);
        return a % b;
    }
}

// File: @openzeppelin/contracts/utils/Address.sol



pragma solidity &gt;=0.6.2 &lt;0.8.0;

/**
 * @dev Collection of functions related to the address type
 */
library Address {
    /**
     * @dev Returns true if `account` is a contract.
     *
     * [IMPORTANT]
     * ====
     * It is unsafe to assume that an address for which this function returns
     * false is an externally-owned account (EOA) and not a contract.
     *
     * Among others, `isContract` will return false for the following
     * types of addresses:
     *
     *  - an externally-owned account
     *  - a contract in construction
     *  - an address where a contract will be created
     *  - an address where a contract lived, but was destroyed
     * ====
     */
    function isContract(address account) internal view returns (bool) {
        // This method relies on extcodesize, which returns 0 for contracts in
        // construction, since the code is only stored at the end of the
        // constructor execution.

        uint256 size;
        // solhint-disable-next-line no-inline-assembly
        assembly { size := extcodesize(account) }
        return size &gt; 0;
    }

    /**
     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to
     * `recipient`, forwarding all available gas and reverting on errors.
     *
     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost
     * of certain opcodes, possibly making contracts go over the 2300 gas limit
     * imposed by `transfer`, making them unable to receive funds via
     * `transfer`. {sendValue} removes this limitation.
     *
     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].
     *
     * IMPORTANT: because control is transferred to `recipient`, care must be
     * taken to not create reentrancy vulnerabilities. Consider using
     * {ReentrancyGuard} or the
     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].
     */
    function sendValue(address payable recipient, uint256 amount) internal {
        require(address(this).balance &gt;= amount, "Address: insufficient balance");

        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value
        (bool success, ) = recipient.call{ value: amount }("");
        require(success, "Address: unable to send value, recipient may have reverted");
    }

    /**
     * @dev Performs a Solidity function call using a low level `call`. A
     * plain`call` is an unsafe replacement for a function call: use this
     * function instead.
     *
     * If `target` reverts with a revert reason, it is bubbled up by this
     * function (like regular Solidity function calls).
     *
     * Returns the raw returned data. To convert to the expected return value,
     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].
     *
     * Requirements:
     *
     * - `target` must be a contract.
     * - calling `target` with `data` must not revert.
     *
     * _Available since v3.1._
     */
    function functionCall(address target, bytes memory data) internal returns (bytes memory) {
      return functionCall(target, data, "Address: low-level call failed");
    }

    /**
     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with
     * `errorMessage` as a fallback revert reason when `target` reverts.
     *
     * _Available since v3.1._
     */
    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {
        return functionCallWithValue(target, data, 0, errorMessage);
    }

    /**
     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],
     * but also transferring `value` wei to `target`.
     *
     * Requirements:
     *
     * - the calling contract must have an ETH balance of at least `value`.
     * - the called Solidity function must be `payable`.
     *
     * _Available since v3.1._
     */
    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {
        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");
    }

    /**
     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but
     * with `errorMessage` as a fallback revert reason when `target` reverts.
     *
     * _Available since v3.1._
     */
    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {
        require(address(this).balance &gt;= value, "Address: insufficient balance for call");
        require(isContract(target), "Address: call to non-contract");

        // solhint-disable-next-line avoid-low-level-calls
        (bool success, bytes memory returndata) = target.call{ value: value }(data);
        return _verifyCallResult(success, returndata, errorMessage);
    }

    /**
     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],
     * but performing a static call.
     *
     * _Available since v3.3._
     */
    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {
        return functionStaticCall(target, data, "Address: low-level static call failed");
    }

    /**
     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],
     * but performing a static call.
     *
     * _Available since v3.3._
     */
    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {
        require(isContract(target), "Address: static call to non-contract");

        // solhint-disable-next-line avoid-low-level-calls
        (bool success, bytes memory returndata) = target.staticcall(data);
        return _verifyCallResult(success, returndata, errorMessage);
    }

    /**
     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],
     * but performing a delegate call.
     *
     * _Available since v3.4._
     */
    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {
        return functionDelegateCall(target, data, "Address: low-level delegate call failed");
    }

    /**
     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],
     * but performing a delegate call.
     *
     * _Available since v3.4._
     */
    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {
        require(isContract(target), "Address: delegate call to non-contract");

        // solhint-disable-next-line avoid-low-level-calls
        (bool success, bytes memory returndata) = target.delegatecall(data);
        return _verifyCallResult(success, returndata, errorMessage);
    }

    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {
        if (success) {
            return returndata;
        } else {
            // Look for revert reason and bubble it up if present
            if (returndata.length &gt; 0) {
                // The easiest way to bubble the revert reason is using memory via assembly

                // solhint-disable-next-line no-inline-assembly
                assembly {
                    let returndata_size := mload(returndata)
                    revert(add(32, returndata), returndata_size)
                }
            } else {
                revert(errorMessage);
            }
        }
    }
}

// File: @openzeppelin/contracts/token/ERC20/SafeERC20.sol



pragma solidity &gt;=0.6.0 &lt;0.8.0;




/**
 * @title SafeERC20
 * @dev Wrappers around ERC20 operations that throw on failure (when the token
 * contract returns false). Tokens that return no value (and instead revert or
 * throw on failure) are also supported, non-reverting calls are assumed to be
 * successful.
 * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,
 * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.
 */
library SafeERC20 {
    using SafeMath for uint256;
    using Address for address;

    function safeTransfer(IERC20 token, address to, uint256 value) internal {
        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));
    }

    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {
        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));
    }

    /**
     * @dev Deprecated. This function has issues similar to the ones found in
     * {IERC20-approve}, and its usage is discouraged.
     *
     * Whenever possible, use {safeIncreaseAllowance} and
     * {safeDecreaseAllowance} instead.
     */
    function safeApprove(IERC20 token, address spender, uint256 value) internal {
        // safeApprove should only be called when setting an initial allowance,
        // or when resetting it to zero. To increase and decrease it, use
        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'
        // solhint-disable-next-line max-line-length
        require((value == 0) || (token.allowance(address(this), spender) == 0),
            "SafeERC20: approve from non-zero to non-zero allowance"
        );
        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));
    }

    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {
        uint256 newAllowance = token.allowance(address(this), spender).add(value);
        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));
    }

    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {
        uint256 newAllowance = token.allowance(address(this), spender).sub(value, "SafeERC20: decreased allowance below zero");
        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));
    }

    /**
     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement
     * on the return value: the return value is optional (but if data is returned, it must not be false).
     * @param token The token targeted by the call.
     * @param data The call data (encoded using abi.encode or one of its variants).
     */
    function _callOptionalReturn(IERC20 token, bytes memory data) private {
        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since
        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that
        // the target address contains contract code and also asserts for success in the low-level call.

        bytes memory returndata = address(token).functionCall(data, "SafeERC20: low-level call failed");
        if (returndata.length &gt; 0) { // Return data is optional
            // solhint-disable-next-line max-line-length
            require(abi.decode(returndata, (bool)), "SafeERC20: ERC20 operation did not succeed");
        }
    }
}

// File: @openzeppelin/contracts/utils/Context.sol



pragma solidity &gt;=0.6.0 &lt;0.8.0;

/*
 * @dev Provides information about the current execution context, including the
 * sender of the transaction and its data. While these are generally available
 * via msg.sender and msg.data, they should not be accessed in such a direct
 * manner, since when dealing with GSN meta-transactions the account sending and
 * paying for execution may not be the actual sender (as far as an application
 * is concerned).
 *
 * This contract is only required for intermediate, library-like contracts.
 */
abstract contract Context {
    function _msgSender() internal view virtual returns (address payable) {
        return msg.sender;
    }

    function _msgData() internal view virtual returns (bytes memory) {
        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691
        return msg.data;
    }
}

// File: @openzeppelin/contracts/access/Ownable.sol



pragma solidity &gt;=0.6.0 &lt;0.8.0;

/**
 * @dev Contract module which provides a basic access control mechanism, where
 * there is an account (an owner) that can be granted exclusive access to
 * specific functions.
 *
 * By default, the owner account will be the one that deploys the contract. This
 * can later be changed with {transferOwnership}.
 *
 * This module is used through inheritance. It will make available the modifier
 * `onlyOwner`, which can be applied to your functions to restrict their use to
 * the owner.
 */
abstract contract Ownable is Context {
    address private _owner;

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    /**
     * @dev Initializes the contract setting the deployer as the initial owner.
     */
    constructor () internal {
        address msgSender = _msgSender();
        _owner = msgSender;
        emit OwnershipTransferred(address(0), msgSender);
    }

    /**
     * @dev Returns the address of the current owner.
     */
    function owner() public view virtual returns (address) {
        return _owner;
    }

    /**
     * @dev Throws if called by any account other than the owner.
     */
    modifier onlyOwner() {
        require(owner() == _msgSender(), "Ownable: caller is not the owner");
        _;
    }

    /**
     * @dev Leaves the contract without owner. It will not be possible to call
     * `onlyOwner` functions anymore. Can only be called by the current owner.
     *
     * NOTE: Renouncing ownership will leave the contract without an owner,
     * thereby removing any functionality that is only available to the owner.
     */
    function renounceOwnership() public virtual onlyOwner {
        emit OwnershipTransferred(_owner, address(0));
        _owner = address(0);
    }

    /**
     * @dev Transfers ownership of the contract to a new account (`newOwner`).
     * Can only be called by the current owner.
     */
    function transferOwnership(address newOwner) public virtual onlyOwner {
        require(newOwner != address(0), "Ownable: new owner is the zero address");
        emit OwnershipTransferred(_owner, newOwner);
        _owner = newOwner;
    }
}

// File: @uniswap/lib/contracts/libraries/FullMath.sol

pragma solidity &gt;=0.4.0;

// taken from https://medium.com/coinmonks/math-in-solidity-part-3-percents-and-proportions-4db014e080b1
// license is CC-BY-4.0
library FullMath {
    function fullMul(uint256 x, uint256 y) internal pure returns (uint256 l, uint256 h) {
        uint256 mm = mulmod(x, y, uint256(-1));
        l = x * y;
        h = mm - l;
        if (mm &lt; l) h -= 1;
    }

    function fullDiv(
        uint256 l,
        uint256 h,
        uint256 d
    ) private pure returns (uint256) {
        uint256 pow2 = d &amp; -d;
        d /= pow2;
        l /= pow2;
        l += h * ((-pow2) / pow2 + 1);
        uint256 r = 1;
        r *= 2 - d * r;
        r *= 2 - d * r;
        r *= 2 - d * r;
        r *= 2 - d * r;
        r *= 2 - d * r;
        r *= 2 - d * r;
        r *= 2 - d * r;
        r *= 2 - d * r;
        return l * r;
    }

    function mulDiv(
        uint256 x,
        uint256 y,
        uint256 d
    ) internal pure returns (uint256) {
        (uint256 l, uint256 h) = fullMul(x, y);

        uint256 mm = mulmod(x, y, d);
        if (mm &gt; l) h -= 1;
        l -= mm;

        if (h == 0) return l / d;

        require(h &lt; d, 'FullMath: FULLDIV_OVERFLOW');
        return fullDiv(l, h, d);
    }
}

// File: @uniswap/lib/contracts/libraries/Babylonian.sol


pragma solidity &gt;=0.4.0;

// computes square roots using the babylonian method
// https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method
library Babylonian {
    // credit for this implementation goes to
    // https://github.com/abdk-consulting/abdk-libraries-solidity/blob/master/ABDKMath64x64.sol#L687
    function sqrt(uint256 x) internal pure returns (uint256) {
        if (x == 0) return 0;
        // this block is equivalent to r = uint256(1) &lt;&lt; (BitMath.mostSignificantBit(x) / 2);
        // however that code costs significantly more gas
        uint256 xx = x;
        uint256 r = 1;
        if (xx &gt;= 0x100000000000000000000000000000000) {
            xx &gt;&gt;= 128;
            r &lt;&lt;= 64;
        }
        if (xx &gt;= 0x10000000000000000) {
            xx &gt;&gt;= 64;
            r &lt;&lt;= 32;
        }
        if (xx &gt;= 0x100000000) {
            xx &gt;&gt;= 32;
            r &lt;&lt;= 16;
        }
        if (xx &gt;= 0x10000) {
            xx &gt;&gt;= 16;
            r &lt;&lt;= 8;
        }
        if (xx &gt;= 0x100) {
            xx &gt;&gt;= 8;
            r &lt;&lt;= 4;
        }
        if (xx &gt;= 0x10) {
            xx &gt;&gt;= 4;
            r &lt;&lt;= 2;
        }
        if (xx &gt;= 0x8) {
            r &lt;&lt;= 1;
        }
        r = (r + x / r) &gt;&gt; 1;
        r = (r + x / r) &gt;&gt; 1;
        r = (r + x / r) &gt;&gt; 1;
        r = (r + x / r) &gt;&gt; 1;
        r = (r + x / r) &gt;&gt; 1;
        r = (r + x / r) &gt;&gt; 1;
        r = (r + x / r) &gt;&gt; 1; // Seven iterations should be enough
        uint256 r1 = x / r;
        return (r &lt; r1 ? r : r1);
    }
}

// File: @uniswap/lib/contracts/libraries/BitMath.sol

pragma solidity &gt;=0.5.0;

library BitMath {
    // returns the 0 indexed position of the most significant bit of the input x
    // s.t. x &gt;= 2**msb and x &lt; 2**(msb+1)
    function mostSignificantBit(uint256 x) internal pure returns (uint8 r) {
        require(x &gt; 0, 'BitMath::mostSignificantBit: zero');

        if (x &gt;= 0x100000000000000000000000000000000) {
            x &gt;&gt;= 128;
            r += 128;
        }
        if (x &gt;= 0x10000000000000000) {
            x &gt;&gt;= 64;
            r += 64;
        }
        if (x &gt;= 0x100000000) {
            x &gt;&gt;= 32;
            r += 32;
        }
        if (x &gt;= 0x10000) {
            x &gt;&gt;= 16;
            r += 16;
        }
        if (x &gt;= 0x100) {
            x &gt;&gt;= 8;
            r += 8;
        }
        if (x &gt;= 0x10) {
            x &gt;&gt;= 4;
            r += 4;
        }
        if (x &gt;= 0x4) {
            x &gt;&gt;= 2;
            r += 2;
        }
        if (x &gt;= 0x2) r += 1;
    }

    // returns the 0 indexed position of the least significant bit of the input x
    // s.t. (x &amp; 2**lsb) != 0 and (x &amp; (2**(lsb) - 1)) == 0)
    // i.e. the bit at the index is set and the mask of all lower bits is 0
    function leastSignificantBit(uint256 x) internal pure returns (uint8 r) {
        require(x &gt; 0, 'BitMath::leastSignificantBit: zero');

        r = 255;
        if (x &amp; uint128(-1) &gt; 0) {
            r -= 128;
        } else {
            x &gt;&gt;= 128;
        }
        if (x &amp; uint64(-1) &gt; 0) {
            r -= 64;
        } else {
            x &gt;&gt;= 64;
        }
        if (x &amp; uint32(-1) &gt; 0) {
            r -= 32;
        } else {
            x &gt;&gt;= 32;
        }
        if (x &amp; uint16(-1) &gt; 0) {
            r -= 16;
        } else {
            x &gt;&gt;= 16;
        }
        if (x &amp; uint8(-1) &gt; 0) {
            r -= 8;
        } else {
            x &gt;&gt;= 8;
        }
        if (x &amp; 0xf &gt; 0) {
            r -= 4;
        } else {
            x &gt;&gt;= 4;
        }
        if (x &amp; 0x3 &gt; 0) {
            r -= 2;
        } else {
            x &gt;&gt;= 2;
        }
        if (x &amp; 0x1 &gt; 0) r -= 1;
    }
}

// File: @uniswap/lib/contracts/libraries/FixedPoint.sol

pragma solidity &gt;=0.4.0;




// a library for handling binary fixed point numbers (https://en.wikipedia.org/wiki/Q_(number_format))
library FixedPoint {
    // range: [0, 2**112 - 1]
    // resolution: 1 / 2**112
    struct uq112x112 {
        uint224 _x;
    }

    // range: [0, 2**144 - 1]
    // resolution: 1 / 2**112
    struct uq144x112 {
        uint256 _x;
    }

    uint8 public constant RESOLUTION = 112;
    uint256 public constant Q112 = 0x10000000000000000000000000000; // 2**112
    uint256 private constant Q224 = 0x100000000000000000000000000000000000000000000000000000000; // 2**224
    uint256 private constant LOWER_MASK = 0xffffffffffffffffffffffffffff; // decimal of UQ*x112 (lower 112 bits)

    // encode a uint112 as a UQ112x112
    function encode(uint112 x) internal pure returns (uq112x112 memory) {
        return uq112x112(uint224(x) &lt;&lt; RESOLUTION);
    }

    // encodes a uint144 as a UQ144x112
    function encode144(uint144 x) internal pure returns (uq144x112 memory) {
        return uq144x112(uint256(x) &lt;&lt; RESOLUTION);
    }

    // decode a UQ112x112 into a uint112 by truncating after the radix point
    function decode(uq112x112 memory self) internal pure returns (uint112) {
        return uint112(self._x &gt;&gt; RESOLUTION);
    }

    // decode a UQ144x112 into a uint144 by truncating after the radix point
    function decode144(uq144x112 memory self) internal pure returns (uint144) {
        return uint144(self._x &gt;&gt; RESOLUTION);
    }

    // multiply a UQ112x112 by a uint, returning a UQ144x112
    // reverts on overflow
    function mul(uq112x112 memory self, uint256 y) internal pure returns (uq144x112 memory) {
        uint256 z = 0;
        require(y == 0 || (z = self._x * y) / y == self._x, 'FixedPoint::mul: overflow');
        return uq144x112(z);
    }

    // multiply a UQ112x112 by an int and decode, returning an int
    // reverts on overflow
    function muli(uq112x112 memory self, int256 y) internal pure returns (int256) {
        uint256 z = FullMath.mulDiv(self._x, uint256(y &lt; 0 ? -y : y), Q112);
        require(z &lt; 2**255, 'FixedPoint::muli: overflow');
        return y &lt; 0 ? -int256(z) : int256(z);
    }

    // multiply a UQ112x112 by a UQ112x112, returning a UQ112x112
    // lossy
    function muluq(uq112x112 memory self, uq112x112 memory other) internal pure returns (uq112x112 memory) {
        if (self._x == 0 || other._x == 0) {
            return uq112x112(0);
        }
        uint112 upper_self = uint112(self._x &gt;&gt; RESOLUTION); // * 2^0
        uint112 lower_self = uint112(self._x &amp; LOWER_MASK); // * 2^-112
        uint112 upper_other = uint112(other._x &gt;&gt; RESOLUTION); // * 2^0
        uint112 lower_other = uint112(other._x &amp; LOWER_MASK); // * 2^-112

        // partial products
        uint224 upper = uint224(upper_self) * upper_other; // * 2^0
        uint224 lower = uint224(lower_self) * lower_other; // * 2^-224
        uint224 uppers_lowero = uint224(upper_self) * lower_other; // * 2^-112
        uint224 uppero_lowers = uint224(upper_other) * lower_self; // * 2^-112

        // so the bit shift does not overflow
        require(upper &lt;= uint112(-1), 'FixedPoint::muluq: upper overflow');

        // this cannot exceed 256 bits, all values are 224 bits
        uint256 sum = uint256(upper &lt;&lt; RESOLUTION) + uppers_lowero + uppero_lowers + (lower &gt;&gt; RESOLUTION);

        // so the cast does not overflow
        require(sum &lt;= uint224(-1), 'FixedPoint::muluq: sum overflow');

        return uq112x112(uint224(sum));
    }

    // divide a UQ112x112 by a UQ112x112, returning a UQ112x112
    function divuq(uq112x112 memory self, uq112x112 memory other) internal pure returns (uq112x112 memory) {
        require(other._x &gt; 0, 'FixedPoint::divuq: division by zero');
        if (self._x == other._x) {
            return uq112x112(uint224(Q112));
        }
        if (self._x &lt;= uint144(-1)) {
            uint256 value = (uint256(self._x) &lt;&lt; RESOLUTION) / other._x;
            require(value &lt;= uint224(-1), 'FixedPoint::divuq: overflow');
            return uq112x112(uint224(value));
        }

        uint256 result = FullMath.mulDiv(Q112, self._x, other._x);
        require(result &lt;= uint224(-1), 'FixedPoint::divuq: overflow');
        return uq112x112(uint224(result));
    }

    // returns a UQ112x112 which represents the ratio of the numerator to the denominator
    // can be lossy
    function fraction(uint256 numerator, uint256 denominator) internal pure returns (uq112x112 memory) {
        require(denominator &gt; 0, 'FixedPoint::fraction: division by zero');
        if (numerator == 0) return FixedPoint.uq112x112(0);

        if (numerator &lt;= uint144(-1)) {
            uint256 result = (numerator &lt;&lt; RESOLUTION) / denominator;
            require(result &lt;= uint224(-1), 'FixedPoint::fraction: overflow');
            return uq112x112(uint224(result));
        } else {
            uint256 result = FullMath.mulDiv(numerator, Q112, denominator);
            require(result &lt;= uint224(-1), 'FixedPoint::fraction: overflow');
            return uq112x112(uint224(result));
        }
    }

    // take the reciprocal of a UQ112x112
    // reverts on overflow
    // lossy
    function reciprocal(uq112x112 memory self) internal pure returns (uq112x112 memory) {
        require(self._x != 0, 'FixedPoint::reciprocal: reciprocal of zero');
        require(self._x != 1, 'FixedPoint::reciprocal: overflow');
        return uq112x112(uint224(Q224 / self._x));
    }

    // square root of a UQ112x112
    // lossy between 0/1 and 40 bits
    function sqrt(uq112x112 memory self) internal pure returns (uq112x112 memory) {
        if (self._x &lt;= uint144(-1)) {
            return uq112x112(uint224(Babylonian.sqrt(uint256(self._x) &lt;&lt; 112)));
        }

        uint8 safeShiftBits = 255 - BitMath.mostSignificantBit(self._x);
        safeShiftBits -= safeShiftBits % 2;
        return uq112x112(uint224(Babylonian.sqrt(uint256(self._x) &lt;&lt; safeShiftBits) &lt;&lt; ((112 - safeShiftBits) / 2)));
    }
}

// File: @uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol

pragma solidity &gt;=0.5.0;

interface IUniswapV2Pair {
    event Approval(address indexed owner, address indexed spender, uint value);
    event Transfer(address indexed from, address indexed to, uint value);

    function name() external pure returns (string memory);
    function symbol() external pure returns (string memory);
    function decimals() external pure returns (uint8);
    function totalSupply() external view returns (uint);
    function balanceOf(address owner) external view returns (uint);
    function allowance(address owner, address spender) external view returns (uint);

    function approve(address spender, uint value) external returns (bool);
    function transfer(address to, uint value) external returns (bool);
    function transferFrom(address from, address to, uint value) external returns (bool);

    function DOMAIN_SEPARATOR() external view returns (bytes32);
    function PERMIT_TYPEHASH() external pure returns (bytes32);
    function nonces(address owner) external view returns (uint);

    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;

    event Mint(address indexed sender, uint amount0, uint amount1);
    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);
    event Swap(
        address indexed sender,
        uint amount0In,
        uint amount1In,
        uint amount0Out,
        uint amount1Out,
        address indexed to
    );
    event Sync(uint112 reserve0, uint112 reserve1);

    function MINIMUM_LIQUIDITY() external pure returns (uint);
    function factory() external view returns (address);
    function token0() external view returns (address);
    function token1() external view returns (address);
    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);
    function price0CumulativeLast() external view returns (uint);
    function price1CumulativeLast() external view returns (uint);
    function kLast() external view returns (uint);

    function mint(address to) external returns (uint liquidity);
    function burn(address to) external returns (uint amount0, uint amount1);
    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;
    function skim(address to) external;
    function sync() external;

    function initialize(address, address) external;
}

// File: @uniswap/v2-periphery/contracts/libraries/UniswapV2OracleLibrary.sol

pragma solidity &gt;=0.5.0;



// library with helper methods for oracles that are concerned with computing average prices
library UniswapV2OracleLibrary {
    using FixedPoint for *;

    // helper function that returns the current block timestamp within the range of uint32, i.e. [0, 2**32 - 1]
    function currentBlockTimestamp() internal view returns (uint32) {
        return uint32(block.timestamp % 2 ** 32);
    }

    // produces the cumulative price using counterfactuals to save gas and avoid a call to sync.
    function currentCumulativePrices(
        address pair
    ) internal view returns (uint price0Cumulative, uint price1Cumulative, uint32 blockTimestamp) {
        blockTimestamp = currentBlockTimestamp();
        price0Cumulative = IUniswapV2Pair(pair).price0CumulativeLast();
        price1Cumulative = IUniswapV2Pair(pair).price1CumulativeLast();

        // if time has elapsed since the last update on the pair, mock the accumulated price values
        (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast) = IUniswapV2Pair(pair).getReserves();
        if (blockTimestampLast != blockTimestamp) {
            // subtraction overflow is desired
            uint32 timeElapsed = blockTimestamp - blockTimestampLast;
            // addition overflow is desired
            // counterfactual
            price0Cumulative += uint(FixedPoint.fraction(reserve1, reserve0)._x) * timeElapsed;
            // counterfactual
            price1Cumulative += uint(FixedPoint.fraction(reserve0, reserve1)._x) * timeElapsed;
        }
    }
}

// File: interfaces/IInvitation.sol

pragma solidity 0.6.12;

interface IInvitation{

    function acceptInvitation(address _invitor) external;

    function getInvitation(address _sender) external view returns(address _invitor, address[] memory _invitees, bool _isWithdrawn);
    
}

// File: contracts/ActivityBase.sol


pragma solidity 0.6.12;



contract ActivityBase is Ownable{
    using SafeMath for uint256;

    address public admin;
    
    address public marketingFund;
    // token as the unit of measurement
    address public WETHToken;
    // invitee's supply 5% deposit weight to its invitor
    uint256 public constant INVITEE_WEIGHT = 20; 
    // invitee's supply 10% deposit weight to its invitor
    uint256 public constant INVITOR_WEIGHT = 10;

    // The block number when SHARD mining starts.
    uint256 public startBlock;

    // dev fund
    uint256 public userDividendWeight;
    uint256 public devDividendWeight;
    address public developerDAOFund;

    // deposit limit
    uint256 public amountFeeRateNumerator;
    uint256 public amountfeeRateDenominator;

    // contract sender fee rate
    uint256 public contractFeeRateNumerator;
    uint256 public contractFeeRateDenominator;

    // Info of each user is Contract sender
    mapping (uint256 =&gt; mapping (address =&gt; bool)) <span class="marker" id="mapping-380"></span><span class="token add" data-title="visibility/internal">internal</span> isUserContractSender;
    mapping (uint256 =&gt; uint256) public poolTokenAmountLimit;

    function setDividendWeight(uint256 _userDividendWeight, uint256 _devDividendWeight) external virtual{
        checkAdmin();
        require(
            _userDividendWeight != 0 &amp;&amp; _devDividendWeight != 0,
            "invalid input"
        );
        userDividendWeight = _userDividendWeight;
        devDividendWeight = _devDividendWeight;
    }

    function setDeveloperDAOFund(address _developerDAOFund) external virtual onlyOwner {
        developerDAOFund = _developerDAOFund;
    }

    function setTokenAmountLimit(uint256 _pid, uint256 _tokenAmountLimit) external virtual {
        checkAdmin();
        poolTokenAmountLimit[_pid] = _tokenAmountLimit;
    }

    function setTokenAmountLimitFeeRate(uint256 _feeRateNumerator, uint256 _feeRateDenominator) external virtual {
        checkAdmin();
        require(
            _feeRateDenominator &gt;= _feeRateNumerator, "invalid input"
        );
        amountFeeRateNumerator = _feeRateNumerator;
        amountfeeRateDenominator = _feeRateDenominator;
    }

    function setContracSenderFeeRate(uint256 _feeRateNumerator, uint256 _feeRateDenominator) external virtual {
        checkAdmin();
        require(
            _feeRateDenominator &gt;= _feeRateNumerator, "invalid input"
        );
        contractFeeRateNumerator = _feeRateNumerator;
        contractFeeRateDenominator = _feeRateDenominator;
    }

    function setStartBlock(uint256 _startBlock) external virtual onlyOwner { 
        require(startBlock &gt; block.number, "invalid start block");
        startBlock = _startBlock;
        updateAfterModifyStartBlock(_startBlock);
    }

    function transferAdmin(address _admin) external virtual {
        checkAdmin();
        admin = _admin;
    }

    function setMarketingFund(address _marketingFund) external virtual onlyOwner {
        marketingFund = _marketingFund;
    }

    function updateAfterModifyStartBlock(uint256 _newStartBlock) internal virtual{
    }

    function calculateDividend(uint256 _pending, uint256 _pid, uint256 _userAmount, bool _isContractSender) internal view returns (uint256 _marketingFundDividend, uint256 _devDividend, uint256 _userDividend){
        uint256 fee = 0;
        <span class="marker" id="mapping-381"></span><span class="token mv" id="move-dst-1" data-title="function_body/if_statement">if(devDividendWeight &gt; 0){
            fee = _pending.mul(devDividendWeight).div(devDividendWeight.add(userDividendWeight));
            _devDividend = _devDividend.add(fee);
            _pending = _pending.sub(fee);
        }</span>
        if(_isContractSender &amp;&amp; contractFeeRateDenominator &gt; 0){
            fee = _pending.mul(contractFeeRateNumerator).div(contractFeeRateDenominator);
            _marketingFundDividend = _marketingFundDividend.add(fee);
            _pending = _pending.sub(fee);
        }
        if(poolTokenAmountLimit[_pid] &gt; 0 &amp;&amp; amountfeeRateDenominator &gt; 0 &amp;&amp; _userAmount &gt;= poolTokenAmountLimit[_pid]){
            fee = _pending.mul(amountFeeRateNumerator).div(amountfeeRateDenominator);
            _marketingFundDividend =_marketingFundDividend.add(fee);
            _pending = _pending.sub(fee);
        }
        _userDividend = _pending;
    }

    function judgeContractSender(uint256 _pid) internal {
        if(msg.sender != tx.origin){
            isUserContractSender[_pid][msg.sender] = true;
        }
    }

    function checkAdmin() internal view {
        require(admin == msg.sender, "invalid authorized");
    }
}

// File: @openzeppelin/contracts/GSN/Context.sol



pragma solidity &gt;=0.6.0 &lt;0.8.0;

// File: @openzeppelin/contracts/token/ERC20/ERC20.sol



pragma solidity &gt;=0.6.0 &lt;0.8.0;




/**
 * @dev Implementation of the {IERC20} interface.
 *
 * This implementation is agnostic to the way tokens are created. This means
 * that a supply mechanism has to be added in a derived contract using {_mint}.
 * For a generic mechanism see {ERC20PresetMinterPauser}.
 *
 * TIP: For a detailed writeup see our guide
 * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How
 * to implement supply mechanisms].
 *
 * We have followed general OpenZeppelin guidelines: functions revert instead
 * of returning `false` on failure. This behavior is nonetheless conventional
 * and does not conflict with the expectations of ERC20 applications.
 *
 * Additionally, an {Approval} event is emitted on calls to {transferFrom}.
 * This allows applications to reconstruct the allowance for all accounts just
 * by listening to said events. Other implementations of the EIP may not emit
 * these events, as it isn't required by the specification.
 *
 * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}
 * functions have been added to mitigate the well-known issues around setting
 * allowances. See {IERC20-approve}.
 */
contract ERC20 is Context, IERC20 {
    using SafeMath for uint256;

    mapping (address =&gt; uint256) private _balances;

    mapping (address =&gt; mapping (address =&gt; uint256)) private _allowances;

    uint256 private _totalSupply;

    string private _name;
    string private _symbol;
    uint8 private _decimals;

    /**
     * @dev Sets the values for {name} and {symbol}, initializes {decimals} with
     * a default value of 18.
     *
     * To select a different value for {decimals}, use {_setupDecimals}.
     *
     * All three of these values are immutable: they can only be set once during
     * construction.
     */
    constructor (string memory name_, string memory symbol_) public {
        _name = name_;
        _symbol = symbol_;
        _decimals = 18;
    }

    /**
     * @dev Returns the name of the token.
     */
    function name() public view virtual returns (string memory) {
        return _name;
    }

    /**
     * @dev Returns the symbol of the token, usually a shorter version of the
     * name.
     */
    function symbol() public view virtual returns (string memory) {
        return _symbol;
    }

    /**
     * @dev Returns the number of decimals used to get its user representation.
     * For example, if `decimals` equals `2`, a balance of `505` tokens should
     * be displayed to a user as `5,05` (`505 / 10 ** 2`).
     *
     * Tokens usually opt for a value of 18, imitating the relationship between
     * Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is
     * called.
     *
     * NOTE: This information is only used for _display_ purposes: it in
     * no way affects any of the arithmetic of the contract, including
     * {IERC20-balanceOf} and {IERC20-transfer}.
     */
    function decimals() public view virtual returns (uint8) {
        return _decimals;
    }

    /**
     * @dev See {IERC20-totalSupply}.
     */
    function totalSupply() public view virtual override returns (uint256) {
        return _totalSupply;
    }

    /**
     * @dev See {IERC20-balanceOf}.
     */
    function balanceOf(address account) public view virtual override returns (uint256) {
        return _balances[account];
    }

    /**
     * @dev See {IERC20-transfer}.
     *
     * Requirements:
     *
     * - `recipient` cannot be the zero address.
     * - the caller must have a balance of at least `amount`.
     */
    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {
        _transfer(_msgSender(), recipient, amount);
        return true;
    }

    /**
     * @dev See {IERC20-allowance}.
     */
    function allowance(address owner, address spender) public view virtual override returns (uint256) {
        return _allowances[owner][spender];
    }

    /**
     * @dev See {IERC20-approve}.
     *
     * Requirements:
     *
     * - `spender` cannot be the zero address.
     */
    function approve(address spender, uint256 amount) public virtual override returns (bool) {
        _approve(_msgSender(), spender, amount);
        return true;
    }

    /**
     * @dev See {IERC20-transferFrom}.
     *
     * Emits an {Approval} event indicating the updated allowance. This is not
     * required by the EIP. See the note at the beginning of {ERC20}.
     *
     * Requirements:
     *
     * - `sender` and `recipient` cannot be the zero address.
     * - `sender` must have a balance of at least `amount`.
     * - the caller must have allowance for ``sender``'s tokens of at least
     * `amount`.
     */
    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {
        _transfer(sender, recipient, amount);
        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, "ERC20: transfer amount exceeds allowance"));
        return true;
    }

    /**
     * @dev Atomically increases the allowance granted to `spender` by the caller.
     *
     * This is an alternative to {approve} that can be used as a mitigation for
     * problems described in {IERC20-approve}.
     *
     * Emits an {Approval} event indicating the updated allowance.
     *
     * Requirements:
     *
     * - `spender` cannot be the zero address.
     */
    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {
        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));
        return true;
    }

    /**
     * @dev Atomically decreases the allowance granted to `spender` by the caller.
     *
     * This is an alternative to {approve} that can be used as a mitigation for
     * problems described in {IERC20-approve}.
     *
     * Emits an {Approval} event indicating the updated allowance.
     *
     * Requirements:
     *
     * - `spender` cannot be the zero address.
     * - `spender` must have allowance for the caller of at least
     * `subtractedValue`.
     */
    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {
        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, "ERC20: decreased allowance below zero"));
        return true;
    }

    /**
     * @dev Moves tokens `amount` from `sender` to `recipient`.
     *
     * This is internal function is equivalent to {transfer}, and can be used to
     * e.g. implement automatic token fees, slashing mechanisms, etc.
     *
     * Emits a {Transfer} event.
     *
     * Requirements:
     *
     * - `sender` cannot be the zero address.
     * - `recipient` cannot be the zero address.
     * - `sender` must have a balance of at least `amount`.
     */
    function _transfer(address sender, address recipient, uint256 amount) internal virtual {
        require(sender != address(0), "ERC20: transfer from the zero address");
        require(recipient != address(0), "ERC20: transfer to the zero address");

        _beforeTokenTransfer(sender, recipient, amount);

        _balances[sender] = _balances[sender].sub(amount, "ERC20: transfer amount exceeds balance");
        _balances[recipient] = _balances[recipient].add(amount);
        emit Transfer(sender, recipient, amount);
    }

    /** @dev Creates `amount` tokens and assigns them to `account`, increasing
     * the total supply.
     *
     * Emits a {Transfer} event with `from` set to the zero address.
     *
     * Requirements:
     *
     * - `to` cannot be the zero address.
     */
    function _mint(address account, uint256 amount) internal virtual {
        require(account != address(0), "ERC20: mint to the zero address");

        _beforeTokenTransfer(address(0), account, amount);

        _totalSupply = _totalSupply.add(amount);
        _balances[account] = _balances[account].add(amount);
        emit Transfer(address(0), account, amount);
    }

    /**
     * @dev Destroys `amount` tokens from `account`, reducing the
     * total supply.
     *
     * Emits a {Transfer} event with `to` set to the zero address.
     *
     * Requirements:
     *
     * - `account` cannot be the zero address.
     * - `account` must have at least `amount` tokens.
     */
    function _burn(address account, uint256 amount) internal virtual {
        require(account != address(0), "ERC20: burn from the zero address");

        _beforeTokenTransfer(account, address(0), amount);

        _balances[account] = _balances[account].sub(amount, "ERC20: burn amount exceeds balance");
        _totalSupply = _totalSupply.sub(amount);
        emit Transfer(account, address(0), amount);
    }

    /**
     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.
     *
     * This internal function is equivalent to `approve`, and can be used to
     * e.g. set automatic allowances for certain subsystems, etc.
     *
     * Emits an {Approval} event.
     *
     * Requirements:
     *
     * - `owner` cannot be the zero address.
     * - `spender` cannot be the zero address.
     */
    function _approve(address owner, address spender, uint256 amount) internal virtual {
        require(owner != address(0), "ERC20: approve from the zero address");
        require(spender != address(0), "ERC20: approve to the zero address");

        _allowances[owner][spender] = amount;
        emit Approval(owner, spender, amount);
    }

    /**
     * @dev Sets {decimals} to a value other than the default one of 18.
     *
     * WARNING: This function should only be called from the constructor. Most
     * applications that interact with token contracts will not expect
     * {decimals} to ever change, and may work incorrectly if it does.
     */
    function _setupDecimals(uint8 decimals_) internal virtual {
        _decimals = decimals_;
    }

    /**
     * @dev Hook that is called before any transfer of tokens. This includes
     * minting and burning.
     *
     * Calling conditions:
     *
     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens
     * will be to transferred to `to`.
     * - when `from` is zero, `amount` tokens will be minted for `to`.
     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.
     * - `from` and `to` are never both zero.
     *
     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].
     */
    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }
}

// File: contracts/SHDToken.sol


pragma solidity 0.6.12;






// SHDToken with Governance.
contract SHDToken is ERC20("ShardingDAO", "SHD"), Ownable {
    // cross chain
    mapping(address =&gt; bool) public minters;

    struct Checkpoint {
        uint256 fromBlock;
        uint256 votes;
    }
    /// @notice A record of votes checkpoints for each account, by index
    mapping(address =&gt; mapping(uint256 =&gt; Checkpoint)) public checkpoints;

    /// @notice The number of checkpoints for each account
    mapping(address =&gt; uint256) public numCheckpoints;
    event VotesBalanceChanged(
        address indexed user,
        uint256 previousBalance,
        uint256 newBalance
    );

    /// @notice Creates `_amount` token to `_to`. Must only be called by the owner (MasterChef).
    function mint(address _to, uint256 _amount) public {
        require(minters[msg.sender] == true, "SHD : You are not the miner");
        _mint(_to, _amount);
    }

    function burn(uint256 _amount) public {
        _burn(msg.sender, _amount);
    }

    function addMiner(address _miner) external onlyOwner {
        minters[_miner] = true;
    }

    function removeMiner(address _miner) external onlyOwner {
        minters[_miner] = false;
    }

    function getPriorVotes(address account, uint256 blockNumber)
        public
        view
        returns (uint256)
    {
        require(
            blockNumber &lt; block.number,
            "getPriorVotes: not yet determined"
        );

        uint256 nCheckpoints = numCheckpoints[account];
        if (nCheckpoints == 0) {
            return 0;
        }

        // First check most recent balance
        if (checkpoints[account][nCheckpoints - 1].fromBlock &lt;= blockNumber) {
            return checkpoints[account][nCheckpoints - 1].votes;
        }

        // Next check implicit zero balance
        if (checkpoints[account][0].fromBlock &gt; blockNumber) {
            return 0;
        }

        uint256 lower = 0;
        uint256 upper = nCheckpoints - 1;
        while (upper &gt; lower) {
            uint256 center = upper - (upper - lower) / 2; // ceil, avoiding overflow
            Checkpoint memory cp = checkpoints[account][center];
            if (cp.fromBlock == blockNumber) {
                return cp.votes;
            } else if (cp.fromBlock &lt; blockNumber) {
                lower = center;
            } else {
                upper = center - 1;
            }
        }
        return checkpoints[account][lower].votes;
    }

    function _voteTransfer(
        address from,
        address to,
        uint256 amount
    ) internal {
        if (from != to &amp;&amp; amount &gt; 0) {
            if (from != address(0)) {
                uint256 fromNum = numCheckpoints[from];
                uint256 fromOld =
                    fromNum &gt; 0 ? checkpoints[from][fromNum - 1].votes : 0;
                uint256 fromNew = fromOld.sub(amount);
                _writeCheckpoint(from, fromNum, fromOld, fromNew);
            }

            if (to != address(0)) {
                uint256 toNum = numCheckpoints[to];
                uint256 toOld =
                    toNum &gt; 0 ? checkpoints[to][toNum - 1].votes : 0;
                uint256 toNew = toOld.add(amount);
                _writeCheckpoint(to, toNum, toOld, toNew);
            }
        }
    }

    function _writeCheckpoint(
        address user,
        uint256 nCheckpoints,
        uint256 oldVotes,
        uint256 newVotes
    ) internal {
        uint256 blockNumber = block.number;
        if (
            nCheckpoints &gt; 0 &amp;&amp;
            checkpoints[user][nCheckpoints - 1].fromBlock == blockNumber
        ) {
            checkpoints[user][nCheckpoints - 1].votes = newVotes;
        } else {
            checkpoints[user][nCheckpoints] = Checkpoint(blockNumber, newVotes);
            numCheckpoints[user] = nCheckpoints + 1;
        }

        emit VotesBalanceChanged(user, oldVotes, newVotes);
    }

    function _beforeTokenTransfer(
        address from,
        address to,
        uint256 amount
    ) internal override {
        _voteTransfer(from, to, amount);
    }
}

// File: contracts/ShardingDAOMining.sol


pragma solidity 0.6.12;











contract ShardingDAOMining is IInvitation, ActivityBase {
    using SafeMath for uint256;
    using SafeERC20 for IERC20; 
    using FixedPoint for *;

    // Info of each user.
    struct UserInfo {
        uint256 amount; // How much LP token the user has provided.
        uint256 originWeight; //initial weight
        uint256 inviteeWeight; // invitees' weight
        uint256 endBlock;
        bool isCalculateInvitation;
    }

    // Info of each pool.
    struct PoolInfo {
        uint256 nftPoolId;
        address lpTokenSwap; // uniswapPair contract address
        uint256 accumulativeDividend;
        uint256 usersTotalWeight; // user's sum weight
        uint256 lpTokenAmount; // lock amount
        uint256 oracleWeight; // eth value
        uint256 lastDividendHeight; // last dividend block height
        TokenPairInfo tokenToEthPairInfo;
        bool isFirstTokenShard;
    }

    struct TokenPairInfo{
        IUniswapV2Pair tokenToEthSwap; 
        FixedPoint.uq112x112 price; 
        bool isFirstTokenEth;
        uint256 priceCumulativeLast;
        uint32  blockTimestampLast;
        uint256 lastPriceUpdateHeight;
    }

    struct InvitationInfo {
        address invitor;
        address[] invitees;
        bool isUsed;
        bool isWithdrawn;
        mapping(address =&gt; uint256) inviteeIndexMap;
    }

    // black list
    struct EvilPoolInfo {
        uint256 pid;
        string description;
    }

    // The SHD TOKEN!
    SHDToken public SHD;
    // Info of each pool.
    uint256[] <span class="marker" id="mapping-382"></span><span class="token add" data-title="visibility/internal">internal</span> rankPoolIndex;
    // indicates whether the pool is in the rank
    mapping(uint256 =&gt; uint256) <span class="marker" id="mapping-383"></span><span class="token add" data-title="visibility/internal">internal</span> rankPoolIndexMap;
    // relationship info about invitation
    mapping(address =&gt; InvitationInfo) <span class="marker" id="mapping-384"></span><span class="token add" data-title="visibility/internal">internal</span> usersRelationshipInfo;
    // Info of each user that stakes LP tokens.
    mapping(uint256 =&gt; mapping(address =&gt; UserInfo)) <span class="marker" id="mapping-385"></span><span class="token add" data-title="visibility/internal">internal</span> userInfo;
    // Info of each pool.
    PoolInfo[] private poolInfo;
    // Total allocation poitns. Must be the sum of all allocation points in all pools.
    uint256 public maxRankNumber = 10;
    // Last block number that SHARDs distribution occurs.
    uint256 public lastRewardBlock;
    // produced blocks per day
    uint256 public constant produceBlocksPerDay = 6496;
    // produced blocks per month
    uint256 public constant produceBlocksPerMonth = produceBlocksPerDay * 30;
    // SHD tokens created per block.
    uint256 public SHDPerBlock = 104994 * (1e13);
    // after each term, mine half SHD token
    uint256 public constant MINT_DECREASE_TERM = 9500000;
    // used to caculate user deposit weight
    uint256[] private depositTimeWeight;
    // max lock time in stage two
    uint256 private constant MAX_MONTH = 36;
    // add pool automatically in nft shard
    address public nftShard;
    // oracle token price update term
    uint256 public updateTokenPriceTerm = 120;
    // to mint token cross chain
    uint256 <span class="marker" id="mapping-386"></span><span class="token add" data-title="visibility/internal">internal</span> shardMintWeight = 1;
    uint256 <span class="marker" id="mapping-387"></span><span class="token add" data-title="visibility/internal">internal</span> reserveMintWeight = 0;
    uint256 <span class="marker" id="mapping-388"></span><span class="token add" data-title="visibility/internal">internal</span> reserveToMint;
    // black list
    EvilPoolInfo[] <span class="marker" id="mapping-389"></span><span class="token add" data-title="state_variable_declaration/visibility">internal</span> blackList;
    mapping(uint256 =&gt; uint256) <span class="marker" id="mapping-390"></span><span class="token mv" id="move-dst-158" data-title="state_variable_declaration/visibility">internal</span> blackListMap;
    // undividend shard
    uint256 public unDividendShard;
    // 20% shard =&gt; SHD - ETH pool
    uint256 public shardPoolDividendWeight = 2;
    // 80% shard =&gt; SHD - ETH pool
    uint256 public otherPoolDividendWeight = 8;

    <span class="marker" id="mapping-391"></span><span class="token add" data-title="contract_body/state_variable_declaration"><span class="marker" id="mapping-392"></span><span class="token add" data-title="state_variable_declaration/type_name">mapping(uint256 =&gt; uint256)</span> <span class="marker" id="mapping-393"></span><span class="token mv" id="move-dst-3" data-title="state_variable_declaration/visibility">public</span> poolAccs;</span>
    <span class="marker" id="mapping-394"></span><span class="token add" data-title="contract_body/struct_declaration">struct UserRevenueInfo {
        <span class="marker" id="mapping-395"></span><span class="token add" data-title="struct_declaration/struct_member"><span class="marker" id="mapping-396"></span><span class="token mv" id="move-dst-147" data-title="struct_member/type_name">uint256</span> userRewardDebt;</span>
        <span class="marker" id="mapping-397"></span><span class="token add" data-title="struct_declaration/struct_member"><span class="marker" id="mapping-398"></span><span class="token mv" id="move-dst-146" data-title="struct_member/type_name">uint256</span> revenue;</span>
    }</span>
    <span class="marker" id="mapping-399"></span><span class="token add" data-title="contract_body/state_variable_declaration"><span class="marker" id="mapping-400"></span><span class="token add" data-title="state_variable_declaration/type_name">mapping(uint256 =&gt; mapping(address =&gt; UserRevenueInfo))</span> <span class="marker" id="mapping-401"></span><span class="token mv" id="move-dst-2" data-title="state_variable_declaration/visibility">public</span> userRevenueInfo;</span>

    event Deposit(
        address indexed user,
        uint256 indexed pid,
        uint256 amount,
        uint256 weight
    );
    event Withdraw(address indexed user, uint256 indexed pid, uint256 amount);
    event Replace(
        address indexed user,
        uint256 indexed rankIndex,
        uint256 newPid
    );

    event AddToBlacklist(
        uint256 indexed pid
    );

    event RemoveFromBlacklist(
        uint256 indexed pid
    );
    event AddPool(uint256 indexed pid, uint256 nftId, address tokenAddress);

    function initialize(
        SHDToken _SHD,
        address _wethToken,
        address _developerDAOFund,
        address _marketingFund,
        uint256 _maxRankNumber,
        uint256 _startBlock
    ) <span class="marker" id="mapping-402"></span><span class="token mv" id="move-dst-31" data-title="function_definition/visibility">external</span> onlyOwner{
        require(WETHToken == address(0), "already initialized");
        SHD = _SHD;
        maxRankNumber = _maxRankNumber;
        if (_startBlock &lt; block.number) {
            startBlock = block.number;
        } else {
            startBlock = _startBlock;
        }
        lastRewardBlock = startBlock.sub(1);
        WETHToken = _wethToken;
        developerDAOFund = _developerDAOFund;
        marketingFund = _marketingFund;
        InvitationInfo storage initialInvitor =
            usersRelationshipInfo[address(this)];
        <span class="marker" id="mapping-403"></span><span class="token mv" id="move-dst-4" data-title="function_body/expression_statement">initialInvitor.isUsed =true;</span>

        userDividendWeight = 8;
        devDividendWeight = 2;

        amountFeeRateNumerator = 0;
        amountfeeRateDenominator = 0;

        contractFeeRateNumerator = 1;
        contractFeeRateDenominator = 5;
    
        <span class="marker" id="mapping-404"></span><span class="token mv" id="move-dst-5" data-title="function_body/expression_statement">depositTimeWeight = [1238,1383,1495,1587,1665,1732,1790,1842,1888,1929,1966,2000,
                             2031,2059,2085,2108,2131,2152,2171,2189,2206,2221,2236,2250,
                             2263,2276,2287,2298,2309,2319,2328,2337,2346,2355,2363,2370];</span>
    }

    function setNftShard(address _nftShard) external virtual {
        checkAdmin();
        nftShard = _nftShard;
    }

    // Add a new lp to the pool. Can only be called by the nft shard contract.
    // if _lpTokenSwap contains tokenA instead of eth, then _tokenToEthSwap should consist of token A and eth
    function add(
        uint256 _nftPoolId,
        IUniswapV2Pair _lpTokenSwap,
        IUniswapV2Pair _tokenToEthSwap
    ) external virtual {
        require(msg.sender == nftShard || msg.sender == admin, "invalid sender");
        TokenPairInfo memory tokenToEthInfo;
        uint256 lastDividendHeight = 0;
        if(poolInfo.length == 0){
            _nftPoolId = 0;
            lastDividendHeight = lastRewardBlock;
        }
        bool isFirstTokenShard;
        if (address(_tokenToEthSwap) != address(0)) {
            (address token0, address token1, uint256 targetTokenPosition) =
                getTargetTokenInSwap(_tokenToEthSwap, WETHToken);
            address wantToken;
            bool isFirstTokenEthToken;
            if (targetTokenPosition == 0) {
                isFirstTokenEthToken = true;
                wantToken = token1;
            } else {
                isFirstTokenEthToken = false;
                wantToken = token0;
            }
            (, , targetTokenPosition) = getTargetTokenInSwap(
                _lpTokenSwap,
                wantToken
            );
            if (targetTokenPosition == 0) {
                isFirstTokenShard = false;
            } else {
                isFirstTokenShard = true;
            }
            tokenToEthInfo = generateOrcaleInfo(
                _tokenToEthSwap,
                isFirstTokenEthToken
            );
        } else {
            (, , uint256 targetTokenPosition) =
                getTargetTokenInSwap(_lpTokenSwap, WETHToken);
            if (targetTokenPosition == 0) {
                isFirstTokenShard = false;
            } else {
                isFirstTokenShard = true;
            }
            tokenToEthInfo = generateOrcaleInfo(
                _lpTokenSwap,
                !isFirstTokenShard
            );
        }
        poolInfo.push(
            PoolInfo({
                nftPoolId: _nftPoolId,
                lpTokenSwap: address(_lpTokenSwap),
                lpTokenAmount: 0,
                usersTotalWeight: 0,
                accumulativeDividend: 0,
                oracleWeight: 0,
                lastDividendHeight: lastDividendHeight,
                tokenToEthPairInfo: tokenToEthInfo,
                isFirstTokenShard: isFirstTokenShard
            })
        );
        emit AddPool(poolInfo.length.sub(1), _nftPoolId, address(_lpTokenSwap));
    }

    function setPriceUpdateTerm(uint256 _term) external virtual onlyOwner{
        updateTokenPriceTerm = _term;
    }

    function kickEvilPoolByPid(uint256 _pid, string calldata description)
        external
        virtual
        onlyOwner
    {
        require(_pid &gt; 0, "invalid pid");
        <span class="marker" id="mapping-405"></span><span class="token add" data-title="function_body/expression_statement">require(blackListMap[_pid] == 0, "pool has been added into blacklist");</span>
        uint256 poolRankIndex = rankPoolIndexMap[_pid];
        <span class="marker" id="mapping-406"></span><span class="token mv" id="move-dst-6" data-title="function_body/variable_declaration_statement"><span class="marker" id="mapping-407"></span><span class="token mv" id="move-dst-18" data-title="variable_declaration/type_name">uint256</span> <span class="marker" id="mapping-408"></span><span class="token upd" id="move-dst-7" data-title="variable_declaration/identifier">addR<span class="cupd">e</span>ward</span> = <span class="marker" id="mapping-409"></span><span class="token add" data-title="variable_declaration_statement/number_literal">0</span>;</span>
        if (poolRankIndex &gt; 0) {  
            <span class="marker" id="mapping-410"></span><span class="token mv" id="move-dst-148" data-title="block_statement/variable_declaration_statement">PoolInfo storage pool = poolInfo[_pid];</span>
            uint256 <span class="marker" id="mapping-411"></span><span class="token upd" id="move-dst-9" data-title="variable_declaration/identifier"><span class="cupd">a</span>ccumulativeDivide<span class="cupd">n</span><span class="cupd">d</span>BeforeUpdate</span> = <span class="marker" id="mapping-412"></span><span class="token mv" id="move-dst-19" data-title="variable_declaration_statement/member_expression">pool.accumulativeDividend</span>;
            <span class="marker" id="mapping-413"></span><span class="token mv" id="move-dst-8" data-title="block_statement/expression_statement">massUpdatePools();</span>
            <span class="marker" id="mapping-414"></span><span class="token mv" id="move-dst-14" data-title="variable_declaration_statement/variable_declaration">uint256 lastPidInRank</span> = <span class="marker" id="mapping-415"></span><span class="token add" data-title="variable_declaration_statement/array_access">rankPoolIndex[<span class="marker" id="mapping-416"></span><span class="token mv" id="move-dst-13" data-title="array_access/call_expression">rankPoolIndex.length.sub(1)</span>]</span>;
            <span class="marker" id="mapping-417"></span><span class="token add" data-title="block_statement/expression_statement"><span class="marker" id="mapping-418"></span><span class="token add" data-title="expression_statement/assignment_expression"><span class="marker" id="mapping-419"></span><span class="token add" data-title="assignment_expression/array_access">rankPoolIndex[<span class="marker" id="mapping-420"></span><span class="token mv" id="move-dst-10" data-title="array_access/call_expression">poolRankIndex.sub(1)</span>]</span> = lastPidInRank</span>;</span>
            rankPoolIndexMap[lastPidInRank] = poolRankIndex;
            delete rankPoolIndexMap[_pid];
            rankPoolIndex.pop();
            <span class="marker" id="mapping-421"></span><span class="token add" data-title="block_statement/expression_statement"><span class="marker" id="mapping-422"></span><span class="token add" data-title="expression_statement/assignment_expression">addReward = <span class="marker" id="mapping-423"></span><span class="token add" data-title="assignment_expression/call_expression"><span class="marker" id="mapping-424"></span><span class="token add" data-title="call_expression/member_expression"><span class="marker" id="mapping-425"></span><span class="token mv" id="move-dst-56" data-title="member_expression/member_expression">pool.accumulativeDividend</span>.sub</span>(<span class="marker" id="mapping-426"></span><span class="token add" data-title="call_expression/call_argument">accumulativeDividendBeforeUpdate</span>)</span></span>;</span>
            <span class="marker" id="mapping-427"></span><span class="token add" data-title="block_statement/if_statement">if(addReward &gt; 0 &amp;&amp; pool.usersTotalWeight &gt; 0){
                poolAccs[_pid] = poolAccs[_pid].sub(addReward.mul(1e12).div(pool.usersTotalWeight));
            }</span>
        }
        <span class="marker" id="mapping-428"></span><span class="token mv" id="move-dst-16" data-title="function_body/expression_statement">blackList.push(EvilPoolInfo({pid: _pid, description: description}));</span>
        <span class="marker" id="mapping-429"></span><span class="token mv" id="move-dst-17" data-title="function_body/expression_statement">blackListMap[_pid] = blackList.length;</span>
        <span class="marker" id="mapping-430"></span><span class="token add" data-title="function_body/expression_statement"><span class="marker" id="mapping-431"></span><span class="token add" data-title="expression_statement/call_expression">dealEvilPoolDiviend(<span class="marker" id="mapping-432"></span><span class="token mv" id="move-dst-15" data-title="call_expression/call_argument">_pid</span>, <span class="marker" id="mapping-433"></span><span class="token add" data-title="call_expression/call_argument">addReward</span>)</span>;</span>
        emit AddToBlacklist(_pid);
    }

    function resetEvilPool(uint256 _pid) external virtual onlyOwner {
        uint256 poolPosition = blackListMap[_pid];
        if (poolPosition == 0) {
            return;
        }
        uint256 poolIndex = poolPosition.sub(1);
        uint256 lastIndex = blackList.length.sub(1);
        EvilPoolInfo storage lastEvilInBlackList = blackList[lastIndex];
        uint256 lastPidInBlackList = lastEvilInBlackList.pid;
        blackListMap[lastPidInBlackList] = poolPosition;
        blackList[poolIndex] = blackList[lastIndex];
        delete blackListMap[_pid];
        blackList.pop();
        emit RemoveFromBlacklist(_pid);
    }

    function dealEvilPoolDiviend(uint256 _pid<span class="marker" id="mapping-434"></span><span class="token add" data-title="function_definition/,">,</span> <span class="marker" id="mapping-435"></span><span class="token mv" id="move-dst-29" data-title="function_definition/parameter">uint256 <span class="marker" id="mapping-436"></span><span class="token upd" id="move-dst-30" data-title="parameter/identifier"><span class="cupd">_</span>undi<span class="cupd">s</span>t<span class="cupd">r</span><span class="cupd">i</span>bu<span class="cupd">t</span><span class="cupd">e</span>Dividend</span></span>) private {
        PoolInfo storage pool = poolInfo[_pid];
        if (<span class="marker" id="mapping-437"></span><span class="token upd" id="move-dst-20" data-title="binary_expression/identifier">_<span class="cupd">undistributeDividend</span></span> == 0) {
            return;
        }
        uint256 currentRankCount = rankPoolIndex.length;
        if (currentRankCount &gt; 0) {
            uint256 averageDividend =
                <span class="marker" id="mapping-438"></span><span class="token upd" id="move-dst-21" data-title="member_expression/identifier">_<span class="cupd">undistributeDividend</span></span>.div(currentRankCount);
            for (uint256 i = 0; i &lt; currentRankCount; i++) {
                <span class="marker" id="mapping-439"></span><span class="token add" data-title="block_statement/variable_declaration_statement"><span class="marker" id="mapping-440"></span><span class="token add" data-title="variable_declaration_statement/variable_declaration"><span class="marker" id="mapping-441"></span><span class="token mv" id="move-dst-111" data-title="variable_declaration/type_name">uint256</span> currentPid</span> = <span class="marker" id="mapping-442"></span><span class="token mv" id="move-dst-22" data-title="variable_declaration_statement/array_access">rankPoolIndex[i]</span>;</span>
                PoolInfo storage poolInRank = poolInfo[<span class="marker" id="mapping-443"></span><span class="token add" data-title="array_access/identifier">currentPid</span>];
                <span class="marker" id="mapping-444"></span><span class="token add" data-title="block_statement/variable_declaration_statement"><span class="marker" id="mapping-445"></span><span class="token mv" id="move-dst-11" data-title="variable_declaration_statement/variable_declaration">uint256 <span class="marker" id="mapping-446"></span><span class="token upd" id="move-dst-12" data-title="variable_declaration/identifier">addDivid<span class="cupd">en</span>d</span></span>;</span>
                <span class="marker" id="mapping-447"></span><span class="token add" data-title="block_statement/if_statement">if (<span class="marker" id="mapping-448"></span><span class="token mv" id="move-dst-23" data-title="if_statement/binary_expression">i &lt; currentRankCount - 1</span>)<span class="marker" id="mapping-449"></span><span class="token add" data-title="if_statement/block_statement">{
                    <span class="marker" id="mapping-450"></span><span class="token add" data-title="block_statement/expression_statement">addDividend = averageDividend;</span>
                    <span class="marker" id="mapping-451"></span><span class="token add" data-title="block_statement/expression_statement"><span class="marker" id="mapping-452"></span><span class="token add" data-title="expression_statement/assignment_expression">_undistributeDividend = <span class="marker" id="mapping-453"></span><span class="token add" data-title="assignment_expression/call_expression"><span class="marker" id="mapping-454"></span><span class="token add" data-title="call_expression/member_expression">_undistributeDividend.sub</span>(<span class="marker" id="mapping-455"></span><span class="token mv" id="move-dst-24" data-title="call_expression/call_argument">averageDividend</span>)</span></span>;</span>
                }</span>
                else<span class="marker" id="mapping-456"></span><span class="token add" data-title="if_statement/block_statement">{
                    addDividend = _undistributeDividend;
                }</span></span>
                <span class="marker" id="mapping-457"></span><span class="token mv" id="move-dst-25" data-title="block_statement/expression_statement">poolInRank.accumulativeDividend = poolInRank.accumulativeDividend.add(<span class="marker" id="mapping-458"></span><span class="token upd" id="move-dst-26" data-title="call_argument/identifier">a<span class="cupd">d</span>d<span class="cupd">Dividend</span></span>);</span>
                <span class="marker" id="mapping-459"></span><span class="token add" data-title="block_statement/if_statement">if(poolInRank.usersTotalWeight &gt; 0){
                    poolAccs[currentPid] = poolAccs[currentPid].add(addDividend.mul(1e12).div(poolInRank.usersTotalWeight));
                }</span>
            }
        } else {
            unDividendShard = unDividendShard.add(<span class="marker" id="mapping-460"></span><span class="token upd" id="move-dst-27" data-title="call_argument/identifier">_<span class="cupd">undistributeDividend</span></span>);
        }
        pool.accumulativeDividend = <span class="marker" id="mapping-461"></span><span class="token add" data-title="assignment_expression/call_expression">pool.accumulativeDividend.sub(_undistributeDividend)</span>;
    }

    function setShardPoolDividendWeight(
        uint256 _shardPoolWeight,
        uint256 _otherPoolWeight
    ) external virtual {
        checkAdmin();
        require(
            _shardPoolWeight != 0 &amp;&amp; _otherPoolWeight != 0,
            "invalid input"
        );
        massUpdatePools();
        shardPoolDividendWeight = _shardPoolWeight;
        otherPoolDividendWeight = _otherPoolWeight;
    }

    function setSHDPerBlock(uint256 _SHDPerBlock, bool _withUpdate) external virtual {
        checkAdmin();
        if (_withUpdate) {
            massUpdatePools();
        }
        SHDPerBlock = _SHDPerBlock;
    }

    function massUpdatePools() public virtual {
        uint256 poolCountInRank = rankPoolIndex.length;
        uint256 farmMintShard = mintSHARD(address(this), block.number);
        updateSHARDPoolAccumulativeDividend(block.number);
        if(poolCountInRank == 0){
            farmMintShard = farmMintShard.mul(otherPoolDividendWeight)
                                     .div(shardPoolDividendWeight.add(otherPoolDividendWeight));
            if(farmMintShard &gt; 0){
                unDividendShard = unDividendShard.add(farmMintShard);
            }
        }
        for (uint256 i = 0; i &lt; poolCountInRank; i++) {
            updatePoolAccumulativeDividend(
                rankPoolIndex[i],
                poolCountInRank,
                block.number
            );
        }
    }

    // update reward vairables for a pool
    function updatePoolDividend(uint256 _pid) public virtual {
        if(_pid == 0){
            updateSHARDPoolAccumulativeDividend(block.number);
            return;
        }
        updatePoolAccumulativeDividend(
            _pid,
            rankPoolIndex.length,
            block.number
        );
    }

    function mintSHARD(address _address, uint256 _toBlock) private returns (uint256){
        uint256 recentlyRewardBlock = lastRewardBlock;
        if (recentlyRewardBlock &gt;= _toBlock) {
            return 0;
        }
        uint256 totalReward =
            getRewardToken(recentlyRewardBlock.add(1), _toBlock);
        if (totalReward &gt; 0) {
            SHD.mint(_address, <span class="marker" id="mapping-462"></span><span class="token upd" id="move-dst-37" data-title="call_argument/identifier">tot<span class="cupd">a</span>lReward</span>);
            lastRewardBlock = _toBlock;
        }
        return <span class="marker" id="mapping-463"></span><span class="token upd" id="move-dst-38" data-title="return_statement/identifier">tot<span class="cupd">a</span>lReward</span>;
    }

    function updatePoolAccumulativeDividend(
        uint256 _pid,
        uint256 _validRankPoolCount,
        uint256 _toBlock
    ) private {
        PoolInfo storage pool = poolInfo[_pid];
        <span class="marker" id="mapping-464"></span><span class="token add" data-title="function_body/variable_declaration_statement"><span class="marker" id="mapping-465"></span><span class="token mv" id="move-dst-33" data-title="variable_declaration_statement/variable_declaration">uint256 <span class="marker" id="mapping-466"></span><span class="token upd" id="move-dst-34" data-title="variable_declaration/identifier"><span class="cupd">a</span>ccu<span class="cupd">m</span>ulat<span class="cupd">i</span>veSHDPerWeight</span></span> = <span class="marker" id="mapping-467"></span><span class="token add" data-title="variable_declaration_statement/array_access">poolAccs[_pid]</span>;</span>
        <span class="marker" id="mapping-468"></span><span class="token mv" id="move-dst-40" data-title="function_body/variable_declaration_statement">uint256 existedDividend = pool.accumulativeDividend;</span>
        <span class="marker" id="mapping-469"></span><span class="token add" data-title="function_body/if_statement">if(<span class="marker" id="mapping-470"></span><span class="token add" data-title="if_statement/binary_expression">accumulativeSHDPerWeight == 0 &amp;&amp; existedDividend &gt; 0 &amp;&amp; pool.usersTotalWeight &gt; 0</span>)<span class="marker" id="mapping-471"></span><span class="token add" data-title="if_statement/block_statement">{
            <span class="marker" id="mapping-472"></span><span class="token mv" id="move-dst-92" data-title="block_statement/expression_statement"><span class="marker" id="mapping-473"></span><span class="token upd" id="move-dst-93" data-title="assignment_expression/identifier">accumulativ<span class="cupd">e</span>SHDPerWe<span class="cupd">i</span>ght</span> = <span class="marker" id="mapping-474"></span><span class="token add" data-title="member_expression/call_expression">existedDividend.mul(1e12)</span>.div(pool.usersTotalWeight);</span>
            <span class="marker" id="mapping-475"></span><span class="token add" data-title="block_statement/expression_statement">poolAccs[_pid] = accumulativeSHDPerWeight;</span>
        }</span></span>
        if (pool.lastDividendHeight &gt;= _toBlock) return;
        <span class="marker" id="mapping-476"></span><span class="token mv" id="move-dst-32" data-title="function_body/if_statement">if (rankPoolIndexMap[_pid] == 0) {
            return;
        }</span>
        uint256 poolReward =
            <span class="marker" id="mapping-477"></span><span class="token upd" id="move-dst-39" data-title="call_expression/identifier"><span class="cupd">get</span><span class="cupd">RewardToken</span></span>(pool.lastDividendHeight.add(1), _toBlock)
                                    .mul(otherPoolDividendWeight)
                                    .div(shardPoolDividendWeight.add(otherPoolDividendWeight));

        uint256 otherPoolReward = poolReward.div(_validRankPoolCount);                            
        pool.lastDividendHeight = _toBlock;
        <span class="marker" id="mapping-478"></span><span class="token add" data-title="assignment_expression/identifier">existedDividend</span> = existedDividend.add(otherPoolReward);
        <span class="marker" id="mapping-479"></span><span class="token add" data-title="function_body/expression_statement"><span class="marker" id="mapping-480"></span><span class="token add" data-title="expression_statement/assignment_expression"><span class="marker" id="mapping-481"></span><span class="token mv" id="move-dst-41" data-title="assignment_expression/member_expression">pool.accumulativeDividend</span> = existedDividend</span>;</span>
        <span class="marker" id="mapping-482"></span><span class="token add" data-title="function_body/if_statement">if(<span class="marker" id="mapping-483"></span><span class="token add" data-title="if_statement/binary_expression"><span class="marker" id="mapping-484"></span><span class="token mv" id="move-dst-149" data-title="binary_expression/member_expression">pool.usersTotalWeight</span> &gt; 0</span>)<span class="marker" id="mapping-485"></span><span class="token add" data-title="if_statement/block_statement">{
            accumulativeSHDPerWeight = accumulativeSHDPerWeight.add(otherPoolReward.mul(1e12).div(pool.usersTotalWeight));
        }</span></span>
        <span class="marker" id="mapping-486"></span><span class="token add" data-title="function_body/expression_statement">poolAccs[_pid] = accumulativeSHDPerWeight;</span>
    }

    function updateSHARDPoolAccumulativeDividend (uint256 _toBlock) private{
        PoolInfo storage pool = poolInfo[0];
        <span class="marker" id="mapping-487"></span><span class="token mv" id="move-dst-43" data-title="function_body/variable_declaration_statement">uint256 existedDividend = pool.accumulativeDividend;</span>
        <span class="marker" id="mapping-488"></span><span class="token mv" id="move-dst-35" data-title="function_body/variable_declaration_statement">uint256 <span class="marker" id="mapping-489"></span><span class="token upd" id="move-dst-36" data-title="variable_declaration/identifier">accumulativ<span class="cupd">e</span>SHDP<span class="cupd">er</span>Weight</span> = <span class="marker" id="mapping-490"></span><span class="token add" data-title="variable_declaration_statement/array_access">poolAccs[0]</span>;</span> 
        <span class="marker" id="mapping-491"></span><span class="token add" data-title="function_body/if_statement">if(accumulativeSHDPerWeight == 0 &amp;&amp; existedDividend &gt; 0 &amp;&amp; pool.usersTotalWeight &gt; 0){
            accumulativeSHDPerWeight = existedDividend.mul(1e12).div(pool.usersTotalWeight);
            poolAccs[0] = accumulativeSHDPerWeight;
        }</span>
        if (pool.lastDividendHeight &gt;= _toBlock) return;
        uint256 poolReward =
            <span class="marker" id="mapping-492"></span><span class="token upd" id="move-dst-42" data-title="call_expression/identifier"><span class="cupd">get</span><span class="cupd">RewardToken</span></span>(pool.lastDividendHeight.add(1), _toBlock);

        uint256 shardPoolDividend = poolReward.mul(shardPoolDividendWeight)
                                               .div(shardPoolDividendWeight.add(otherPoolDividendWeight));                              
        pool.lastDividendHeight = _toBlock;
        <span class="marker" id="mapping-493"></span><span class="token add" data-title="assignment_expression/identifier">existedDividend</span> = existedDividend.add(shardPoolDividend);
        <span class="marker" id="mapping-494"></span><span class="token add" data-title="function_body/expression_statement"><span class="marker" id="mapping-495"></span><span class="token add" data-title="expression_statement/assignment_expression"><span class="marker" id="mapping-496"></span><span class="token mv" id="move-dst-44" data-title="assignment_expression/member_expression">pool.accumulativeDividend</span> = existedDividend</span>;</span>
        <span class="marker" id="mapping-497"></span><span class="token add" data-title="function_body/if_statement">if(pool.usersTotalWeight &gt; 0){
            accumulativeSHDPerWeight = accumulativeSHDPerWeight.add(shardPoolDividend.mul(1e12).div(pool.usersTotalWeight));
        }</span>
        <span class="marker" id="mapping-498"></span><span class="token add" data-title="function_body/expression_statement">poolAccs[0] = accumulativeSHDPerWeight;</span>
    }

    <span class="marker" id="mapping-499"></span><span class="token add" data-title="contract_body/struct_declaration">struct InvitationRelationParam {
        <span class="marker" id="mapping-500"></span><span class="token add" data-title="struct_declaration/struct_member"><span class="marker" id="mapping-501"></span><span class="token mv" id="move-dst-28" data-title="struct_member/type_name">uint256</span> pid;</span>
        <span class="marker" id="mapping-502"></span><span class="token add" data-title="struct_declaration/struct_member"><span class="marker" id="mapping-503"></span><span class="token mv" id="move-dst-81" data-title="struct_member/type_name">address</span> user;</span>
        <span class="marker" id="mapping-504"></span><span class="token add" data-title="struct_declaration/struct_member"><span class="marker" id="mapping-505"></span><span class="token mv" id="move-dst-90" data-title="struct_member/type_name">uint256</span> addWeight;</span>
        <span class="marker" id="mapping-506"></span><span class="token add" data-title="struct_declaration/struct_member"><span class="marker" id="mapping-507"></span><span class="token mv" id="move-dst-145" data-title="struct_member/type_name">uint256</span> addInvitorWeight;</span>
        <span class="marker" id="mapping-508"></span><span class="token add" data-title="struct_declaration/struct_member"><span class="marker" id="mapping-509"></span><span class="token mv" id="move-dst-144" data-title="struct_member/type_name">uint256</span> addInviteeWeight;</span>
        <span class="marker" id="mapping-510"></span><span class="token add" data-title="struct_declaration/struct_member"><span class="marker" id="mapping-511"></span><span class="token mv" id="move-dst-130" data-title="struct_member/type_name">uint256</span> existedAmount;</span>
    }</span>

    // deposit LP tokens to MasterChef for SHD allocation.
    // ignore lockTime in stage one
    function deposit(
        uint256 _pid,
        uint256 _amount,
        uint256 _lockTime
    ) external virtual {
        require(_amount &gt; 0, "invalid deposit amount");
        InvitationInfo storage senderInfo = usersRelationshipInfo[msg.sender];
        require(senderInfo.isUsed, "must accept an invitation firstly");
        require(_lockTime &gt; 0 &amp;&amp; _lockTime &lt;= 36, "invalid lock time"); // less than 36 months
        <span class="marker" id="mapping-512"></span><span class="token add" data-title="function_body/expression_statement">updatePoolDividend(_pid);</span>
        PoolInfo storage pool = poolInfo[_pid];
        uint256 lpTokenAmount = pool.lpTokenAmount.add(_amount);
        UserInfo storage user = userInfo[_pid][msg.sender];
        uint256 newOriginWeight = user.originWeight;
        <span class="marker" id="mapping-513"></span><span class="token add" data-title="variable_declaration_statement/variable_declaration">InvitationRelationParam memory p</span>;  <span class="marker" id="mapping-514"></span><span class="token add" data-title="function_body/comment">// Relieves stack pressure</span>
        <span class="marker" id="mapping-515"></span><span class="token mv" id="move-dst-112" data-title="function_body/expression_statement"><span class="marker" id="mapping-516"></span><span class="token add" data-title="assignment_expression/member_expression">p.existedAmount</span> = user.amount;</span>
        uint256 endBlock = user.endBlock;
        uint256 newEndBlock =
            block.number.add(produceBlocksPerMonth.mul(_lockTime));
        if (<span class="marker" id="mapping-517"></span><span class="token add" data-title="binary_expression/member_expression">p.existedAmount</span> &gt; 0) {
            if(newEndBlock &lt; endBlock){
                newOriginWeight = newOriginWeight.add(getDepositWeight(
                    _amount,
                    endBlock.sub(block.number).div(produceBlocksPerMonth)
                ));
                newEndBlock = endBlock;
            }
            else{
                newOriginWeight = newOriginWeight.add(getDepositWeight(
                    _amount,
                    _lockTime
                ));
                newOriginWeight = newOriginWeight.add(getDepositWeight(
                    <span class="marker" id="mapping-518"></span><span class="token add" data-title="call_argument/member_expression">p.existedAmount</span>,
                    newEndBlock.sub(endBlock).div(produceBlocksPerMonth)
                ));
            }
        } else {
            judgeContractSender(_pid);
            newOriginWeight = getDepositWeight(_amount, _lockTime);
        }
        <span class="marker" id="mapping-519"></span><span class="token add" data-title="function_body/expression_statement">p.pid = _pid;</span>
        <span class="marker" id="mapping-520"></span><span class="token add" data-title="function_body/expression_statement">p.user = msg.sender;</span>
        <span class="marker" id="mapping-521"></span><span class="token add" data-title="function_body/expression_statement"><span class="marker" id="mapping-522"></span><span class="token add" data-title="expression_statement/assignment_expression"><span class="marker" id="mapping-523"></span><span class="token add" data-title="assignment_expression/member_expression">p.addWeight</span> = <span class="marker" id="mapping-524"></span><span class="token add" data-title="assignment_expression/call_expression"><span class="marker" id="mapping-525"></span><span class="token add" data-title="call_expression/member_expression">newOriginWeight.sub</span>(<span class="marker" id="mapping-526"></span><span class="token mv" id="move-dst-49" data-title="call_expression/call_argument">user.originWeight</span>)</span></span>;</span>
        <span class="marker" id="mapping-527"></span><span class="token add" data-title="function_body/expression_statement"><span class="marker" id="mapping-528"></span><span class="token add" data-title="expression_statement/assignment_expression"><span class="marker" id="mapping-529"></span><span class="token add" data-title="assignment_expression/member_expression">p.addInvitorWeight</span> = <span class="marker" id="mapping-530"></span><span class="token add" data-title="assignment_expression/call_expression"><span class="marker" id="mapping-531"></span><span class="token add" data-title="call_expression/member_expression"><span class="marker" id="mapping-532"></span><span class="token add" data-title="member_expression/call_expression"><span class="marker" id="mapping-533"></span><span class="token add" data-title="call_expression/member_expression">newOriginWeight.div</span>(<span class="marker" id="mapping-534"></span><span class="token mv" id="move-dst-156" data-title="call_expression/call_argument">INVITOR_WEIGHT</span>)</span>.sub</span>(<span class="marker" id="mapping-535"></span><span class="token add" data-title="call_expression/call_argument"><span class="marker" id="mapping-536"></span><span class="token add" data-title="call_argument/call_expression"><span class="marker" id="mapping-537"></span><span class="token add" data-title="call_expression/member_expression">user.originWeight.div</span>(<span class="marker" id="mapping-538"></span><span class="token mv" id="move-dst-157" data-title="call_expression/call_argument">INVITOR_WEIGHT</span>)</span></span>)</span></span>;</span>
        <span class="marker" id="mapping-539"></span><span class="token add" data-title="function_body/expression_statement"><span class="marker" id="mapping-540"></span><span class="token add" data-title="expression_statement/assignment_expression"><span class="marker" id="mapping-541"></span><span class="token add" data-title="assignment_expression/member_expression">p.addInviteeWeight</span> = <span class="marker" id="mapping-542"></span><span class="token add" data-title="assignment_expression/call_expression"><span class="marker" id="mapping-543"></span><span class="token add" data-title="call_expression/member_expression"><span class="marker" id="mapping-544"></span><span class="token add" data-title="member_expression/call_expression"><span class="marker" id="mapping-545"></span><span class="token add" data-title="call_expression/member_expression">newOriginWeight.div</span>(<span class="marker" id="mapping-546"></span><span class="token mv" id="move-dst-152" data-title="call_expression/call_argument">INVITEE_WEIGHT</span>)</span>.sub</span>(<span class="marker" id="mapping-547"></span><span class="token add" data-title="call_expression/call_argument"><span class="marker" id="mapping-548"></span><span class="token add" data-title="call_argument/call_expression"><span class="marker" id="mapping-549"></span><span class="token add" data-title="call_expression/member_expression">user.originWeight.div</span>(<span class="marker" id="mapping-550"></span><span class="token mv" id="move-dst-153" data-title="call_expression/call_argument">INVITEE_WEIGHT</span>)</span></span>)</span></span>;</span>
        <span class="marker" id="mapping-551"></span><span class="token add" data-title="function_body/expression_statement">modifyWeightByInvitation(p);</span>
        <span class="marker" id="mapping-552"></span><span class="token add" data-title="function_body/expression_statement"><span class="marker" id="mapping-553"></span><span class="token add" data-title="expression_statement/assignment_expression"><span class="marker" id="mapping-554"></span><span class="token mv" id="move-dst-47" data-title="assignment_expression/member_expression">user.amount</span> = <span class="marker" id="mapping-555"></span><span class="token add" data-title="assignment_expression/call_expression"><span class="marker" id="mapping-556"></span><span class="token add" data-title="call_expression/member_expression">p.existedAmount.add</span>(<span class="marker" id="mapping-557"></span><span class="token mv" id="move-dst-51" data-title="call_expression/call_argument">_amount</span>)</span></span>;</span>
        <span class="marker" id="mapping-558"></span><span class="token mv" id="move-dst-113" data-title="function_body/expression_statement">user.originWeight <span class="marker" id="mapping-559"></span><span class="token mv" id="move-dst-116" data-title="assignment_expression/=">=</span> <span class="marker" id="mapping-560"></span><span class="token mv" id="move-dst-115" data-title="assignment_expression/identifier"><span class="marker" id="mapping-561"></span><span class="token upd" id="move-dst-115" data-title="assignment_expression/identifier">newO<span class="cupd">riginWeight</span></span></span>;</span>
        <span class="marker" id="mapping-562"></span><span class="token mv" id="move-dst-119" data-title="function_body/expression_statement">user.endBlock <span class="marker" id="mapping-563"></span><span class="token mv" id="move-dst-122" data-title="assignment_expression/=">=</span> <span class="marker" id="mapping-564"></span><span class="token mv" id="move-dst-121" data-title="assignment_expression/identifier"><span class="marker" id="mapping-565"></span><span class="token upd" id="move-dst-121" data-title="assignment_expression/identifier">n<span class="cupd">e</span>wE<span class="cupd">ndBlock</span></span></span>;</span>
        IERC20(pool.lpTokenSwap).safeTransferFrom(
            address(msg.sender),
            address(this),
            _amount
        );
        pool.oracleWeight =  <span class="marker" id="mapping-566"></span><span class="token upd" id="move-dst-52" data-title="call_expression/identifier">calculat<span class="cupd">e</span><span class="cupd">OracleWeight</span></span>(pool, lpTokenAmount);
        pool.lpTokenAmount = lpTokenAmount;
        if (
            rankPoolIndexMap[_pid] == 0 &amp;&amp;
            rankPoolIndex.length &lt; maxRankNumber &amp;&amp;
            blackListMap[_pid] == 0
        ) {
            addToRank(pool, _pid);
        }
        emit Deposit(msg.sender, _pid, _amount, newOriginWeight);
    }

    // Withdraw LP tokens from MasterChef.
    function withdraw(uint256 _pid) external virtual {
        UserInfo storage user = userInfo[_pid][msg.sender];
        uint256 amount = user.amount;
        require(amount &gt; 0, "user is not existed");
        require(user.endBlock &lt; block.number, "token is still locked");
        mintSHARD(address(this), block.number);
        updatePoolDividend(_pid);
        uint256 originWeight = user.originWeight;
        PoolInfo storage pool = poolInfo[_pid];
        uint256 userWeight = user.inviteeWeight.add(originWeight);
        if(user.isCalculateInvitation){
            userWeight = userWeight.add(originWeight.div(INVITOR_WEIGHT));
        }
        <span class="marker" id="mapping-567"></span><span class="token add" data-title="function_body/variable_declaration_statement">UserRevenueInfo storage senderRevenueInfo = userRevenueInfo[_pid][msg.sender];</span>
        <span class="marker" id="mapping-568"></span><span class="token mv" id="move-dst-57" data-title="function_body/variable_declaration_statement">uint256 pending = <span class="marker" id="mapping-569"></span><span class="token add" data-title="variable_declaration_statement/call_expression"><span class="marker" id="mapping-570"></span><span class="token add" data-title="call_expression/member_expression"><span class="marker" id="mapping-571"></span><span class="token add" data-title="member_expression/call_expression"><span class="marker" id="mapping-572"></span><span class="token add" data-title="call_expression/member_expression">poolAccs[_pid].mul</span>(<span class="marker" id="mapping-573"></span><span class="token mv" id="move-dst-59" data-title="call_expression/call_argument">userWeight</span>)</span>.div</span>(<span class="marker" id="mapping-574"></span><span class="token add" data-title="call_expression/call_argument">1e12</span>)</span>;</span>
        <span class="marker" id="mapping-575"></span><span class="token add" data-title="function_body/expression_statement">pending = pending.sub(senderRevenueInfo.userRewardDebt);</span>
        <span class="marker" id="mapping-576"></span><span class="token add" data-title="function_body/expression_statement">pending = pending.add(senderRevenueInfo.revenue);</span>
        <span class="marker" id="mapping-577"></span><span class="token add" data-title="function_body/expression_statement">senderRevenueInfo.revenue = 0;</span>
        if(<span class="marker" id="mapping-578"></span><span class="token mv" id="move-dst-69" data-title="if_statement/binary_expression">pending &gt; 0</span>){
            pool.accumulativeDividend = pool.accumulativeDividend.sub(pending);
            <span class="marker" id="mapping-579"></span><span class="token mv" id="move-dst-62" data-title="expression_statement/call_expression"><span class="marker" id="mapping-580"></span><span class="token upd" id="move-dst-63" data-title="call_expression/identifier">d<span class="cupd">ividend</span>Bonus</span>(_pid<span class="marker" id="mapping-581"></span><span class="token mv" id="move-dst-65" data-title="call_expression/,">,</span> <span class="marker" id="mapping-582"></span><span class="token mv" id="move-dst-64" data-title="call_expression/call_argument">pending</span>, amount, isUserContractSender[_pid][msg.sender])</span>;
        }
        pool.usersTotalWeight = <span class="marker" id="mapping-583"></span><span class="token add" data-title="member_expression/member_expression">pool.usersTotalWeight</span>.sub(userWeight);
        user.amount = 0;
        user.originWeight = 0;
        user.endBlock = 0;
        IERC20(pool.lpTokenSwap).safeTransfer(address(msg.sender), amount);
        pool.lpTokenAmount = pool.lpTokenAmount.sub(amount);
        if (pool.lpTokenAmount == 0) pool.oracleWeight = 0;
        else {
            pool.oracleWeight = <span class="marker" id="mapping-584"></span><span class="token upd" id="move-dst-71" data-title="call_expression/identifier">calculat<span class="cupd">e</span><span class="cupd">OracleWeight</span></span>(pool, pool.lpTokenAmount);
        }
        resetInvitationRelationship(_pid, msg.sender, originWeight);
        emit Withdraw(msg.sender, _pid, amount);
    }

    <span class="marker" id="mapping-585"></span><span class="token add" data-title="contract_body/function_definition">function dividendBonus(<span class="marker" id="mapping-586"></span><span class="token mv" id="move-dst-108" data-title="function_definition/parameter">uint256 _pid</span>, <span class="marker" id="mapping-587"></span><span class="token add" data-title="function_definition/parameter">uint256 _pending</span>, <span class="marker" id="mapping-588"></span><span class="token mv" id="move-dst-129" data-title="function_definition/parameter">uint256 _amount</span>, <span class="marker" id="mapping-589"></span><span class="token mv" id="move-dst-159" data-title="function_definition/parameter">bool <span class="marker" id="mapping-590"></span><span class="token upd" id="move-dst-160" data-title="parameter/identifier">_i<span class="cupd">s</span>Contract</span></span>) <span class="marker" id="mapping-591"></span><span class="token mv" id="move-dst-110" data-title="function_definition/visibility">private</span> <span class="marker" id="mapping-592"></span><span class="token add" data-title="function_definition/function_body">{
        <span class="marker" id="mapping-593"></span><span class="token mv" id="move-dst-60" data-title="function_body/variable_declaration_statement">uint256 treasruyDividend;</span>
        <span class="marker" id="mapping-594"></span><span class="token mv" id="move-dst-61" data-title="function_body/variable_declaration_statement">uint256 devDividend;</span>
        <span class="marker" id="mapping-595"></span><span class="token add" data-title="function_body/expression_statement"><span class="marker" id="mapping-596"></span><span class="token add" data-title="expression_statement/assignment_expression"><span class="marker" id="mapping-597"></span><span class="token add" data-title="assignment_expression/tuple_expression">(treasruyDividend, devDividend, _pending)</span> = <span class="marker" id="mapping-598"></span><span class="token add" data-title="assignment_expression/call_expression">calculateDividend(<span class="marker" id="mapping-599"></span><span class="token add" data-title="call_expression/call_argument">_pending</span>, <span class="marker" id="mapping-600"></span><span class="token mv" id="move-dst-117" data-title="call_expression/call_argument">_pid</span>, <span class="marker" id="mapping-601"></span><span class="token mv" id="move-dst-132" data-title="call_expression/call_argument">_amount</span>, <span class="marker" id="mapping-602"></span><span class="token add" data-title="call_expression/call_argument">_isContract</span>)</span></span>;</span>
        <span class="marker" id="mapping-603"></span><span class="token mv" id="move-dst-66" data-title="function_body/if_statement">if(treasruyDividend &gt; 0){
            safeSHARDTransfer(marketingFund, treasruyDividend);
        }</span>
        <span class="marker" id="mapping-604"></span><span class="token mv" id="move-dst-67" data-title="function_body/if_statement">if(devDividend &gt; 0){
            safeSHARDTransfer(developerDAOFund, devDividend);
        }</span>
        <span class="marker" id="mapping-605"></span><span class="token mv" id="move-dst-68" data-title="function_body/if_statement">if(<span class="marker" id="mapping-606"></span><span class="token add" data-title="if_statement/binary_expression">_pending &gt; 0</span>){
            safeSHARDTransfer(msg.sender, <span class="marker" id="mapping-607"></span><span class="token add" data-title="call_expression/call_argument">_pending</span>);
        }</span>
    }</span></span>

    function addToRank(
        PoolInfo storage _pool,
        uint256 _pid
    ) private {
        if(_pid == 0){
            return;
        }
        massUpdatePools();
        _pool.lastDividendHeight = block.number;
        rankPoolIndex.push(_pid);
        rankPoolIndexMap[_pid] = rankPoolIndex.length;
        if(unDividendShard &gt; 0){
            _pool.accumulativeDividend = _pool.accumulativeDividend.add(unDividendShard);
            <span class="marker" id="mapping-608"></span><span class="token add" data-title="block_statement/if_statement">if(_pool.usersTotalWeight &gt; 0){
                poolAccs[_pid] = poolAccs[_pid].add(unDividendShard.mul(1e12).div(_pool.usersTotalWeight));
            }</span>
            unDividendShard = 0;
        }
        emit Replace(msg.sender, rankPoolIndex.length.sub(1), _pid);
        return;
    }

    //_poolIndexInRank is the index in rank
    //_pid is the index in poolInfo
    function tryToReplacePoolInRank(uint256 _poolIndexInRank, uint256 _pid)
        external
        virtual
    {
        if(_pid == 0){
            return;
        }
        PoolInfo storage pool = poolInfo[_pid];
        require(pool.lpTokenAmount &gt; 0, "there is not any lp token depsoited");
        require(blackListMap[_pid] == 0, "pool is in the black list");
        if (rankPoolIndexMap[_pid] &gt; 0) {
            return;
        }
        uint256 currentPoolCountInRank = rankPoolIndex.length;
        require(currentPoolCountInRank == maxRankNumber, "invalid operation");
        uint256 targetPid = rankPoolIndex[_poolIndexInRank];
        PoolInfo storage targetPool = poolInfo[targetPid];
        <span class="marker" id="mapping-609"></span><span class="token add" data-title="function_body/expression_statement"><span class="marker" id="mapping-610"></span><span class="token add" data-title="expression_statement/assignment_expression"><span class="marker" id="mapping-611"></span><span class="token add" data-title="assignment_expression/member_expression">targetPool.oracleWeight</span> = <span class="marker" id="mapping-612"></span><span class="token mv" id="move-dst-74" data-title="assignment_expression/call_expression"><span class="marker" id="mapping-613"></span><span class="token upd" id="move-dst-75" data-title="call_expression/identifier">calculat<span class="cupd">e</span><span class="cupd">OracleWeight</span></span>(targetPool, targetPool.lpTokenAmount)</span></span>;</span>
        <span class="marker" id="mapping-614"></span><span class="token mv" id="move-dst-105" data-title="function_body/expression_statement">pool.oracleWeight <span class="marker" id="mapping-615"></span><span class="token mv" id="move-dst-106" data-title="assignment_expression/=">=</span> <span class="marker" id="mapping-616"></span><span class="token mv" id="move-dst-78" data-title="assignment_expression/call_expression"><span class="marker" id="mapping-617"></span><span class="token upd" id="move-dst-79" data-title="call_expression/identifier">calculat<span class="cupd">e</span><span class="cupd">OracleWeight</span></span>(pool, pool.lpTokenAmount)</span>;</span>
        if (<span class="marker" id="mapping-618"></span><span class="token add" data-title="binary_expression/member_expression">pool.oracleWeight</span> &lt;= <span class="marker" id="mapping-619"></span><span class="token add" data-title="binary_expression/member_expression">targetPool.oracleWeight</span>) {
            return;
        }
        updatePoolDividend(targetPid);
        rankPoolIndex[_poolIndexInRank] = _pid;
        delete rankPoolIndexMap[targetPid];
        rankPoolIndexMap[_pid] = _poolIndexInRank.add(1);
        pool.lastDividendHeight = block.number;
        emit Replace(msg.sender, _poolIndexInRank, _pid);
    }

    function acceptInvitation(<span class="marker" id="mapping-620"></span><span class="token mv" id="move-dst-80" data-title="function_definition/parameter">address _invitor</span>) external virtual override {
        require(_invitor != msg.sender, "invitee should not be invitor");
        <span class="marker" id="mapping-621"></span><span class="token mv" id="move-dst-82" data-title="function_body/variable_declaration_statement">InvitationInfo storage invitee = usersRelationshipInfo[<span class="marker" id="mapping-622"></span><span class="token add" data-title="array_access/member_expression">msg.sender</span>];</span>
        <span class="marker" id="mapping-623"></span><span class="token mv" id="move-dst-83" data-title="function_body/expression_statement">require(!invitee.isUsed, "has accepted invitation");</span>
        <span class="marker" id="mapping-624"></span><span class="token mv" id="move-dst-84" data-title="function_body/expression_statement">invitee.isUsed = true;</span>
        <span class="marker" id="mapping-625"></span><span class="token mv" id="move-dst-85" data-title="function_body/variable_declaration_statement">InvitationInfo storage invitor = usersRelationshipInfo[_invitor];</span>
        <span class="marker" id="mapping-626"></span><span class="token mv" id="move-dst-86" data-title="function_body/expression_statement">require(invitor.isUsed, "invitor has not acceptted invitation");</span>
        <span class="marker" id="mapping-627"></span><span class="token mv" id="move-dst-87" data-title="function_body/expression_statement">invitee.invitor = _invitor;</span>
        <span class="marker" id="mapping-628"></span><span class="token mv" id="move-dst-88" data-title="call_expression/member_expression">invitor.invitees.push</span>(msg.sender);
        <span class="marker" id="mapping-629"></span><span class="token mv" id="move-dst-89" data-title="function_body/expression_statement">invitor.inviteeIndexMap[<span class="marker" id="mapping-630"></span><span class="token add" data-title="array_access/member_expression">msg.sender</span>] = invitor.invitees.length.sub(1);</span>
    }

    function setMaxRankNumber(uint256 _count) external virtual {
        checkAdmin();
        require(_count &gt; 0, "invalid count");
        if (maxRankNumber == _count) return;
        massUpdatePools();
        maxRankNumber = _count;
        uint256 currentPoolCountInRank = rankPoolIndex.length;
        if (_count &gt;= currentPoolCountInRank) {
            return;
        }
        uint256 sparePoolCount = currentPoolCountInRank.sub(_count);
        uint256 lastPoolIndex = currentPoolCountInRank.sub(1);
        while (sparePoolCount &gt; 0) {
            delete rankPoolIndexMap[rankPoolIndex[lastPoolIndex]];
            rankPoolIndex.pop();
            lastPoolIndex--;
            sparePoolCount--;
        }
    }

    // View function to see pending SHARDs on frontend.
    function pendingSHARDByPids(uint256[] memory _pids, address _user)
        external
        view
        virtual
        returns (uint256[] memory _pending, uint256[] memory _potential, uint256 _blockNumber)
    {
         uint256 poolCount = _pids.length;
        _pending = new uint256[](poolCount);
        _potential = new uint256[](poolCount);
        _blockNumber = block.number;
        for(uint i = 0; i &lt; poolCount; i ++){
            (_pending[i], _potential[i]) = calculatePendingSHARD(_pids[i], _user);
        }
    }

    function calculatePendingSHARD(uint256 _pid, address _user) private view returns (uint256 _pending, uint256 _potential){
        PoolInfo storage pool = poolInfo[_pid];
        UserInfo storage user = userInfo[_pid][_user];
        <span class="marker" id="mapping-631"></span><span class="token add" data-title="function_body/variable_declaration_statement">UserRevenueInfo storage userRevenue = userRevenueInfo[_pid][_user];</span>
        if (user.amount == 0) {
            return (0, 0);
        }
        uint256 userModifiedWeight = getUserModifiedWeight(_pid, _user);
        <span class="marker" id="mapping-632"></span><span class="token mv" id="move-dst-95" data-title="function_body/variable_declaration_statement">uint256 <span class="marker" id="mapping-633"></span><span class="token upd" id="move-dst-96" data-title="variable_declaration/identifier">acc<span class="cupd">um</span>ulativSHDP<span class="cupd">er</span>Weight</span> <span class="marker" id="mapping-634"></span><span class="token add" data-title="variable_declaration_statement/=">=</span> <span class="marker" id="mapping-635"></span><span class="token add" data-title="variable_declaration_statement/array_access">poolAccs[_pid]</span>;</span>
        <span class="marker" id="mapping-636"></span><span class="token mv" id="move-dst-101" data-title="function_body/if_statement">if(<span class="marker" id="mapping-637"></span><span class="token add" data-title="binary_expression/member_expression">accumulativSHDPerWeight == 0 &amp;&amp; pool.accumulativeDividend</span> <span class="marker" id="mapping-638"></span><span class="token add" data-title="binary_expression/>">&gt;</span> 0)<span class="marker" id="mapping-639"></span><span class="token add" data-title="if_statement/block_statement">{
            <span class="marker" id="mapping-640"></span><span class="token add" data-title="block_statement/expression_statement"><span class="marker" id="mapping-641"></span><span class="token add" data-title="expression_statement/assignment_expression">accumulativSHDPerWeight = <span class="marker" id="mapping-642"></span><span class="token mv" id="move-dst-58" data-title="assignment_expression/call_expression">pool.accumulativeDividend.mul(<span class="marker" id="mapping-643"></span><span class="token add" data-title="call_expression/call_argument">1e12</span>).div(<span class="marker" id="mapping-644"></span><span class="token add" data-title="call_argument/member_expression">pool.usersTotalWeight</span>)</span></span>;</span>
        }</span></span>
        <span class="marker" id="mapping-645"></span><span class="token add" data-title="function_body/expression_statement">_pending = userRevenue.revenue;</span>
        <span class="marker" id="mapping-646"></span><span class="token add" data-title="function_body/expression_statement"><span class="marker" id="mapping-647"></span><span class="token add" data-title="expression_statement/assignment_expression">_pending = <span class="marker" id="mapping-648"></span><span class="token add" data-title="assignment_expression/call_expression"><span class="marker" id="mapping-649"></span><span class="token add" data-title="call_expression/member_expression">_pending.add</span>(<span class="marker" id="mapping-650"></span><span class="token add" data-title="call_expression/call_argument"><span class="marker" id="mapping-651"></span><span class="token add" data-title="call_argument/call_expression"><span class="marker" id="mapping-652"></span><span class="token add" data-title="call_expression/member_expression"><span class="marker" id="mapping-653"></span><span class="token add" data-title="member_expression/call_expression"><span class="marker" id="mapping-654"></span><span class="token add" data-title="call_expression/member_expression">accumulativSHDPerWeight.mul</span>(<span class="marker" id="mapping-655"></span><span class="token mv" id="move-dst-91" data-title="call_expression/call_argument">userModifiedWeight</span>)</span>.div</span>(<span class="marker" id="mapping-656"></span><span class="token add" data-title="call_expression/call_argument">1e12</span>)</span></span>)</span></span>;</span>
        <span class="marker" id="mapping-657"></span><span class="token add" data-title="function_body/expression_statement">_pending = _pending.sub(userRevenue.userRewardDebt);</span>
        bool isContractSender = isUserContractSender[_pid][_user];
        (,,_pending) = calculateDividend(_pending, _pid, user.amount, isContractSender);
        if (pool.lastDividendHeight &gt;= block.number) {
            return (_pending, 0);
        }
        if (_pid != 0 &amp;&amp; (rankPoolIndex.length == 0 || rankPoolIndexMap[_pid] == 0)) {
            return (_pending, 0);
        }
        uint256 poolReward =
            <span class="marker" id="mapping-658"></span><span class="token upd" id="move-dst-94" data-title="call_expression/identifier"><span class="cupd">get</span><span class="cupd">RewardToken</span></span>(pool.lastDividendHeight.add(1), block.number);
        uint256 <span class="marker" id="mapping-659"></span><span class="token upd" id="move-dst-97" data-title="variable_declaration/identifier">toBeDivi<span class="cupd">den</span>d</span> = <span class="marker" id="mapping-660"></span><span class="token mv" id="move-dst-102" data-title="member_expression/call_expression">poolReward.mul(<span class="marker" id="mapping-661"></span><span class="token mv" id="move-dst-100" data-title="call_expression/call_argument">shardPoolDividendWeight</span>)</span>
                                               .<span class="marker" id="mapping-662"></span><span class="token mv" id="move-dst-99" data-title="member_expression/identifier"><span class="marker" id="mapping-663"></span><span class="token upd" id="move-dst-99" data-title="member_expression/identifier">d<span class="cupd">iv</span></span></span>(<span class="marker" id="mapping-664"></span><span class="token add" data-title="call_expression/call_argument">shardPoolDividendWeight.add(otherPoolDividendWeight)</span>);  
        if(_pid <span class="marker" id="mapping-665"></span><span class="token add" data-title="binary_expression/>">&gt;</span> 0){
            <span class="marker" id="mapping-666"></span><span class="token upd" id="move-dst-103" data-title="assignment_expression/identifier">t<span class="cupd">o</span>B<span class="cupd">e</span>Dividend</span> = <span class="marker" id="mapping-667"></span><span class="token add" data-title="member_expression/call_expression">poolReward.sub(toBeDividend)</span>.div(rankPoolIndex.length);
        }    
        _potential = <span class="marker" id="mapping-668"></span><span class="token upd" id="move-dst-104" data-title="member_expression/identifier">t<span class="cupd">o</span>B<span class="cupd">e</span>Dividend</span>.mul(userModifiedWeight).div(pool.usersTotalWeight);
        (,,_potential) = calculateDividend(_potential, _pid, user.amount, isContractSender);
    }

    //calculate the weight and end block when users deposit
    function getDepositWeight(uint256 _lockAmount, uint256 _lockTime)
        private
        view
        returns (uint256)
    {
        if (_lockTime == 0) return 0;
        if (_lockTime.div(MAX_MONTH) &gt; 1) _lockTime = MAX_MONTH;
        return depositTimeWeight[_lockTime.sub(1)].sub(500).mul(_lockAmount);
    }

    function getPoolLength() external view virtual returns (uint256) {
        return poolInfo.length;
    }

    function getInstantPagePoolInfo(uint256 _fromIndex, uint256 _toIndex)
    external
    virtual
    returns (
        uint256[] memory _nftPoolId,
        uint256[] memory _accumulativeDividend,
        uint256[] memory _usersTotalWeight,
        uint256[] memory _lpTokenAmount,
        uint256[] memory _oracleWeight,
        address[] memory _swapAddress
    )
    {
        uint256 poolCount = _toIndex.sub(_fromIndex).add(1);
        _nftPoolId = new uint256[](poolCount);
        _accumulativeDividend = new uint256[](poolCount);
        _usersTotalWeight = new uint256[](poolCount);
        _lpTokenAmount = new uint256[](poolCount);
        _oracleWeight = new uint256[](poolCount);
        _swapAddress = new address[](poolCount);
        uint256 startIndex = 0;
        for (uint256 i = _fromIndex; i &lt;= _toIndex; i++) {
            PoolInfo storage pool = poolInfo[i];
            _nftPoolId[startIndex] = pool.nftPoolId;
            _accumulativeDividend[startIndex] = pool.accumulativeDividend;
            _usersTotalWeight[startIndex] = pool.usersTotalWeight;
            _lpTokenAmount[startIndex] = pool.lpTokenAmount;
            _oracleWeight[startIndex] = <span class="marker" id="mapping-669"></span><span class="token upd" id="move-dst-107" data-title="call_expression/identifier">calculat<span class="cupd">e</span><span class="cupd">OracleWeight</span></span>(pool, <span class="marker" id="mapping-670"></span><span class="token add" data-title="call_argument/member_expression">pool.lpTokenAmount</span>);
            _swapAddress[startIndex] = pool.lpTokenSwap;
            startIndex++;
        }
    }

    function getRankList() external view virtual returns (uint256[] memory) {
        uint256[] memory rankIdList = rankPoolIndex;
        return rankIdList;
    }

    function getBlackList()
        external
        view
        virtual
        returns (EvilPoolInfo[] memory _blackList)
    {
        _blackList = blackList;
    }

    function getInvitation(address _sender)
        external
        view
        virtual
        override
        returns (
            address _invitor,
            address[] memory _invitees,
            bool _isWithdrawn
        )
    {
        InvitationInfo storage invitation = usersRelationshipInfo[_sender];
        _invitees = invitation.invitees;
        _invitor = invitation.invitor;
        _isWithdrawn = invitation.isWithdrawn;
    }

    function getUserInfoByPids(uint256[] memory _pids, address _user)
        external
        view
        virtual
        returns (
            uint256[] memory _amount,
            uint256[] memory _originWeight,
            uint256[] memory _modifiedWeight,
            uint256[] memory _endBlock
        )
    {
        uint256 poolCount = _pids.length;
        _amount = new uint256[](poolCount);
        _originWeight = new uint256[](poolCount);
        _modifiedWeight = new uint256[](poolCount);
        _endBlock = new uint256[](poolCount);
        for(uint i = 0; i &lt; poolCount; i ++){
             <span class="marker" id="mapping-671"></span><span class="token add" data-title="block_statement/variable_declaration_statement">UserInfo storage user = userInfo[_pids[i]][_user];</span>
            <span class="marker" id="mapping-672"></span><span class="token add" data-title="block_statement/expression_statement"><span class="marker" id="mapping-673"></span><span class="token add" data-title="expression_statement/assignment_expression"><span class="marker" id="mapping-674"></span><span class="token mv" id="move-dst-123" data-title="assignment_expression/array_access">_amount[i]</span> = <span class="marker" id="mapping-675"></span><span class="token add" data-title="assignment_expression/member_expression">user.amount</span></span>;</span>
            <span class="marker" id="mapping-676"></span><span class="token add" data-title="block_statement/expression_statement"><span class="marker" id="mapping-677"></span><span class="token add" data-title="expression_statement/assignment_expression"><span class="marker" id="mapping-678"></span><span class="token mv" id="move-dst-124" data-title="assignment_expression/array_access">_originWeight[i]</span> = <span class="marker" id="mapping-679"></span><span class="token add" data-title="assignment_expression/member_expression">user.originWeight</span></span>;</span>
            <span class="marker" id="mapping-680"></span><span class="token mv" id="move-dst-125" data-title="assignment_expression/array_access">_modifiedWeight[i]</span> = <span class="marker" id="mapping-681"></span><span class="token upd" id="move-dst-127" data-title="call_expression/identifier"><span class="cupd">getUser</span>ModifiedWeight</span>(_pids[i], _user);
            <span class="marker" id="mapping-682"></span><span class="token add" data-title="block_statement/expression_statement"><span class="marker" id="mapping-683"></span><span class="token add" data-title="expression_statement/assignment_expression"><span class="marker" id="mapping-684"></span><span class="token mv" id="move-dst-126" data-title="assignment_expression/array_access">_endBlock[i]</span> = <span class="marker" id="mapping-685"></span><span class="token add" data-title="assignment_expression/member_expression">user.endBlock</span></span>;</span>
        }
    }

    // Safe SHD transfer function, just in case if rounding error causes pool to not have enough SHARDs.
    function safeSHARDTransfer(address _to, uint256 _amount) internal {
        uint256 SHARDBal = SHD.balanceOf(address(this));
        if (_amount &gt; SHARDBal) {
            SHD.transfer(_to, SHARDBal);
        } else {
            SHD.transfer(_to, _amount);
        }
    }

    function calculateOracleWeight(PoolInfo storage _pool, uint256 _amount)
        private
        returns (uint256 _oracleWeight)
    {
        uint256 lpTokenTotalSupply =
            IUniswapV2Pair(_pool.lpTokenSwap).totalSupply();
        (uint112 shardReserve, uint112 wantTokenReserve, ) =
            IUniswapV2Pair(_pool.lpTokenSwap).getReserves();
        if (_amount == 0) {
            _amount = _pool.lpTokenAmount;
            if (_amount == 0) {
                return 0;
            }
        }
        if (!_pool.isFirstTokenShard) {
            uint112 wantToken = wantTokenReserve;
            wantTokenReserve = shardReserve;
            shardReserve = wantToken;
        }
        FixedPoint.uq112x112 memory price;
        if(_pool.tokenToEthPairInfo.blockTimestampLast == 0){
            price = initializeTokenOracle(_pool.tokenToEthPairInfo);
        }
        else{
            price = updateTokenOracle(_pool.tokenToEthPairInfo);
        }
        if (
            address(_pool.tokenToEthPairInfo.tokenToEthSwap) ==
            _pool.lpTokenSwap
        ) {
            _oracleWeight = uint256(price.mul(shardReserve).decode144())
                .mul(2)
                .mul(_amount)
                .div(lpTokenTotalSupply);
        } else {
            _oracleWeight = uint256(price.mul(wantTokenReserve).decode144())
                .mul(2)
                .mul(_amount)
                .div(lpTokenTotalSupply);
        }
    }

    function resetInvitationRelationship(
        uint256 _pid,
        <span class="marker" id="mapping-686"></span><span class="token mv" id="move-dst-109" data-title="function_definition/parameter">address _user</span>,
        uint256 _originWeight
    ) <span class="marker" id="mapping-687"></span><span class="token mv" id="move-dst-131" data-title="function_definition/visibility">private</span> {
        InvitationInfo storage senderRelationshipInfo =
            usersRelationshipInfo[_user];
        if (!senderRelationshipInfo.isWithdrawn){
            <span class="marker" id="mapping-688"></span><span class="token add" data-title="block_statement/expression_statement"><span class="marker" id="mapping-689"></span><span class="token add" data-title="expression_statement/call_expression">cancleInvitation(<span class="marker" id="mapping-690"></span><span class="token add" data-title="call_expression/call_argument">senderRelationshipInfo</span>, <span class="marker" id="mapping-691"></span><span class="token mv" id="move-dst-118" data-title="call_expression/call_argument">_user</span>)</span>;</span>
        }
        UserInfo storage invitorInfo =
            userInfo[_pid][senderRelationshipInfo.invitor];
        UserInfo storage user =
            userInfo[_pid][_user];
        if(!user.isCalculateInvitation){
            return;
        }
        user.isCalculateInvitation = false;
        <span class="marker" id="mapping-692"></span><span class="token mv" id="move-dst-72" data-title="function_body/variable_declaration_statement">uint256 <span class="marker" id="mapping-693"></span><span class="token upd" id="move-dst-73" data-title="variable_declaration/identifier">invi<span class="cupd">t</span>o<span class="cupd">r</span>M<span class="cupd">o</span>difi<span class="cupd">e</span>d<span class="cupd">Weight</span></span> = <span class="marker" id="mapping-694"></span><span class="token add" data-title="variable_declaration_statement/call_expression">getUserModifiedWeight(<span class="marker" id="mapping-695"></span><span class="token mv" id="move-dst-48" data-title="call_expression/call_argument">_pid</span>, <span class="marker" id="mapping-696"></span><span class="token add" data-title="call_expression/call_argument">senderRelationshipInfo.invitor</span>)</span>;</span>
        uint256 inviteeToSubWeight = _originWeight.div(INVITEE_WEIGHT);
        invitorInfo.inviteeWeight = invitorInfo.inviteeWeight.sub(inviteeToSubWeight);
        if (invitorInfo.amount == 0){
            return;
        }
        <span class="marker" id="mapping-697"></span><span class="token add" data-title="function_body/variable_declaration_statement">UserRevenueInfo storage invitorRevenueInfo = userRevenueInfo[_pid][senderRelationshipInfo.invitor];</span>
        <span class="marker" id="mapping-698"></span><span class="token add" data-title="function_body/variable_declaration_statement">uint256 pending = poolAccs[_pid].mul(invitorModifiedWeight);</span>
        <span class="marker" id="mapping-699"></span><span class="token add" data-title="function_body/expression_statement">pending = pending.div(1e12).sub(invitorRevenueInfo.userRewardDebt);</span>
        <span class="marker" id="mapping-700"></span><span class="token add" data-title="function_body/expression_statement"><span class="marker" id="mapping-701"></span><span class="token add" data-title="expression_statement/assignment_expression"><span class="marker" id="mapping-702"></span><span class="token add" data-title="assignment_expression/member_expression">invitorRevenueInfo.revenue</span> = <span class="marker" id="mapping-703"></span><span class="token add" data-title="assignment_expression/call_expression"><span class="marker" id="mapping-704"></span><span class="token add" data-title="call_expression/member_expression">invitorRevenueInfo.revenue.add</span>(<span class="marker" id="mapping-705"></span><span class="token mv" id="move-dst-70" data-title="call_expression/call_argument">pending</span>)</span></span>;</span>
        <span class="marker" id="mapping-706"></span><span class="token add" data-title="function_body/expression_statement">invitorModifiedWeight = invitorModifiedWeight.sub(inviteeToSubWeight);</span>
        <span class="marker" id="mapping-707"></span><span class="token add" data-title="function_body/expression_statement">invitorRevenueInfo.userRewardDebt = poolAccs[_pid].mul(invitorModifiedWeight).div(1e12);</span>
        PoolInfo storage pool = poolInfo[_pid];
        pool.usersTotalWeight = pool.usersTotalWeight.sub(inviteeToSubWeight);
    }

    <span class="marker" id="mapping-708"></span><span class="token add" data-title="contract_body/function_definition">function cancleInvitation(<span class="marker" id="mapping-709"></span><span class="token add" data-title="function_definition/parameter">InvitationInfo storage senderRelationshipInfo</span>, <span class="marker" id="mapping-710"></span><span class="token mv" id="move-dst-133" data-title="function_definition/parameter">address _user</span>) <span class="marker" id="mapping-711"></span><span class="token mv" id="move-dst-134" data-title="function_definition/visibility">private</span><span class="marker" id="mapping-712"></span><span class="token add" data-title="function_definition/function_body">{
        <span class="marker" id="mapping-713"></span><span class="token mv" id="move-dst-135" data-title="function_body/expression_statement">senderRelationshipInfo.isWithdrawn = true;</span>
        <span class="marker" id="mapping-714"></span><span class="token mv" id="move-dst-136" data-title="function_body/variable_declaration_statement">InvitationInfo storage invitorRelationshipInfo = usersRelationshipInfo[senderRelationshipInfo.invitor];</span>
        <span class="marker" id="mapping-715"></span><span class="token mv" id="move-dst-137" data-title="function_body/variable_declaration_statement">uint256 targetIndex = invitorRelationshipInfo.inviteeIndexMap[_user];</span>
        <span class="marker" id="mapping-716"></span><span class="token mv" id="move-dst-138" data-title="function_body/variable_declaration_statement">uint256 inviteesCount = invitorRelationshipInfo.invitees.length;</span>
        <span class="marker" id="mapping-717"></span><span class="token mv" id="move-dst-139" data-title="function_body/variable_declaration_statement">address lastInvitee = invitorRelationshipInfo.invitees[inviteesCount.sub(1)];</span>
        <span class="marker" id="mapping-718"></span><span class="token mv" id="move-dst-140" data-title="function_body/expression_statement">invitorRelationshipInfo.inviteeIndexMap[lastInvitee] = targetIndex;</span>
        <span class="marker" id="mapping-719"></span><span class="token mv" id="move-dst-141" data-title="function_body/expression_statement">invitorRelationshipInfo.invitees[targetIndex] = lastInvitee;</span>
        <span class="marker" id="mapping-720"></span><span class="token mv" id="move-dst-142" data-title="function_body/expression_statement">delete invitorRelationshipInfo.inviteeIndexMap[_user];</span>
        <span class="marker" id="mapping-721"></span><span class="token mv" id="move-dst-143" data-title="function_body/expression_statement">invitorRelationshipInfo.invitees.pop();</span>
    }</span></span>

    function modifyWeightByInvitation(
        <span class="marker" id="mapping-722"></span><span class="token add" data-title="function_definition/parameter">InvitationRelationParam memory p</span>
    ) private{
        <span class="marker" id="mapping-723"></span><span class="token add" data-title="function_body/variable_declaration_statement">PoolInfo storage pool = poolInfo[p.pid];</span>
        InvitationInfo storage senderInfo = usersRelationshipInfo[<span class="marker" id="mapping-724"></span><span class="token add" data-title="array_access/member_expression">p.user</span>];
        uint256 poolTotalWeight = <span class="marker" id="mapping-725"></span><span class="token add" data-title="variable_declaration_statement/call_expression"><span class="marker" id="mapping-726"></span><span class="token add" data-title="call_expression/member_expression"><span class="marker" id="mapping-727"></span><span class="token mv" id="move-dst-55" data-title="member_expression/member_expression">pool.usersTotalWeight</span>.add</span>(<span class="marker" id="mapping-728"></span><span class="token add" data-title="call_expression/call_argument">p.addWeight</span>)</span>;
        <span class="marker" id="mapping-729"></span><span class="token mv" id="move-dst-161" data-title="function_body/variable_declaration_statement">uint256 <span class="marker" id="mapping-730"></span><span class="token upd" id="move-dst-162" data-title="variable_declaration/identifier">se<span class="cupd">n</span>derTot<span class="cupd">a</span>lW<span class="cupd">e</span>i<span class="cupd">g</span>ht</span> = <span class="marker" id="mapping-731"></span><span class="token add" data-title="variable_declaration_statement/call_expression">getUserModifiedWeight(p.pid, p.user)</span>;</span>
        <span class="marker" id="mapping-732"></span><span class="token add" data-title="function_body/variable_declaration_statement"><span class="marker" id="mapping-733"></span><span class="token add" data-title="variable_declaration_statement/variable_declaration"><span class="marker" id="mapping-734"></span><span class="token mv" id="move-dst-128" data-title="variable_declaration/type_name">UserInfo</span> storage user</span> = <span class="marker" id="mapping-735"></span><span class="token add" data-title="variable_declaration_statement/array_access">userInfo[p.pid][p.user]</span>;</span>
        <span class="marker" id="mapping-736"></span><span class="token mv" id="move-dst-53" data-title="function_body/variable_declaration_statement">uint256 <span class="marker" id="mapping-737"></span><span class="token upd" id="move-dst-54" data-title="variable_declaration/identifier">poolSHDP<span class="cupd">er</span><span class="cupd">Weight</span></span> = <span class="marker" id="mapping-738"></span><span class="token add" data-title="variable_declaration_statement/array_access">poolAccs[p.pid]</span>;</span>
        <span class="marker" id="mapping-739"></span><span class="token add" data-title="function_body/variable_declaration_statement">UserRevenueInfo storage senderRevenueInfo = userRevenueInfo[p.pid][p.user];</span>
        <span class="marker" id="mapping-740"></span><span class="token mv" id="move-dst-76" data-title="function_body/variable_declaration_statement">uint256 <span class="marker" id="mapping-741"></span><span class="token upd" id="move-dst-77" data-title="variable_declaration/identifier">s<span class="cupd">en</span>d<span class="cupd">er</span>R<span class="cupd">e</span>venue</span>;</span>
        if(<span class="marker" id="mapping-742"></span><span class="token add" data-title="binary_expression/member_expression">p.existedAmount</span> == 0){
            poolTotalWeight = poolTotalWeight.add(<span class="marker" id="mapping-743"></span><span class="token mv" id="move-dst-50" data-title="call_expression/call_argument">user.inviteeWeight</span>);
            <span class="marker" id="mapping-744"></span><span class="token add" data-title="block_statement/if_statement">if(pool.usersTotalWeight == 0 &amp;&amp; pool.accumulativeDividend &gt; 0 &amp;&amp; poolSHDPerWeight &gt; 0){
                senderRevenue = pool.accumulativeDividend;
            }</span>
        }<span class="marker" id="mapping-745"></span><span class="token add" data-title="if_statement/else">else</span><span class="marker" id="mapping-746"></span><span class="token add" data-title="if_statement/block_statement">{
            senderRevenue = senderTotalWeight.mul(poolSHDPerWeight).div(1e12).sub(senderRevenueInfo.userRewardDebt);   
        }</span>
        <span class="marker" id="mapping-747"></span><span class="token add" data-title="function_body/expression_statement">senderRevenueInfo.revenue = senderRevenueInfo.revenue.add(senderRevenue);</span>
        <span class="marker" id="mapping-748"></span><span class="token add" data-title="function_body/expression_statement">senderTotalWeight = senderTotalWeight.add(p.addWeight);</span>    
        if (!senderInfo.isWithdrawn || (<span class="marker" id="mapping-749"></span><span class="token add" data-title="binary_expression/member_expression">p.existedAmount</span> &gt; 0 &amp;&amp; user.isCalculateInvitation)) {
            <span class="marker" id="mapping-750"></span><span class="token add" data-title="block_statement/expression_statement">senderTotalWeight = senderTotalWeight.add(p.addInvitorWeight);</span>
            UserInfo storage invitorInfo = userInfo[<span class="marker" id="mapping-751"></span><span class="token add" data-title="array_access/member_expression">p.pid</span>][senderInfo.invitor];
            <span class="marker" id="mapping-752"></span><span class="token add" data-title="block_statement/variable_declaration_statement"><span class="marker" id="mapping-753"></span><span class="token mv" id="move-dst-150" data-title="variable_declaration_statement/variable_declaration">uint256 <span class="marker" id="mapping-754"></span><span class="token upd" id="move-dst-151" data-title="variable_declaration/identifier">i<span class="cupd">nvit</span>orModifi<span class="cupd">e</span>d<span class="cupd">Weight</span></span></span> = <span class="marker" id="mapping-755"></span><span class="token add" data-title="variable_declaration_statement/call_expression">getUserModifiedWeight(p.pid, senderInfo.invitor)</span>;</span>
            user.isCalculateInvitation = true;
            invitorInfo.inviteeWeight = invitorInfo.inviteeWeight.add(<span class="marker" id="mapping-756"></span><span class="token add" data-title="call_argument/member_expression">p.addInviteeWeight</span>);
            poolTotalWeight = poolTotalWeight.add(<span class="marker" id="mapping-757"></span><span class="token add" data-title="call_argument/member_expression">p.addInvitorWeight</span>);
            if (invitorInfo.amount &gt; 0) {
                poolTotalWeight = poolTotalWeight.add(<span class="marker" id="mapping-758"></span><span class="token add" data-title="call_argument/member_expression">p.addInviteeWeight</span>);
                <span class="marker" id="mapping-759"></span><span class="token add" data-title="block_statement/variable_declaration_statement">UserRevenueInfo storage invitorRevenueInfo = userRevenueInfo[p.pid][senderInfo.invitor];</span>
                <span class="marker" id="mapping-760"></span><span class="token add" data-title="block_statement/variable_declaration_statement"><span class="marker" id="mapping-761"></span><span class="token mv" id="move-dst-45" data-title="variable_declaration_statement/variable_declaration">uint256 <span class="marker" id="mapping-762"></span><span class="token upd" id="move-dst-46" data-title="variable_declaration/identifier"><span class="cupd">i</span>nvi<span class="cupd">t</span>orR<span class="cupd">e</span>venue</span></span> = <span class="marker" id="mapping-763"></span><span class="token add" data-title="variable_declaration_statement/call_expression">invitorModifiedWeight.mul(poolSHDPerWeight).div(1e12).sub(invitorRevenueInfo.userRewardDebt)</span>;</span>
                <span class="marker" id="mapping-764"></span><span class="token add" data-title="block_statement/expression_statement">invitorRevenueInfo.revenue = invitorRevenueInfo.revenue.add(invitorRevenue);</span>
                <span class="marker" id="mapping-765"></span><span class="token add" data-title="block_statement/variable_declaration_statement"><span class="marker" id="mapping-766"></span><span class="token mv" id="move-dst-154" data-title="variable_declaration_statement/variable_declaration">uint256 <span class="marker" id="mapping-767"></span><span class="token upd" id="move-dst-155" data-title="variable_declaration/identifier">i<span class="cupd">nvitor</span>R<span class="cupd">e</span>wardDebt</span></span> = <span class="marker" id="mapping-768"></span><span class="token add" data-title="variable_declaration_statement/call_expression">invitorModifiedWeight.add(p.addInviteeWeight)</span>;</span>
                <span class="marker" id="mapping-769"></span><span class="token add" data-title="block_statement/expression_statement">invitorRewardDebt = invitorRewardDebt.mul(poolSHDPerWeight).div(1e12);</span>
                <span class="marker" id="mapping-770"></span><span class="token add" data-title="block_statement/expression_statement">invitorRevenueInfo.userRewardDebt = invitorRewardDebt;</span>
            } 
        }
        <span class="marker" id="mapping-771"></span><span class="token add" data-title="function_body/expression_statement">senderRevenueInfo.userRewardDebt = senderTotalWeight.mul(poolSHDPerWeight).div(1e12);</span>
        pool.usersTotalWeight = poolTotalWeight;
    }

    function getUserModifiedWeight(uint256 _pid, address _user) private view returns (uint256){
        UserInfo storage user =  userInfo[_pid][_user];
        <span class="marker" id="mapping-772"></span><span class="token add" data-title="function_body/if_statement">if(user.amount == 0){
            return 0;
        }</span>
        uint256 originWeight = user.originWeight;
        uint256 modifiedWeight = originWeight.add(user.inviteeWeight);
        if(user.isCalculateInvitation){
            modifiedWeight = modifiedWeight.add(originWeight.div(INVITOR_WEIGHT));
        }
        return modifiedWeight;
    }

        // get how much token will be mined from _toBlock to _toBlock.
    function getRewardToken(uint256 _fromBlock, uint256 _toBlock) public view virtual returns (uint256){
        return calculateRewardToken(MINT_DECREASE_TERM, SHDPerBlock, startBlock, _fromBlock, _toBlock);
    }

    function calculateRewardToken(uint _term, uint256 _initialBlock, uint256 _startBlock, uint256 _fromBlock, uint256 _toBlock) private pure returns (uint256){
        if(_fromBlock &gt; _toBlock || _startBlock &gt; _toBlock)
            return 0;
        if(_startBlock &gt; _fromBlock)
            _fromBlock = _startBlock;
        uint256 totalReward = 0;
        uint256 blockPeriod = _fromBlock.sub(_startBlock).add(1);
        uint256 yearPeriod = blockPeriod.div(_term);  // produce 5760 blocks per day, 2102400 blocks per year.
        for (uint256 i = 0; i &lt; yearPeriod; i++){
            _initialBlock = _initialBlock.div(2);
        }
        uint256 termStartIndex = yearPeriod.add(1).mul(_term).add(_startBlock);
        uint256 beforeCalculateIndex = _fromBlock.sub(1);
        while(_toBlock &gt;= termStartIndex &amp;&amp; _initialBlock &gt; 0){
            totalReward = totalReward.add(termStartIndex.sub(beforeCalculateIndex).mul(_initialBlock));
            beforeCalculateIndex = termStartIndex.add(1);
            _initialBlock = _initialBlock.div(2);
            termStartIndex = termStartIndex.add(_term);
        }
        if(_toBlock &gt; beforeCalculateIndex){
            totalReward = totalReward.add(_toBlock.sub(beforeCalculateIndex).mul(_initialBlock));
        }
        return totalReward;
    }

    function getTargetTokenInSwap(IUniswapV2Pair _lpTokenSwap, address _targetToken) internal view returns (address, address, uint256){
        address token0 = _lpTokenSwap.token0();
        address token1 = _lpTokenSwap.token1();
        if(token0 == _targetToken){
            return(token0, token1, 0);
        }
        if(token1 == _targetToken){
            return(token0, token1, 1);
        }
        require(false, "invalid uniswap");
    }

    function generateOrcaleInfo(IUniswapV2Pair _pairSwap, bool _isFirstTokenEth) internal view returns(TokenPairInfo memory){
        uint256 priceTokenCumulativeLast = _isFirstTokenEth? _pairSwap.price1CumulativeLast(): _pairSwap.price0CumulativeLast();
        uint32 tokenBlockTimestampLast = 0;
        if(priceTokenCumulativeLast != 0){
            (, , tokenBlockTimestampLast) = _pairSwap.getReserves();
        }
        TokenPairInfo memory tokenBInfo = TokenPairInfo({
            tokenToEthSwap: _pairSwap,
            isFirstTokenEth: _isFirstTokenEth,
            priceCumulativeLast: priceTokenCumulativeLast,
            blockTimestampLast: tokenBlockTimestampLast,
            price: FixedPoint.uq112x112(0),
            lastPriceUpdateHeight: block.number
        });
        return tokenBInfo;
    }

    function initializeTokenOracle(TokenPairInfo storage _pairInfo) internal returns (FixedPoint.uq112x112 memory _price){
        uint32 blockTimestamp = uint32(block.timestamp % 2 ** 32);
        uint32 timeElapsed;
        uint256 initialPriceCumulative;
        (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast) = IUniswapV2Pair(_pairInfo.tokenToEthSwap).getReserves();
        if(_pairInfo.isFirstTokenEth){
            _price = FixedPoint.fraction(reserve0, reserve1);
            initialPriceCumulative = IUniswapV2Pair(_pairInfo.tokenToEthSwap).price1CumulativeLast();
        }
        else{
            _price = FixedPoint.fraction(reserve1, reserve0);
            initialPriceCumulative = IUniswapV2Pair(_pairInfo.tokenToEthSwap).price0CumulativeLast();
        }
        _pairInfo.price = _price;
        timeElapsed = blockTimestamp - blockTimestampLast;
        initialPriceCumulative = initialPriceCumulative.add(uint(_price._x).mul(timeElapsed));
        _pairInfo.priceCumulativeLast = initialPriceCumulative;
        _pairInfo.lastPriceUpdateHeight = block.number;
        _pairInfo.blockTimestampLast = blockTimestamp;
        return _price;
    }

    function updateTokenOracle(TokenPairInfo storage _pairInfo) internal returns (FixedPoint.uq112x112 memory _price) {
        FixedPoint.uq112x112 memory cachedPrice = _pairInfo.price;
        if(cachedPrice._x &gt; 0 &amp;&amp; block.number.sub(_pairInfo.lastPriceUpdateHeight) &lt;= updateTokenPriceTerm){
            return cachedPrice;
        }
        (uint price0Cumulative, uint price1Cumulative, uint32 blockTimestamp) =
            UniswapV2OracleLibrary.currentCumulativePrices(address(_pairInfo.tokenToEthSwap));
        uint32 timeElapsed = blockTimestamp - _pairInfo.blockTimestampLast; // overflow is desired
        // overflow is desired, casting never truncates
        // cumulative price is in (uq112x112 price * seconds) units so we simply wrap it after division by time elapsed
        if(_pairInfo.isFirstTokenEth){
            _price = FixedPoint.uq112x112(uint224(price1Cumulative.sub(_pairInfo.priceCumulativeLast).div(timeElapsed)));
            _pairInfo.priceCumulativeLast = price1Cumulative;
        }     
        else{
            _price = FixedPoint.uq112x112(uint224(price0Cumulative.sub(_pairInfo.priceCumulativeLast).div(timeElapsed)));
            _pairInfo.priceCumulativeLast = price0Cumulative;
        }
        _pairInfo.price = _price;
        _pairInfo.lastPriceUpdateHeight = block.number;
        _pairInfo.blockTimestampLast = blockTimestamp;
    }

    function updateAfterModifyStartBlock(uint256 _newStartBlock) internal override{
        lastRewardBlock = _newStartBlock.sub(1);
        if(poolInfo.length &gt; 0){
            PoolInfo storage shdPool = poolInfo[0];
            shdPool.lastDividendHeight = lastRewardBlock;
        }
    }
}

// File: contracts/ShardingDAOMiningDelegate.sol


pragma solidity 0.6.12;



contract ShardingDAOMiningDelegate is DelegateInterface, ShardingDAOMining {
    /**
     * @notice Construct an empty delegate
     */
    constructor() public {}

    /**
     * @notice Called by the delegator on a delegate to initialize it for duty
     * @param data The encoded bytes data for any initialization
     */
    function _becomeImplementation(bytes memory data)
        public
        override
    {
        checkAdmin();
        // Shh -- currently unused
        data;

        // Shh -- we don't ever want this hook to be marked pure
        if (false) {
            implementation = address(0);
        }
    }

    /**
     * @notice Called by the delegator on a delegate to forfeit its responsibility
     */
    function _resignImplementation() public override {
        checkAdmin();
        // Shh -- we don't ever want this hook to be marked pure
        if (false) {
            implementation = address(0);
        }
    }
}</pre></div></div></div></body></html>