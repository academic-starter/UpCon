<html lang="en"><head><meta charset="utf8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>GumTree</title><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css"><style type="text/css">/*
 * This file is part of GumTree.
 *
 * GumTree is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * GumTree is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with GumTree.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Copyright 2011-2015 Jean-Rémy Falleri <jr.falleri@gmail.com>
 * Copyright 2011-2015 Floréal Morandat <florealm@gmail.com>
 */

.add {
	border: 1px solid black;
	background-color: MediumSeaGreen;
}

.del {
	border: 1px solid black;
	background-color: IndianRed;
}

.mv {
	border: 1px solid black;
	background-color: Plum;
}

.upd {
	border: 1px solid black;
	background-color: DarkOrange;
	font-weight: bold;
}

.cupd {
	font-weight: normal;
	color: DimGray;
}

.selected {
	background-color: Gold;
}

.marker {
	margin: 0;
	padding: 0;
}

div {
	margin: 0px;
	padding: 0px;
}

.pre-scrollable {
	margin: 0px;
	padding: 0px;
	font-size: 10pt;
	color: black;
	max-height: 90vh;
	background-color: white;
	border: 1px solid black;
	font-family: "Hack, Inconsolata", "Consolas", "Liberation Sans Regular", "DejaVu Sans Mono", monospace;
}

.tooltip-inner {
    max-width: none;
}
</style><script type="text/javascript" src="https://code.jquery.com/jquery-3.4.1.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/js/bootstrap.bundle.min.js"></script><script type="text/javascript">/*
 * This file is part of GumTree.
 *
 * GumTree is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * GumTree is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with GumTree.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Copyright 2011-2015 Jean-Rémy Falleri <jr.falleri@gmail.com>
 * Copyright 2011-2015 Floréal Morandat <florealm@gmail.com>
 */

$(function(){
    let popoverTriggerList = [].slice.call(document.querySelectorAll('[data-bs-toggle="popover"]'))
    let popoverList = popoverTriggerList.map(function (popoverTriggerEl) {
      return new bootstrap.Popover(popoverTriggerEl)
    })

    $("body").keypress(function (event) {
        switch (event.which) {
            case 116:
                $('html, body').animate({scrollTop: 0}, 100);
                break;
            case 98:
                $("html, body").animate({ scrollTop: $(document).height() }, 100);
                break;
            case 113:
                window.location = "/quit";
                break;
            case 108:
                window.location = "/list";
                break;
        }
    });
});
</script><script type="text/javascript">/*
 * This file is part of GumTree.
 *
 * GumTree is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * GumTree is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with GumTree.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Copyright 2011-2015 Jean-Rémy Falleri <jr.falleri@gmail.com>
 * Copyright 2011-2015 Floréal Morandat <florealm@gmail.com>
 */

currentMapping = 0;

if (typeof String.prototype.startsWith != 'function') {
  String.prototype.startsWith = function (str){
    return this.slice(0, str.length) == str;
  };
}

function getMappedElement(eltId) {
	if (eltId.startsWith("move-src")) {
		return eltId.replace("src","dst");  	 	
  	}
  	else {
  		return eltId.replace("dst","src");
  	}
}

function nextMapping() {
	if (currentMapping == 0) {
		currentMapping = 1;
		return "#mapping-" + currentMapping.toString();
	} else {
		currentMapping++;
		
		if ($("#mapping-" + currentMapping.toString()).length > 0) {
			return "#mapping-" + currentMapping.toString();
		} else {
			currentMapping = 1;
			return "#mapping-" + currentMapping.toString();		
		}		
	}
}

function isSrc(eltId) {
	return eltId.startsWith("move-src");
}

$(function() {
    $("body").keypress(function (event) {
        switch(event.which) {
            case 110:
                const mapping = $(nextMapping());
                const pre = mapping.closest("pre");
                pre.animate({scrollTop: pre.scrollTop() + mapping.position().top - 200}, 100);
                break;
        }
    });

    // highlight
    $("span.mv.token, span.token.upd").click(function(event) {
        if ($(this).hasClass("selected")) {
            $("span.mv.token, span.token.upd").removeClass("selected");
        } else {
            $("span.mv.token, span.token.upd").removeClass("selected");
            const refElt = $("#" + getMappedElement($(this).attr("id")));
            $(this).addClass("selected");
            refElt.addClass("selected");
            const pre = refElt.closest("pre");
            console.log(pre);
            pre.animate({scrollTop: pre.scrollTop() + refElt.position().top - 200}, 100);
        }
        event.stopPropagation();
    });
    
    $("span.add.token, span.token.del").click(function(event) {
        $("span.mv.token, span.token.upd").removeClass("selected");
        event.stopPropagation();
    });

    // tooltip
    $("span.token").hover(
    	function (event) {
    		$(this).tooltip('show');
    		event.stopPropagation();
    	},
    	function (event) {
    		$(this).tooltip('hide');
    		event.stopPropagation();
    	}
    );
});
</script></head><body><div class="container-fluid"><div class="row"><div class="col"><div class="btn-toolbar justify-content-end"><div class="btn-group mr-2"><button class="btn btn-primary btn-sm" id="legend" data-bs-toggle="popover" data-bs-placement="bottom" data-bs-html="true" data-bs-content="<span class='del'>&nbsp;&nbsp;</span> deleted<br><span class='add'>&nbsp;&nbsp;</span> added<br><span class='mv'>&nbsp;&nbsp;</span> moved<br><span class='upd';>&nbsp;&nbsp;</span> updated<br>">Legend</button><button class="btn btn-primary btn-sm" id="shortcuts" data-bs-toggle="popover" data-bs-placement="bottom" data-bs-html="true" data-bs-content="<b>q</b> quit<br><b>l</b> list<br><b>n</b> next<br><b>t</b> top<br><b>b</b> bottom">Shortcuts</button></div><div class="btn-group"><a href="/list" class="btn btn-default btn-sm btn-primary">Back</a><a href="/quit" class="btn btn-default btn-sm btn-danger">Quit</a></div></div></div></div><div class="row"><div class="col-6"><h5>StakingEscrow.sol</h5><pre class="pre-scrollable">// SPDX-License-Identifier: AGPL-3.0-or-later

pragma solidity ^0.7.0;


import "IERC900History.sol";
import "Issuer.sol";
import "Bits.sol";
import "Snapshot.sol";
import "SafeMath.sol";
import "SafeERC20.sol";


/**
* @notice PolicyManager interface
*/
interface PolicyManagerInterface {
    function register(address _node, uint16 _period) external;
    function <span class="marker" id="mapping-1"></span><span class="token upd" id="move-src-1" data-title="function_definition/identifier">escrow</span>() external <span class="marker" id="mapping-2"></span><span class="token mv" id="move-src-2" data-title="function_definition/state_mutability">view</span> <span class="marker" id="mapping-3"></span><span class="token del" data-title="function_definition/return_type_definition">returns (<span class="marker" id="mapping-4"></span><span class="token mv" id="move-src-3" data-title="return_type_definition/parameter">address</span>)</span>;
    function ping(
        address _node,
        uint16 _processedPeriod1,
        uint16 _processedPeriod2,
        uint16 _periodToSetDefault
    ) external;
}


/**
* @notice Adjudicator interface
*/
interface AdjudicatorInterface {
    function <span class="marker" id="mapping-5"></span><span class="token upd" id="move-src-4" data-title="function_definition/identifier"><span class="cupd">e</span>sc<span class="cupd">r</span>ow</span>() external view returns (<span class="marker" id="mapping-6"></span><span class="token del" data-title="primitive_type/address">address</span>);
}


/**
* @notice WorkLock interface
*/
interface WorkLockInterface {
    function <span class="marker" id="mapping-7"></span><span class="token upd" id="move-src-5" data-title="function_definition/identifier">escrow</span>() external view returns (<span class="marker" id="mapping-8"></span><span class="token mv" id="move-src-6" data-title="parameter/type_name">address</span>);
}


<span class="marker" id="mapping-9"></span><span class="token upd" id="move-src-7" data-title="source_file/comment"><span class="cupd">/**
* @</span>no<span class="cupd">ti</span>c<span class="cupd">e </span>Con<span class="cupd">t</span>r<span class="cupd">a</span><span class="cupd">c</span><span class="cupd">t</span><span class="cupd"> </span>holds<span class="cupd"> </span>a<span class="cupd">n</span>d l<span class="cupd">o</span><span class="cupd">c</span>k<span class="cupd">s </span><span class="cupd">s</span>tak<span class="cupd">e</span>rs<span class="cupd"> to</span>k<span class="cupd">e</span>ns.<span class="cupd">
</span>* E<span class="cupd">a</span>ch<span class="cupd"> </span>s<span class="cupd">tak</span>e<span class="cupd">r</span><span class="cupd"> </span>th<span class="cupd">a</span><span class="cupd">t</span><span class="cupd"> </span><span class="cupd">l</span><span class="cupd">o</span>cks <span class="cupd">the</span>i<span class="cupd">r </span>t<span class="cupd">o</span>ke<span class="cupd">n</span>s<span class="cupd"> </span>will<span class="cupd"> </span>r<span class="cupd">e</span>ceive<span class="cupd"> some </span>comp<span class="cupd">e</span>n<span class="cupd">s</span><span class="cupd">a</span>tion<span class="cupd">
* @dev |v</span>5<span class="cupd">.</span>5<span class="cupd">.</span>1<span class="cupd">|
*/</span></span>
contract StakingEscrow is Issuer, IERC900History {

    using AdditionalMath for uint256;
    using AdditionalMath for uint16;
    using Bits for uint256;
    using SafeMath for uint256;
    using Snapshot for uint128[];
    using SafeERC20 for NuCypherToken;

    event Deposited(address indexed staker, uint256 value, uint16 periods);
    event Locked(address indexed staker, uint256 value, uint16 firstPeriod, uint16 periods);
    event Divided(
        address indexed staker,
        uint256 oldValue,
        uint16 lastPeriod,
        uint256 newValue,
        uint16 periods
    );
    event Merged(address indexed staker, uint256 value1, uint256 value2, uint16 lastPeriod);
    event Prolonged(address indexed staker, uint256 value, uint16 lastPeriod, uint16 periods);
    event Withdrawn(address indexed staker, uint256 value);
    event CommitmentMade(address indexed staker, uint16 indexed period, uint256 value);
    event Minted(address indexed staker, uint16 indexed period, uint256 value);
    event Slashed(address indexed staker, uint256 penalty, address indexed investigator, uint256 reward);
    event ReStakeSet(address indexed staker, bool reStake);
    <span class="marker" id="mapping-10"></span><span class="token mv" id="move-src-8" data-title="contract_body/event_definition">event <span class="marker" id="mapping-11"></span><span class="token upd" id="move-src-9" data-title="event_definition/identifier">ReS<span class="cupd">t</span>ak<span class="cupd">e</span>Locked</span>(address indexed staker, uint16 <span class="marker" id="mapping-12"></span><span class="token upd" id="move-src-10" data-title="event_paramater/identifier">lockUntilP<span class="cupd">eriod</span></span>);</span>
    event WorkerBonded(address indexed staker, address indexed worker, uint16 indexed startPeriod);
    <span class="marker" id="mapping-13"></span><span class="token mv" id="move-src-11" data-title="contract_body/event_definition">event WorkMeasurementSet(address indexed staker, bool measureWork);</span>
    event WindDownSet(address indexed staker, bool windDown);
    event SnapshotSet(address indexed staker, bool snapshotsEnabled);

    struct SubStakeInfo {
        uint16 firstPeriod;
        uint16 lastPeriod;
        <span class="marker" id="mapping-14"></span><span class="token mv" id="move-src-12" data-title="struct_declaration/struct_member">uint16 <span class="marker" id="mapping-15"></span><span class="token upd" id="move-src-13" data-title="struct_member/identifier">periods</span>;</span>
        uint128 lockedValue;
    }

    struct Downtime {
        uint16 startPeriod;
        uint16 endPeriod;
    }

    struct StakerInfo {
        uint256 value;
        /*
        * Stores periods that are committed but not yet rewarded.
        * In order to optimize storage, only two values are used instead of an array.
        * commitToNextPeriod() method invokes mint() method so there can only be two committed
        * periods that are not yet rewarded: the current and the next periods.
        */
        uint16 currentCommittedPeriod;
        uint16 nextCommittedPeriod;
        uint16 lastCommittedPeriod;
        <span class="marker" id="mapping-16"></span><span class="token mv" id="move-src-14" data-title="struct_declaration/struct_member">uint16 <span class="marker" id="mapping-17"></span><span class="token upd" id="move-src-15" data-title="struct_member/identifier"><span class="cupd">lock</span>ReSt<span class="cupd">a</span>keUn<span class="cupd">ti</span>lPeriod</span>;</span>
        uint256 completedWork;
        uint16 workerStartPeriod; // period when worker was bonded
        address worker;
        uint256 flags; // uint256 to acquire whole slot and minimize operations on it

        uint256 reservedSlot1;
        uint256 reservedSlot2;
        uint256 reservedSlot3;
        uint256 reservedSlot4;
        uint256 reservedSlot5;

        Downtime[] pastDowntime;
        SubStakeInfo[] subStakes;
        uint128[] history;

    }

    // used only for upgrading
    uint16 internal constant RESERVED_PERIOD = 0;
    uint16 internal constant MAX_CHECKED_VALUES = 5;
    // to prevent high gas consumption in loops for slashing
    uint16 public constant MAX_SUB_STAKES = 30;
    uint16 internal constant MAX_UINT16 = 65535;

    // indices for flags
    uint8 internal constant RE_STAKE_DISABLED_INDEX = 0;
    uint8 internal constant WIND_DOWN_INDEX = 1;
    uint8 internal constant MEASURE_WORK_INDEX = 2;
    uint8 internal constant SNAPSHOTS_DISABLED_INDEX = 3;

    uint16 public immutable minLockedPeriods;
    uint16 public immutable minWorkerPeriods;
    uint256 public immutable minAllowableLockedTokens;
    uint256 public immutable maxAllowableLockedTokens;
    <span class="marker" id="mapping-18"></span><span class="token mv" id="move-src-16" data-title="contract_body/state_variable_declaration"><span class="marker" id="mapping-19"></span><span class="token del" data-title="primitive_type/bool">bool</span> public immutable <span class="marker" id="mapping-20"></span><span class="token upd" id="move-src-17" data-title="state_variable_declaration/identifier">i<span class="cupd">s</span>T<span class="cupd">e</span>stC<span class="cupd">on</span>tract</span>;</span>

    mapping (address =&gt; StakerInfo) public stakerInfo;
    address[] public stakers;
    mapping (address =&gt; address) public stakerFromWorker;

    mapping (uint16 =&gt; uint256) <span class="marker" id="mapping-21"></span><span class="token mv" id="move-src-18" data-title="state_variable_declaration/visibility">public</span> <span class="marker" id="mapping-22"></span><span class="token upd" id="move-src-19" data-title="state_variable_declaration/identifier">lockedPerPeriod</span>;
    uint128[] public balanceHistory;

    <span class="marker" id="mapping-23"></span><span class="token mv" id="move-src-20" data-title="contract_body/state_variable_declaration">PolicyManagerInterface public policyManager;</span>
    <span class="marker" id="mapping-24"></span><span class="token mv" id="move-src-21" data-title="contract_body/state_variable_declaration">AdjudicatorInterface public adjudicator;</span>
    <span class="marker" id="mapping-25"></span><span class="token mv" id="move-src-22" data-title="contract_body/state_variable_declaration">WorkLockInterface public workLock;</span>

    <span class="marker" id="mapping-26"></span><span class="token mv" id="move-src-23" data-title="contract_body/comment"><span class="marker" id="mapping-27"></span><span class="token upd" id="move-src-24" data-title="contract_body/comment"><span class="cupd">/**
    * @notice </span>Constructor sets address of token contract and coeff<span class="cupd">i</span>cients for mintin<span class="cupd">g</span>
    * @param _toke<span class="cupd">n</span> Token contr<span class="cupd">a</span>ct
    * @param _hoursPerPeriod Size of period in hours
    * @param _issuanceDecayCoefficient (d) Coefficient which modifies the rate at which the maximum issuance decays,
    * on<span class="cupd">l</span>y applicable to Pha<span class="cupd">s</span>e<span class="cupd"> </span>2. d = 365 * half-life / LOG2 where defaul<span class="cupd">t</span> <span class="cupd">ha</span>lf-life = 2.
    * See Equa<span class="cupd">t</span>ion<span class="cupd"> </span>10 in S<span class="cupd">t</span>aking Pr<span class="cupd">o</span>tocol &amp; Economics paper
    * @param _loc<span class="cupd">k</span>DurationCo<span class="cupd">e</span>fficie<span class="cupd">n</span>t1 (k1) Numerator of the coefficient which modifie<span class="cupd">s </span>the extent
    * to <span class="cupd">w</span>hich a stak<span class="cupd">e</span>'s lock du<span class="cupd">r</span>ation aff<span class="cupd">e</span>cts<span class="cupd"> </span>the subsi<span class="cupd">d</span>y it r<span class="cupd">e</span>ceives. Affects stakers differently.
    * A<span class="cupd">p</span>plicable t<span class="cupd">o</span> Pha<span class="cupd">s</span>e 1 and Phase 2. k1 = k2 * small_s<span class="cupd">t</span>ak<span class="cupd">e</span>_multiplier where <span class="cupd">d</span>efault<span class="cupd"> </span>small_stake_multiplier<span class="cupd"> </span>=<span class="cupd"> </span>0.5.<span class="cupd">
 </span>   <span class="cupd">* </span>See Equation 8 in Staking Protocol &amp; Economics paper.
    * <span class="cupd">@param </span>_lockDurationCoefficient2 (k2) Denominator of the coefficient which modifie<span class="cupd">s</span> <span class="cupd">t</span>he extent
    * to which <span class="cupd">a</span> sta<span class="cupd">ke</span>'s lock du<span class="cupd">r</span>ation<span class="cupd"> </span>affec<span class="cupd">t</span>s the subsidy it receives. Affects st<span class="cupd">aker</span>s<span class="cupd"> </span>differently.
    * Applic<span class="cupd">a</span>ble to Phase 1 an<span class="cupd">d</span> Phase 2. k2 = maximum_rewar<span class="cupd">d</span>ed_pe<span class="cupd">r</span>iods / (1 - small_stak<span class="cupd">e</span>_multiplier)
    * where default maximum_rewarded_period<span class="cupd">s</span> = 365 and default <span class="cupd">s</span>mall_stake_multiplier<span class="cupd"> </span>=<span class="cupd"> </span>0.5.<span class="cupd">
  </span>  <span class="cupd">* </span>See Equation 8 in Staking Protocol &amp; Economics paper.
    * <span class="cupd">@param </span>_m<span class="cupd">a</span>xim<span class="cupd">u</span>mR<span class="cupd">e</span>wardedPeriods<span class="cupd"> </span>(k<span class="cupd">m</span>ax) Number <span class="cupd">o</span>f periods beyond which a stake's lock d<span class="cupd">u</span>ratio<span class="cupd">n</span>
    * no longer increases <span class="cupd">t</span>he<span class="cupd"> </span>subsi<span class="cupd">d</span>y it r<span class="cupd">e</span>ceive<span class="cupd">s</span>. kmax = reward_saturat<span class="cupd">i</span>on * 365 where defaul<span class="cupd">t</span> r<span class="cupd">e</span>war<span class="cupd">d</span>_saturation<span class="cupd"> </span>= 1.
    * See Equat<span class="cupd">i</span>o<span class="cupd">n </span>8 in Staking Protocol &amp; Economics paper.
    * @param _firstPhaseTotalS<span class="cupd">u</span>pply Total supply for the f<span class="cupd">i</span>rs<span class="cupd">t</span> pha<span class="cupd">s</span>e<span class="cupd">
    * @param </span>_firstPhaseMaxIssuance (Imax) Maximum number of new tokens minted <span class="cupd">per</span> per<span class="cupd">iod</span> during Pha<span class="cupd">s</span>e<span class="cupd"> </span>1.
    * See Eq<span class="cupd">u</span>ation 7 in Staking Protocol &amp; Econo<span class="cupd">m</span>ics pap<span class="cupd">er</span>.<span class="cupd">
</span>    * @param _minL<span class="cupd">o</span>ckedPeriods Min amount o<span class="cupd">f periods </span>during which <span class="cupd">tokens </span>can be locked
    * @param _minAllo<span class="cupd">w</span>ableLockedTokens M<span class="cupd">i</span>n amount of tokens that can be <span class="cupd">l</span>ocked
    * @param _maxA<span class="cupd">l</span>lowableLockedTokens<span class="cupd"> </span>Max amount of tokens that can <span class="cupd">be locked
    *</span> @param _minWorkerPeriods Min amount of periods while a worker can't be changed
    * @param _isTestContract True if contract is only for tests
    */</span></span>
    constructor(
        NuCypherToken _token,
        <span class="marker" id="mapping-28"></span><span class="token mv" id="move-src-25" data-title="constructor_definition/parameter">uint32 _hoursPerPeriod</span>,
        <span class="marker" id="mapping-29"></span><span class="token mv" id="move-src-26" data-title="constructor_definition/parameter">uint256 _issuanceDecayCoefficient</span>,
        <span class="marker" id="mapping-30"></span><span class="token mv" id="move-src-27" data-title="constructor_definition/parameter">uint256 _lockDurationCoefficient1</span>,
        <span class="marker" id="mapping-31"></span><span class="token mv" id="move-src-28" data-title="constructor_definition/parameter">uint256 _lockDurationCoefficient2</span>,
        <span class="marker" id="mapping-32"></span><span class="token mv" id="move-src-29" data-title="constructor_definition/parameter">uint16 _maximumRewardedPeriods</span>,
        <span class="marker" id="mapping-33"></span><span class="token mv" id="move-src-30" data-title="constructor_definition/parameter">uint256 _firstPhaseTotalSupply</span>,
        <span class="marker" id="mapping-34"></span><span class="token mv" id="move-src-31" data-title="constructor_definition/parameter">uint256 _firstPhaseMaxIssuance</span>,
        <span class="marker" id="mapping-35"></span><span class="token mv" id="move-src-32" data-title="constructor_definition/parameter">uint16 _minLockedPeriods</span>,
        <span class="marker" id="mapping-36"></span><span class="token mv" id="move-src-33" data-title="constructor_definition/parameter">uint256 _minAllowableLockedTokens</span>,
        <span class="marker" id="mapping-37"></span><span class="token mv" id="move-src-34" data-title="constructor_definition/parameter">uint256 _maxAllowableLockedTokens</span>,
        <span class="marker" id="mapping-38"></span><span class="token mv" id="move-src-35" data-title="constructor_definition/parameter">uint16 _minWorkerPeriods</span>,
        <span class="marker" id="mapping-39"></span><span class="token mv" id="move-src-36" data-title="constructor_definition/parameter"><span class="marker" id="mapping-40"></span><span class="token del" data-title="primitive_type/bool">bool</span> <span class="marker" id="mapping-41"></span><span class="token upd" id="move-src-37" data-title="parameter/identifier"><span class="cupd">_</span><span class="cupd">is</span>T<span class="cupd">e</span>stContract</span></span>
    )
        Issuer(
            _token,
            <span class="marker" id="mapping-42"></span><span class="token mv" id="move-src-38" data-title="modifier_invocation/call_argument">_hoursPerPeriod</span>,
            <span class="marker" id="mapping-43"></span><span class="token mv" id="move-src-39" data-title="modifier_invocation/call_argument">_issuanceDecayCoefficient</span>,
            <span class="marker" id="mapping-44"></span><span class="token mv" id="move-src-40" data-title="modifier_invocation/call_argument">_lockDurationCoefficient1</span>,
            <span class="marker" id="mapping-45"></span><span class="token mv" id="move-src-41" data-title="modifier_invocation/call_argument">_lockDurationCoefficient2</span>,
            <span class="marker" id="mapping-46"></span><span class="token mv" id="move-src-42" data-title="modifier_invocation/call_argument">_maximumRewardedPeriods</span>,
            <span class="marker" id="mapping-47"></span><span class="token mv" id="move-src-43" data-title="modifier_invocation/call_argument">_firstPhaseTotalSupply</span>,
            _firstPhaseMaxIssuance
        )
    {
        // constant `1` in the expression `_minLockedPeriods &gt; 1` uses to simplify the `lock` method
        require(_minLockedPeriods &gt; 1 &amp;&amp; _maxAllowableLockedTokens != 0);
        minLockedPeriods = _minLockedPeriods;
        minAllowableLockedTokens = _minAllowableLockedTokens;
        maxAllowableLockedTokens = _maxAllowableLockedTokens;
        minWorkerPeriods = _minWorkerPeriods;
        <span class="marker" id="mapping-48"></span><span class="token del" data-title="expression_statement/assignment_expression">isTestContract = _isTestContract</span>;
    }

    /**
    * @dev Checks the existence of a staker in the contract
    */
    modifier onlyStaker()
    {
        StakerInfo storage info = stakerInfo[msg.sender];
        <span class="marker" id="mapping-49"></span><span class="token mv" id="move-src-44" data-title="expression_statement/call_expression"><span class="marker" id="mapping-50"></span><span class="token del" data-title="call_expression/identifier">require</span>(<span class="marker" id="mapping-51"></span><span class="token mv" id="move-src-45" data-title="call_expression/call_argument"><span class="marker" id="mapping-52"></span><span class="token mv" id="move-src-46" data-title="call_argument/binary_expression">info.value &gt; 0 || info.nextCommittedPeriod != 0</span></span>)</span>;
        _;
    }

    <span class="marker" id="mapping-53"></span><span class="token mv" id="move-src-47" data-title="contract_body/comment"><span class="marker" id="mapping-54"></span><span class="token upd" id="move-src-48" data-title="contract_body/comment"><span class="cupd">/</span>/------------------------I<span class="cupd">n</span><span class="cupd">i</span><span class="cupd">t</span><span class="cupd">i</span><span class="cupd">a</span><span class="cupd">l</span><span class="cupd">i</span>z<span class="cupd">a</span><span class="cupd">t</span><span class="cupd">i</span>on------------------------</span></span>
    <span class="marker" id="mapping-55"></span><span class="token mv" id="move-src-49" data-title="contract_body/comment"><span class="marker" id="mapping-56"></span><span class="token upd" id="move-src-50" data-title="contract_body/comment"><span class="cupd">/**
    * @notice S</span><span class="cupd">e</span><span class="cupd">t</span><span class="cupd"> </span><span class="cupd">p</span><span class="cupd">ol</span><span class="cupd">i</span>cy<span class="cupd"> </span><span class="cupd">m</span><span class="cupd">a</span><span class="cupd">na</span>g<span class="cupd">e</span><span class="cupd">r</span><span class="cupd"> </span><span class="cupd">a</span><span class="cupd">d</span>d<span class="cupd">r</span><span class="cupd">e</span><span class="cupd">s</span><span class="cupd">s</span><span class="cupd">
    */</span></span></span>
    <span class="marker" id="mapping-57"></span><span class="token del" data-title="contract_body/function_definition">function setPolicyManager(<span class="marker" id="mapping-58"></span><span class="token mv" id="move-src-51" data-title="function_definition/parameter">PolicyManagerInterface _policyManager</span>) <span class="marker" id="mapping-59"></span><span class="token mv" id="move-src-52" data-title="function_definition/visibility">external</span> <span class="marker" id="mapping-60"></span><span class="token del" data-title="function_definition/modifier_invocation">onlyOwner</span> <span class="marker" id="mapping-61"></span><span class="token del" data-title="function_definition/function_body">{
        // Policy manager can be set only once
        <span class="marker" id="mapping-62"></span><span class="token del" data-title="function_body/expression_statement">require(address(policyManager) == address(0));</span>
        // This escrow must be the escrow for the new policy manager
        <span class="marker" id="mapping-63"></span><span class="token mv" id="move-src-53" data-title="function_body/expression_statement">require(<span class="marker" id="mapping-64"></span><span class="token del" data-title="binary_expression/call_expression">_policyManager.escrow()</span> == address(<span class="marker" id="mapping-65"></span><span class="token upd" id="move-src-54" data-title="call_argument/identifier">this</span>));</span>
        <span class="marker" id="mapping-66"></span><span class="token mv" id="move-src-55" data-title="function_body/expression_statement">policyManager = _policyManager;</span>
    }</span></span>

    <span class="marker" id="mapping-67"></span><span class="token mv" id="move-src-56" data-title="contract_body/comment"><span class="marker" id="mapping-68"></span><span class="token upd" id="move-src-57" data-title="contract_body/comment"><span class="cupd">/**
    * @notice S</span><span class="cupd">e</span><span class="cupd">t</span><span class="cupd"> </span><span class="cupd">a</span><span class="cupd">d</span>j<span class="cupd">u</span>d<span class="cupd">i</span><span class="cupd">c</span><span class="cupd">a</span><span class="cupd">t</span>o<span class="cupd">r</span><span class="cupd"> </span><span class="cupd">a</span><span class="cupd">d</span><span class="cupd">d</span><span class="cupd">r</span><span class="cupd">e</span><span class="cupd">s</span><span class="cupd">s</span><span class="cupd">
    */</span></span></span>
    <span class="marker" id="mapping-69"></span><span class="token del" data-title="contract_body/function_definition">function setAdjudicator(<span class="marker" id="mapping-70"></span><span class="token mv" id="move-src-58" data-title="function_definition/parameter">AdjudicatorInterface _adjudicator</span>) <span class="marker" id="mapping-71"></span><span class="token del" data-title="function_definition/visibility">external</span> <span class="marker" id="mapping-72"></span><span class="token del" data-title="function_definition/modifier_invocation">onlyOwner</span> <span class="marker" id="mapping-73"></span><span class="token del" data-title="function_definition/function_body">{
        // Adjudicator can be set only once
        <span class="marker" id="mapping-74"></span><span class="token del" data-title="function_body/expression_statement">require(address(adjudicator) == address(0));</span>
        // This escrow must be the escrow for the new adjudicator
        <span class="marker" id="mapping-75"></span><span class="token del" data-title="function_body/expression_statement">require(_adjudicator.escrow() == address(this));</span>
        <span class="marker" id="mapping-76"></span><span class="token mv" id="move-src-59" data-title="function_body/expression_statement">adjudicator = _adjudicator;</span>
    }</span></span>

    <span class="marker" id="mapping-77"></span><span class="token mv" id="move-src-60" data-title="contract_body/comment"><span class="marker" id="mapping-78"></span><span class="token upd" id="move-src-61" data-title="contract_body/comment"><span class="cupd">/**
    * @notice S</span>e<span class="cupd">t</span><span class="cupd"> </span><span class="cupd">w</span><span class="cupd">o</span><span class="cupd">r</span><span class="cupd">k</span><span class="cupd">l</span><span class="cupd">o</span>c<span class="cupd">k</span><span class="cupd"> </span><span class="cupd">a</span><span class="cupd">d</span><span class="cupd">d</span><span class="cupd">r</span><span class="cupd">e</span><span class="cupd">s</span><span class="cupd">s
</span><span class="cupd"> </span><span class="cupd"> </span><span class="cupd">  </span><span class="cupd">*/</span></span></span>
    <span class="marker" id="mapping-79"></span><span class="token del" data-title="contract_body/function_definition">function setWorkLock(<span class="marker" id="mapping-80"></span><span class="token mv" id="move-src-62" data-title="function_definition/parameter">WorkLockInterface _workLock</span>) <span class="marker" id="mapping-81"></span><span class="token del" data-title="function_definition/visibility">external</span> <span class="marker" id="mapping-82"></span><span class="token del" data-title="function_definition/modifier_invocation">onlyOwner</span> <span class="marker" id="mapping-83"></span><span class="token del" data-title="function_definition/function_body">{
        // WorkLock can be set only once
        <span class="marker" id="mapping-84"></span><span class="token del" data-title="function_body/expression_statement"><span class="marker" id="mapping-85"></span><span class="token mv" id="move-src-63" data-title="expression_statement/call_expression"><span class="marker" id="mapping-86"></span><span class="token del" data-title="call_expression/identifier">require</span>(<span class="marker" id="mapping-87"></span><span class="token mv" id="move-src-64" data-title="call_expression/call_argument"><span class="marker" id="mapping-88"></span><span class="token mv" id="move-src-65" data-title="call_argument/binary_expression">address(<span class="marker" id="mapping-89"></span><span class="token upd" id="move-src-66" data-title="call_argument/identifier"><span class="cupd">workLock</span></span>) == address(0) || <span class="marker" id="mapping-90"></span><span class="token upd" id="move-src-67" data-title="binary_expression/identifier">isTestC<span class="cupd">o</span>nt<span class="cupd">r</span>act</span></span></span>)</span>;</span>
        // This escrow must be the escrow for the new worklock
        <span class="marker" id="mapping-91"></span><span class="token del" data-title="function_body/expression_statement">require(_workLock.escrow() == address(this));</span>
        <span class="marker" id="mapping-92"></span><span class="token mv" id="move-src-68" data-title="function_body/expression_statement">workLock = _workLock;</span>
    }</span></span>

    //------------------------Main getters------------------------
    /**
    * @notice Get all tokens belonging to the staker
    */
    function getAllTokens(address _staker) external view returns (uint256) {
        return stakerInfo[_staker].value;
    }

    /**
    * @notice Get all flags for the staker
    */
    function getFlags(address _staker)
        external view returns (
            bool windDown,
            bool reStake,
            bool measureWork,
            bool snapshots
        )
    {
        StakerInfo storage info = stakerInfo[_staker];
        windDown = info.flags.bitSet(WIND_DOWN_INDEX);
        reStake = !info.flags.bitSet(RE_STAKE_DISABLED_INDEX);
        measureWork = info.flags.bitSet(MEASURE_WORK_INDEX);
        snapshots = !info.flags.bitSet(SNAPSHOTS_DISABLED_INDEX);
    }

    /**
    * @notice Get the start period. Use in the calculation of the last period of the sub stake
    * @param _info Staker structure
    * @param _currentPeriod Current period
    */
    function getStartPeriod(StakerInfo storage _info, uint16 _currentPeriod)
        internal view returns (uint16)
    {
        // if the next period (after current) is committed
        if (_info.flags.bitSet(WIND_DOWN_INDEX) &amp;&amp; _info.nextCommittedPeriod &gt; _currentPeriod) {
            return _currentPeriod + 1;
        }
        return _currentPeriod;
    }

    /**
    * @notice Get the last period of the sub stake
    * @param _subStake Sub stake structure
    * @param _startPeriod Pre-calculated start period
    */
    function getLastPeriodOfSubStake(SubStakeInfo storage _subStake, uint16 _startPeriod)
        internal view returns (uint16)
    {
        if (_subStake.lastPeriod != 0) {
            return _subStake.lastPeriod;
        }
        uint32 lastPeriod = uint32(_startPeriod) + _subStake.<span class="marker" id="mapping-93"></span><span class="token upd" id="move-src-69" data-title="member_expression/identifier">pe<span class="cupd">r</span><span class="cupd">io</span>ds</span>;
        if (lastPeriod &gt; uint32(MAX_UINT16)) {
            return MAX_UINT16;
        }
        return uint16(lastPeriod);
    }

    /**
    * @notice Get the last period of the sub stake
    * @param _staker Staker
    * @param _index Stake index
    */
    function getLastPeriodOfSubStake(address _staker, uint256 _index)
        public view returns (uint16)
    {
        StakerInfo storage info = stakerInfo[_staker];
        SubStakeInfo storage subStake = info.subStakes[_index];
        uint16 startPeriod = getStartPeriod(info, getCurrentPeriod());
        return getLastPeriodOfSubStake(subStake, startPeriod);
    }


    /**
    * @notice Get the value of locked tokens for a staker in a specified period
    * @dev Information may be incorrect for rewarded or not committed surpassed period
    * @param _info Staker structure
    * @param _currentPeriod Current period
    * @param _period Next period
    */
    function getLockedTokens(StakerInfo storage _info, uint16 _currentPeriod, uint16 _period)
        internal view returns (uint256 lockedValue)
    {
        lockedValue = 0;
        uint16 startPeriod = getStartPeriod(_info, _currentPeriod);
        for (uint256 i = 0; i &lt; _info.subStakes.length; i++) {
            SubStakeInfo storage subStake = _info.subStakes[i];
            if (subStake.firstPeriod &lt;= _period &amp;&amp;
                getLastPeriodOfSubStake(subStake, startPeriod) &gt;= _period) {
                lockedValue += subStake.lockedValue;
            }
        }
    }

    <span class="marker" id="mapping-94"></span><span class="token mv" id="move-src-70" data-title="contract_body/comment"><span class="marker" id="mapping-95"></span><span class="token upd" id="move-src-71" data-title="contract_body/comment"><span class="cupd">/**
    * @notice </span>Get<span class="cupd"> th</span>e v<span class="cupd">a</span>lue<span class="cupd"> </span>of locked <span class="cupd">tokens </span>fo<span class="cupd">r</span> a stak<span class="cupd">e</span>r<span class="cupd"> </span><span class="cupd">i</span>n a fu<span class="cupd">t</span>ure period
    * @dev T<span class="cupd">h</span>is function is use<span class="cupd">d</span> by P<span class="cupd">r</span>e<span class="cupd">a</span>llocatio<span class="cupd">n</span>Escrow<span class="cupd"> </span>s<span class="cupd">o </span>i<span class="cupd">t</span>s<span class="cupd"> s</span>igna<span class="cupd">t</span>ure c<span class="cupd">a</span>n't b<span class="cupd">e</span><span class="cupd"> </span>updated.<span class="cupd">
   </span> <span class="cupd">* @param </span>_<span class="cupd">staker Staker
</span><span class="cupd">    </span><span class="cupd">* @param </span>_p<span class="cupd">e</span>riods<span class="cupd"> Amount </span>of per<span class="cupd">i</span>ods <span class="cupd">th</span><span class="cupd">a</span>t<span class="cupd"> </span>w<span class="cupd">i</span>ll<span class="cupd"> </span>be added to the c<span class="cupd">u</span>rren<span class="cupd">t</span><span class="cupd"> </span>period<span class="cupd">
   </span> <span class="cupd">*/</span></span></span>
    function getLockedTokens(address _staker, <span class="marker" id="mapping-96"></span><span class="token mv" id="move-src-72" data-title="function_definition/parameter">uint16 <span class="marker" id="mapping-97"></span><span class="token upd" id="move-src-73" data-title="parameter/identifier"><span class="cupd">_period</span>s</span></span>)
        external view returns (uint256 lockedValue)
    {
        StakerInfo storage info = stakerInfo[_staker];
        uint16 currentPeriod = getCurrentPeriod();
        <span class="marker" id="mapping-98"></span><span class="token mv" id="move-src-74" data-title="function_body/variable_declaration_statement"><span class="marker" id="mapping-99"></span><span class="token del" data-title="variable_declaration_statement/variable_declaration">uint16 nextPeriod</span> = currentPeriod.add16(<span class="marker" id="mapping-100"></span><span class="token upd" id="move-src-75" data-title="call_argument/identifier"><span class="cupd">_</span>p<span class="cupd">e</span><span class="cupd">riods</span></span>);</span>
        return getLockedTokens(info, currentPeriod, nextPeriod);
    }

    /**
    * @notice Get the last committed staker's period
    * @param _staker Staker
    */
    function getLastCommittedPeriod(address _staker) public view returns (uint16) {
        StakerInfo storage info = stakerInfo[_staker];
        return info.nextCommittedPeriod != 0 ? info.nextCommittedPeriod : info.lastCommittedPeriod;
    }

    <span class="marker" id="mapping-101"></span><span class="token mv" id="move-src-76" data-title="contract_body/comment"><span class="marker" id="mapping-102"></span><span class="token upd" id="move-src-77" data-title="contract_body/comment"><span class="cupd">/**
    * @notice </span>Get<span class="cupd"> th</span>e v<span class="cupd">a</span>lue<span class="cupd"> </span>of lock<span class="cupd">e</span>d<span class="cupd"> </span>t<span class="cupd">o</span><span class="cupd">ke</span>ns fo<span class="cupd">r a</span><span class="cupd">c</span>t<span class="cupd">i</span>ve st<span class="cupd">a</span>kers in (ge<span class="cupd">t</span>Curr<span class="cupd">e</span>ntPerio<span class="cupd">d</span>()<span class="cupd"> </span>+ _per<span class="cupd">i</span>ods)<span class="cupd"> </span>p<span class="cupd">e</span>riod<span class="cupd">
</span>    * a<span class="cupd">s</span> well as s<span class="cupd">taker</span>s<span class="cupd"> </span><span class="cupd">a</span>n<span class="cupd">d</span> th<span class="cupd">e</span>ir<span class="cupd"> </span>l<span class="cupd">o</span>cked <span class="cupd">t</span>ok<span class="cupd">en</span>s<span class="cupd">
</span>    * @param _peri<span class="cupd">o</span>ds<span class="cupd"> </span>Amou<span class="cupd">n</span><span class="cupd">t </span>of <span class="cupd">period</span>s<span class="cupd"> </span>for<span class="cupd"> </span>locked<span class="cupd"> </span>tokens<span class="cupd"> </span>calculation<span class="cupd">
</span>    <span class="cupd">* @param </span>_<span class="cupd">sta</span><span class="cupd">r</span>tIndex<span class="cupd"> Sta</span><span class="cupd">r</span>t<span class="cupd"> </span>in<span class="cupd">d</span>ex fo<span class="cupd">r</span> looking in stak<span class="cupd">e</span>r<span class="cupd">s</span><span class="cupd"> </span>array<span class="cupd">
   </span> <span class="cupd">* @param </span>_maxStak<span class="cupd">er</span>s<span class="cupd"> </span>Max stak<span class="cupd">er</span>s f<span class="cupd">o</span>r<span class="cupd"> </span>l<span class="cupd">o</span>ok<span class="cupd">i</span>ng, if se<span class="cupd">t</span> 0 <span class="cupd">t</span>h<span class="cupd">e</span>n<span class="cupd"> </span>all<span class="cupd"> </span>will<span class="cupd"> </span>be<span class="cupd"> </span>used<span class="cupd">
 </span>   <span class="cupd">* @</span><span class="cupd">r</span>eturn <span class="cupd">a</span>llLockedTokens Su<span class="cupd">m </span>of locked tokens for acti<span class="cupd">v</span>e st<span class="cupd">a</span>kers
    * @ret<span class="cupd">u</span>rn activ<span class="cupd">e</span>Stakers<span class="cupd"> A</span>rray <span class="cupd">o</span>f stakers a<span class="cupd">n</span>d <span class="cupd">t</span>heir<span class="cupd"> </span>l<span class="cupd">o</span>cked<span class="cupd"> tokens</span>.<span class="cupd"> </span>S<span class="cupd">take</span>rs a<span class="cupd">d</span>dresses<span class="cupd"> </span>st<span class="cupd">or</span>ed<span class="cupd"> </span>as uin<span class="cupd">t</span>256
    * @d<span class="cupd">e</span>v<span class="cupd"> </span>N<span class="cupd">o</span><span class="cupd">t</span><span class="cupd">e</span><span class="cupd"> </span>that activ<span class="cupd">e</span>Stake<span class="cupd">r</span>s[0] <span class="cupd">i</span>n an array <span class="cupd">o</span>f uint256, but you want a<span class="cupd">d</span>dresses.<span class="cupd"> </span>Careful<span class="cupd"> </span>when<span class="cupd"> </span>used<span class="cupd"> </span>directly!<span class="cupd">
</span>    <span class="cupd">*/</span></span></span>
    function getActiveStakers(<span class="marker" id="mapping-103"></span><span class="token mv" id="move-src-78" data-title="function_definition/parameter">uint16 <span class="marker" id="mapping-104"></span><span class="token upd" id="move-src-79" data-title="parameter/identifier"><span class="cupd">_</span>pe<span class="cupd">r</span><span class="cupd">io</span>ds</span></span>, uint256 _startIndex, uint256 _maxStakers)
        external view returns (uint256 allLockedTokens, uint256[2][] memory activeStakers)
    {
        require(<span class="marker" id="mapping-105"></span><span class="token upd" id="move-src-80" data-title="binary_expression/identifier"><span class="cupd">_</span>p<span class="cupd">e</span><span class="cupd">riods</span></span> &gt; 0);

        uint256 endIndex = stakers.length;
        require(_startIndex &lt; endIndex);
        if (_maxStakers != 0 &amp;&amp; _startIndex + _maxStakers &lt; endIndex) {
            endIndex = _startIndex + _maxStakers;
        }
        activeStakers = new uint256[2][](endIndex - _startIndex);
        allLockedTokens = 0;

        uint256 resultIndex = 0;
        uint16 currentPeriod = getCurrentPeriod();
        <span class="marker" id="mapping-106"></span><span class="token mv" id="move-src-81" data-title="function_body/variable_declaration_statement">uint16 nextPeriod = currentPeriod.add16(<span class="marker" id="mapping-107"></span><span class="token upd" id="move-src-82" data-title="call_argument/identifier"><span class="cupd">_</span>p<span class="cupd">e</span><span class="cupd">riods</span></span>);</span>

        for (uint256 i = _startIndex; i &lt; endIndex; i++) {
            address staker = stakers[i];
            StakerInfo storage info = stakerInfo[staker];
            if (info.currentCommittedPeriod != currentPeriod &amp;&amp;
                info.nextCommittedPeriod != currentPeriod) {
                continue;
            }
            uint256 lockedTokens = getLockedTokens(info, currentPeriod, nextPeriod);
            if (lockedTokens != 0) {
                activeStakers[resultIndex][0] = uint256(staker);
                activeStakers[resultIndex++][1] = lockedTokens;
                allLockedTokens += lockedTokens;
            }
        }
        assembly {
            mstore(activeStakers, resultIndex)
        }
    }

    <span class="marker" id="mapping-108"></span><span class="token mv" id="move-src-83" data-title="contract_body/comment"><span class="marker" id="mapping-109"></span><span class="token upd" id="move-src-84" data-title="contract_body/comment"><span class="cupd">/**
    * @notice </span>C<span class="cupd">h</span><span class="cupd">e</span>ck<span class="cupd">s </span><span class="cupd">i</span><span class="cupd">f</span><span class="cupd"> </span>`<span class="cupd">re</span>Stak<span class="cupd">e</span>`<span class="cupd"> </span><span class="cupd">param</span><span class="cupd">e</span><span class="cupd">t</span><span class="cupd">er </span>i<span class="cupd">s</span><span class="cupd"> </span><span class="cupd">a</span>v<span class="cupd">a</span><span class="cupd">i</span>labl<span class="cupd">e</span><span class="cupd"> </span>f<span class="cupd">o</span>r<span class="cupd"> </span>cha<span class="cupd">n</span>g<span class="cupd">in</span>g<span class="cupd">
</span><span class="cupd">    </span><span class="cupd">* @param </span>_st<span class="cupd">a</span>k<span class="cupd">e</span>r<span class="cupd"> </span>S<span class="cupd">t</span>ak<span class="cupd">e</span>r<span class="cupd">
</span><span class="cupd"> </span><span class="cupd">   </span><span class="cupd">*/</span></span></span>
    <span class="marker" id="mapping-110"></span><span class="token del" data-title="contract_body/function_definition">function isReStakeLocked(<span class="marker" id="mapping-111"></span><span class="token mv" id="move-src-85" data-title="function_definition/parameter">address _staker</span>) <span class="marker" id="mapping-112"></span><span class="token mv" id="move-src-86" data-title="function_definition/visibility">public</span> <span class="marker" id="mapping-113"></span><span class="token mv" id="move-src-87" data-title="function_definition/state_mutability">view</span> <span class="marker" id="mapping-114"></span><span class="token del" data-title="function_definition/return_type_definition">returns (<span class="marker" id="mapping-115"></span><span class="token mv" id="move-src-88" data-title="return_type_definition/parameter">bool</span>)</span> <span class="marker" id="mapping-116"></span><span class="token del" data-title="function_definition/function_body">{
        return getCurrentPeriod() &lt; stakerInfo[_staker].lockReStakeUntilPeriod;
    }</span></span>

    /**
    * @notice Get worker using staker's address
    */
    function getWorkerFromStaker(address _staker) external view returns (address) {
        return stakerInfo[_staker].worker;
    }

    /**
    * @notice Get work that completed by the staker
    */
    function getCompletedWork(address _staker) external view returns (uint256) {
        return stakerInfo[_staker].completedWork;
    }

    /**
    * @notice Find index of downtime structure that includes specified period
    * @dev If specified period is outside all downtime periods, the length of the array will be returned
    * @param _staker Staker
    * @param _period Specified period number
    */
    function findIndexOfPastDowntime(address _staker, uint16 _period) external view returns (uint256 index) {
        StakerInfo storage info = stakerInfo[_staker];
        for (index = 0; index &lt; info.pastDowntime.length; index++) {
            if (_period &lt;= info.pastDowntime[index].endPeriod) {
                return index;
            }
        }
    }

    //------------------------Main methods------------------------
    /**
    * @notice Start or stop measuring the work of a staker
    * @param _staker Staker
    * @param _measureWork Value for `measureWork` parameter
    * @return Work that was previously done
    */
    function setWorkMeasurement(address _staker, bool _measureWork) external returns (uint256) {
        require(msg.sender == address(workLock));
        StakerInfo storage info = stakerInfo[_staker];
        if (info.flags.bitSet(MEASURE_WORK_INDEX) == _measureWork) {
            return info.completedWork;
        }
        info.flags = info.flags.toggleBit(MEASURE_WORK_INDEX);
        emit WorkMeasurementSet(_staker, _measureWork);
        return info.completedWork;
    }

    /**
    * @notice Bond worker
    * @param _worker Worker address. Must be a real address, not a contract
    */
    function bondWorker(address _worker) external onlyStaker {
        StakerInfo storage info = stakerInfo[msg.sender];
        // Specified worker is already bonded with this staker
        require(_worker != info.worker);
        uint16 currentPeriod = getCurrentPeriod();
        if (info.worker != address(0)) { // If this staker had a worker ...
            // Check that enough time has passed to change it
            require(currentPeriod &gt;= info.workerStartPeriod.add16(minWorkerPeriods));
            // Remove the old relation "worker-&gt;staker"
            stakerFromWorker[info.worker] = address(0);
        }

        if (_worker != address(0)) {
            // Specified worker is already in use
            require(stakerFromWorker[_worker] == address(0));
            // Specified worker is a staker
            require(stakerInfo[_worker].subStakes.length == 0 || _worker == msg.sender);
            // Set new worker-&gt;staker relation
            stakerFromWorker[_worker] = msg.sender;
        }

        // Bond new worker (or unbond if _worker == address(0))
        info.worker = _worker;
        info.workerStartPeriod = currentPeriod;
        emit WorkerBonded(msg.sender, _worker, currentPeriod);
    }

    <span class="marker" id="mapping-117"></span><span class="token mv" id="move-src-89" data-title="contract_body/comment"><span class="marker" id="mapping-118"></span><span class="token upd" id="move-src-90" data-title="contract_body/comment"><span class="cupd">/**
    * @notice S</span>et<span class="cupd"> </span>`reS<span class="cupd">t</span><span class="cupd">a</span>ke` parame<span class="cupd">t</span>er.<span class="cupd"> </span>If <span class="cupd">t</span>rue t<span class="cupd">he</span>n<span class="cupd"> </span>all <span class="cupd">stak</span>ing<span class="cupd"> </span>re<span class="cupd">wa</span>rd<span class="cupd">s </span>wi<span class="cupd">l</span>l be <span class="cupd">a</span>dd<span class="cupd">ed </span><span class="cupd">t</span>o loc<span class="cupd">ke</span>d<span class="cupd"> </span>s<span class="cupd">take</span><span class="cupd">
</span><span class="cupd">    </span><span class="cupd">* </span>O<span class="cupd">n</span><span class="cupd">l</span><span class="cupd">y </span><span class="cupd">i</span>f<span class="cupd"> </span><span class="cupd">t</span>his<span class="cupd"> </span><span class="cupd">param</span><span class="cupd">e</span><span class="cupd">t</span>e<span class="cupd">r </span><span class="cupd">i</span>s n<span class="cupd">o</span>t<span class="cupd"> </span>lock<span class="cupd">e</span>d<span class="cupd">
    * @param </span>_<span class="cupd">re</span>St<span class="cupd">a</span>ke<span class="cupd"> Value </span><span class="cupd">f</span>o<span class="cupd">r</span><span class="cupd"> p</span>a<span class="cupd">r</span>am<span class="cupd">e</span><span class="cupd">t</span><span class="cupd">e</span><span class="cupd">r
</span><span class="cupd"> </span><span class="cupd">   </span><span class="cupd">*/</span></span></span>
    function setReStake(bool _reStake) external {
        <span class="marker" id="mapping-119"></span><span class="token del" data-title="function_body/expression_statement">require(!isReStakeLocked(msg.sender));</span>
        StakerInfo storage info = stakerInfo[msg.sender];
        if (info.flags.bitSet(RE_STAKE_DISABLED_INDEX) == !_reStake) {
            return;
        }
        info.flags = info.flags.toggleBit(RE_STAKE_DISABLED_INDEX);
        emit ReStakeSet(msg.sender, _reStake);
    }

    <span class="marker" id="mapping-120"></span><span class="token mv" id="move-src-91" data-title="contract_body/comment"><span class="marker" id="mapping-121"></span><span class="token upd" id="move-src-92" data-title="contract_body/comment"><span class="cupd">/**
    * @notice </span>Lock<span class="cupd"> </span>`<span class="cupd">re</span>S<span class="cupd">take</span>`<span class="cupd"> parameter</span>.<span class="cupd"> </span>Only<span class="cupd"> </span><span class="cupd">i</span>f <span class="cupd">t</span>h<span class="cupd">i</span>s<span class="cupd"> </span><span class="cupd">param</span>e<span class="cupd">t</span><span class="cupd">er </span>is no<span class="cupd">t</span> loc<span class="cupd">ke</span><span class="cupd">d</span><span class="cupd">
    * @param </span>_lockR<span class="cupd">eStake</span><span class="cupd">U</span>n<span class="cupd">t</span>ilP<span class="cupd">e</span>rio<span class="cupd">d </span>C<span class="cupd">a</span>n't ch<span class="cupd">a</span>ng<span class="cupd">e</span> `reS<span class="cupd">t</span>ak<span class="cupd">e</span>`<span class="cupd"> value </span>until<span class="cupd"> </span>this<span class="cupd"> </span>period<span class="cupd">
 </span>   <span class="cupd">*/</span></span></span>
    <span class="marker" id="mapping-122"></span><span class="token del" data-title="contract_body/function_definition">function lockReStake(<span class="marker" id="mapping-123"></span><span class="token mv" id="move-src-93" data-title="function_definition/parameter">uint16 <span class="marker" id="mapping-124"></span><span class="token upd" id="move-src-94" data-title="parameter/identifier"><span class="cupd">_</span>l<span class="cupd">o</span>ckR<span class="cupd">e</span>S<span class="cupd">t</span>akeUntil<span class="cupd">Period</span></span></span>) <span class="marker" id="mapping-125"></span><span class="token del" data-title="function_definition/visibility">external</span> <span class="marker" id="mapping-126"></span><span class="token del" data-title="function_definition/function_body">{
        require(!isReStakeLocked(msg.sender) &amp;&amp;
            _lockReStakeUntilPeriod &gt; getCurrentPeriod());
        stakerInfo[msg.sender].lockReStakeUntilPeriod = _lockReStakeUntilPeriod;
        emit ReStakeLocked(msg.sender, _lockReStakeUntilPeriod);
    }</span></span>

    <span class="marker" id="mapping-127"></span><span class="token mv" id="move-src-95" data-title="contract_body/comment"><span class="marker" id="mapping-128"></span><span class="token upd" id="move-src-96" data-title="contract_body/comment"><span class="cupd">/**
    * @notice </span>Depo<span class="cupd">s</span>i<span class="cupd">t</span><span class="cupd"> </span>t<span class="cupd">o</span><span class="cupd">ke</span>n<span class="cupd">s </span>fr<span class="cupd">o</span>m<span class="cupd"> </span>W<span class="cupd">o</span>rkLock<span class="cupd"> </span>con<span class="cupd">t</span><span class="cupd">r</span>act<span class="cupd">
    * @param </span>_<span class="cupd">staker Staker address
    * @param </span>_valu<span class="cupd">e</span><span class="cupd"> </span>Am<span class="cupd">o</span>unt of to<span class="cupd">ke</span>ns<span class="cupd"> </span>to <span class="cupd">d</span><span class="cupd">e</span>po<span class="cupd">s</span>it<span class="cupd">
    * @param </span>_p<span class="cupd">eriod</span>s<span class="cupd"> </span>Amount of p<span class="cupd">eriod</span>s<span class="cupd"> </span><span class="cupd">d</span>ur<span class="cupd">ing </span>which t<span class="cupd">o</span>kens will be lo<span class="cupd">c</span>k<span class="cupd">ed
    */</span></span></span>
    function depositFromWorkLock(
        address _staker,
        uint256 _value,
        <span class="marker" id="mapping-129"></span><span class="token mv" id="move-src-97" data-title="function_definition/parameter">uint16 <span class="marker" id="mapping-130"></span><span class="token upd" id="move-src-98" data-title="parameter/identifier"><span class="cupd">_</span>p<span class="cupd">e</span><span class="cupd">riods</span></span></span>
    )
        external
    {
        require(msg.sender == address(workLock));
        StakerInfo storage info = stakerInfo[_staker];
        if (!info.flags.bitSet(WIND_DOWN_INDEX) &amp;&amp; info.subStakes.length == 0) {
            info.flags = info.flags.toggleBit(WIND_DOWN_INDEX);
            emit WindDownSet(_staker, true);
        }
        <span class="marker" id="mapping-131"></span><span class="token del" data-title="function_body/expression_statement"><span class="marker" id="mapping-132"></span><span class="token del" data-title="expression_statement/call_expression">deposit(<span class="marker" id="mapping-133"></span><span class="token mv" id="move-src-99" data-title="call_expression/call_argument">_staker</span>, <span class="marker" id="mapping-134"></span><span class="token del" data-title="call_expression/call_argument">msg.sender</span>, <span class="marker" id="mapping-135"></span><span class="token mv" id="move-src-100" data-title="call_expression/call_argument">MAX_SUB_STAKES</span>, <span class="marker" id="mapping-136"></span><span class="token mv" id="move-src-101" data-title="call_expression/call_argument">_value</span>, <span class="marker" id="mapping-137"></span><span class="token del" data-title="call_expression/call_argument">_periods</span>)</span>;</span>
    }

    /**
    * @notice Set `windDown` parameter.
    * If true then stake's duration will be decreasing in each period with `commitToNextPeriod()`
    * @param _windDown Value for parameter
    */
    function setWindDown(bool _windDown) external {
        StakerInfo storage info = stakerInfo[msg.sender];
        if (info.flags.bitSet(WIND_DOWN_INDEX) == _windDown) {
            return;
        }
        info.flags = info.flags.toggleBit(WIND_DOWN_INDEX);
        emit WindDownSet(msg.sender, _windDown);

        // duration adjustment if next period is committed
        uint16 nextPeriod = getCurrentPeriod() + 1;
        if (info.nextCommittedPeriod != nextPeriod) {
           return;
        }

        // adjust sub-stakes duration for the new value of winding down parameter
        for (uint256 index = 0; index &lt; info.subStakes.length; index++) {
            SubStakeInfo storage subStake = info.subStakes[index];
            // sub-stake does not have fixed last period when winding down is disabled
            if (!_windDown &amp;&amp; subStake.lastPeriod == nextPeriod) {
                subStake.lastPeriod = 0;
                subStake.<span class="marker" id="mapping-138"></span><span class="token upd" id="move-src-102" data-title="member_expression/identifier">pe<span class="cupd">r</span><span class="cupd">io</span>ds</span> = 1;
                continue;
            }
            // this sub-stake is no longer affected by winding down parameter
            if (subStake.lastPeriod != 0 || subStake.<span class="marker" id="mapping-139"></span><span class="token upd" id="move-src-103" data-title="member_expression/identifier">pe<span class="cupd">r</span><span class="cupd">io</span>ds</span> == 0) {
                continue;
            }

            subStake.<span class="marker" id="mapping-140"></span><span class="token upd" id="move-src-104" data-title="member_expression/identifier">pe<span class="cupd">r</span><span class="cupd">io</span>ds</span> = _windDown ? subStake.<span class="marker" id="mapping-141"></span><span class="token upd" id="move-src-105" data-title="member_expression/identifier">pe<span class="cupd">r</span><span class="cupd">io</span>ds</span> - 1 : subStake.<span class="marker" id="mapping-142"></span><span class="token upd" id="move-src-106" data-title="member_expression/identifier">pe<span class="cupd">r</span><span class="cupd">io</span>ds</span> + 1;
            if (subStake.<span class="marker" id="mapping-143"></span><span class="token upd" id="move-src-107" data-title="member_expression/identifier">pe<span class="cupd">r</span><span class="cupd">io</span>ds</span> == 0) {
                subStake.lastPeriod = nextPeriod;
            }
        }
    }

    /**
    * @notice Activate/deactivate taking snapshots of balances
    * @param _enableSnapshots True to activate snapshots, False to deactivate
    */
    function setSnapshots(bool _enableSnapshots) external {
        StakerInfo storage info = stakerInfo[msg.sender];
        if (info.flags.bitSet(SNAPSHOTS_DISABLED_INDEX) == !_enableSnapshots) {
            return;
        }

        uint256 lastGlobalBalance = uint256(balanceHistory.lastValue());
        if(_enableSnapshots){
            info.history.addSnapshot(info.value);
            balanceHistory.addSnapshot(lastGlobalBalance + info.value);
        } else {
            info.history.addSnapshot(0);
            balanceHistory.addSnapshot(lastGlobalBalance - info.value);
        }
        info.flags = info.flags.toggleBit(SNAPSHOTS_DISABLED_INDEX);

        emit SnapshotSet(msg.sender, _enableSnapshots);
    }

    /**
    * @notice Adds a new snapshot to both the staker and global balance histories,
    * assuming the staker's balance was already changed
    * @param _info Reference to affected staker's struct
    * @param _addition Variance in balance. It can be positive or negative.
    */
    function addSnapshot(StakerInfo storage _info, int256 _addition) internal {
        if(!_info.flags.bitSet(SNAPSHOTS_DISABLED_INDEX)){
            _info.history.addSnapshot(_info.value);
            uint256 lastGlobalBalance = uint256(balanceHistory.lastValue());
            balanceHistory.addSnapshot(lastGlobalBalance.addSigned(_addition));
        }
    }


    <span class="marker" id="mapping-144"></span><span class="token mv" id="move-src-108" data-title="contract_body/comment"><span class="marker" id="mapping-145"></span><span class="token upd" id="move-src-109" data-title="contract_body/comment"><span class="cupd">/**
    * @notice </span>B<span class="cupd">a</span><span class="cupd">t</span>c<span class="cupd">h</span><span class="cupd"> </span>d<span class="cupd">e</span>posit.<span class="cupd"> </span>Allo<span class="cupd">w</span>e<span class="cupd">d</span> <span class="cupd">o</span><span class="cupd">n</span>ly<span class="cupd"> </span>initi<span class="cupd">a</span>l d<span class="cupd">e</span>posi<span class="cupd">t</span> fo<span class="cupd">r </span>e<span class="cupd">a</span><span class="cupd">c</span>h s<span class="cupd">t</span><span class="cupd">a</span>k<span class="cupd">e</span>r
    * @p<span class="cupd">a</span>ram _s<span class="cupd">t</span><span class="cupd">a</span>kers S<span class="cupd">t</span>ak<span class="cupd">e</span>rs<span class="cupd">
    * @param </span>_numberOfSubS<span class="cupd">take</span>s Numbe<span class="cupd">r </span>of sub-s<span class="cupd">take</span>s which belong to stake<span class="cupd">r </span>in _v<span class="cupd">a</span>lues an<span class="cupd">d</span> _perio<span class="cupd">d</span>s a<span class="cupd">r</span>ray<span class="cupd">s</span><span class="cupd">
    * @param </span>_values Amou<span class="cupd">n</span>t <span class="cupd">o</span>f toke<span class="cupd">n</span>s<span class="cupd"> </span>to <span class="cupd">d</span>eposit for e<span class="cupd">a</span>ch s<span class="cupd">t</span>ak<span class="cupd">e</span>r<span class="cupd">
</span>    * @<span class="cupd">param</span> _p<span class="cupd">e</span>riods Amoun<span class="cupd">t</span> of p<span class="cupd">er</span>iods<span class="cupd"> </span>d<span class="cupd">u</span>ring which tok<span class="cupd">e</span>ns<span class="cupd"> </span>will<span class="cupd"> </span>be<span class="cupd"> </span>locked<span class="cupd"> </span>for<span class="cupd"> </span>each staker
    <span class="cupd">*/</span></span></span>
    <span class="marker" id="mapping-146"></span><span class="token del" data-title="contract_body/function_definition">function batchDeposit(
        <span class="marker" id="mapping-147"></span><span class="token del" data-title="function_definition/parameter"><span class="marker" id="mapping-148"></span><span class="token del" data-title="parameter/type_name"><span class="marker" id="mapping-149"></span><span class="token mv" id="move-src-110" data-title="type_name/type_name">address</span>[]</span> calldata _stakers</span>,
        <span class="marker" id="mapping-150"></span><span class="token del" data-title="function_definition/parameter">uint256[] calldata _numberOfSubStakes</span>,
        <span class="marker" id="mapping-151"></span><span class="token mv" id="move-src-111" data-title="function_definition/parameter"><span class="marker" id="mapping-152"></span><span class="token del" data-title="parameter/type_name"><span class="marker" id="mapping-153"></span><span class="token mv" id="move-src-112" data-title="type_name/type_name">uint256</span>[]</span> <span class="marker" id="mapping-154"></span><span class="token del" data-title="parameter/calldata">calldata</span> <span class="marker" id="mapping-155"></span><span class="token del" data-title="parameter/identifier">_values</span></span>,
        <span class="marker" id="mapping-156"></span><span class="token del" data-title="function_definition/parameter">uint16[] calldata _periods</span>
    )
        <span class="marker" id="mapping-157"></span><span class="token del" data-title="function_definition/visibility">external</span>
    <span class="marker" id="mapping-158"></span><span class="token del" data-title="function_definition/function_body">{
        <span class="marker" id="mapping-159"></span><span class="token del" data-title="function_body/variable_declaration_statement">uint256 subStakesLength = _values.length;</span>
        <span class="marker" id="mapping-160"></span><span class="token del" data-title="function_body/expression_statement">require(_stakers.length != 0 &amp;&amp;
            _stakers.length == _numberOfSubStakes.length &amp;&amp;
            subStakesLength &gt;= _stakers.length &amp;&amp;
            _periods.length == subStakesLength);</span>
        <span class="marker" id="mapping-161"></span><span class="token mv" id="move-src-113" data-title="function_body/variable_declaration_statement">uint16 <span class="marker" id="mapping-162"></span><span class="token upd" id="move-src-114" data-title="variable_declaration/identifier">p<span class="cupd">r</span><span class="cupd">e</span>vious<span class="cupd">Period</span></span> = <span class="marker" id="mapping-163"></span><span class="token del" data-title="variable_declaration_statement/binary_expression">getCurrentPeriod() - 1</span>;</span>
        <span class="marker" id="mapping-164"></span><span class="token del" data-title="function_body/variable_declaration_statement"><span class="marker" id="mapping-165"></span><span class="token mv" id="move-src-115" data-title="variable_declaration_statement/variable_declaration">uint16 nextPeriod</span> = <span class="marker" id="mapping-166"></span><span class="token del" data-title="variable_declaration_statement/binary_expression">previousPeriod + 2</span>;</span>
        <span class="marker" id="mapping-167"></span><span class="token del" data-title="function_body/variable_declaration_statement">uint256 sumValue = 0;</span>

        <span class="marker" id="mapping-168"></span><span class="token del" data-title="function_body/variable_declaration_statement">uint256 j = 0;</span>
        <span class="marker" id="mapping-169"></span><span class="token del" data-title="function_body/for_statement">for (<span class="marker" id="mapping-170"></span><span class="token mv" id="move-src-116" data-title="for_statement/variable_declaration_statement">uint256 i = 0;</span> <span class="marker" id="mapping-171"></span><span class="token del" data-title="for_statement/expression_statement">i &lt; _stakers.length;</span> <span class="marker" id="mapping-172"></span><span class="token mv" id="move-src-117" data-title="for_statement/update_expression">i++</span>) <span class="marker" id="mapping-173"></span><span class="token del" data-title="for_statement/block_statement">{
            <span class="marker" id="mapping-174"></span><span class="token del" data-title="block_statement/variable_declaration_statement"><span class="marker" id="mapping-175"></span><span class="token del" data-title="variable_declaration_statement/variable_declaration"><span class="marker" id="mapping-176"></span><span class="token mv" id="move-src-118" data-title="variable_declaration/type_name">address</span> staker</span> = <span class="marker" id="mapping-177"></span><span class="token del" data-title="variable_declaration_statement/array_access">_stakers[i]</span>;</span>
            <span class="marker" id="mapping-178"></span><span class="token del" data-title="block_statement/variable_declaration_statement">uint256 numberOfSubStakes = _numberOfSubStakes[i];</span>
            <span class="marker" id="mapping-179"></span><span class="token del" data-title="block_statement/variable_declaration_statement">uint256 endIndex = j + numberOfSubStakes;</span>
            <span class="marker" id="mapping-180"></span><span class="token del" data-title="block_statement/expression_statement">require(numberOfSubStakes &gt; 0 &amp;&amp; subStakesLength &gt;= endIndex);</span>
            <span class="marker" id="mapping-181"></span><span class="token del" data-title="block_statement/variable_declaration_statement">StakerInfo storage info = stakerInfo[staker];</span>
            <span class="marker" id="mapping-182"></span><span class="token del" data-title="block_statement/expression_statement"><span class="marker" id="mapping-183"></span><span class="token del" data-title="expression_statement/call_expression">require(<span class="marker" id="mapping-184"></span><span class="token del" data-title="call_expression/call_argument"><span class="marker" id="mapping-185"></span><span class="token del" data-title="call_argument/call_expression"><span class="marker" id="mapping-186"></span><span class="token del" data-title="call_expression/member_expression"><span class="marker" id="mapping-187"></span><span class="token del" data-title="member_expression/binary_expression"><span class="marker" id="mapping-188"></span><span class="token del" data-title="binary_expression/binary_expression">info.subStakes.length == 0</span> &amp;&amp; <span class="marker" id="mapping-189"></span><span class="token del" data-title="binary_expression/unary_expression">!<span class="marker" id="mapping-190"></span><span class="token mv" id="move-src-119" data-title="unary_expression/member_expression">info.flags</span></span></span>.bitSet</span>(<span class="marker" id="mapping-191"></span><span class="token del" data-title="call_expression/call_argument">SNAPSHOTS_DISABLED_INDEX</span>)</span></span>)</span>;</span>
            // A staker can't be a worker for another staker
            <span class="marker" id="mapping-192"></span><span class="token del" data-title="block_statement/expression_statement">require(stakerFromWorker[staker] == address(0));</span>
            <span class="marker" id="mapping-193"></span><span class="token del" data-title="block_statement/expression_statement"><span class="marker" id="mapping-194"></span><span class="token del" data-title="expression_statement/call_expression"><span class="marker" id="mapping-195"></span><span class="token del" data-title="call_expression/member_expression">stakers.push</span>(<span class="marker" id="mapping-196"></span><span class="token mv" id="move-src-120" data-title="call_expression/call_argument">staker</span>)</span>;</span>
            <span class="marker" id="mapping-197"></span><span class="token del" data-title="block_statement/expression_statement">policyManager.register(staker, previousPeriod);</span>

            <span class="marker" id="mapping-198"></span><span class="token del" data-title="block_statement/for_statement">for (; <span class="marker" id="mapping-199"></span><span class="token del" data-title="for_statement/expression_statement">j &lt; endIndex;</span> <span class="marker" id="mapping-200"></span><span class="token del" data-title="for_statement/update_expression">j++</span>) <span class="marker" id="mapping-201"></span><span class="token del" data-title="for_statement/block_statement">{
                <span class="marker" id="mapping-202"></span><span class="token del" data-title="block_statement/variable_declaration_statement">uint256 value =  _values[j];</span>
                <span class="marker" id="mapping-203"></span><span class="token mv" id="move-src-121" data-title="block_statement/variable_declaration_statement">uint16 <span class="marker" id="mapping-204"></span><span class="token upd" id="move-src-122" data-title="variable_declaration/identifier">p<span class="cupd">eriod</span>s</span> = <span class="marker" id="mapping-205"></span><span class="token del" data-title="variable_declaration_statement/array_access">_periods[j]</span>;</span>
                <span class="marker" id="mapping-206"></span><span class="token del" data-title="block_statement/expression_statement">require(value &gt;= minAllowableLockedTokens &amp;&amp; periods &gt;= minLockedPeriods);</span>
                <span class="marker" id="mapping-207"></span><span class="token del" data-title="block_statement/expression_statement">info.value = info.value.add(value);</span>
                <span class="marker" id="mapping-208"></span><span class="token mv" id="move-src-123" data-title="block_statement/expression_statement"><span class="marker" id="mapping-209"></span><span class="token del" data-title="expression_statement/call_expression"><span class="marker" id="mapping-210"></span><span class="token mv" id="move-src-124" data-title="call_expression/member_expression"><span class="marker" id="mapping-211"></span><span class="token mv" id="move-src-125" data-title="member_expression/member_expression">info.subStakes</span>.<span class="marker" id="mapping-212"></span><span class="token upd" id="move-src-126" data-title="member_expression/identifier">push</span></span>(<span class="marker" id="mapping-213"></span><span class="token del" data-title="call_expression/call_argument">SubStakeInfo(nextPeriod, 0, periods, uint128(value))</span>)</span>;</span>
                <span class="marker" id="mapping-214"></span><span class="token del" data-title="block_statement/expression_statement">sumValue = sumValue.add(value);</span>
                <span class="marker" id="mapping-215"></span><span class="token del" data-title="block_statement/emit_statement">emit Deposited(staker, value, periods);</span>
                <span class="marker" id="mapping-216"></span><span class="token del" data-title="block_statement/emit_statement">emit Locked(staker, value, nextPeriod, periods);</span>
            }</span></span>
            <span class="marker" id="mapping-217"></span><span class="token del" data-title="block_statement/expression_statement">require(info.value &lt;= maxAllowableLockedTokens);</span>
            <span class="marker" id="mapping-218"></span><span class="token del" data-title="block_statement/expression_statement">info.history.addSnapshot(info.value);</span>
        }</span></span>
        <span class="marker" id="mapping-219"></span><span class="token del" data-title="function_body/expression_statement">require(j == subStakesLength);</span>
        <span class="marker" id="mapping-220"></span><span class="token del" data-title="function_body/variable_declaration_statement">uint256 lastGlobalBalance = uint256(balanceHistory.lastValue());</span>
        <span class="marker" id="mapping-221"></span><span class="token del" data-title="function_body/expression_statement">balanceHistory.addSnapshot(lastGlobalBalance + sumValue);</span>
        <span class="marker" id="mapping-222"></span><span class="token mv" id="move-src-127" data-title="function_body/expression_statement"><span class="marker" id="mapping-223"></span><span class="token del" data-title="call_expression/member_expression">token.safeTransferFrom</span>(msg.sender, <span class="marker" id="mapping-224"></span><span class="token del" data-title="call_expression/call_argument">address(this)</span>, <span class="marker" id="mapping-225"></span><span class="token upd" id="move-src-128" data-title="call_argument/identifier">s<span class="cupd">u</span>mVa<span class="cupd">l</span>ue</span>);</span>
    }</span></span>

    <span class="marker" id="mapping-226"></span><span class="token mv" id="move-src-129" data-title="contract_body/comment"><span class="marker" id="mapping-227"></span><span class="token upd" id="move-src-130" data-title="contract_body/comment"><span class="cupd">/**
    * @notice </span>Imp<span class="cupd">l</span>emen<span class="cupd">t</span><span class="cupd">at</span>ion<span class="cupd"> </span>of <span class="cupd">the </span>receiveApproval(addre<span class="cupd">s</span>s,ui<span class="cupd">n</span>t256,<span class="cupd">a</span>ddre<span class="cupd">s</span>s,by<span class="cupd">t</span>es)<span class="cupd"> </span><span class="cupd">met</span>hod
    * (s<span class="cupd">e</span>e NuCyphe<span class="cupd">r</span>Token<span class="cupd"> </span>contr<span class="cupd">a</span>ct). Depo<span class="cupd">s</span>it<span class="cupd"> a</span>ll <span class="cupd">t</span>okens th<span class="cupd">at</span> w<span class="cupd">e</span>r<span class="cupd">e</span> <span class="cupd">a</span>ppro<span class="cupd">v</span><span class="cupd">ed </span>to<span class="cupd"> </span>transfer<span class="cupd">
  </span>  <span class="cupd">* @param </span>_f<span class="cupd">r</span>om<span class="cupd"> Staker
</span>    * @p<span class="cupd">a</span><span class="cupd">r</span>am _valu<span class="cupd">e</span> Amount of token<span class="cupd">s</span> to depo<span class="cupd">s</span>it<span class="cupd">
    * @param </span>_toke<span class="cupd">n</span>C<span class="cupd">o</span><span class="cupd">n</span>tr<span class="cupd">a</span>ct Tok<span class="cupd">e</span>n<span class="cupd"> </span>contr<span class="cupd">a</span>c<span class="cupd">t</span> a<span class="cupd">d</span>dress<span class="cupd">
</span>    * @notice (<span class="cupd">param</span> _<span class="cupd">e</span>x<span class="cupd">t</span>raData) Amount of p<span class="cupd">er</span>iods<span class="cupd"> </span>d<span class="cupd">u</span>ring which tok<span class="cupd">e</span>ns<span class="cupd"> </span>will<span class="cupd"> </span>be<span class="cupd"> </span>locked<span class="cupd">
 </span>   <span class="cupd">*/</span></span></span>
    function receiveApproval(
        address _from,
        uint256 _value,
        address _tokenContract,
        bytes calldata /* _extraData */
    )
        external
    {
        require(_tokenContract == address(token) &amp;&amp; msg.sender == address(token));

        // Copy first 32 bytes from _extraData, according to calldata memory layout:
        //
        // 0x00: method signature      4 bytes
        // 0x04: _from                 32 bytes after encoding
        // 0x24: _value                32 bytes after encoding
        // 0x44: _tokenContract        32 bytes after encoding
        // 0x64: _extraData pointer    32 bytes. Value must be 0x80 (offset of _extraData wrt to 1st parameter)
        // 0x84: _extraData length     32 bytes
        // 0xA4: _extraData data       Length determined by previous variable
        //
        // See https://solidity.readthedocs.io/en/latest/abi-spec.html#examples

        uint256 payloadSize;
        uint256 payload;
        assembly {
            payloadSize := calldataload(0x84)
            payload := calldataload(0xA4)
        }
        payload = payload &gt;&gt; 8*(32 - payloadSize);
        deposit(_from, _from, MAX_SUB_STAKES, _value, uint16(payload));
    }

    <span class="marker" id="mapping-228"></span><span class="token mv" id="move-src-131" data-title="contract_body/comment"><span class="marker" id="mapping-229"></span><span class="token upd" id="move-src-132" data-title="contract_body/comment"><span class="cupd">/**
    * @notice </span>Depos<span class="cupd">i</span>t toke<span class="cupd">n</span><span class="cupd">s </span><span class="cupd">a</span>nd<span class="cupd"> </span>crea<span class="cupd">t</span><span class="cupd">e </span>new <span class="cupd">s</span>ub-s<span class="cupd">take</span>.<span class="cupd"> </span>Us<span class="cupd">e</span><span class="cupd"> th</span><span class="cupd">i</span><span class="cupd">s</span><span class="cupd"> </span>me<span class="cupd">t</span>h<span class="cupd">o</span>d<span class="cupd"> t</span>o<span class="cupd"> </span>b<span class="cupd">e</span>come<span class="cupd"> </span>a stak<span class="cupd">er</span><span class="cupd">
</span><span class="cupd">    </span><span class="cupd">* @param </span>_<span class="cupd">staker Staker
</span>    * @p<span class="cupd">a</span><span class="cupd">r</span>am _valu<span class="cupd">e</span> Amount of token<span class="cupd">s</span> to depo<span class="cupd">s</span>it<span class="cupd">
    * @param </span>_<span class="cupd">period</span>s<span class="cupd"> </span>Amount of p<span class="cupd">eriod</span>s<span class="cupd"> </span>duri<span class="cupd">n</span>g<span class="cupd"> </span>wh<span class="cupd">i</span>ch <span class="cupd">t</span><span class="cupd">o</span>ke<span class="cupd">n</span>s<span class="cupd"> </span>will b<span class="cupd">e</span> lock<span class="cupd">ed
    */</span></span></span>
    <span class="marker" id="mapping-230"></span><span class="token del" data-title="contract_body/function_definition">function deposit(<span class="marker" id="mapping-231"></span><span class="token mv" id="move-src-133" data-title="function_definition/parameter">address _staker</span>, <span class="marker" id="mapping-232"></span><span class="token mv" id="move-src-134" data-title="function_definition/parameter">uint256 _value</span>, <span class="marker" id="mapping-233"></span><span class="token mv" id="move-src-135" data-title="function_definition/parameter">uint16 <span class="marker" id="mapping-234"></span><span class="token upd" id="move-src-136" data-title="parameter/identifier"><span class="cupd">_</span>pe<span class="cupd">r</span><span class="cupd">io</span>ds</span></span>) <span class="marker" id="mapping-235"></span><span class="token mv" id="move-src-137" data-title="function_definition/visibility">external</span> <span class="marker" id="mapping-236"></span><span class="token del" data-title="function_definition/function_body">{
        <span class="marker" id="mapping-237"></span><span class="token mv" id="move-src-138" data-title="function_body/expression_statement">deposit(_staker, msg.sender, MAX_SUB_STAKES, _value, <span class="marker" id="mapping-238"></span><span class="token upd" id="move-src-139" data-title="call_argument/identifier"><span class="cupd">_</span>pe<span class="cupd">r</span><span class="cupd">io</span>ds</span>);</span>
    }</span></span>

    /**
    * @notice Deposit tokens and increase lock amount of an existing sub-stake
    * @dev This is preferable way to stake tokens because will be fewer active sub-stakes in the result
    * @param _index Index of the sub stake
    * @param _value Amount of tokens which will be locked
    */
    function depositAndIncrease(uint256 _index, uint256 _value) external onlyStaker {
        require(_index &lt; MAX_SUB_STAKES);
        deposit(msg.sender, msg.sender, _index, _value, 0);
    }

    <span class="marker" id="mapping-239"></span><span class="token mv" id="move-src-140" data-title="contract_body/comment"><span class="marker" id="mapping-240"></span><span class="token upd" id="move-src-141" data-title="contract_body/comment"><span class="cupd">/</span>**<span class="cupd">
</span>    * @not<span class="cupd">i</span>ce Deposit toke<span class="cupd">n</span>s
    * @dev Specify ei<span class="cupd">t</span>h<span class="cupd">er</span> i<span class="cupd">n</span>dex <span class="cupd">a</span>nd zero periods (for an existing sub-stake)
    * or index &gt;= MAX_SUB_STAKES and rea<span class="cupd">l </span>valu<span class="cupd">e</span> for periods (for a new sub-stake), not both
    * @param _staker Staker
    * @param _payer Owner of tokens
    * @param _index Index of the sub stake
    * @param _<span class="cupd">v</span>alu<span class="cupd">e</span> Amou<span class="cupd">nt</span> of tokens to deposit
    * @param _periods Amount of periods during which tokens will be locked
    */</span></span>
    function deposit(address _staker, address _payer, uint256 _index, uint256 _value, <span class="marker" id="mapping-241"></span><span class="token mv" id="move-src-142" data-title="function_definition/parameter">uint16 <span class="marker" id="mapping-242"></span><span class="token upd" id="move-src-143" data-title="parameter/identifier"><span class="cupd">_</span>pe<span class="cupd">r</span><span class="cupd">io</span>ds</span></span>) internal {
        require(_value != 0);
        StakerInfo storage info = stakerInfo[_staker];
        // A staker can't be a worker for another staker
        require(stakerFromWorker[_staker] == address(0) || stakerFromWorker[_staker] == info.worker);
        // initial stake of the staker
        if (<span class="marker" id="mapping-243"></span><span class="token mv" id="move-src-144" data-title="if_statement/binary_expression">info.subStakes.length == 0</span>) {
            stakers.push(_staker);
            policyManager.register(_staker, getCurrentPeriod() - 1);
        }
        token.safeTransferFrom(_payer, address(this), _value);
        info.value += _value;
        lock(_staker, _index, _value, <span class="marker" id="mapping-244"></span><span class="token upd" id="move-src-145" data-title="call_argument/identifier"><span class="cupd">_</span>pe<span class="cupd">r</span><span class="cupd">io</span>ds</span>);

        addSnapshot(info, int256(_value));
        if (_index &gt;= MAX_SUB_STAKES) {
            emit Deposited(_staker, _value, <span class="marker" id="mapping-245"></span><span class="token upd" id="move-src-146" data-title="call_argument/identifier"><span class="cupd">_</span>pe<span class="cupd">r</span><span class="cupd">io</span>ds</span>);
        } else {
            uint16 lastPeriod = getLastPeriodOfSubStake(_staker, _index);
            emit Deposited(_staker, _value, lastPeriod - getCurrentPeriod());
        }
    }

    <span class="marker" id="mapping-246"></span><span class="token mv" id="move-src-147" data-title="contract_body/comment"><span class="marker" id="mapping-247"></span><span class="token upd" id="move-src-148" data-title="contract_body/comment"><span class="cupd">/</span>**<span class="cupd">
</span>    * @n<span class="cupd">o</span>tice Lock so<span class="cupd">me</span><span class="cupd"> </span>token<span class="cupd">s</span> as a new sub-stake
    * @param _va<span class="cupd">l</span>ue Am<span class="cupd">o</span>un<span class="cupd">t </span>o<span class="cupd">f</span> t<span class="cupd">o</span>kens<span class="cupd"> </span>which wi<span class="cupd">l</span>l be l<span class="cupd">ocked</span>
    * @param _p<span class="cupd">er</span>iods Amount of p<span class="cupd">eriod</span>s during which tokens will be locked
    */</span></span>
    <span class="marker" id="mapping-248"></span><span class="token mv" id="move-src-149" data-title="contract_body/function_definition">function <span class="marker" id="mapping-249"></span><span class="token upd" id="move-src-150" data-title="function_definition/identifier">lockAn<span class="cupd">d</span>Cr<span class="cupd">e</span>ate</span>(<span class="marker" id="mapping-250"></span><span class="token mv" id="move-src-151" data-title="function_definition/parameter">uint256 _value</span>, <span class="marker" id="mapping-251"></span><span class="token mv" id="move-src-152" data-title="function_definition/parameter">uint16 <span class="marker" id="mapping-252"></span><span class="token upd" id="move-src-153" data-title="parameter/identifier"><span class="cupd">_</span>pe<span class="cupd">r</span><span class="cupd">io</span>ds</span></span>) external <span class="marker" id="mapping-253"></span><span class="token mv" id="move-src-154" data-title="function_definition/modifier_invocation">onlyStaker</span> {
        <span class="marker" id="mapping-254"></span><span class="token upd" id="move-src-155" data-title="call_expression/identifier">lock</span>(<span class="marker" id="mapping-255"></span><span class="token mv" id="move-src-156" data-title="call_expression/call_argument">msg.sender</span>, <span class="marker" id="mapping-256"></span><span class="token mv" id="move-src-157" data-title="call_expression/call_argument">MAX_SUB_STAKES</span>, <span class="marker" id="mapping-257"></span><span class="token mv" id="move-src-158" data-title="call_expression/call_argument">_value</span>, <span class="marker" id="mapping-258"></span><span class="token upd" id="move-src-159" data-title="call_argument/identifier"><span class="cupd">_</span>pe<span class="cupd">r</span><span class="cupd">io</span>ds</span>);
    }</span>

    /**
    * @notice Increase lock amount of an existing sub-stake
    * @param _index Index of the sub-stake
    * @param _value Amount of tokens which will be locked
    */
    function lockAndIncrease(uint256 _index, uint256 _value) external onlyStaker {
        require(_index &lt; MAX_SUB_STAKES);
        lock(msg.sender, _index, _value, 0);
    }

    <span class="marker" id="mapping-259"></span><span class="token mv" id="move-src-160" data-title="contract_body/comment"><span class="marker" id="mapping-260"></span><span class="token upd" id="move-src-161" data-title="contract_body/comment"><span class="cupd">/</span>**<span class="cupd">
</span>    * @n<span class="cupd">o</span>tice Lock so<span class="cupd">me</span> tokens as a stake
    * @dev Specify eithe<span class="cupd">r </span>index and zero period<span class="cupd">s</span> (f<span class="cupd">o</span>r an exis<span class="cupd">t</span>ing<span class="cupd"> </span>sub-stake)
    * or index &gt;= MAX_SUB_STAKES and real value <span class="cupd">for </span>peri<span class="cupd">o</span>ds (for a new sub-stake), not both
    * @param _staker Staker
    * @param _index Index of the sub stake
    * @param _va<span class="cupd">l</span>ue Amount of tokens wh<span class="cupd">ic</span>h will be locked
    * @p<span class="cupd">a</span>r<span class="cupd">a</span>m _p<span class="cupd">er</span>iods Amount of periods during which tokens will be locked
    */</span></span>
    function lock(address _staker, uint256 _index, uint256 _value, <span class="marker" id="mapping-261"></span><span class="token mv" id="move-src-162" data-title="function_definition/parameter">uint16 <span class="marker" id="mapping-262"></span><span class="token upd" id="move-src-163" data-title="parameter/identifier"><span class="cupd">_</span>pe<span class="cupd">r</span><span class="cupd">io</span>ds</span></span>) internal {
        if (_index &lt; MAX_SUB_STAKES) {
            require(_value &gt; 0);
        } else {
            require(_value &gt;= minAllowableLockedTokens &amp;&amp; <span class="marker" id="mapping-263"></span><span class="token upd" id="move-src-164" data-title="binary_expression/identifier"><span class="cupd">_</span>pe<span class="cupd">r</span><span class="cupd">io</span>ds</span> &gt;= minLockedPeriods);
        }

        uint16 currentPeriod = getCurrentPeriod();
        uint16 nextPeriod = currentPeriod + 1;
        StakerInfo storage info = stakerInfo[_staker];
        uint256 lockedTokens = getLockedTokens(info, currentPeriod, nextPeriod);
        uint256 requestedLockedTokens = _value.add(lockedTokens);
        require(requestedLockedTokens &lt;= info.value &amp;&amp; requestedLockedTokens &lt;= maxAllowableLockedTokens);

        // next period is committed
        if (info.nextCommittedPeriod == nextPeriod) {
            <span class="marker" id="mapping-264"></span><span class="token upd" id="move-src-165" data-title="array_access/identifier"><span class="cupd">lockedPerPeriod</span></span>[nextPeriod] += _value;
            emit CommitmentMade(_staker, nextPeriod, _value);
        }

        // if index was provided then increase existing sub-stake
        if (_index &lt; MAX_SUB_STAKES) {
            lockAndIncrease(info, currentPeriod, nextPeriod, _staker, _index, _value);
        // otherwise create new
        } else {
            lockAndCreate(info, nextPeriod, _staker, _value, <span class="marker" id="mapping-265"></span><span class="token upd" id="move-src-166" data-title="call_argument/identifier"><span class="cupd">_</span>pe<span class="cupd">r</span><span class="cupd">io</span>ds</span>);
        }
    }

    <span class="marker" id="mapping-266"></span><span class="token mv" id="move-src-167" data-title="contract_body/comment"><span class="marker" id="mapping-267"></span><span class="token upd" id="move-src-168" data-title="contract_body/comment"><span class="cupd">/</span>**<span class="cupd">
</span>    * @notice Lock some tokens as a new sub-stake
    * @param _in<span class="cupd">fo</span> Stake<span class="cupd">r</span> structure
    * @para<span class="cupd">m</span> _n<span class="cupd">e</span>xtPe<span class="cupd">r</span>iod<span class="cupd"> </span>Next period
    * @param _<span class="cupd">s</span>taker Staker
    * @param _va<span class="cupd">l</span>ue Am<span class="cupd">o</span>un<span class="cupd">t </span>o<span class="cupd">f</span> t<span class="cupd">o</span>kens which will be locked
    * @pa<span class="cupd">r</span>am<span class="cupd"> </span>_perio<span class="cupd">d</span>s Amo<span class="cupd">u</span>nt of perio<span class="cupd">d</span>s dur<span class="cupd">i</span>ng whi<span class="cupd">c</span>h <span class="cupd">to</span>kens will be locked
    */</span></span>
    function lockAndCreate(
        StakerInfo storage _info,
        uint16 _nextPeriod,
        address _staker,
        uint256 _value,
        uint16 <span class="marker" id="mapping-268"></span><span class="token upd" id="move-src-169" data-title="parameter/identifier"><span class="cupd">_</span>pe<span class="cupd">r</span><span class="cupd">io</span>ds</span>
    )
        internal
    {
        uint16 duration = <span class="marker" id="mapping-269"></span><span class="token upd" id="move-src-170" data-title="variable_declaration_statement/identifier"><span class="cupd">_</span>pe<span class="cupd">r</span><span class="cupd">io</span>ds</span>;
        // if winding down is enabled and next period is committed
        // then sub-stakes duration were decreased
        if (_info.nextCommittedPeriod == _nextPeriod &amp;&amp; _info.flags.bitSet(WIND_DOWN_INDEX)) {
            duration -= 1;
        }
        saveSubStake(_info, _nextPeriod, 0, duration, _value);

        emit Locked(_staker, _value, _nextPeriod, <span class="marker" id="mapping-270"></span><span class="token upd" id="move-src-171" data-title="call_argument/identifier"><span class="cupd">_</span>pe<span class="cupd">r</span><span class="cupd">io</span>ds</span>);
    }

    /**
    * @notice Increase lock amount of an existing sub-stake
    * @dev Probably will be created a new sub-stake but it will be active only one period
    * @param _info Staker structure
    * @param _currentPeriod Current period
    * @param _nextPeriod Next period
    * @param _staker Staker
    * @param _index Index of the sub-stake
    * @param _value Amount of tokens which will be locked
    */
    function lockAndIncrease(
        StakerInfo storage _info,
        uint16 _currentPeriod,
        uint16 _nextPeriod,
        address _staker,
        uint256 _index,
        uint256 _value
    )
        internal
    {
        SubStakeInfo storage subStake = _info.subStakes[_index];
        (, uint16 lastPeriod) = checkLastPeriodOfSubStake(_info, subStake, _currentPeriod);

        // create temporary sub-stake for current or previous committed periods
        // to leave locked amount in this period unchanged
        if (_info.currentCommittedPeriod != 0 &amp;&amp;
            _info.currentCommittedPeriod &lt;= _currentPeriod ||
            _info.nextCommittedPeriod != 0 &amp;&amp;
            _info.nextCommittedPeriod &lt;= _currentPeriod)
        {
            saveSubStake(_info, subStake.firstPeriod, _currentPeriod, 0, subStake.lockedValue);
        }

        subStake.lockedValue += uint128(_value);
        // all new locks should start from the next period
        subStake.firstPeriod = _nextPeriod;

        emit Locked(_staker, _value, _nextPeriod, lastPeriod - _currentPeriod);
    }

    /**
    * @notice Checks that last period of sub-stake is greater than the current period
    * @param _info Staker structure
    * @param _subStake Sub-stake structure
    * @param _currentPeriod Current period
    * @return startPeriod Start period. Use in the calculation of the last period of the sub stake
    * @return lastPeriod Last period of the sub stake
    */
    function checkLastPeriodOfSubStake(
        StakerInfo storage _info,
        SubStakeInfo storage _subStake,
        uint16 _currentPeriod
    )
        internal view returns (uint16 startPeriod, uint16 lastPeriod)
    {
        startPeriod = getStartPeriod(_info, _currentPeriod);
        lastPeriod = getLastPeriodOfSubStake(_subStake, startPeriod);
        // The sub stake must be active at least in the next period
        require(lastPeriod &gt; _currentPeriod);
    }

    <span class="marker" id="mapping-271"></span><span class="token mv" id="move-src-172" data-title="contract_body/comment"><span class="marker" id="mapping-272"></span><span class="token upd" id="move-src-173" data-title="contract_body/comment"><span class="cupd">/</span>**<span class="cupd">
</span>    * @notice Save sub stake. First tries to override inactive sub stake
    * @dev Inactive sub stake means that last period o<span class="cupd">f</span> sub stake has been surpassed and already rewarded
    * @param _inf<span class="cupd">o</span> Stake<span class="cupd">r</span> structure
    * @para<span class="cupd">m</span> _firstP<span class="cupd">er</span>iod<span class="cupd"> </span>Fir<span class="cupd">s</span>t period of the sub stake
    * @param _<span class="cupd">l</span>astPeri<span class="cupd">o</span>d Las<span class="cupd">t </span>period o<span class="cupd">f</span> the sub stake
    * @param _peri<span class="cupd">o</span>ds Du<span class="cupd">r</span>ation<span class="cupd"> </span><span class="cupd">o</span>f the sub stake in pe<span class="cupd">r</span>iods
    * @param _loc<span class="cupd">k</span>edValue Am<span class="cupd">o</span>unt of lo<span class="cupd">ck</span>ed tokens
    */</span></span>
    function saveSubStake(
        StakerInfo storage _info,
        uint16 _firstPeriod,
        uint16 _lastPeriod,
        <span class="marker" id="mapping-273"></span><span class="token mv" id="move-src-174" data-title="function_definition/parameter">uint16 <span class="marker" id="mapping-274"></span><span class="token upd" id="move-src-175" data-title="parameter/identifier"><span class="cupd">_</span>pe<span class="cupd">r</span><span class="cupd">io</span>ds</span></span>,
        uint256 _lockedValue
    )
        internal
    {
        for (uint256 i = 0; i &lt; _info.subStakes.length; i++) {
            SubStakeInfo storage subStake = _info.subStakes[i];
            if (subStake.lastPeriod != 0 &amp;&amp;
                (_info.currentCommittedPeriod == 0 ||
                subStake.lastPeriod &lt; _info.currentCommittedPeriod) &amp;&amp;
                (_info.nextCommittedPeriod == 0 ||
                subStake.lastPeriod &lt; _info.nextCommittedPeriod))
            {
                subStake.firstPeriod = _firstPeriod;
                subStake.lastPeriod = _lastPeriod;
                subStake.<span class="marker" id="mapping-275"></span><span class="token upd" id="move-src-176" data-title="member_expression/identifier">pe<span class="cupd">r</span><span class="cupd">io</span>ds</span> = <span class="marker" id="mapping-276"></span><span class="token upd" id="move-src-177" data-title="assignment_expression/identifier"><span class="cupd">_</span>pe<span class="cupd">r</span><span class="cupd">io</span>ds</span>;
                subStake.lockedValue = uint128(_lockedValue);
                return;
            }
        }
        require(_info.subStakes.length &lt; MAX_SUB_STAKES);
        _info.subStakes.push(SubStakeInfo(_firstPeriod, _lastPeriod, <span class="marker" id="mapping-277"></span><span class="token upd" id="move-src-178" data-title="call_argument/identifier"><span class="cupd">_</span>pe<span class="cupd">r</span><span class="cupd">io</span>ds</span>, uint128(_lockedValue)));
    }

    <span class="marker" id="mapping-278"></span><span class="token mv" id="move-src-179" data-title="contract_body/comment"><span class="marker" id="mapping-279"></span><span class="token upd" id="move-src-180" data-title="contract_body/comment"><span class="cupd">/</span>**<span class="cupd">
</span>    * @n<span class="cupd">o</span>tice Divide sub stake i<span class="cupd">n</span>to<span class="cupd"> t</span>w<span class="cupd">o </span>p<span class="cupd">a</span>rts<span class="cupd">
</span>    * @pa<span class="cupd">r</span>am _<span class="cupd">i</span>ndex Index o<span class="cupd">f</span> <span class="cupd">t</span>he sub s<span class="cupd">t</span>ak<span class="cupd">e
</span>    * @pa<span class="cupd">r</span>a<span class="cupd">m </span>_newValue New sub stake value
    * @<span class="cupd">p</span>a<span class="cupd">r</span>am _p<span class="cupd">e</span>r<span class="cupd">io</span>d<span class="cupd">s </span>Amount of p<span class="cupd">er</span><span class="cupd">io</span>ds<span class="cupd"> </span>f<span class="cupd">or</span><span class="cupd"> </span>ex<span class="cupd">te</span>nding sub stake
    */</span></span>
    function divideStake(uint256 _index, uint256 _newValue, <span class="marker" id="mapping-280"></span><span class="token mv" id="move-src-181" data-title="function_definition/parameter">uint16 <span class="marker" id="mapping-281"></span><span class="token upd" id="move-src-182" data-title="parameter/identifier"><span class="cupd">_</span>pe<span class="cupd">r</span><span class="cupd">io</span>ds</span></span>) external onlyStaker {
        StakerInfo storage info = stakerInfo[msg.sender];
        require(_newValue &gt;= minAllowableLockedTokens &amp;&amp; <span class="marker" id="mapping-282"></span><span class="token upd" id="move-src-183" data-title="binary_expression/identifier"><span class="cupd">_</span>pe<span class="cupd">r</span><span class="cupd">io</span>ds</span> &gt; 0);
        SubStakeInfo storage subStake = info.subStakes[_index];
        uint16 currentPeriod = getCurrentPeriod();
        (, uint16 lastPeriod) = checkLastPeriodOfSubStake(info, subStake, currentPeriod);

        uint256 oldValue = subStake.lockedValue;
        subStake.lockedValue = uint128(oldValue.sub(_newValue));
        require(subStake.lockedValue &gt;= minAllowableLockedTokens);
        uint16 requestedPeriods = subStake.<span class="marker" id="mapping-283"></span><span class="token upd" id="move-src-184" data-title="member_expression/identifier">pe<span class="cupd">r</span><span class="cupd">io</span>ds</span>.add16(<span class="marker" id="mapping-284"></span><span class="token upd" id="move-src-185" data-title="call_argument/identifier"><span class="cupd">_</span>pe<span class="cupd">r</span><span class="cupd">io</span>ds</span>);
        saveSubStake(info, subStake.firstPeriod, 0, requestedPeriods, _newValue);
        emit Divided(msg.sender, oldValue, lastPeriod, _newValue, <span class="marker" id="mapping-285"></span><span class="token upd" id="move-src-186" data-title="call_argument/identifier"><span class="cupd">_</span>pe<span class="cupd">r</span><span class="cupd">io</span>ds</span>);
        emit Locked(msg.sender, _newValue, subStake.firstPeriod, requestedPeriods);
    }

    <span class="marker" id="mapping-286"></span><span class="token mv" id="move-src-187" data-title="contract_body/comment"><span class="marker" id="mapping-287"></span><span class="token upd" id="move-src-188" data-title="contract_body/comment"><span class="cupd">/</span>**<span class="cupd">
</span><span class="cupd"> </span>   * @notic<span class="cupd">e</span> Pr<span class="cupd">o</span>long acti<span class="cupd">ve </span>sub st<span class="cupd">a</span>ke
    * @param _index Index o<span class="cupd">f</span> <span class="cupd">t</span>h<span class="cupd">e</span><span class="cupd"> </span>s<span class="cupd">u</span>b stake
    * @<span class="cupd">p</span>a<span class="cupd">ra</span>m _perio<span class="cupd">d</span>s Amount of p<span class="cupd">e</span>riods for extending sub stake
    */</span></span>
    function prolongStake(uint256 _index, <span class="marker" id="mapping-288"></span><span class="token mv" id="move-src-189" data-title="function_definition/parameter">uint16 <span class="marker" id="mapping-289"></span><span class="token upd" id="move-src-190" data-title="parameter/identifier"><span class="cupd">_</span>pe<span class="cupd">r</span><span class="cupd">io</span>ds</span></span>) external onlyStaker {
        StakerInfo storage info = stakerInfo[msg.sender];
        // Incorrect parameters
        require(<span class="marker" id="mapping-290"></span><span class="token upd" id="move-src-191" data-title="binary_expression/identifier"><span class="cupd">_</span>pe<span class="cupd">r</span><span class="cupd">io</span>ds</span> &gt; 0);
        SubStakeInfo storage subStake = info.subStakes[_index];
        uint16 currentPeriod = getCurrentPeriod();
        (uint16 startPeriod, uint16 lastPeriod) = checkLastPeriodOfSubStake(info, subStake, currentPeriod);

        subStake.<span class="marker" id="mapping-291"></span><span class="token upd" id="move-src-192" data-title="member_expression/identifier">pe<span class="cupd">r</span><span class="cupd">io</span>ds</span> = subStake.<span class="marker" id="mapping-292"></span><span class="token upd" id="move-src-193" data-title="member_expression/identifier">pe<span class="cupd">r</span><span class="cupd">io</span>ds</span>.add16(<span class="marker" id="mapping-293"></span><span class="token upd" id="move-src-194" data-title="call_argument/identifier"><span class="cupd">_</span>pe<span class="cupd">r</span><span class="cupd">io</span>ds</span>);
        // if the sub stake ends in the next committed period then reset the `lastPeriod` field
        if (lastPeriod == startPeriod) {
            subStake.lastPeriod = 0;
        }
        // The extended sub stake must not be less than the minimum value
        require(uint32(lastPeriod - currentPeriod) + <span class="marker" id="mapping-294"></span><span class="token upd" id="move-src-195" data-title="binary_expression/identifier"><span class="cupd">_</span>pe<span class="cupd">r</span><span class="cupd">io</span>ds</span> &gt;= minLockedPeriods);
        emit Locked(msg.sender, subStake.lockedValue, lastPeriod + 1, <span class="marker" id="mapping-295"></span><span class="token upd" id="move-src-196" data-title="call_argument/identifier"><span class="cupd">_</span>pe<span class="cupd">r</span><span class="cupd">io</span>ds</span>);
        emit Prolonged(msg.sender, subStake.lockedValue, lastPeriod, <span class="marker" id="mapping-296"></span><span class="token upd" id="move-src-197" data-title="call_argument/identifier"><span class="cupd">_</span>pe<span class="cupd">r</span><span class="cupd">io</span>ds</span>);
    }

    /**
    * @notice Merge two sub-stakes into one if their last periods are equal
    * @dev It's possible that both sub-stakes will be active after this transaction.
    * But only one of them will be active until next call `commitToNextPeriod` (in the next period)
    * @param _index1 Index of the first sub-stake
    * @param _index2 Index of the second sub-stake
    */
    function mergeStake(uint256 _index1, uint256 _index2) external onlyStaker {
        require(_index1 != _index2); // must be different sub-stakes

        StakerInfo storage info = stakerInfo[msg.sender];
        SubStakeInfo storage subStake1 = info.subStakes[_index1];
        SubStakeInfo storage subStake2 = info.subStakes[_index2];
        uint16 currentPeriod = getCurrentPeriod();

        (, uint16 lastPeriod1) = checkLastPeriodOfSubStake(info, subStake1, currentPeriod);
        (, uint16 lastPeriod2) = checkLastPeriodOfSubStake(info, subStake2, currentPeriod);
        // both sub-stakes must have equal last period to be mergeable
        require(lastPeriod1 == lastPeriod2);
        emit Merged(msg.sender, subStake1.lockedValue, subStake2.lockedValue, lastPeriod1);

        if (subStake1.firstPeriod == subStake2.firstPeriod) {
            subStake1.lockedValue += subStake2.lockedValue;
            subStake2.lastPeriod = 1;
            subStake2.<span class="marker" id="mapping-297"></span><span class="token upd" id="move-src-198" data-title="member_expression/identifier">pe<span class="cupd">r</span><span class="cupd">io</span>ds</span> = 0;
        } else if (subStake1.firstPeriod &gt; subStake2.firstPeriod) {
            subStake1.lockedValue += subStake2.lockedValue;
            subStake2.lastPeriod = subStake1.firstPeriod - 1;
            subStake2.<span class="marker" id="mapping-298"></span><span class="token upd" id="move-src-199" data-title="member_expression/identifier">pe<span class="cupd">r</span><span class="cupd">io</span>ds</span> = 0;
        } else {
            subStake2.lockedValue += subStake1.lockedValue;
            subStake1.lastPeriod = subStake2.firstPeriod - 1;
            subStake1.<span class="marker" id="mapping-299"></span><span class="token upd" id="move-src-200" data-title="member_expression/identifier">pe<span class="cupd">r</span><span class="cupd">io</span>ds</span> = 0;
        }
    }

    /**
    * @notice Remove unused sub-stake to decrease gas cost for several methods
    */
    function removeUnusedSubStake(uint16 _index) external onlyStaker {
        StakerInfo storage info = stakerInfo[msg.sender];

        uint256 lastIndex = info.subStakes.length - 1;
        SubStakeInfo storage subStake = info.subStakes[_index];
        require(subStake.lastPeriod != 0 &amp;&amp;
                (info.currentCommittedPeriod == 0 ||
                subStake.lastPeriod &lt; info.currentCommittedPeriod) &amp;&amp;
                (info.nextCommittedPeriod == 0 ||
                subStake.lastPeriod &lt; info.nextCommittedPeriod));

        if (_index != lastIndex) {
            SubStakeInfo storage lastSubStake = info.subStakes[lastIndex];
            subStake.firstPeriod = lastSubStake.firstPeriod;
            subStake.lastPeriod = lastSubStake.lastPeriod;
            subStake.<span class="marker" id="mapping-300"></span><span class="token upd" id="move-src-201" data-title="member_expression/identifier">pe<span class="cupd">r</span><span class="cupd">io</span>ds</span> = lastSubStake.<span class="marker" id="mapping-301"></span><span class="token upd" id="move-src-202" data-title="member_expression/identifier">pe<span class="cupd">r</span><span class="cupd">io</span>ds</span>;
            subStake.lockedValue = lastSubStake.lockedValue;
        }
        info.subStakes.pop();
    }

    /**
    * @notice Withdraw available amount of tokens to staker
    * @param _value Amount of tokens to withdraw
    */
    function withdraw(uint256 _value) external onlyStaker {
        uint16 currentPeriod = getCurrentPeriod();
        uint16 nextPeriod = currentPeriod + 1;
        StakerInfo storage info = stakerInfo[msg.sender];
        // the max locked tokens in most cases will be in the current period
        // but when the staker locks more then we should use the next period
        uint256 lockedTokens = Math.max(getLockedTokens(info, currentPeriod, nextPeriod),
            getLockedTokens(info, currentPeriod, currentPeriod));
        require(_value &lt;= info.value.sub(lockedTokens));
        info.value -= _value;

        addSnapshot(info, - int256(_value));
        token.safeTransfer(msg.sender, _value);
        emit Withdrawn(msg.sender, _value);

        // unbond worker if staker withdraws last portion of NU
        if (info.value == 0 &amp;&amp;
            info.nextCommittedPeriod == 0 &amp;&amp;
            info.worker != address(0))
        {
            stakerFromWorker[info.worker] = address(0);
            info.worker = address(0);
            emit WorkerBonded(msg.sender, address(0), currentPeriod);
        }
    }

    /**
    * @notice Make a commitment to the next period and mint for the previous period
    */
    function commitToNextPeriod() external isInitialized {
        address staker = stakerFromWorker[msg.sender];
        StakerInfo storage info = stakerInfo[staker];
        // Staker must have a stake to make a commitment
        require(info.value &gt; 0);
        // Only worker with real address can make a commitment
        require(msg.sender == tx.origin);

        <span class="marker" id="mapping-302"></span><span class="token mv" id="move-src-203" data-title="function_body/variable_declaration_statement">uint16 lastCommittedPeriod = getLastCommittedPeriod(staker);</span>
        <span class="marker" id="mapping-303"></span><span class="token mv" id="move-src-204" data-title="function_body/variable_declaration_statement">(uint16 processedPeriod1, uint16 processedPeriod2) = mint(staker);</span>
        uint16 currentPeriod = getCurrentPeriod();
        uint16 nextPeriod = currentPeriod + 1;

        // the period has already been committed
        <span class="marker" id="mapping-304"></span><span class="token mv" id="move-src-205" data-title="function_body/if_statement">if (<span class="marker" id="mapping-305"></span><span class="token del" data-title="if_statement/binary_expression">info.nextCommittedPeriod == nextPeriod</span>) {
            return;
        }</span>

        uint256 lockedTokens = getLockedTokens(info, currentPeriod, nextPeriod);
        require(lockedTokens &gt; 0);
        <span class="marker" id="mapping-306"></span><span class="token upd" id="move-src-206" data-title="array_access/identifier"><span class="cupd">lockedPerPeriod</span></span>[nextPeriod] += lockedTokens;

        info.currentCommittedPeriod = info.nextCommittedPeriod;
        info.nextCommittedPeriod = nextPeriod;

        decreaseSubStakesDuration(info, nextPeriod);

        // staker was inactive for several periods
        if (lastCommittedPeriod &lt; currentPeriod) {
            info.pastDowntime.push(Downtime(lastCommittedPeriod + 1, currentPeriod));
        }

        policyManager.ping(staker, processedPeriod1, processedPeriod2, nextPeriod);
        emit CommitmentMade(staker, nextPeriod, lockedTokens);
    }

    /**
    * @notice Decrease sub-stakes duration if `windDown` is enabled
    */
    function decreaseSubStakesDuration(StakerInfo storage _info, uint16 _nextPeriod) internal {
        if (!_info.flags.bitSet(WIND_DOWN_INDEX)) {
            return;
        }
        for (uint256 index = 0; index &lt; _info.subStakes.length; index++) {
            SubStakeInfo storage subStake = _info.subStakes[index];
            if (subStake.lastPeriod != 0 || subStake.<span class="marker" id="mapping-307"></span><span class="token upd" id="move-src-207" data-title="member_expression/identifier">pe<span class="cupd">r</span><span class="cupd">io</span>ds</span> == 0) {
                continue;
            }
            subStake.<span class="marker" id="mapping-308"></span><span class="token upd" id="move-src-208" data-title="member_expression/identifier">pe<span class="cupd">r</span><span class="cupd">io</span>ds</span>--;
            if (subStake.<span class="marker" id="mapping-309"></span><span class="token upd" id="move-src-209" data-title="member_expression/identifier">pe<span class="cupd">r</span><span class="cupd">io</span>ds</span> == 0) {
                subStake.lastPeriod = _nextPeriod;
            }
        }
    }

    /**
    * @notice Mint tokens for previous periods if staker locked their tokens and made a commitment
    */
    function mint() external onlyStaker {
        // save last committed period to the storage if both periods will be empty after minting
        // because we won't be able to calculate last committed period
        // see getLastCommittedPeriod(address)
        StakerInfo storage info = stakerInfo[msg.sender];
        uint16 previousPeriod = getCurrentPeriod() - 1;
        if (info.nextCommittedPeriod &lt;= previousPeriod &amp;&amp; info.nextCommittedPeriod != 0) {
            info.lastCommittedPeriod = info.nextCommittedPeriod;
        }
        (uint16 processedPeriod1, uint16 processedPeriod2) = mint(msg.sender);

        if (processedPeriod1 != 0 || processedPeriod2 != 0) {
            policyManager.ping(msg.sender, processedPeriod1, processedPeriod2, 0);
        }
    }

    /**
    * @notice Mint tokens for previous periods if staker locked their tokens and made a commitment
    * @param _staker Staker
    * @return processedPeriod1 Processed period: currentCommittedPeriod or zero
    * @return processedPeriod2 Processed period: nextCommittedPeriod or zero
    */
    function mint(address _staker) internal returns (uint16 processedPeriod1, uint16 processedPeriod2) {
        uint16 currentPeriod = getCurrentPeriod();
        uint16 previousPeriod = currentPeriod - 1;
        StakerInfo storage info = stakerInfo[_staker];

        if (info.nextCommittedPeriod == 0 ||
            info.currentCommittedPeriod == 0 &amp;&amp;
            info.nextCommittedPeriod &gt; previousPeriod ||
            info.currentCommittedPeriod &gt; previousPeriod) {
            return (0, 0);
        }

        uint16 startPeriod = getStartPeriod(info, currentPeriod);
        uint256 reward = 0;
        bool reStake = !info.flags.bitSet(RE_STAKE_DISABLED_INDEX);

        if (info.currentCommittedPeriod != 0) {
            reward = mint(info, info.currentCommittedPeriod, currentPeriod, startPeriod, reStake);
            processedPeriod1 = info.currentCommittedPeriod;
            info.currentCommittedPeriod = 0;
            if (reStake) {
                <span class="marker" id="mapping-310"></span><span class="token upd" id="move-src-210" data-title="array_access/identifier"><span class="cupd">lockedPerPeriod</span></span>[info.nextCommittedPeriod] += reward;
            }
        }
        if (info.nextCommittedPeriod &lt;= previousPeriod) {
            reward += mint(info, info.nextCommittedPeriod, currentPeriod, startPeriod, reStake);
            processedPeriod2 = info.nextCommittedPeriod;
            info.nextCommittedPeriod = 0;
        }

        info.value += reward;
        if (info.flags.bitSet(MEASURE_WORK_INDEX)) {
            info.completedWork += reward;
        }

        addSnapshot(info, int256(reward));
        emit Minted(_staker, previousPeriod, reward);
    }

    /**
    * @notice Calculate reward for one period
    * @param _info Staker structure
    * @param _mintingPeriod Period for minting calculation
    * @param _currentPeriod Current period
    * @param _startPeriod Pre-calculated start period
    */
    function mint(
        StakerInfo storage _info,
        uint16 _mintingPeriod,
        uint16 _currentPeriod,
        uint16 _startPeriod,
        bool _reStake
    )
        internal returns (uint256 reward)
    {
        reward = 0;
        for (uint256 i = 0; i &lt; _info.subStakes.length; i++) {
            SubStakeInfo storage subStake =  _info.subStakes[i];
            uint16 lastPeriod = getLastPeriodOfSubStake(subStake, _startPeriod);
            if (subStake.firstPeriod &lt;= _mintingPeriod &amp;&amp; lastPeriod &gt;= _mintingPeriod) {
                uint256 subStakeReward = mint(
                    _currentPeriod,
                    subStake.lockedValue,
                    <span class="marker" id="mapping-311"></span><span class="token upd" id="move-src-211" data-title="array_access/identifier"><span class="cupd">lockedPerPeriod</span></span>[_mintingPeriod],
                    lastPeriod.sub16(_mintingPeriod));
                reward += subStakeReward;
                if (_reStake) {
                    subStake.lockedValue += uint128(subStakeReward);
                }
            }
        }
        return reward;
    }

    //-------------------------Slashing-------------------------
    /**
    * @notice Slash the staker's stake and reward the investigator
    * @param _staker Staker's address
    * @param _penalty Penalty
    * @param _investigator Investigator
    * @param _reward Reward for the investigator
    */
    function slashStaker(
        address _staker,
        uint256 _penalty,
        address _investigator,
        uint256 _reward
    )
        public isInitialized
    {
        require(msg.sender == address(adjudicator));
        require(_penalty &gt; 0);
        StakerInfo storage info = stakerInfo[_staker];
        if (info.value &lt;= _penalty) {
            _penalty = info.value;
        }
        info.value -= _penalty;
        if (_reward &gt; _penalty) {
            _reward = _penalty;
        }

        uint16 currentPeriod = getCurrentPeriod();
        uint16 nextPeriod = currentPeriod + 1;
        uint16 startPeriod = getStartPeriod(info, currentPeriod);

        (uint256 currentLock, uint256 nextLock, uint256 currentAndNextLock, uint256 shortestSubStakeIndex) =
            getLockedTokensAndShortestSubStake(info, currentPeriod, nextPeriod, startPeriod);

        // Decrease the stake if amount of locked tokens in the current period more than staker has
        uint256 lockedTokens = currentLock + currentAndNextLock;
        if (info.value &lt; lockedTokens) {
           decreaseSubStakes(info, lockedTokens - info.value, currentPeriod, startPeriod, shortestSubStakeIndex);
        }
        // Decrease the stake if amount of locked tokens in the next period more than staker has
        if (nextLock &gt; 0) {
            lockedTokens = nextLock + currentAndNextLock -
                (currentAndNextLock &gt; info.value ? currentAndNextLock - info.value : 0);
            if (info.value &lt; lockedTokens) {
               decreaseSubStakes(info, lockedTokens - info.value, nextPeriod, startPeriod, MAX_SUB_STAKES);
            }
        }

        emit Slashed(_staker, _penalty, _investigator, _reward);
        if (_penalty &gt; _reward) {
            unMint(_penalty - _reward);
        }
        // TODO change to withdrawal pattern (#1499)
        if (_reward &gt; 0) {
            token.safeTransfer(_investigator, _reward);
        }

        addSnapshot(info, - int256(_penalty));

    }

    /**
    * @notice Get the value of locked tokens for a staker in the current and the next period
    * and find the shortest sub stake
    * @param _info Staker structure
    * @param _currentPeriod Current period
    * @param _nextPeriod Next period
    * @param _startPeriod Pre-calculated start period
    * @return currentLock Amount of tokens that locked in the current period and unlocked in the next period
    * @return nextLock Amount of tokens that locked in the next period and not locked in the current period
    * @return currentAndNextLock Amount of tokens that locked in the current period and in the next period
    * @return shortestSubStakeIndex Index of the shortest sub stake
    */
    function getLockedTokensAndShortestSubStake(
        StakerInfo storage _info,
        uint16 _currentPeriod,
        uint16 _nextPeriod,
        uint16 _startPeriod
    )
        internal view returns (
            uint256 currentLock,
            uint256 nextLock,
            uint256 currentAndNextLock,
            uint256 shortestSubStakeIndex
        )
    {
        uint16 minDuration = MAX_UINT16;
        uint16 minLastPeriod = MAX_UINT16;
        shortestSubStakeIndex = MAX_SUB_STAKES;
        currentLock = 0;
        nextLock = 0;
        currentAndNextLock = 0;

        for (uint256 i = 0; i &lt; _info.subStakes.length; i++) {
            SubStakeInfo storage subStake = _info.subStakes[i];
            uint16 lastPeriod = getLastPeriodOfSubStake(subStake, _startPeriod);
            if (lastPeriod &lt; subStake.firstPeriod) {
                continue;
            }
            if (subStake.firstPeriod &lt;= _currentPeriod &amp;&amp;
                lastPeriod &gt;= _nextPeriod) {
                currentAndNextLock += subStake.lockedValue;
            } else if (subStake.firstPeriod &lt;= _currentPeriod &amp;&amp;
                lastPeriod &gt;= _currentPeriod) {
                currentLock += subStake.lockedValue;
            } else if (subStake.firstPeriod &lt;= _nextPeriod &amp;&amp;
                lastPeriod &gt;= _nextPeriod) {
                nextLock += subStake.lockedValue;
            }
            uint16 duration = lastPeriod - subStake.firstPeriod;
            if (subStake.firstPeriod &lt;= _currentPeriod &amp;&amp;
                lastPeriod &gt;= _currentPeriod &amp;&amp;
                (lastPeriod &lt; minLastPeriod ||
                lastPeriod == minLastPeriod &amp;&amp; duration &lt; minDuration))
            {
                shortestSubStakeIndex = i;
                minDuration = duration;
                minLastPeriod = lastPeriod;
            }
        }
    }

    /**
    * @notice Decrease short sub stakes
    * @param _info Staker structure
    * @param _penalty Penalty rate
    * @param _decreasePeriod The period when the decrease begins
    * @param _startPeriod Pre-calculated start period
    * @param _shortestSubStakeIndex Index of the shortest period
    */
    function decreaseSubStakes(
        StakerInfo storage _info,
        uint256 _penalty,
        uint16 _decreasePeriod,
        uint16 _startPeriod,
        uint256 _shortestSubStakeIndex
    )
        internal
    {
        SubStakeInfo storage shortestSubStake = _info.subStakes[0];
        uint16 minSubStakeLastPeriod = MAX_UINT16;
        uint16 minSubStakeDuration = MAX_UINT16;
        while(_penalty &gt; 0) {
            if (_shortestSubStakeIndex &lt; MAX_SUB_STAKES) {
                shortestSubStake = _info.subStakes[_shortestSubStakeIndex];
                minSubStakeLastPeriod = getLastPeriodOfSubStake(shortestSubStake, _startPeriod);
                minSubStakeDuration = minSubStakeLastPeriod - shortestSubStake.firstPeriod;
                _shortestSubStakeIndex = MAX_SUB_STAKES;
            } else {
                (shortestSubStake, minSubStakeDuration, minSubStakeLastPeriod) =
                    getShortestSubStake(_info, _decreasePeriod, _startPeriod);
            }
            if (minSubStakeDuration == MAX_UINT16) {
                break;
            }
            uint256 appliedPenalty = _penalty;
            if (_penalty &lt; shortestSubStake.lockedValue) {
                shortestSubStake.lockedValue -= uint128(_penalty);
                saveOldSubStake(_info, shortestSubStake.firstPeriod, _penalty, _decreasePeriod);
                _penalty = 0;
            } else {
                shortestSubStake.lastPeriod = _decreasePeriod - 1;
                _penalty -= shortestSubStake.lockedValue;
                appliedPenalty = shortestSubStake.lockedValue;
            }
            if (_info.currentCommittedPeriod &gt;= _decreasePeriod &amp;&amp;
                _info.currentCommittedPeriod &lt;= minSubStakeLastPeriod)
            {
                <span class="marker" id="mapping-312"></span><span class="token upd" id="move-src-212" data-title="array_access/identifier"><span class="cupd">lockedPerPeriod</span></span>[_info.currentCommittedPeriod] -= appliedPenalty;
            }
            if (_info.nextCommittedPeriod &gt;= _decreasePeriod &amp;&amp;
                _info.nextCommittedPeriod &lt;= minSubStakeLastPeriod)
            {
                <span class="marker" id="mapping-313"></span><span class="token upd" id="move-src-213" data-title="array_access/identifier"><span class="cupd">lockedPerPeriod</span></span>[_info.nextCommittedPeriod] -= appliedPenalty;
            }
        }
    }

    /**
    * @notice Get the shortest sub stake
    * @param _info Staker structure
    * @param _currentPeriod Current period
    * @param _startPeriod Pre-calculated start period
    * @return shortestSubStake The shortest sub stake
    * @return minSubStakeDuration Duration of the shortest sub stake
    * @return minSubStakeLastPeriod Last period of the shortest sub stake
    */
    function getShortestSubStake(
        StakerInfo storage _info,
        uint16 _currentPeriod,
        uint16 _startPeriod
    )
        internal view returns (
            SubStakeInfo storage shortestSubStake,
            uint16 minSubStakeDuration,
            uint16 minSubStakeLastPeriod
        )
    {
        shortestSubStake = shortestSubStake;
        minSubStakeDuration = MAX_UINT16;
        minSubStakeLastPeriod = MAX_UINT16;
        for (uint256 i = 0; i &lt; _info.subStakes.length; i++) {
            SubStakeInfo storage subStake = _info.subStakes[i];
            uint16 lastPeriod = getLastPeriodOfSubStake(subStake, _startPeriod);
            if (lastPeriod &lt; subStake.firstPeriod) {
                continue;
            }
            uint16 duration = lastPeriod - subStake.firstPeriod;
            if (subStake.firstPeriod &lt;= _currentPeriod &amp;&amp;
                lastPeriod &gt;= _currentPeriod &amp;&amp;
                (lastPeriod &lt; minSubStakeLastPeriod ||
                lastPeriod == minSubStakeLastPeriod &amp;&amp; duration &lt; minSubStakeDuration))
            {
                shortestSubStake = subStake;
                minSubStakeDuration = duration;
                minSubStakeLastPeriod = lastPeriod;
            }
        }
    }

    /**
    * @notice Save the old sub stake values to prevent decreasing reward for the previous period
    * @dev Saving happens only if the previous period is committed
    * @param _info Staker structure
    * @param _firstPeriod First period of the old sub stake
    * @param _lockedValue Locked value of the old sub stake
    * @param _currentPeriod Current period, when the old sub stake is already unlocked
    */
    function saveOldSubStake(
        StakerInfo storage _info,
        uint16 _firstPeriod,
        uint256 _lockedValue,
        uint16 _currentPeriod
    )
        internal
    {
        // Check that the old sub stake should be saved
        bool oldCurrentCommittedPeriod = _info.currentCommittedPeriod != 0 &amp;&amp;
            _info.currentCommittedPeriod &lt; _currentPeriod;
        bool oldnextCommittedPeriod = _info.nextCommittedPeriod != 0 &amp;&amp;
            _info.nextCommittedPeriod &lt; _currentPeriod;
        bool crosscurrentCommittedPeriod = oldCurrentCommittedPeriod &amp;&amp; _info.currentCommittedPeriod &gt;= _firstPeriod;
        bool crossnextCommittedPeriod = oldnextCommittedPeriod &amp;&amp; _info.nextCommittedPeriod &gt;= _firstPeriod;
        if (!crosscurrentCommittedPeriod &amp;&amp; !crossnextCommittedPeriod) {
            return;
        }
        // Try to find already existent proper old sub stake
        uint16 previousPeriod = _currentPeriod - 1;
        for (uint256 i = 0; i &lt; _info.subStakes.length; i++) {
            SubStakeInfo storage subStake = _info.subStakes[i];
            if (subStake.lastPeriod == previousPeriod &amp;&amp;
                ((crosscurrentCommittedPeriod ==
                (oldCurrentCommittedPeriod &amp;&amp; _info.currentCommittedPeriod &gt;= subStake.firstPeriod)) &amp;&amp;
                (crossnextCommittedPeriod ==
                (oldnextCommittedPeriod &amp;&amp; _info.nextCommittedPeriod &gt;= subStake.firstPeriod))))
            {
                subStake.lockedValue += uint128(_lockedValue);
                return;
            }
        }
        saveSubStake(_info, _firstPeriod, previousPeriod, 0, _lockedValue);
    }

    //-------------Additional getters for stakers info-------------
    /**
    * @notice Return the length of the array of stakers
    */
    function getStakersLength() external view returns (uint256) {
        return stakers.length;
    }

    /**
    * @notice Return the length of the array of sub stakes
    */
    function getSubStakesLength(address _staker) external view returns (uint256) {
        return stakerInfo[_staker].subStakes.length;
    }

    /**
    * @notice Return the information about sub stake
    */
    function getSubStakeInfo(address _staker, uint256 _index)
    // TODO change to structure when ABIEncoderV2 is released (#1501)
//        public view returns (SubStakeInfo)
        // TODO "virtual" only for tests, probably will be removed after #1512
        external view virtual returns (uint16 firstPeriod, uint16 lastPeriod, uint16 <span class="marker" id="mapping-314"></span><span class="token upd" id="move-src-214" data-title="parameter/identifier">pe<span class="cupd">r</span><span class="cupd">io</span>ds</span>, uint128 lockedValue)
    {
        SubStakeInfo storage info = stakerInfo[_staker].subStakes[_index];
        firstPeriod = info.firstPeriod;
        lastPeriod = info.lastPeriod;
        <span class="marker" id="mapping-315"></span><span class="token upd" id="move-src-215" data-title="assignment_expression/identifier">pe<span class="cupd">r</span><span class="cupd">io</span>ds</span> = info.<span class="marker" id="mapping-316"></span><span class="token upd" id="move-src-216" data-title="member_expression/identifier">pe<span class="cupd">r</span><span class="cupd">io</span>ds</span>;
        lockedValue = info.lockedValue;
    }

    /**
    * @notice Return the length of the array of past downtime
    */
    function getPastDowntimeLength(address _staker) external view returns (uint256) {
        return stakerInfo[_staker].pastDowntime.length;
    }

    /**
    * @notice Return the information about past downtime
    */
    function  getPastDowntime(address _staker, uint256 _index)
    // TODO change to structure when ABIEncoderV2 is released (#1501)
//        public view returns (Downtime)
        external view returns (uint16 startPeriod, uint16 endPeriod)
    {
        Downtime storage downtime = stakerInfo[_staker].pastDowntime[_index];
        startPeriod = downtime.startPeriod;
        endPeriod = downtime.endPeriod;
    }

    //------------------ ERC900 connectors ----------------------

    function totalStakedForAt(address _owner, uint256 _blockNumber) public view override returns (uint256){
        return stakerInfo[_owner].history.getValueAt(_blockNumber);
    }

    function totalStakedAt(uint256 _blockNumber) public view override returns (uint256){
        return balanceHistory.getValueAt(_blockNumber);
    }

    function supportsHistory() external pure override returns (bool){
        return true;
    }

    //------------------------Upgradeable------------------------
    /**
    * @dev Get StakerInfo structure by delegatecall
    */
    function delegateGetStakerInfo(address _target, bytes32 _staker)
        internal returns (StakerInfo memory result)
    {
        bytes32 memoryAddress = delegateGetData(_target, this.stakerInfo.selector, 1, _staker, 0);
        assembly {
            result := memoryAddress
        }
    }

    /**
    * @dev Get SubStakeInfo structure by delegatecall
    */
    function delegateGetSubStakeInfo(address _target, bytes32 _staker, uint256 _index)
        internal returns (SubStakeInfo memory result)
    {
        bytes32 memoryAddress = delegateGetData(
            _target, this.getSubStakeInfo.selector, 2, _staker, bytes32(_index));
        assembly {
            result := memoryAddress
        }
    }

    /**
    * @dev Get Downtime structure by delegatecall
    */
    function delegateGetPastDowntime(address _target, bytes32 _staker, uint256 _index)
        internal returns (Downtime memory result)
    {
        bytes32 memoryAddress = delegateGetData(
            _target, this.getPastDowntime.selector, 2, _staker, bytes32(_index));
        assembly {
            result := memoryAddress
        }
    }

    /// @dev the `onlyWhileUpgrading` modifier works through a call to the parent `verifyState`
    function verifyState(address _testTarget) public override virtual {
        super.verifyState(_testTarget);
        <span class="marker" id="mapping-317"></span><span class="token del" data-title="function_body/expression_statement"><span class="marker" id="mapping-318"></span><span class="token del" data-title="expression_statement/call_expression">require(<span class="marker" id="mapping-319"></span><span class="token del" data-title="call_expression/call_argument"><span class="marker" id="mapping-320"></span><span class="token del" data-title="call_argument/binary_expression"><span class="marker" id="mapping-321"></span><span class="token del" data-title="binary_expression/type_cast_expression"><span class="marker" id="mapping-322"></span><span class="token del" data-title="type_cast_expression/primitive_type">address</span>(<span class="marker" id="mapping-323"></span><span class="token del" data-title="type_cast_expression/call_argument"><span class="marker" id="mapping-324"></span><span class="token del" data-title="call_argument/call_expression">delegateGet(<span class="marker" id="mapping-325"></span><span class="token mv" id="move-src-217" data-title="call_expression/call_argument">_testTarget</span>, <span class="marker" id="mapping-326"></span><span class="token del" data-title="call_expression/call_argument">this.policyManager.selector</span>)</span></span>)</span> == <span class="marker" id="mapping-327"></span><span class="token del" data-title="binary_expression/type_cast_expression">address(policyManager)</span></span></span>)</span>;</span>
        <span class="marker" id="mapping-328"></span><span class="token del" data-title="function_body/expression_statement"><span class="marker" id="mapping-329"></span><span class="token del" data-title="expression_statement/call_expression">require(<span class="marker" id="mapping-330"></span><span class="token del" data-title="call_expression/call_argument"><span class="marker" id="mapping-331"></span><span class="token del" data-title="call_argument/binary_expression"><span class="marker" id="mapping-332"></span><span class="token del" data-title="binary_expression/type_cast_expression"><span class="marker" id="mapping-333"></span><span class="token mv" id="move-src-218" data-title="type_cast_expression/primitive_type">address</span>(<span class="marker" id="mapping-334"></span><span class="token del" data-title="type_cast_expression/call_argument"><span class="marker" id="mapping-335"></span><span class="token del" data-title="call_argument/call_expression">delegateGet(<span class="marker" id="mapping-336"></span><span class="token mv" id="move-src-219" data-title="call_expression/call_argument">_testTarget</span>, <span class="marker" id="mapping-337"></span><span class="token del" data-title="call_expression/call_argument">this.adjudicator.selector</span>)</span></span>)</span> == <span class="marker" id="mapping-338"></span><span class="token del" data-title="binary_expression/type_cast_expression">address(adjudicator)</span></span></span>)</span>;</span>
        <span class="marker" id="mapping-339"></span><span class="token del" data-title="function_body/expression_statement"><span class="marker" id="mapping-340"></span><span class="token del" data-title="expression_statement/call_expression">require(<span class="marker" id="mapping-341"></span><span class="token del" data-title="call_expression/call_argument"><span class="marker" id="mapping-342"></span><span class="token del" data-title="call_argument/binary_expression"><span class="marker" id="mapping-343"></span><span class="token del" data-title="binary_expression/type_cast_expression"><span class="marker" id="mapping-344"></span><span class="token del" data-title="type_cast_expression/primitive_type">address</span>(<span class="marker" id="mapping-345"></span><span class="token del" data-title="type_cast_expression/call_argument"><span class="marker" id="mapping-346"></span><span class="token del" data-title="call_argument/call_expression">delegateGet(<span class="marker" id="mapping-347"></span><span class="token mv" id="move-src-220" data-title="call_expression/call_argument">_testTarget</span>, <span class="marker" id="mapping-348"></span><span class="token del" data-title="call_expression/call_argument">this.workLock.selector</span>)</span></span>)</span> == <span class="marker" id="mapping-349"></span><span class="token del" data-title="binary_expression/type_cast_expression">address(workLock)</span></span></span>)</span>;</span>
        require(<span class="marker" id="mapping-350"></span><span class="token del" data-title="call_argument/array_access"><span class="marker" id="mapping-351"></span><span class="token mv" id="move-src-221" data-title="array_access/binary_expression">delegateGet(_testTarget, this.lockedPerPeriod.selector,
            bytes32(bytes2(RESERVED_PERIOD))) == <span class="marker" id="mapping-352"></span><span class="token del" data-title="binary_expression/identifier">lockedPerPeriod</span></span>[RESERVED_PERIOD]</span>);
        require(address(delegateGet(_testTarget, this.stakerFromWorker.selector, bytes32(0))) ==
            stakerFromWorker[address(0)]);

        require(delegateGet(_testTarget, this.getStakersLength.selector) == stakers.length);
        if (stakers.length == 0) {
            return;
        }
        address stakerAddress = stakers[0];
        require(address(uint160(delegateGet(_testTarget, this.stakers.selector, 0))) == stakerAddress);
        StakerInfo storage info = stakerInfo[stakerAddress];
        bytes32 staker = bytes32(uint256(stakerAddress));
        StakerInfo memory infoToCheck = delegateGetStakerInfo(_testTarget, staker);
        require(<span class="marker" id="mapping-353"></span><span class="token del" data-title="call_argument/binary_expression"><span class="marker" id="mapping-354"></span><span class="token del" data-title="binary_expression/member_expression"><span class="marker" id="mapping-355"></span><span class="token del" data-title="member_expression/binary_expression"><span class="marker" id="mapping-356"></span><span class="token mv" id="move-src-222" data-title="binary_expression/binary_expression">infoToCheck.value == info.value &amp;&amp;
            infoToCheck.currentCommittedPeriod == info.currentCommittedPeriod &amp;&amp;
            infoToCheck.nextCommittedPeriod == info.nextCommittedPeriod &amp;&amp;
            infoToCheck.flags == info.flags &amp;&amp;
            infoToCheck.<span class="marker" id="mapping-357"></span><span class="token upd" id="move-src-223" data-title="member_expression/identifier"><span class="cupd">l</span><span class="cupd">o</span>ckReS<span class="cupd">t</span>ak<span class="cupd">e</span>Until<span class="cupd">Period</span></span> == <span class="marker" id="mapping-358"></span><span class="token del" data-title="binary_expression/member_expression">info.lockReStakeUntilPeriod</span> &amp;&amp;
            infoToCheck.<span class="marker" id="mapping-359"></span><span class="token upd" id="move-src-224" data-title="member_expression/identifier">lastC<span class="cupd">om</span>mi<span class="cupd">t</span>t<span class="cupd">ed</span>Period</span> == <span class="marker" id="mapping-360"></span><span class="token mv" id="move-src-225" data-title="binary_expression/member_expression">info.lastCommittedPeriod</span> &amp;&amp;
            infoToCheck.<span class="marker" id="mapping-361"></span><span class="token upd" id="move-src-226" data-title="member_expression/identifier">c<span class="cupd">o</span>mpl<span class="cupd">e</span>tedWork</span> == <span class="marker" id="mapping-362"></span><span class="token mv" id="move-src-227" data-title="binary_expression/member_expression">info.completedWork</span> &amp;&amp;
            infoToCheck.<span class="marker" id="mapping-363"></span><span class="token upd" id="move-src-228" data-title="member_expression/identifier"><span class="cupd">worker</span></span> == <span class="marker" id="mapping-364"></span><span class="token mv" id="move-src-229" data-title="binary_expression/member_expression">info.worker</span></span> &amp;&amp;
            infoToCheck</span>.workerStartPeriod</span> == <span class="marker" id="mapping-365"></span><span class="token mv" id="move-src-230" data-title="binary_expression/member_expression">info.workerStartPeriod</span></span>);

        require(delegateGet(_testTarget, this.getPastDowntimeLength.selector, staker) ==
            info.pastDowntime.length);
        for (uint256 i = 0; i &lt; info.pastDowntime.length &amp;&amp; i &lt; MAX_CHECKED_VALUES; i++) {
            Downtime storage downtime = info.pastDowntime[i];
            Downtime memory downtimeToCheck = delegateGetPastDowntime(_testTarget, staker, i);
            require(downtimeToCheck.startPeriod == downtime.startPeriod &amp;&amp;
                downtimeToCheck.endPeriod == downtime.endPeriod);
        }

        require(delegateGet(_testTarget, this.getSubStakesLength.selector, staker) == info.subStakes.length);
        for (uint256 i = 0; i &lt; info.subStakes.length &amp;&amp; i &lt; MAX_CHECKED_VALUES; i++) {
            SubStakeInfo storage subStakeInfo = info.subStakes[i];
            SubStakeInfo memory subStakeInfoToCheck = delegateGetSubStakeInfo(_testTarget, staker, i);
            require(subStakeInfoToCheck.firstPeriod == subStakeInfo.firstPeriod &amp;&amp;
                subStakeInfoToCheck.lastPeriod == subStakeInfo.lastPeriod &amp;&amp;
                subStakeInfoToCheck.<span class="marker" id="mapping-366"></span><span class="token upd" id="move-src-231" data-title="member_expression/identifier">pe<span class="cupd">r</span><span class="cupd">io</span>ds</span> == subStakeInfo.<span class="marker" id="mapping-367"></span><span class="token upd" id="move-src-232" data-title="member_expression/identifier">pe<span class="cupd">r</span><span class="cupd">io</span>ds</span> &amp;&amp;
                subStakeInfoToCheck.lockedValue == subStakeInfo.lockedValue);
        }

        // it's not perfect because checks not only slot value but also decoding
        // at least without additional functions
        require(delegateGet(_testTarget, this.totalStakedForAt.selector, staker, bytes32(block.number)) ==
            totalStakedForAt(stakerAddress, block.number));
        require(delegateGet(_testTarget, this.totalStakedAt.selector, bytes32(block.number)) ==
            totalStakedAt(block.number));

        if (info.worker != address(0)) {
            require(address(delegateGet(_testTarget, this.stakerFromWorker.selector, bytes32(uint256(info.worker)))) ==
                stakerFromWorker[info.worker]);
        }
    }

    /// @dev the `onlyWhileUpgrading` modifier works through a call to the parent `finishUpgrade`
    function finishUpgrade(address _target) public override virtual {
        super.finishUpgrade(_target);
        // Create fake period
        <span class="marker" id="mapping-368"></span><span class="token upd" id="move-src-233" data-title="array_access/identifier"><span class="cupd">lockedPerPeriod</span></span>[RESERVED_PERIOD] = 111;

        // Create fake worker
        stakerFromWorker[address(0)] = address(this);
    }
}
</pre></div><div class="col-6"><h5>StakingEscrow.sol</h5><pre class="pre-scrollable">// SPDX-License-Identifier: AGPL-3.0-or-later

pragma solidity ^0.7.0;


import "IERC900History.sol";
import "Issuer.sol";
import "Bits.sol";
import "Snapshot.sol";
import "SafeMath.sol";
import "SafeERC20.sol";


/**
* @notice PolicyManager interface
*/
interface PolicyManagerInterface {
    <span class="marker" id="mapping-369"></span><span class="token add" data-title="contract_body/function_definition">function secondsPerPeriod() <span class="marker" id="mapping-370"></span><span class="token mv" id="move-dst-52" data-title="function_definition/visibility">external</span> <span class="marker" id="mapping-371"></span><span class="token mv" id="move-dst-2" data-title="function_definition/state_mutability">view</span> <span class="marker" id="mapping-372"></span><span class="token add" data-title="function_definition/return_type_definition">returns (uint32)</span>;</span>
    function register(address _node, uint16 _period) external;
    function <span class="marker" id="mapping-373"></span><span class="token upd" id="move-dst-1" data-title="function_definition/identifier">migrate</span>(<span class="marker" id="mapping-374"></span><span class="token mv" id="move-dst-3" data-title="function_definition/parameter">address <span class="marker" id="mapping-375"></span><span class="token add" data-title="parameter/identifier">_node</span></span>) external;
    function ping(
        address _node,
        uint16 _processedPeriod1,
        uint16 _processedPeriod2,
        uint16 _periodToSetDefault
    ) external;
}


/**
* @notice Adjudicator interface
*/
interface AdjudicatorInterface {
    function <span class="marker" id="mapping-376"></span><span class="token upd" id="move-dst-4" data-title="function_definition/identifier">r<span class="cupd">e</span>wa<span class="cupd">r</span>dCoefficient</span>() external view returns (<span class="marker" id="mapping-377"></span><span class="token add" data-title="primitive_type/uint32">uint32</span>);
}


/**
* @notice WorkLock interface
*/
interface WorkLockInterface {
    function <span class="marker" id="mapping-378"></span><span class="token upd" id="move-dst-5" data-title="function_definition/identifier">token</span>() external view returns (<span class="marker" id="mapping-379"></span><span class="token add" data-title="parameter/type_name">NuCypherToken</span>);
}

<span class="marker" id="mapping-380"></span><span class="token upd" id="move-dst-7" data-title="source_file/comment"><span class="cupd">/**
* @</span><span class="cupd">ti</span>tl<span class="cupd">e </span>S<span class="cupd">t</span><span class="cupd">a</span>kingEs<span class="cupd">c</span>rowS<span class="cupd">t</span>ub<span class="cupd">
</span>*<span class="cupd"> </span>@<span class="cupd">n</span><span class="cupd">o</span>ti<span class="cupd">c</span>e Stub i<span class="cupd">s </span>u<span class="cupd">s</span><span class="cupd">e</span>d<span class="cupd"> to</span> d<span class="cupd">e</span>ploy<span class="cupd"> </span>m<span class="cupd">a</span>in<span class="cupd"> </span>S<span class="cupd">tak</span>ingEsc<span class="cupd">r</span>ow<span class="cupd"> </span><span class="cupd">a</span>f<span class="cupd">t</span>er<span class="cupd"> </span>a<span class="cupd">l</span>l <span class="cupd">o</span><span class="cupd">the</span><span class="cupd">r </span>c<span class="cupd">o</span><span class="cupd">n</span>tract<span class="cupd"> </span>and<span class="cupd"> </span>mak<span class="cupd">e</span><span class="cupd"> some </span>variabl<span class="cupd">e</span><span class="cupd">s</span> immut<span class="cupd">a</span>ble<span class="cupd">
* @dev |v</span>1<span class="cupd">.</span>0<span class="cupd">.</span>0<span class="cupd">|
*/</span></span>
<span class="marker" id="mapping-381"></span><span class="token add" data-title="source_file/contract_declaration">contract StakingEscrowStub is <span class="marker" id="mapping-382"></span><span class="token add" data-title="contract_declaration/inheritance_specifier">Upgradeable</span> <span class="marker" id="mapping-383"></span><span class="token add" data-title="contract_declaration/contract_body">{
    <span class="marker" id="mapping-384"></span><span class="token add" data-title="contract_body/using_directive">using AdditionalMath for uint32;</span>

    <span class="marker" id="mapping-385"></span><span class="token add" data-title="contract_body/state_variable_declaration">NuCypherToken public immutable token;</span>
    <span class="marker" id="mapping-386"></span><span class="token add" data-title="contract_body/state_variable_declaration"><span class="marker" id="mapping-387"></span><span class="token add" data-title="state_variable_declaration/type_name">uint32</span> <span class="marker" id="mapping-388"></span><span class="token mv" id="move-dst-18" data-title="state_variable_declaration/visibility">public</span> immutable genesisSecondsPerPeriod;</span>
    <span class="marker" id="mapping-389"></span><span class="token mv" id="move-dst-16" data-title="contract_body/state_variable_declaration"><span class="marker" id="mapping-390"></span><span class="token add" data-title="primitive_type/uint32">uint32</span> public immutable <span class="marker" id="mapping-391"></span><span class="token upd" id="move-dst-17" data-title="state_variable_declaration/identifier"><span class="cupd">s</span><span class="cupd">e</span>c<span class="cupd">on</span>dsPerPeriod</span>;</span>
    <span class="marker" id="mapping-392"></span><span class="token add" data-title="contract_body/state_variable_declaration">uint16 public immutable minLockedPeriods;</span>
    <span class="marker" id="mapping-393"></span><span class="token add" data-title="contract_body/state_variable_declaration">uint256 public immutable minAllowableLockedTokens;</span>
    <span class="marker" id="mapping-394"></span><span class="token add" data-title="contract_body/state_variable_declaration">uint256 public immutable maxAllowableLockedTokens;</span>

    /**
    * @notice Predefines some variables for use when deploying other contracts
    * @param _token Token contract
    * @param _genesisHoursPerPeriod Size of period in hours at genesis
    * @param _hoursPerPeriod Size of period in hours
    * @param _minLockedPeriods Min amount of periods during which tokens can be locked
    * @param _minAllowableLockedTokens Min amount of tokens that can be locked
    * @param _maxAllowableLockedTokens Max amount of tokens that can be locked
    */
    <span class="marker" id="mapping-395"></span><span class="token add" data-title="contract_body/constructor_definition">constructor(
        NuCypherToken _token,
        uint32 _genesisHoursPerPeriod,
        uint32 _hoursPerPeriod,
        uint16 _minLockedPeriods,
        uint256 _minAllowableLockedTokens,
        uint256 _maxAllowableLockedTokens
    ) {
        require(_token.totalSupply() &gt; 0 &amp;&amp;
            _hoursPerPeriod != 0 &amp;&amp;
            _genesisHoursPerPeriod != 0 &amp;&amp;
            _genesisHoursPerPeriod &lt;= _hoursPerPeriod &amp;&amp;
            _minLockedPeriods &gt; 1 &amp;&amp;
            _maxAllowableLockedTokens != 0);

        token = _token;
        secondsPerPeriod = _hoursPerPeriod.mul32(1 hours);
        genesisSecondsPerPeriod = _genesisHoursPerPeriod.mul32(1 hours);
        minLockedPeriods = _minLockedPeriods;
        minAllowableLockedTokens = _minAllowableLockedTokens;
        maxAllowableLockedTokens = _maxAllowableLockedTokens;
    }</span>

    /// @dev the `onlyWhileUpgrading` modifier works through a call to the parent `verifyState`
    <span class="marker" id="mapping-396"></span><span class="token add" data-title="contract_body/function_definition">function verifyState(<span class="marker" id="mapping-397"></span><span class="token add" data-title="function_definition/parameter">address _testTarget</span>) <span class="marker" id="mapping-398"></span><span class="token add" data-title="function_definition/visibility">public</span> <span class="marker" id="mapping-399"></span><span class="token add" data-title="function_definition/override_specifier">override</span> virtual <span class="marker" id="mapping-400"></span><span class="token add" data-title="function_definition/function_body">{
        <span class="marker" id="mapping-401"></span><span class="token add" data-title="function_body/expression_statement">super.verifyState(_testTarget);</span>

        // we have to use real values even though this is a stub
        <span class="marker" id="mapping-402"></span><span class="token mv" id="move-dst-53" data-title="function_body/expression_statement">require(<span class="marker" id="mapping-403"></span><span class="token add" data-title="binary_expression/type_cast_expression"><span class="marker" id="mapping-404"></span><span class="token mv" id="move-dst-218" data-title="type_cast_expression/primitive_type">address</span>(<span class="marker" id="mapping-405"></span><span class="token add" data-title="type_cast_expression/call_argument"><span class="marker" id="mapping-406"></span><span class="token add" data-title="call_argument/call_expression">delegateGet(<span class="marker" id="mapping-407"></span><span class="token mv" id="move-dst-219" data-title="call_expression/call_argument">_testTarget</span>, <span class="marker" id="mapping-408"></span><span class="token add" data-title="call_expression/call_argument">this.token.selector</span>)</span></span>)</span> == address(<span class="marker" id="mapping-409"></span><span class="token upd" id="move-dst-54" data-title="call_argument/identifier">token</span>));</span>
        // TODO uncomment after merging this PR #2579
//        require(uint32(delegateGet(_testTarget, this.genesisSecondsPerPeriod.selector)) == genesisSecondsPerPeriod);
        <span class="marker" id="mapping-410"></span><span class="token add" data-title="function_body/expression_statement"><span class="marker" id="mapping-411"></span><span class="token add" data-title="expression_statement/call_expression">require(<span class="marker" id="mapping-412"></span><span class="token add" data-title="call_expression/call_argument"><span class="marker" id="mapping-413"></span><span class="token add" data-title="call_argument/binary_expression"><span class="marker" id="mapping-414"></span><span class="token add" data-title="binary_expression/type_cast_expression"><span class="marker" id="mapping-415"></span><span class="token add" data-title="type_cast_expression/primitive_type">uint32</span>(<span class="marker" id="mapping-416"></span><span class="token add" data-title="type_cast_expression/call_argument"><span class="marker" id="mapping-417"></span><span class="token add" data-title="call_argument/call_expression">delegateGet(<span class="marker" id="mapping-418"></span><span class="token mv" id="move-dst-220" data-title="call_expression/call_argument">_testTarget</span>, <span class="marker" id="mapping-419"></span><span class="token add" data-title="call_expression/call_argument">this.secondsPerPeriod.selector</span>)</span></span>)</span> == secondsPerPeriod</span></span>)</span>;</span>
        <span class="marker" id="mapping-420"></span><span class="token add" data-title="function_body/expression_statement"><span class="marker" id="mapping-421"></span><span class="token add" data-title="expression_statement/call_expression">require(<span class="marker" id="mapping-422"></span><span class="token add" data-title="call_expression/call_argument"><span class="marker" id="mapping-423"></span><span class="token add" data-title="call_argument/binary_expression"><span class="marker" id="mapping-424"></span><span class="token add" data-title="binary_expression/type_cast_expression"><span class="marker" id="mapping-425"></span><span class="token add" data-title="type_cast_expression/primitive_type">uint16</span>(<span class="marker" id="mapping-426"></span><span class="token add" data-title="type_cast_expression/call_argument"><span class="marker" id="mapping-427"></span><span class="token add" data-title="call_argument/call_expression">delegateGet(<span class="marker" id="mapping-428"></span><span class="token mv" id="move-dst-217" data-title="call_expression/call_argument">_testTarget</span>, <span class="marker" id="mapping-429"></span><span class="token add" data-title="call_expression/call_argument">this.minLockedPeriods.selector</span>)</span></span>)</span> == minLockedPeriods</span></span>)</span>;</span>
        <span class="marker" id="mapping-430"></span><span class="token add" data-title="function_body/expression_statement">require(delegateGet(_testTarget, this.minAllowableLockedTokens.selector) == minAllowableLockedTokens);</span>
        <span class="marker" id="mapping-431"></span><span class="token add" data-title="function_body/expression_statement">require(delegateGet(_testTarget, this.maxAllowableLockedTokens.selector) == maxAllowableLockedTokens);</span>
    }</span></span>
}</span></span>


<span class="marker" id="mapping-432"></span><span class="token add" data-title="source_file/comment">/**
* @title StakingEscrow
* @notice Contract holds and locks stakers tokens.
* Each staker that locks their tokens will receive some compensation
* @dev |v5.7.1|
*/</span>
contract StakingEscrow is Issuer, IERC900History {

    using AdditionalMath for uint256;
    using AdditionalMath for uint16;
    using Bits for uint256;
    using SafeMath for uint256;
    using Snapshot for uint128[];
    using SafeERC20 for NuCypherToken;

    <span class="marker" id="mapping-433"></span><span class="token mv" id="move-dst-24" data-title="contract_body/comment"><span class="marker" id="mapping-434"></span><span class="token upd" id="move-dst-24" data-title="contract_body/comment"><span class="cupd">/**
    * @notice </span>S<span class="cupd">i</span><span class="cupd">g</span><span class="cupd">n</span><span class="cupd">a</span><span class="cupd">l</span><span class="cupd">s</span><span class="cupd"> </span><span class="cupd">t</span><span class="cupd">ha</span><span class="cupd">t</span><span class="cupd"> </span><span class="cupd">t</span><span class="cupd">o</span><span class="cupd">k</span><span class="cupd">e</span><span class="cupd">n</span><span class="cupd">s </span><span class="cupd">w</span><span class="cupd">e</span><span class="cupd">r</span><span class="cupd">e</span><span class="cupd"> </span><span class="cupd">d</span><span class="cupd">e</span><span class="cupd">p</span><span class="cupd">o</span><span class="cupd">s</span>i<span class="cupd">t</span><span class="cupd">e</span><span class="cupd">d</span><span class="cupd">
</span><span class="cupd"> </span><span class="cupd"> </span><span class="cupd">  </span><span class="cupd">* </span><span class="cupd">@param </span><span class="cupd">s</span><span class="cupd">t</span><span class="cupd">a</span><span class="cupd">ke</span><span class="cupd">r</span><span class="cupd"> </span>S<span class="cupd">t</span><span class="cupd">aker</span><span class="cupd"> </span><span class="cupd">a</span><span class="cupd">d</span><span class="cupd">d</span><span class="cupd">r</span><span class="cupd">e</span><span class="cupd">s</span><span class="cupd">s</span><span class="cupd">
</span><span class="cupd"> </span><span class="cupd">   </span><span class="cupd">* </span><span class="cupd">@param </span>v<span class="cupd">a</span>l<span class="cupd">u</span><span class="cupd">e</span><span class="cupd"> </span>A<span class="cupd">m</span><span class="cupd">o</span><span class="cupd">u</span><span class="cupd">n</span><span class="cupd">t</span><span class="cupd"> </span><span class="cupd">d</span><span class="cupd">e</span>po<span class="cupd">s</span><span class="cupd">i</span><span class="cupd">t</span><span class="cupd">e</span><span class="cupd">d</span><span class="cupd"> </span>(<span class="cupd">i</span><span class="cupd">n </span>N<span class="cupd">u</span>N<span class="cupd">i</span><span class="cupd">t</span><span class="cupd">s</span>)<span class="cupd">
    * @param </span><span class="cupd">per</span><span class="cupd">iod</span><span class="cupd">s</span><span class="cupd"> </span>N<span class="cupd">u</span><span class="cupd">m</span>b<span class="cupd">er</span><span class="cupd"> </span><span class="cupd">o</span><span class="cupd">f periods </span><span class="cupd">tokens </span><span class="cupd">w</span><span class="cupd">i</span><span class="cupd">l</span><span class="cupd">l</span><span class="cupd"> </span><span class="cupd">be locked
    *</span>/</span></span>
    event Deposited(address indexed staker, uint256 value, uint16 periods);

    <span class="marker" id="mapping-435"></span><span class="token mv" id="move-dst-48" data-title="contract_body/comment"><span class="marker" id="mapping-436"></span><span class="token upd" id="move-dst-48" data-title="contract_body/comment"><span class="cupd">/</span>**
    * @<span class="cupd">n</span>ot<span class="cupd">i</span>ce Signals <span class="cupd">t</span>hat tokens were stake locked
    * @param staker Staker address
    * @param value Amount locked (<span class="cupd">i</span>n NuNits)
    * @p<span class="cupd">a</span>ram firstPeriod Starting <span class="cupd">l</span>ock per<span class="cupd">i</span>od
    * @p<span class="cupd">a</span>ram periods Number of periods <span class="cupd">t</span>okens w<span class="cupd">i</span>ll be locked
    */</span></span>
    event Locked(address indexed staker, uint256 value, uint16 firstPeriod, uint16 periods);

    <span class="marker" id="mapping-437"></span><span class="token mv" id="move-dst-50" data-title="contract_body/comment"><span class="marker" id="mapping-438"></span><span class="token upd" id="move-dst-50" data-title="contract_body/comment"><span class="cupd">/**
    * @notice S</span>ignals that a sub-stak<span class="cupd">e</span> was divided
    * @param s<span class="cupd">t</span>aker<span class="cupd"> </span>Staker address
    * @<span class="cupd">p</span>aram <span class="cupd">ol</span>dValue Old sub-stake value (<span class="cupd">i</span>n<span class="cupd"> </span>NuNits)
    * @para<span class="cupd">m</span> l<span class="cupd">a</span>stPeriod Fi<span class="cupd">na</span>l lock<span class="cupd">e</span>d pe<span class="cupd">r</span>iod<span class="cupd"> </span>of old sub-st<span class="cupd">a</span>ke
    * @param newValue New sub-stake value (in NuNits)
    * @param perio<span class="cupd">d</span>s Numbe<span class="cupd">r</span> of p<span class="cupd">e</span>riod<span class="cupd">s</span> to extend <span class="cupd">s</span>ub-stake<span class="cupd">
    */</span></span></span>
    event Divided(
        address indexed staker,
        uint256 oldValue,
        uint16 lastPeriod,
        uint256 newValue,
        uint16 periods
    );

    <span class="marker" id="mapping-439"></span><span class="token mv" id="move-dst-57" data-title="contract_body/comment"><span class="marker" id="mapping-440"></span><span class="token upd" id="move-dst-57" data-title="contract_body/comment"><span class="cupd">/**
    * @notice S</span>ignals that two sub-stak<span class="cupd">e</span>s were merged
    * @param s<span class="cupd">t</span>aker<span class="cupd"> </span>St<span class="cupd">a</span>ker a<span class="cupd">d</span>dress
    * @param val<span class="cupd">u</span>e1 Value of f<span class="cupd">i</span>rst sub-stake (in NuNits)
    * @param value2 Value of se<span class="cupd">c</span>ond sub-st<span class="cupd">a</span>ke (in NuNi<span class="cupd">t</span>s)
    * @pa<span class="cupd">r</span>am<span class="cupd"> </span>l<span class="cupd">a</span>stPerio<span class="cupd">d</span> Final locke<span class="cupd">d</span> pe<span class="cupd">r</span>iod of m<span class="cupd">e</span>rged <span class="cupd">s</span>ub-<span class="cupd">s</span>take<span class="cupd">
    */</span></span></span>
    event Merged(address indexed staker, uint256 value1, uint256 value2, uint16 lastPeriod);

    <span class="marker" id="mapping-441"></span><span class="token mv" id="move-dst-61" data-title="contract_body/comment"><span class="marker" id="mapping-442"></span><span class="token upd" id="move-dst-61" data-title="contract_body/comment"><span class="cupd">/**
    * @notice S</span>ignals <span class="cupd">t</span>hat<span class="cupd"> </span>a sub-stake <span class="cupd">w</span>as pr<span class="cupd">o</span>longed
    * @pa<span class="cupd">r</span>am sta<span class="cupd">k</span>er Staker address
    * @param va<span class="cupd">l</span>ue Value <span class="cupd">o</span>f sub-sta<span class="cupd">k</span>e<span class="cupd">
</span>    * @p<span class="cupd">a</span>ram lastPerio<span class="cupd">d</span> Final locke<span class="cupd">d</span> pe<span class="cupd">r</span>iod of old sub-stak<span class="cupd">e</span>
    * @param period<span class="cupd">s</span> Number of period<span class="cupd">s </span>sub-stake<span class="cupd"> </span>was<span class="cupd"> </span>extended<span class="cupd">
 </span>   <span class="cupd">*/</span></span></span>
    event Prolonged(address indexed staker, uint256 value, uint16 lastPeriod, uint16 periods);

    <span class="marker" id="mapping-443"></span><span class="token mv" id="move-dst-71" data-title="contract_body/comment"><span class="marker" id="mapping-444"></span><span class="token upd" id="move-dst-71" data-title="contract_body/comment"><span class="cupd">/**
    * @notice </span>Signals<span class="cupd"> th</span><span class="cupd">a</span>t<span class="cupd"> </span><span class="cupd">tokens </span>we<span class="cupd">r</span><span class="cupd">e</span><span class="cupd"> </span>w<span class="cupd">i</span><span class="cupd">t</span><span class="cupd">h</span><span class="cupd">d</span><span class="cupd">r</span><span class="cupd">a</span>w<span class="cupd">n</span><span class="cupd"> </span>t<span class="cupd">o </span><span class="cupd">t</span>he<span class="cupd"> s</span><span class="cupd">t</span><span class="cupd">a</span>k<span class="cupd">e</span>r<span class="cupd">
</span><span class="cupd">    </span><span class="cupd">* @param </span><span class="cupd">staker Staker </span>address<span class="cupd">
   </span> <span class="cupd">* @param </span>valu<span class="cupd">e</span><span class="cupd"> Amount </span>w<span class="cupd">i</span><span class="cupd">th</span>dr<span class="cupd">a</span>ws<span class="cupd"> </span>(<span class="cupd">i</span>n<span class="cupd"> </span>N<span class="cupd">u</span>Ni<span class="cupd">t</span>s)<span class="cupd">
</span><span class="cupd">    </span><span class="cupd">*/</span></span></span>
    event Withdrawn(address indexed staker, uint256 value);

    <span class="marker" id="mapping-445"></span><span class="token mv" id="move-dst-77" data-title="contract_body/comment"><span class="marker" id="mapping-446"></span><span class="token upd" id="move-dst-77" data-title="contract_body/comment"><span class="cupd">/**
    * @notice </span>Signals<span class="cupd"> th</span><span class="cupd">a</span>t<span class="cupd"> </span>th<span class="cupd">e</span><span class="cupd"> </span>w<span class="cupd">o</span>r<span class="cupd">ke</span><span class="cupd">r a</span>sso<span class="cupd">c</span><span class="cupd">i</span><span class="cupd">a</span><span class="cupd">t</span><span class="cupd">e</span><span class="cupd">d</span><span class="cupd"> </span>w<span class="cupd">i</span>th<span class="cupd"> </span>th<span class="cupd">e</span><span class="cupd"> </span><span class="cupd">s</span><span class="cupd">taker</span><span class="cupd"> </span>m<span class="cupd">a</span><span class="cupd">d</span><span class="cupd">e</span><span class="cupd"> </span>a c<span class="cupd">o</span>mmi<span class="cupd">t</span>m<span class="cupd">en</span>t<span class="cupd"> </span>t<span class="cupd">o</span><span class="cupd"> </span><span class="cupd">n</span>ex<span class="cupd">t </span><span class="cupd">period</span><span class="cupd">
</span><span class="cupd"> </span><span class="cupd"> </span><span class="cupd"> </span><span class="cupd"> </span><span class="cupd">* @param </span><span class="cupd">sta</span>ke<span class="cupd">r</span><span class="cupd"> Sta</span>ke<span class="cupd">r</span><span class="cupd"> </span>a<span class="cupd">d</span>d<span class="cupd">r</span><span class="cupd">e</span><span class="cupd">s</span>s<span class="cupd">
</span><span class="cupd">    </span><span class="cupd">* @param </span>p<span class="cupd">er</span>iod<span class="cupd"> </span>P<span class="cupd">er</span>i<span class="cupd">o</span>d<span class="cupd"> </span>c<span class="cupd">o</span>mm<span class="cupd">i</span><span class="cupd">t</span><span class="cupd">t</span><span class="cupd">e</span>d<span class="cupd"> </span>to<span class="cupd">
</span><span class="cupd"> </span><span class="cupd"> </span><span class="cupd">  </span><span class="cupd">* @</span>pa<span class="cupd">r</span><span class="cupd">a</span><span class="cupd">m </span><span class="cupd">v</span><span class="cupd">a</span>l<span class="cupd">u</span><span class="cupd">e</span><span class="cupd"> A</span>m<span class="cupd">o</span>u<span class="cupd">n</span><span class="cupd">t</span><span class="cupd"> </span><span class="cupd">o</span>f<span class="cupd"> tokens</span><span class="cupd"> </span>s<span class="cupd">take</span><span class="cupd">d</span><span class="cupd"> </span>f<span class="cupd">or</span><span class="cupd"> </span><span class="cupd">t</span>h<span class="cupd">e</span><span class="cupd"> </span>c<span class="cupd">o</span>mmi<span class="cupd">t</span>t<span class="cupd">e</span>d<span class="cupd"> </span>p<span class="cupd">e</span><span class="cupd">r</span><span class="cupd">i</span><span class="cupd">o</span><span class="cupd">d</span><span class="cupd">
</span><span class="cupd"> </span><span class="cupd"> </span><span class="cupd"> </span><span class="cupd"> </span><span class="cupd">*/</span></span></span>
    event CommitmentMade(address indexed staker, uint16 indexed period, uint256 value);

    <span class="marker" id="mapping-447"></span><span class="token mv" id="move-dst-84" data-title="contract_body/comment"><span class="marker" id="mapping-448"></span><span class="token upd" id="move-dst-84" data-title="contract_body/comment"><span class="cupd">/**
    * @notice </span>Signals t<span class="cupd">h</span>at tok<span class="cupd">e</span>n<span class="cupd">s </span>were m<span class="cupd">i</span>nted <span class="cupd">f</span>or<span class="cupd"> </span>p<span class="cupd">re</span>vious p<span class="cupd">e</span>riods<span class="cupd">
</span>    * @<span class="cupd">param</span> stak<span class="cupd">e</span>r S<span class="cupd">t</span>ak<span class="cupd">er </span>addre<span class="cupd">s</span>s<span class="cupd">
</span>    * @p<span class="cupd">a</span>r<span class="cupd">a</span>m per<span class="cupd">i</span>od Pr<span class="cupd">e</span>vious<span class="cupd"> </span>peri<span class="cupd">o</span>d<span class="cupd"> </span>toke<span class="cupd">n</span>s m<span class="cupd">in</span>ted<span class="cupd"> </span>for<span class="cupd">
   </span> <span class="cupd">* @param </span>v<span class="cupd">a</span>lu<span class="cupd">e</span><span class="cupd"> </span>Amoun<span class="cupd">t</span> mint<span class="cupd">e</span>d<span class="cupd"> </span>(in<span class="cupd"> </span>NuNits)<span class="cupd">
  </span>  <span class="cupd">*/</span></span></span>
    event Minted(address indexed staker, uint16 indexed period, uint256 value);

    <span class="marker" id="mapping-449"></span><span class="token mv" id="move-dst-90" data-title="contract_body/comment"><span class="marker" id="mapping-450"></span><span class="token upd" id="move-dst-90" data-title="contract_body/comment"><span class="cupd">/**
    * @notice S</span>ignals<span class="cupd"> </span><span class="cupd">t</span>h<span class="cupd">a</span><span class="cupd">t</span><span class="cupd"> </span><span class="cupd">t</span><span class="cupd">he</span><span class="cupd"> </span><span class="cupd">stak</span>er<span class="cupd"> </span><span class="cupd">wa</span><span class="cupd">s </span>s<span class="cupd">l</span><span class="cupd">a</span>sh<span class="cupd">ed
</span>    * @param s<span class="cupd">t</span>a<span class="cupd">ke</span>r<span class="cupd"> </span>S<span class="cupd">take</span>r<span class="cupd"> </span>address<span class="cupd">
   </span> <span class="cupd">* </span>@param pe<span class="cupd">n</span>a<span class="cupd">l</span>t<span class="cupd">y </span>Slash<span class="cupd">i</span>ng<span class="cupd"> </span>penal<span class="cupd">t</span>y<span class="cupd">
</span>    * @<span class="cupd">param</span> inv<span class="cupd">e</span>s<span class="cupd">t</span>igato<span class="cupd">r </span>Invest<span class="cupd">i</span>gat<span class="cupd">o</span>r<span class="cupd"> </span>addr<span class="cupd">e</span>ss<span class="cupd">
    * @param </span><span class="cupd">re</span>w<span class="cupd">a</span>rd<span class="cupd"> Value </span>o<span class="cupd">f</span> <span class="cupd">r</span>eward<span class="cupd"> p</span><span class="cupd">r</span>ovid<span class="cupd">e</span>d <span class="cupd">t</span>o inv<span class="cupd">e</span>stigato<span class="cupd">r </span>(in<span class="cupd"> </span>NuNits)<span class="cupd">
  </span>  <span class="cupd">*/</span></span></span>
    event Slashed(address indexed staker, uint256 penalty, address indexed investigator, uint256 reward);

    <span class="marker" id="mapping-451"></span><span class="token mv" id="move-dst-92" data-title="contract_body/comment"><span class="marker" id="mapping-452"></span><span class="token upd" id="move-dst-92" data-title="contract_body/comment"><span class="cupd">/**
    * @notice </span>Signals<span class="cupd"> </span>that the <span class="cupd">re</span>s<span class="cupd">take</span><span class="cupd"> parameter</span><span class="cupd"> </span>was<span class="cupd"> </span>act<span class="cupd">i</span>va<span class="cupd">t</span>ed/deact<span class="cupd">i</span>vated<span class="cupd">
</span>    * @<span class="cupd">param</span> s<span class="cupd">t</span>ak<span class="cupd">er </span>S<span class="cupd">t</span>a<span class="cupd">ke</span>r a<span class="cupd">d</span>dress<span class="cupd">
    * @param </span>r<span class="cupd">eStake</span> <span class="cupd">U</span>pda<span class="cupd">t</span><span class="cupd">e</span><span class="cupd">d </span>p<span class="cupd">a</span>r<span class="cupd">a</span>m<span class="cupd">e</span><span class="cupd">t</span><span class="cupd">e</span>r<span class="cupd"> value
</span><span class="cupd"> </span><span class="cupd"> </span><span class="cupd">  </span><span class="cupd">*/</span></span></span>
    event ReStakeSet(address indexed staker, bool reStake);

    <span class="marker" id="mapping-453"></span><span class="token mv" id="move-dst-96" data-title="contract_body/comment"><span class="marker" id="mapping-454"></span><span class="token upd" id="move-dst-96" data-title="contract_body/comment"><span class="cupd">/**
    * @notice </span>Signal<span class="cupd">s</span> <span class="cupd">t</span>hat<span class="cupd"> </span>a w<span class="cupd">o</span>r<span class="cupd">ke</span>r wa<span class="cupd">s </span>b<span class="cupd">o</span>nded<span class="cupd"> </span>t<span class="cupd">o</span><span class="cupd"> </span><span class="cupd">t</span>he stake<span class="cupd">r</span><span class="cupd">
    * @param </span><span class="cupd">staker Staker address
    * @param </span>work<span class="cupd">e</span>r<span class="cupd"> </span>W<span class="cupd">o</span>r<span class="cupd">ke</span>r<span class="cupd"> </span>a<span class="cupd">d</span>dr<span class="cupd">e</span><span class="cupd">s</span>s<span class="cupd">
    * @param </span>startP<span class="cupd">eriod</span><span class="cupd"> </span>P<span class="cupd">eriod</span><span class="cupd"> </span>bon<span class="cupd">d</span><span class="cupd">ing </span><span class="cupd">o</span><span class="cupd">c</span>curr<span class="cupd">ed
    */</span></span></span>
    event WorkerBonded(address indexed staker, address indexed worker, uint16 indexed startPeriod);

    <span class="marker" id="mapping-455"></span><span class="token mv" id="move-dst-109" data-title="contract_body/comment"><span class="marker" id="mapping-456"></span><span class="token upd" id="move-dst-109" data-title="contract_body/comment"><span class="cupd">/**
    * @notice </span>Sign<span class="cupd">a</span>ls <span class="cupd">t</span><span class="cupd">h</span>at<span class="cupd"> </span>th<span class="cupd">e</span><span class="cupd"> </span><span class="cupd">w</span>in<span class="cupd">d</span>d<span class="cupd">o</span>w<span class="cupd">n</span><span class="cupd"> </span>p<span class="cupd">a</span>ram<span class="cupd">e</span><span class="cupd">t</span>e<span class="cupd">r </span>w<span class="cupd">a</span>s a<span class="cupd">c</span><span class="cupd">t</span>iv<span class="cupd">a</span>t<span class="cupd">e</span>d/de<span class="cupd">a</span>c<span class="cupd">t</span>iv<span class="cupd">a</span><span class="cupd">t</span><span class="cupd">e</span>d<span class="cupd">
    * @param </span>s<span class="cupd">take</span><span class="cupd">r </span>S<span class="cupd">take</span><span class="cupd">r </span><span class="cupd">a</span><span class="cupd">d</span><span class="cupd">d</span><span class="cupd">r</span>e<span class="cupd">s</span>s<span class="cupd">
    * @param </span>wi<span class="cupd">n</span>dD<span class="cupd">o</span>w<span class="cupd">n</span><span class="cupd"> </span>Up<span class="cupd">d</span><span class="cupd">a</span><span class="cupd">t</span><span class="cupd">e</span>d<span class="cupd"> </span><span class="cupd">param</span><span class="cupd">e</span><span class="cupd">t</span><span class="cupd">er</span><span class="cupd"> </span>val<span class="cupd">u</span><span class="cupd">e</span><span class="cupd">
</span><span class="cupd"> </span><span class="cupd"> </span><span class="cupd"> </span><span class="cupd"> </span><span class="cupd">*/</span></span></span>
    event WindDownSet(address indexed staker, bool windDown);

    <span class="marker" id="mapping-457"></span><span class="token mv" id="move-dst-130" data-title="contract_body/comment"><span class="marker" id="mapping-458"></span><span class="token upd" id="move-dst-130" data-title="contract_body/comment"><span class="cupd">/**
    * @notice </span>Signa<span class="cupd">l</span>s <span class="cupd">t</span>h<span class="cupd">at</span><span class="cupd"> </span><span class="cupd">the </span><span class="cupd">s</span><span class="cupd">n</span><span class="cupd">a</span>p<span class="cupd">s</span>ho<span class="cupd">t</span><span class="cupd"> </span>para<span class="cupd">met</span><span class="cupd">e</span><span class="cupd">r</span><span class="cupd"> </span>w<span class="cupd">a</span><span class="cupd">s</span><span class="cupd"> a</span>c<span class="cupd">t</span>iv<span class="cupd">at</span><span class="cupd">e</span>d/d<span class="cupd">e</span><span class="cupd">a</span>cti<span class="cupd">v</span>at<span class="cupd">ed
</span><span class="cupd"> </span><span class="cupd">   </span><span class="cupd">* @param </span>stake<span class="cupd">r</span><span class="cupd"> Staker </span><span class="cupd">a</span>dd<span class="cupd">r</span><span class="cupd">e</span><span class="cupd">s</span><span class="cupd">s</span><span class="cupd">
    * @param </span>s<span class="cupd">n</span>apsh<span class="cupd">o</span>tsE<span class="cupd">n</span><span class="cupd">a</span>bl<span class="cupd">e</span>d<span class="cupd"> </span>Upd<span class="cupd">a</span><span class="cupd">t</span>e<span class="cupd">d</span><span class="cupd"> </span><span class="cupd">param</span><span class="cupd">e</span><span class="cupd">t</span><span class="cupd">er</span><span class="cupd"> </span>val<span class="cupd">u</span><span class="cupd">e</span><span class="cupd">
</span><span class="cupd"> </span><span class="cupd"> </span><span class="cupd">  </span><span class="cupd">*/</span></span></span>
    event SnapshotSet(address indexed staker, bool snapshotsEnabled);

    <span class="marker" id="mapping-459"></span><span class="token mv" id="move-dst-132" data-title="contract_body/comment"><span class="marker" id="mapping-460"></span><span class="token upd" id="move-dst-132" data-title="contract_body/comment"><span class="cupd">/**
    * @notice </span>S<span class="cupd">i</span>g<span class="cupd">n</span>al<span class="cupd">s </span>th<span class="cupd">a</span>t<span class="cupd"> </span><span class="cupd">t</span>h<span class="cupd">e </span><span class="cupd">s</span><span class="cupd">take</span>r<span class="cupd"> </span>migrat<span class="cupd">e</span>d<span class="cupd"> th</span>e<span class="cupd">i</span>r <span class="cupd">s</span>take<span class="cupd"> </span><span class="cupd">t</span><span class="cupd">o</span><span class="cupd"> t</span>he<span class="cupd"> </span>n<span class="cupd">e</span>w<span class="cupd"> </span>p<span class="cupd">er</span>iod<span class="cupd"> </span>length<span class="cupd">
   </span> <span class="cupd">* @param </span><span class="cupd">staker Staker </span><span class="cupd">a</span>dd<span class="cupd">r</span><span class="cupd">e</span><span class="cupd">s</span><span class="cupd">s</span><span class="cupd">
    * @param </span><span class="cupd">period</span><span class="cupd"> </span>P<span class="cupd">eriod</span><span class="cupd"> </span>whe<span class="cupd">n</span><span class="cupd"> </span>m<span class="cupd">i</span>gra<span class="cupd">t</span>i<span class="cupd">o</span><span class="cupd">n</span><span class="cupd"> </span>happ<span class="cupd">e</span>n<span class="cupd">ed
    */</span></span></span>
    <span class="marker" id="mapping-461"></span><span class="token mv" id="move-dst-8" data-title="contract_body/event_definition">event <span class="marker" id="mapping-462"></span><span class="token upd" id="move-dst-9" data-title="event_definition/identifier">Migra<span class="cupd">t</span><span class="cupd">e</span>d</span>(address indexed staker, uint16 <span class="marker" id="mapping-463"></span><span class="token add" data-title="event_paramater/indexed">indexed</span> <span class="marker" id="mapping-464"></span><span class="token upd" id="move-dst-10" data-title="event_paramater/identifier">p<span class="cupd">eriod</span></span>);</span>

    <span class="marker" id="mapping-465"></span><span class="token mv" id="move-dst-141" data-title="contract_body/comment"><span class="marker" id="mapping-466"></span><span class="token upd" id="move-dst-141" data-title="contract_body/comment"><span class="cupd">/</span>//<span class="cupd"> </span><span class="cupd">i</span><span class="cupd">n</span><span class="cupd">t</span><span class="cupd">er</span><span class="cupd">n</span><span class="cupd">a</span><span class="cupd">l </span><span class="cupd">e</span><span class="cupd">v</span><span class="cupd">e</span><span class="cupd">nt</span></span></span>
    <span class="marker" id="mapping-467"></span><span class="token mv" id="move-dst-11" data-title="contract_body/event_definition">event WorkMeasurementSet(address indexed staker, bool measureWork);</span>

    struct SubStakeInfo {
        uint16 firstPeriod;
        uint16 lastPeriod;
        <span class="marker" id="mapping-468"></span><span class="token mv" id="move-dst-14" data-title="struct_declaration/struct_member">uint16 <span class="marker" id="mapping-469"></span><span class="token upd" id="move-dst-15" data-title="struct_member/identifier">un<span class="cupd">lock</span>ingDur<span class="cupd">a</span><span class="cupd">ti</span>on</span>;</span>
        uint128 lockedValue;
    }

    struct Downtime {
        uint16 startPeriod;
        uint16 endPeriod;
    }

    struct StakerInfo {
        uint256 value;
        /*
        * Stores periods that are committed but not yet rewarded.
        * In order to optimize storage, only two values are used instead of an array.
        * commitToNextPeriod() method invokes mint() method so there can only be two committed
        * periods that are not yet rewarded: the current and the next periods.
        */
        uint16 currentCommittedPeriod;
        uint16 nextCommittedPeriod;
        uint16 lastCommittedPeriod;
        <span class="marker" id="mapping-470"></span><span class="token mv" id="move-dst-12" data-title="struct_declaration/struct_member">uint16 <span class="marker" id="mapping-471"></span><span class="token upd" id="move-dst-13" data-title="struct_member/identifier">stub1</span>;</span> <span class="marker" id="mapping-472"></span><span class="token add" data-title="struct_declaration/comment">// former slot for lockReStakeUntilPeriod</span>
        uint256 completedWork;
        uint16 workerStartPeriod; // period when worker was bonded
        address worker;
        uint256 flags; // uint256 to acquire whole slot and minimize operations on it

        uint256 reservedSlot1;
        uint256 reservedSlot2;
        uint256 reservedSlot3;
        uint256 reservedSlot4;
        uint256 reservedSlot5;

        Downtime[] pastDowntime;
        SubStakeInfo[] subStakes;
        uint128[] history;

    }

    // used only for upgrading
    uint16 internal constant RESERVED_PERIOD = 0;
    uint16 internal constant MAX_CHECKED_VALUES = 5;
    // to prevent high gas consumption in loops for slashing
    uint16 public constant MAX_SUB_STAKES = 30;
    uint16 internal constant MAX_UINT16 = 65535;

    // indices for flags
    uint8 internal constant RE_STAKE_DISABLED_INDEX = 0;
    uint8 internal constant WIND_DOWN_INDEX = 1;
    uint8 internal constant MEASURE_WORK_INDEX = 2;
    uint8 internal constant SNAPSHOTS_DISABLED_INDEX = 3;
    <span class="marker" id="mapping-473"></span><span class="token add" data-title="contract_body/state_variable_declaration">uint8 internal constant MIGRATED_INDEX = 4;</span>

    uint16 public immutable minLockedPeriods;
    uint16 public immutable minWorkerPeriods;
    uint256 public immutable minAllowableLockedTokens;
    uint256 public immutable maxAllowableLockedTokens;

    <span class="marker" id="mapping-474"></span><span class="token mv" id="move-dst-20" data-title="contract_body/state_variable_declaration">PolicyManagerInterface public <span class="marker" id="mapping-475"></span><span class="token add" data-title="state_variable_declaration/immutable">immutable</span> policyManager;</span>
    <span class="marker" id="mapping-476"></span><span class="token mv" id="move-dst-21" data-title="contract_body/state_variable_declaration">AdjudicatorInterface public <span class="marker" id="mapping-477"></span><span class="token add" data-title="state_variable_declaration/immutable">immutable</span> adjudicator;</span>
    <span class="marker" id="mapping-478"></span><span class="token mv" id="move-dst-22" data-title="contract_body/state_variable_declaration">WorkLockInterface public <span class="marker" id="mapping-479"></span><span class="token add" data-title="state_variable_declaration/immutable">immutable</span> workLock;</span>

    mapping (address =&gt; StakerInfo) public stakerInfo;
    address[] public stakers;
    mapping (address =&gt; address) public stakerFromWorker;

    mapping (uint16 =&gt; uint256) <span class="marker" id="mapping-480"></span><span class="token upd" id="move-dst-19" data-title="state_variable_declaration/identifier">stub4</span>; <span class="marker" id="mapping-481"></span><span class="token mv" id="move-dst-148" data-title="contract_body/comment"><span class="marker" id="mapping-482"></span><span class="token upd" id="move-dst-148" data-title="contract_body/comment"><span class="cupd">/</span>/<span class="cupd"> </span>f<span class="cupd">o</span>r<span class="cupd">me</span>r<span class="cupd"> </span><span class="cupd">s</span><span class="cupd">l</span><span class="cupd">o</span><span class="cupd">t </span><span class="cupd">f</span><span class="cupd">o</span>r<span class="cupd"> </span><span class="cupd">l</span><span class="cupd">ocked</span>P<span class="cupd">er</span>P<span class="cupd">eriod</span></span></span>
    uint128[] public balanceHistory;

    <span class="marker" id="mapping-483"></span><span class="token add" data-title="contract_body/state_variable_declaration"><span class="marker" id="mapping-484"></span><span class="token mv" id="move-dst-110" data-title="state_variable_declaration/type_name">address</span> stub1;</span> <span class="marker" id="mapping-485"></span><span class="token mv" id="move-dst-161" data-title="contract_body/comment"><span class="marker" id="mapping-486"></span><span class="token upd" id="move-dst-161" data-title="contract_body/comment"><span class="cupd">/</span>/<span class="cupd"> </span>f<span class="cupd">o</span>r<span class="cupd">me</span><span class="cupd">r </span><span class="cupd">s</span>l<span class="cupd">o</span><span class="cupd">t</span><span class="cupd"> </span><span class="cupd">for </span>P<span class="cupd">o</span><span class="cupd">l</span><span class="cupd">ic</span>yM<span class="cupd">a</span>n<span class="cupd">a</span>g<span class="cupd">er</span></span></span>
    <span class="marker" id="mapping-487"></span><span class="token add" data-title="contract_body/state_variable_declaration"><span class="marker" id="mapping-488"></span><span class="token mv" id="move-dst-118" data-title="state_variable_declaration/type_name">address</span> stub2;</span> <span class="marker" id="mapping-489"></span><span class="token mv" id="move-dst-168" data-title="contract_body/comment"><span class="marker" id="mapping-490"></span><span class="token upd" id="move-dst-168" data-title="contract_body/comment"><span class="cupd">/</span>/<span class="cupd"> </span><span class="cupd">fo</span><span class="cupd">r</span><span class="cupd">m</span><span class="cupd">e</span><span class="cupd">r</span><span class="cupd"> </span><span class="cupd">s</span><span class="cupd">l</span><span class="cupd">o</span><span class="cupd">t </span><span class="cupd">f</span><span class="cupd">o</span><span class="cupd">r</span><span class="cupd"> </span>A<span class="cupd">d</span>j<span class="cupd">u</span><span class="cupd">d</span><span class="cupd">i</span><span class="cupd">c</span>a<span class="cupd">to</span>r</span></span>
    <span class="marker" id="mapping-491"></span><span class="token add" data-title="contract_body/state_variable_declaration"><span class="marker" id="mapping-492"></span><span class="token mv" id="move-dst-6" data-title="state_variable_declaration/type_name">address</span> stub3;</span> <span class="marker" id="mapping-493"></span><span class="token mv" id="move-dst-173" data-title="contract_body/comment"><span class="marker" id="mapping-494"></span><span class="token upd" id="move-dst-173" data-title="contract_body/comment"><span class="cupd">/</span>/<span class="cupd"> </span><span class="cupd">f</span><span class="cupd">o</span><span class="cupd">r</span><span class="cupd">m</span><span class="cupd">er</span><span class="cupd"> </span><span class="cupd">s</span><span class="cupd">l</span><span class="cupd">o</span><span class="cupd">t </span><span class="cupd">f</span><span class="cupd">o</span><span class="cupd">r</span><span class="cupd"> </span>W<span class="cupd">o</span><span class="cupd">r</span><span class="cupd">k</span>L<span class="cupd">o</span><span class="cupd">ck</span></span></span>

    <span class="marker" id="mapping-495"></span><span class="token add" data-title="contract_body/state_variable_declaration">mapping (uint16 =&gt; uint256) _lockedPerPeriod;</span>
    <span class="marker" id="mapping-496"></span><span class="token mv" id="move-dst-180" data-title="contract_body/comment"><span class="marker" id="mapping-497"></span><span class="token upd" id="move-dst-180" data-title="contract_body/comment"><span class="cupd">/</span>/<span class="cupd"> </span><span class="cupd">o</span><span class="cupd">n</span>ly<span class="cupd"> t</span><span class="cupd">o </span>m<span class="cupd">a</span>ke<span class="cupd"> </span>ve<span class="cupd">r</span><span class="cupd">i</span><span class="cupd">f</span>yS<span class="cupd">t</span>a<span class="cupd">t</span><span class="cupd">e </span>f<span class="cupd">r</span>o<span class="cupd">m </span><span class="cupd">p</span><span class="cupd">r</span><span class="cupd">e</span>v<span class="cupd">io</span>u<span class="cupd">s </span>v<span class="cupd">er</span>s<span class="cupd">io</span>n<span class="cupd"> </span>w<span class="cupd">or</span>k,<span class="cupd"> </span><span class="cupd">te</span>mporary</span></span>
    <span class="marker" id="mapping-498"></span><span class="token mv" id="move-dst-188" data-title="contract_body/comment"><span class="marker" id="mapping-499"></span><span class="token upd" id="move-dst-188" data-title="contract_body/comment"><span class="cupd">/</span>/<span class="cupd"> </span>TODO<span class="cupd"> </span>r<span class="cupd">e</span>m<span class="cupd">o</span><span class="cupd">ve </span><span class="cupd">a</span><span class="cupd">f</span><span class="cupd">t</span><span class="cupd">e</span>r<span class="cupd"> </span><span class="cupd">u</span><span class="cupd">p</span>g<span class="cupd">ra</span><span class="cupd">d</span><span class="cupd">e</span> #2579</span></span>
    <span class="marker" id="mapping-500"></span><span class="token add" data-title="contract_body/function_definition">function lockedPerPeriod(<span class="marker" id="mapping-501"></span><span class="token mv" id="move-dst-72" data-title="function_definition/parameter">uint16 <span class="marker" id="mapping-502"></span><span class="token upd" id="move-dst-73" data-title="parameter/identifier"><span class="cupd">_period</span></span></span>) <span class="marker" id="mapping-503"></span><span class="token add" data-title="function_definition/visibility">public</span> <span class="marker" id="mapping-504"></span><span class="token mv" id="move-dst-87" data-title="function_definition/state_mutability">view</span> <span class="marker" id="mapping-505"></span><span class="token add" data-title="function_definition/return_type_definition">returns (<span class="marker" id="mapping-506"></span><span class="token mv" id="move-dst-111" data-title="return_type_definition/parameter"><span class="marker" id="mapping-507"></span><span class="token mv" id="move-dst-112" data-title="parameter/type_name">uint256</span></span>)</span> <span class="marker" id="mapping-508"></span><span class="token add" data-title="function_definition/function_body">{
        return _period != RESERVED_PERIOD ? _lockedPerPeriod[_period] : 111;
    }</span></span>

    <span class="marker" id="mapping-509"></span><span class="token add" data-title="contract_body/comment">/**
    * @notice Constructor sets address of token contract and coefficients for minting
    * @param _token Token contract
    * @param _policyManager Policy Manager contract
    * @param _adjudicator Adjudicator contract
    * @param _workLock WorkLock contract. Zero address if there is no WorkLock
    * @param _genesisHoursPerPeriod Size of period in hours at genesis
    * @param _hoursPerPeriod Size of period in hours
    * @param _issuanceDecayCoefficient (d) Coefficient which modifies the rate at which the maximum issuance decays,
    * only applicable to Phase 2. d = 365 * half-life / LOG2 where default half-life = 2.
    * See Equation 10 in Staking Protocol &amp; Economics paper
    * @param _lockDurationCoefficient1 (k1) Numerator of the coefficient which modifies the extent
    * to which a stake's lock duration affects the subsidy it receives. Affects stakers differently.
    * Applicable to Phase 1 and Phase 2. k1 = k2 * small_stake_multiplier where default small_stake_multiplier = 0.5.
    * See Equation 8 in Staking Protocol &amp; Economics paper.
    * @param _lockDurationCoefficient2 (k2) Denominator of the coefficient which modifies the extent
    * to which a stake's lock duration affects the subsidy it receives. Affects stakers differently.
    * Applicable to Phase 1 and Phase 2. k2 = maximum_rewarded_periods / (1 - small_stake_multiplier)
    * where default maximum_rewarded_periods = 365 and default small_stake_multiplier = 0.5.
    * See Equation 8 in Staking Protocol &amp; Economics paper.
    * @param _maximumRewardedPeriods (kmax) Number of periods beyond which a stake's lock duration
    * no longer increases the subsidy it receives. kmax = reward_saturation * 365 where default reward_saturation = 1.
    * See Equation 8 in Staking Protocol &amp; Economics paper.
    * @param _firstPhaseTotalSupply Total supply for the first phase
    * @param _firstPhaseMaxIssuance (Imax) Maximum number of new tokens minted per period during Phase 1.
    * See Equation 7 in Staking Protocol &amp; Economics paper.
    * @param _minLockedPeriods Min amount of periods during which tokens can be locked
    * @param _minAllowableLockedTokens Min amount of tokens that can be locked
    * @param _maxAllowableLockedTokens Max amount of tokens that can be locked
    * @param _minWorkerPeriods Min amount of periods while a worker can't be changed
    */</span>
    constructor(
        NuCypherToken _token,
        <span class="marker" id="mapping-510"></span><span class="token mv" id="move-dst-51" data-title="constructor_definition/parameter">PolicyManagerInterface _policyManager</span>,
        <span class="marker" id="mapping-511"></span><span class="token mv" id="move-dst-58" data-title="constructor_definition/parameter">AdjudicatorInterface _adjudicator</span>,
        <span class="marker" id="mapping-512"></span><span class="token mv" id="move-dst-62" data-title="constructor_definition/parameter">WorkLockInterface _workLock</span>,
        <span class="marker" id="mapping-513"></span><span class="token mv" id="move-dst-36" data-title="constructor_definition/parameter"><span class="marker" id="mapping-514"></span><span class="token add" data-title="primitive_type/uint32">uint32</span> <span class="marker" id="mapping-515"></span><span class="token upd" id="move-dst-37" data-title="parameter/identifier"><span class="cupd">_</span>genes<span class="cupd">is</span>HoursP<span class="cupd">e</span>rPeriod</span></span>,
        <span class="marker" id="mapping-516"></span><span class="token mv" id="move-dst-25" data-title="constructor_definition/parameter">uint32 _hoursPerPeriod</span>,
        <span class="marker" id="mapping-517"></span><span class="token mv" id="move-dst-26" data-title="constructor_definition/parameter">uint256 _issuanceDecayCoefficient</span>,
        <span class="marker" id="mapping-518"></span><span class="token mv" id="move-dst-27" data-title="constructor_definition/parameter">uint256 _lockDurationCoefficient1</span>,
        <span class="marker" id="mapping-519"></span><span class="token mv" id="move-dst-28" data-title="constructor_definition/parameter">uint256 _lockDurationCoefficient2</span>,
        <span class="marker" id="mapping-520"></span><span class="token mv" id="move-dst-29" data-title="constructor_definition/parameter">uint16 _maximumRewardedPeriods</span>,
        <span class="marker" id="mapping-521"></span><span class="token mv" id="move-dst-30" data-title="constructor_definition/parameter">uint256 _firstPhaseTotalSupply</span>,
        <span class="marker" id="mapping-522"></span><span class="token mv" id="move-dst-31" data-title="constructor_definition/parameter">uint256 _firstPhaseMaxIssuance</span>,
        <span class="marker" id="mapping-523"></span><span class="token mv" id="move-dst-32" data-title="constructor_definition/parameter">uint16 _minLockedPeriods</span><span class="marker" id="mapping-524"></span><span class="token add" data-title="constructor_definition/,">,</span>
        <span class="marker" id="mapping-525"></span><span class="token mv" id="move-dst-33" data-title="constructor_definition/parameter">uint256 _minAllowableLockedTokens</span><span class="marker" id="mapping-526"></span><span class="token add" data-title="constructor_definition/,">,</span>
        <span class="marker" id="mapping-527"></span><span class="token mv" id="move-dst-34" data-title="constructor_definition/parameter">uint256 _maxAllowableLockedTokens</span><span class="marker" id="mapping-528"></span><span class="token add" data-title="constructor_definition/,">,</span>
        <span class="marker" id="mapping-529"></span><span class="token mv" id="move-dst-35" data-title="constructor_definition/parameter">uint16 _minWorkerPeriods</span>
    )
        Issuer(
            _token,
            <span class="marker" id="mapping-530"></span><span class="token add" data-title="modifier_invocation/call_argument">_genesisHoursPerPeriod</span>,
            <span class="marker" id="mapping-531"></span><span class="token mv" id="move-dst-38" data-title="modifier_invocation/call_argument">_hoursPerPeriod</span>,
            <span class="marker" id="mapping-532"></span><span class="token mv" id="move-dst-39" data-title="modifier_invocation/call_argument">_issuanceDecayCoefficient</span>,
            <span class="marker" id="mapping-533"></span><span class="token mv" id="move-dst-40" data-title="modifier_invocation/call_argument">_lockDurationCoefficient1</span>,
            <span class="marker" id="mapping-534"></span><span class="token mv" id="move-dst-41" data-title="modifier_invocation/call_argument">_lockDurationCoefficient2</span>,
            <span class="marker" id="mapping-535"></span><span class="token mv" id="move-dst-42" data-title="modifier_invocation/call_argument">_maximumRewardedPeriods</span>,
            <span class="marker" id="mapping-536"></span><span class="token mv" id="move-dst-43" data-title="modifier_invocation/call_argument">_firstPhaseTotalSupply</span><span class="marker" id="mapping-537"></span><span class="token add" data-title="modifier_invocation/,">,</span>
            _firstPhaseMaxIssuance
        )
    {
        // constant `1` in the expression `_minLockedPeriods &gt; 1` uses to simplify the `lock` method
        require(_minLockedPeriods &gt; 1 &amp;&amp; _maxAllowableLockedTokens != 0);
        minLockedPeriods = _minLockedPeriods;
        minAllowableLockedTokens = _minAllowableLockedTokens;
        maxAllowableLockedTokens = _maxAllowableLockedTokens;
        minWorkerPeriods = _minWorkerPeriods;

        <span class="marker" id="mapping-538"></span><span class="token add" data-title="expression_statement/call_expression">require(<span class="marker" id="mapping-539"></span><span class="token mv" id="move-dst-64" data-title="call_expression/call_argument"><span class="marker" id="mapping-540"></span><span class="token add" data-title="call_argument/binary_expression"><span class="marker" id="mapping-541"></span><span class="token add" data-title="binary_expression/binary_expression">(_policyManager.secondsPerPeriod() == _hoursPerPeriod * (1 hours) ||
            _policyManager.secondsPerPeriod() == _genesisHoursPerPeriod * (1 hours)) &amp;&amp;
            _adjudicator.rewardCoefficient() != 0</span> &amp;&amp;
            <span class="marker" id="mapping-542"></span><span class="token add" data-title="binary_expression/parenthesized_expression">(<span class="marker" id="mapping-543"></span><span class="token add" data-title="parenthesized_expression/binary_expression"><span class="marker" id="mapping-544"></span><span class="token mv" id="move-dst-63" data-title="binary_expression/call_expression"><span class="marker" id="mapping-545"></span><span class="token add" data-title="call_expression/member_expression"><span class="marker" id="mapping-546"></span><span class="token mv" id="move-dst-65" data-title="member_expression/binary_expression">address(<span class="marker" id="mapping-547"></span><span class="token upd" id="move-dst-66" data-title="call_argument/identifier">_<span class="cupd">workLock</span></span>) == address(0) || <span class="marker" id="mapping-548"></span><span class="token upd" id="move-dst-67" data-title="binary_expression/identifier">_w<span class="cupd">o</span><span class="cupd">r</span>kLock</span></span>.token</span>()</span> == _token</span>)</span></span></span>)</span>;
        <span class="marker" id="mapping-549"></span><span class="token mv" id="move-dst-55" data-title="function_body/expression_statement">policyManager = _policyManager;</span>
        <span class="marker" id="mapping-550"></span><span class="token mv" id="move-dst-59" data-title="function_body/expression_statement">adjudicator = _adjudicator;</span>
        <span class="marker" id="mapping-551"></span><span class="token mv" id="move-dst-68" data-title="function_body/expression_statement">workLock = _workLock;</span>
    }

    /**
    * @dev Checks the existence of a staker in the contract
    */
    modifier onlyStaker()
    {
        StakerInfo storage info = stakerInfo[msg.sender];
        <span class="marker" id="mapping-552"></span><span class="token add" data-title="expression_statement/call_expression">require(<span class="marker" id="mapping-553"></span><span class="token mv" id="move-dst-45" data-title="call_expression/call_argument"><span class="marker" id="mapping-554"></span><span class="token mv" id="move-dst-44" data-title="call_argument/call_expression"><span class="marker" id="mapping-555"></span><span class="token add" data-title="call_expression/member_expression"><span class="marker" id="mapping-556"></span><span class="token add" data-title="member_expression/binary_expression"><span class="marker" id="mapping-557"></span><span class="token add" data-title="binary_expression/parenthesized_expression">(<span class="marker" id="mapping-558"></span><span class="token mv" id="move-dst-46" data-title="parenthesized_expression/binary_expression">info.value &gt; 0 || info.nextCommittedPeriod != 0</span>)</span> &amp;&amp;
            <span class="marker" id="mapping-559"></span><span class="token add" data-title="binary_expression/member_expression">info.flags</span></span>.bitSet</span>(<span class="marker" id="mapping-560"></span><span class="token add" data-title="call_expression/call_argument">MIGRATED_INDEX</span>)</span></span>)</span>;
        _;
    }

    //------------------------Main getters------------------------
    /**
    * @notice Get all tokens belonging to the staker
    */
    function getAllTokens(address _staker) external view returns (uint256) {
        return stakerInfo[_staker].value;
    }

    /**
    * @notice Get all flags for the staker
    */
    function getFlags(address _staker)
        external view returns (
            bool windDown,
            bool reStake,
            bool measureWork,
            bool snapshots<span class="marker" id="mapping-561"></span><span class="token add" data-title="return_type_definition/,">,</span>
            <span class="marker" id="mapping-562"></span><span class="token mv" id="move-dst-88" data-title="return_type_definition/parameter">bool <span class="marker" id="mapping-563"></span><span class="token add" data-title="parameter/identifier">migrated</span></span>
        )
    {
        StakerInfo storage info = stakerInfo[_staker];
        windDown = info.flags.bitSet(WIND_DOWN_INDEX);
        reStake = !info.flags.bitSet(RE_STAKE_DISABLED_INDEX);
        measureWork = info.flags.bitSet(MEASURE_WORK_INDEX);
        snapshots = !info.flags.bitSet(SNAPSHOTS_DISABLED_INDEX);
        <span class="marker" id="mapping-564"></span><span class="token add" data-title="function_body/expression_statement">migrated = info.flags.bitSet(MIGRATED_INDEX);</span>
    }

    /**
    * @notice Get the start period. Use in the calculation of the last period of the sub stake
    * @param _info Staker structure
    * @param _currentPeriod Current period
    */
    function getStartPeriod(StakerInfo storage _info, uint16 _currentPeriod)
        internal view returns (uint16)
    {
        // if the next period (after current) is committed
        if (_info.flags.bitSet(WIND_DOWN_INDEX) &amp;&amp; _info.nextCommittedPeriod &gt; _currentPeriod) {
            return _currentPeriod + 1;
        }
        return _currentPeriod;
    }

    /**
    * @notice Get the last period of the sub stake
    * @param _subStake Sub stake structure
    * @param _startPeriod Pre-calculated start period
    */
    function getLastPeriodOfSubStake(SubStakeInfo storage _subStake, uint16 _startPeriod)
        internal view returns (uint16)
    {
        if (_subStake.lastPeriod != 0) {
            return _subStake.lastPeriod;
        }
        uint32 lastPeriod = uint32(_startPeriod) + _subStake.<span class="marker" id="mapping-565"></span><span class="token upd" id="move-dst-69" data-title="member_expression/identifier">unlockingDu<span class="cupd">r</span>at<span class="cupd">io</span>n</span>;
        if (lastPeriod &gt; uint32(MAX_UINT16)) {
            return MAX_UINT16;
        }
        return uint16(lastPeriod);
    }

    /**
    * @notice Get the last period of the sub stake
    * @param _staker Staker
    * @param _index Stake index
    */
    function getLastPeriodOfSubStake(address _staker, uint256 _index)
        public view returns (uint16)
    {
        StakerInfo storage info = stakerInfo[_staker];
        SubStakeInfo storage subStake = info.subStakes[_index];
        uint16 startPeriod = getStartPeriod(info, getCurrentPeriod());
        return getLastPeriodOfSubStake(subStake, startPeriod);
    }


    /**
    * @notice Get the value of locked tokens for a staker in a specified period
    * @dev Information may be incorrect for rewarded or not committed surpassed period
    * @param _info Staker structure
    * @param _currentPeriod Current period
    * @param _period Next period
    */
    function getLockedTokens(StakerInfo storage _info, uint16 _currentPeriod, uint16 _period)
        internal view returns (uint256 lockedValue)
    {
        lockedValue = 0;
        uint16 startPeriod = getStartPeriod(_info, _currentPeriod);
        for (uint256 i = 0; i &lt; _info.subStakes.length; i++) {
            SubStakeInfo storage subStake = _info.subStakes[i];
            if (subStake.firstPeriod &lt;= _period &amp;&amp;
                getLastPeriodOfSubStake(subStake, startPeriod) &gt;= _period) {
                lockedValue += subStake.lockedValue;
            }
        }
    }

    <span class="marker" id="mapping-566"></span><span class="token add" data-title="contract_body/comment">/**
    * @notice Get the value of locked tokens for a staker in a future period
    * @dev This function is used by PreallocationEscrow so its signature can't be updated.
    * @param _staker Staker
    * @param _offsetPeriods Amount of periods that will be added to the current period
    */</span>
    function getLockedTokens(address _staker, <span class="marker" id="mapping-567"></span><span class="token mv" id="move-dst-97" data-title="function_definition/parameter">uint16 <span class="marker" id="mapping-568"></span><span class="token upd" id="move-dst-98" data-title="parameter/identifier"><span class="cupd">_</span>offs<span class="cupd">e</span>tPe<span class="cupd">riods</span></span></span>)
        external view returns (uint256 lockedValue)
    {
        StakerInfo storage info = stakerInfo[_staker];
        uint16 currentPeriod = getCurrentPeriod();
        <span class="marker" id="mapping-569"></span><span class="token mv" id="move-dst-81" data-title="function_body/variable_declaration_statement">uint16 nextPeriod = currentPeriod.add16(<span class="marker" id="mapping-570"></span><span class="token upd" id="move-dst-82" data-title="call_argument/identifier"><span class="cupd">_</span>offs<span class="cupd">e</span>tPe<span class="cupd">riods</span></span>);</span>
        return getLockedTokens(info, currentPeriod, nextPeriod);
    }

    /**
    * @notice Get the last committed staker's period
    * @param _staker Staker
    */
    function getLastCommittedPeriod(address _staker) public view returns (uint16) {
        StakerInfo storage info = stakerInfo[_staker];
        return info.nextCommittedPeriod != 0 ? info.nextCommittedPeriod : info.lastCommittedPeriod;
    }

    <span class="marker" id="mapping-571"></span><span class="token add" data-title="contract_body/comment">/**
    * @notice Get the value of locked tokens for active stakers in (getCurrentPeriod() + _offsetPeriods) period
    * as well as stakers and their locked tokens
    * @param _offsetPeriods Amount of periods for locked tokens calculation
    * @param _startIndex Start index for looking in stakers array
    * @param _maxStakers Max stakers for looking, if set 0 then all will be used
    * @return allLockedTokens Sum of locked tokens for active stakers
    * @return activeStakers Array of stakers and their locked tokens. Stakers addresses stored as uint256
    * @dev Note that activeStakers[0] in an array of uint256, but you want addresses. Careful when used directly!
    */</span>
    function getActiveStakers(<span class="marker" id="mapping-572"></span><span class="token mv" id="move-dst-93" data-title="function_definition/parameter">uint16 <span class="marker" id="mapping-573"></span><span class="token upd" id="move-dst-94" data-title="parameter/identifier"><span class="cupd">_</span><span class="cupd">o</span>ffs<span class="cupd">e</span><span class="cupd">t</span><span class="cupd">Period</span>s</span></span>, uint256 _startIndex, uint256 _maxStakers)
        external view returns (uint256 allLockedTokens, uint256[2][] memory activeStakers)
    {
        require(<span class="marker" id="mapping-574"></span><span class="token upd" id="move-dst-80" data-title="binary_expression/identifier"><span class="cupd">_</span>offs<span class="cupd">e</span>tPe<span class="cupd">riods</span></span> &gt; 0);

        uint256 endIndex = stakers.length;
        require(_startIndex &lt; endIndex);
        if (_maxStakers != 0 &amp;&amp; _startIndex + _maxStakers &lt; endIndex) {
            endIndex = _startIndex + _maxStakers;
        }
        activeStakers = new uint256[2][](endIndex - _startIndex);
        allLockedTokens = 0;

        uint256 resultIndex = 0;
        uint16 currentPeriod = getCurrentPeriod();
        <span class="marker" id="mapping-575"></span><span class="token mv" id="move-dst-74" data-title="function_body/variable_declaration_statement"><span class="marker" id="mapping-576"></span><span class="token mv" id="move-dst-115" data-title="variable_declaration_statement/variable_declaration">uint16 nextPeriod</span> = currentPeriod.add16(<span class="marker" id="mapping-577"></span><span class="token upd" id="move-dst-75" data-title="call_argument/identifier"><span class="cupd">_</span>offs<span class="cupd">e</span>tPe<span class="cupd">riods</span></span>);</span>

        for (uint256 i = _startIndex; i &lt; endIndex; i++) {
            address staker = stakers[i];
            StakerInfo storage info = stakerInfo[staker];
            if (info.currentCommittedPeriod != currentPeriod &amp;&amp;
                info.nextCommittedPeriod != currentPeriod) {
                continue;
            }
            uint256 lockedTokens = getLockedTokens(info, currentPeriod, nextPeriod);
            if (lockedTokens != 0) {
                activeStakers[resultIndex][0] = uint256(staker);
                activeStakers[resultIndex++][1] = lockedTokens;
                allLockedTokens += lockedTokens;
            }
        }
        assembly {
            mstore(activeStakers, resultIndex)
        }
    }

    /**
    * @notice Get worker using staker's address
    */
    function getWorkerFromStaker(address _staker) external view returns (address) {
        return stakerInfo[_staker].worker;
    }

    /**
    * @notice Get work that completed by the staker
    */
    function getCompletedWork(address _staker) external view returns (uint256) {
        return stakerInfo[_staker].completedWork;
    }

    /**
    * @notice Find index of downtime structure that includes specified period
    * @dev If specified period is outside all downtime periods, the length of the array will be returned
    * @param _staker Staker
    * @param _period Specified period number
    */
    function findIndexOfPastDowntime(address _staker, uint16 _period) external view returns (uint256 index) {
        StakerInfo storage info = stakerInfo[_staker];
        for (index = 0; index &lt; info.pastDowntime.length; index++) {
            if (_period &lt;= info.pastDowntime[index].endPeriod) {
                return index;
            }
        }
    }

    //------------------------Main methods------------------------
    /**
    * @notice Start or stop measuring the work of a staker
    * @param _staker Staker
    * @param _measureWork Value for `measureWork` parameter
    * @return Work that was previously done
    */
    function setWorkMeasurement(address _staker, bool _measureWork) external returns (uint256) {
        require(msg.sender == address(workLock));
        StakerInfo storage info = stakerInfo[_staker];
        if (info.flags.bitSet(MEASURE_WORK_INDEX) == _measureWork) {
            return info.completedWork;
        }
        info.flags = info.flags.toggleBit(MEASURE_WORK_INDEX);
        emit WorkMeasurementSet(_staker, _measureWork);
        return info.completedWork;
    }

    /**
    * @notice Bond worker
    * @param _worker Worker address. Must be a real address, not a contract
    */
    function bondWorker(address _worker) external onlyStaker {
        StakerInfo storage info = stakerInfo[msg.sender];
        // Specified worker is already bonded with this staker
        require(_worker != info.worker);
        uint16 currentPeriod = getCurrentPeriod();
        if (info.worker != address(0)) { // If this staker had a worker ...
            // Check that enough time has passed to change it
            require(currentPeriod &gt;= info.workerStartPeriod.add16(minWorkerPeriods));
            // Remove the old relation "worker-&gt;staker"
            stakerFromWorker[info.worker] = address(0);
        }

        if (_worker != address(0)) {
            // Specified worker is already in use
            require(stakerFromWorker[_worker] == address(0));
            // Specified worker is a staker
            require(stakerInfo[_worker].subStakes.length == 0 || _worker == msg.sender);
            // Set new worker-&gt;staker relation
            stakerFromWorker[_worker] = msg.sender;
        }

        // Bond new worker (or unbond if _worker == address(0))
        info.worker = _worker;
        info.workerStartPeriod = currentPeriod;
        emit WorkerBonded(msg.sender, _worker, currentPeriod);
    }

    <span class="marker" id="mapping-578"></span><span class="token add" data-title="contract_body/comment">/**
    * @notice Set `reStake` parameter. If true then all staking rewards will be added to locked stake
    * @param _reStake Value for parameter
    */</span>
    function setReStake(bool _reStake) external {
        StakerInfo storage info = stakerInfo[msg.sender];
        if (info.flags.bitSet(RE_STAKE_DISABLED_INDEX) == !_reStake) {
            return;
        }
        info.flags = info.flags.toggleBit(RE_STAKE_DISABLED_INDEX);
        emit ReStakeSet(msg.sender, _reStake);
    }

    <span class="marker" id="mapping-579"></span><span class="token add" data-title="contract_body/comment">/**
    * @notice Deposit tokens from WorkLock contract
    * @param _staker Staker address
    * @param _value Amount of tokens to deposit
    * @param _unlockingDuration Amount of periods during which tokens will be unlocked when wind down is enabled
    */</span>
    function depositFromWorkLock(
        address _staker,
        uint256 _value,
        <span class="marker" id="mapping-580"></span><span class="token mv" id="move-dst-135" data-title="function_definition/parameter">uint16 <span class="marker" id="mapping-581"></span><span class="token upd" id="move-dst-136" data-title="parameter/identifier"><span class="cupd">_</span>unlockingDu<span class="cupd">r</span>at<span class="cupd">io</span>n</span></span>
    )
        external
    {
        require(msg.sender == address(workLock));
        StakerInfo storage info = stakerInfo[_staker];
        if (!info.flags.bitSet(WIND_DOWN_INDEX) &amp;&amp; info.subStakes.length == 0) {
            info.flags = info.flags.toggleBit(WIND_DOWN_INDEX);
            emit WindDownSet(_staker, true);
        }
        <span class="marker" id="mapping-582"></span><span class="token add" data-title="function_body/comment">// WorkLock still uses the genesis period length (24h)</span>
        <span class="marker" id="mapping-583"></span><span class="token add" data-title="function_body/expression_statement">_unlockingDuration = recalculatePeriod(_unlockingDuration);</span>
        <span class="marker" id="mapping-584"></span><span class="token mv" id="move-dst-138" data-title="function_body/expression_statement">deposit(_staker, msg.sender, MAX_SUB_STAKES, _value, <span class="marker" id="mapping-585"></span><span class="token upd" id="move-dst-139" data-title="call_argument/identifier"><span class="cupd">_</span>unlockingDu<span class="cupd">r</span>at<span class="cupd">io</span>n</span>);</span>
    }

    /**
    * @notice Set `windDown` parameter.
    * If true then stake's duration will be decreasing in each period with `commitToNextPeriod()`
    * @param _windDown Value for parameter
    */
    function setWindDown(bool _windDown) external {
        StakerInfo storage info = stakerInfo[msg.sender];
        if (info.flags.bitSet(WIND_DOWN_INDEX) == _windDown) {
            return;
        }
        info.flags = info.flags.toggleBit(WIND_DOWN_INDEX);
        emit WindDownSet(msg.sender, _windDown);

        // duration adjustment if next period is committed
        uint16 nextPeriod = getCurrentPeriod() + 1;
        if (info.nextCommittedPeriod != nextPeriod) {
           return;
        }

        // adjust sub-stakes duration for the new value of winding down parameter
        for (uint256 index = 0; index &lt; info.subStakes.length; index++) {
            SubStakeInfo storage subStake = info.subStakes[index];
            // sub-stake does not have fixed last period when winding down is disabled
            if (!_windDown &amp;&amp; subStake.lastPeriod == nextPeriod) {
                subStake.lastPeriod = 0;
                subStake.<span class="marker" id="mapping-586"></span><span class="token upd" id="move-dst-102" data-title="member_expression/identifier">unlockingDu<span class="cupd">r</span>at<span class="cupd">io</span>n</span> = 1;
                continue;
            }
            // this sub-stake is no longer affected by winding down parameter
            if (subStake.lastPeriod != 0 || subStake.<span class="marker" id="mapping-587"></span><span class="token upd" id="move-dst-103" data-title="member_expression/identifier">unlockingDu<span class="cupd">r</span>at<span class="cupd">io</span>n</span> == 0) {
                continue;
            }

            subStake.<span class="marker" id="mapping-588"></span><span class="token upd" id="move-dst-104" data-title="member_expression/identifier">unlockingDu<span class="cupd">r</span>at<span class="cupd">io</span>n</span> = _windDown ? subStake.<span class="marker" id="mapping-589"></span><span class="token upd" id="move-dst-105" data-title="member_expression/identifier">unlockingDu<span class="cupd">r</span>at<span class="cupd">io</span>n</span> - 1 : subStake.<span class="marker" id="mapping-590"></span><span class="token upd" id="move-dst-106" data-title="member_expression/identifier">unlockingDu<span class="cupd">r</span>at<span class="cupd">io</span>n</span> + 1;
            if (subStake.<span class="marker" id="mapping-591"></span><span class="token upd" id="move-dst-107" data-title="member_expression/identifier">unlockingDu<span class="cupd">r</span>at<span class="cupd">io</span>n</span> == 0) {
                subStake.lastPeriod = nextPeriod;
            }
        }
    }

    /**
    * @notice Activate/deactivate taking snapshots of balances
    * @param _enableSnapshots True to activate snapshots, False to deactivate
    */
    function setSnapshots(bool _enableSnapshots) external {
        StakerInfo storage info = stakerInfo[msg.sender];
        if (info.flags.bitSet(SNAPSHOTS_DISABLED_INDEX) == !_enableSnapshots) {
            return;
        }

        uint256 lastGlobalBalance = uint256(balanceHistory.lastValue());
        if(_enableSnapshots){
            info.history.addSnapshot(info.value);
            balanceHistory.addSnapshot(lastGlobalBalance + info.value);
        } else {
            info.history.addSnapshot(0);
            balanceHistory.addSnapshot(lastGlobalBalance - info.value);
        }
        info.flags = info.flags.toggleBit(SNAPSHOTS_DISABLED_INDEX);

        emit SnapshotSet(msg.sender, _enableSnapshots);
    }

    /**
    * @notice Adds a new snapshot to both the staker and global balance histories,
    * assuming the staker's balance was already changed
    * @param _info Reference to affected staker's struct
    * @param _addition Variance in balance. It can be positive or negative.
    */
    function addSnapshot(StakerInfo storage _info, int256 _addition) internal {
        if(!_info.flags.bitSet(SNAPSHOTS_DISABLED_INDEX)){
            _info.history.addSnapshot(_info.value);
            uint256 lastGlobalBalance = uint256(balanceHistory.lastValue());
            balanceHistory.addSnapshot(lastGlobalBalance.addSigned(_addition));
        }
    }

    <span class="marker" id="mapping-592"></span><span class="token add" data-title="contract_body/comment">/**
    * @notice Implementation of the receiveApproval(address,uint256,address,bytes) method
    * (see NuCypherToken contract). Deposit all tokens that were approved to transfer
    * @param _from Staker
    * @param _value Amount of tokens to deposit
    * @param _tokenContract Token contract address
    * @notice (param _extraData) Amount of periods during which tokens will be unlocked when wind down is enabled
    */</span>
    function receiveApproval(
        address _from,
        uint256 _value,
        address _tokenContract,
        bytes calldata /* _extraData */
    )
        external
    {
        require(_tokenContract == address(token) &amp;&amp; msg.sender == address(token));

        // Copy first 32 bytes from _extraData, according to calldata memory layout:
        //
        // 0x00: method signature      4 bytes
        // 0x04: _from                 32 bytes after encoding
        // 0x24: _value                32 bytes after encoding
        // 0x44: _tokenContract        32 bytes after encoding
        // 0x64: _extraData pointer    32 bytes. Value must be 0x80 (offset of _extraData wrt to 1st parameter)
        // 0x84: _extraData length     32 bytes
        // 0xA4: _extraData data       Length determined by previous variable
        //
        // See https://solidity.readthedocs.io/en/latest/abi-spec.html#examples

        uint256 payloadSize;
        uint256 payload;
        assembly {
            payloadSize := calldataload(0x84)
            payload := calldataload(0xA4)
        }
        payload = payload &gt;&gt; 8*(32 - payloadSize);
        deposit(_from, _from, MAX_SUB_STAKES, _value, uint16(payload));
    }

    <span class="marker" id="mapping-593"></span><span class="token add" data-title="contract_body/comment">/**
    * @notice Deposit tokens and create new sub-stake. Use this method to become a staker
    * @param _staker Staker
    * @param _value Amount of tokens to deposit
    * @param _unlockingDuration Amount of periods during which tokens will be unlocked when wind down is enabled
    */</span>
    <span class="marker" id="mapping-594"></span><span class="token mv" id="move-dst-149" data-title="contract_body/function_definition">function <span class="marker" id="mapping-595"></span><span class="token upd" id="move-dst-150" data-title="function_definition/identifier"><span class="cupd">d</span><span class="cupd">e</span>posit</span>(<span class="marker" id="mapping-596"></span><span class="token mv" id="move-dst-133" data-title="function_definition/parameter">address _staker</span>, <span class="marker" id="mapping-597"></span><span class="token mv" id="move-dst-151" data-title="function_definition/parameter">uint256 _value</span><span class="marker" id="mapping-598"></span><span class="token add" data-title="function_definition/,">,</span> <span class="marker" id="mapping-599"></span><span class="token mv" id="move-dst-162" data-title="function_definition/parameter">uint16 <span class="marker" id="mapping-600"></span><span class="token upd" id="move-dst-163" data-title="parameter/identifier"><span class="cupd">_</span>unlockingDu<span class="cupd">r</span>at<span class="cupd">io</span>n</span></span>) external {
        <span class="marker" id="mapping-601"></span><span class="token upd" id="move-dst-155" data-title="call_expression/identifier">deposit</span>(<span class="marker" id="mapping-602"></span><span class="token mv" id="move-dst-99" data-title="call_expression/call_argument">_staker</span>, <span class="marker" id="mapping-603"></span><span class="token mv" id="move-dst-156" data-title="call_expression/call_argument">msg.sender</span>, <span class="marker" id="mapping-604"></span><span class="token mv" id="move-dst-157" data-title="call_expression/call_argument">MAX_SUB_STAKES</span>, <span class="marker" id="mapping-605"></span><span class="token mv" id="move-dst-158" data-title="call_expression/call_argument">_value</span><span class="marker" id="mapping-606"></span><span class="token add" data-title="call_expression/,">,</span> <span class="marker" id="mapping-607"></span><span class="token upd" id="move-dst-159" data-title="call_argument/identifier"><span class="cupd">_</span>unlockingDu<span class="cupd">r</span>at<span class="cupd">io</span>n</span>);
    }</span>

    /**
    * @notice Deposit tokens and increase lock amount of an existing sub-stake
    * @dev This is preferable way to stake tokens because will be fewer active sub-stakes in the result
    * @param _index Index of the sub stake
    * @param _value Amount of tokens which will be locked
    */
    function depositAndIncrease(uint256 _index, uint256 _value) external onlyStaker {
        require(_index &lt; MAX_SUB_STAKES);
        deposit(msg.sender, msg.sender, _index, _value, 0);
    }

    <span class="marker" id="mapping-608"></span><span class="token add" data-title="contract_body/comment">/**
    * @notice Deposit tokens
    * @dev Specify either index and zero periods (for an existing sub-stake)
    * or index &gt;= MAX_SUB_STAKES and real value for periods (for a new sub-stake), not both
    * @param _staker Staker
    * @param _payer Owner of tokens
    * @param _index Index of the sub stake
    * @param _value Amount of tokens to deposit
    * @param _unlockingDuration Amount of periods during which tokens will be unlocked when wind down is enabled
    */</span>
    function deposit(address _staker, address _payer, uint256 _index, uint256 _value, <span class="marker" id="mapping-609"></span><span class="token mv" id="move-dst-174" data-title="function_definition/parameter">uint16 <span class="marker" id="mapping-610"></span><span class="token upd" id="move-dst-175" data-title="parameter/identifier"><span class="cupd">_</span>unlockingDu<span class="cupd">r</span>at<span class="cupd">io</span>n</span></span>) internal {
        require(_value != 0);
        StakerInfo storage info = stakerInfo[_staker];
        // A staker can't be a worker for another staker
        require(stakerFromWorker[_staker] == address(0) || stakerFromWorker[_staker] == info.worker);
        // initial stake of the staker
        if (<span class="marker" id="mapping-611"></span><span class="token add" data-title="if_statement/binary_expression"><span class="marker" id="mapping-612"></span><span class="token add" data-title="binary_expression/member_expression"><span class="marker" id="mapping-613"></span><span class="token add" data-title="member_expression/binary_expression"><span class="marker" id="mapping-614"></span><span class="token mv" id="move-dst-144" data-title="binary_expression/binary_expression">info.subStakes.length == 0</span> &amp;&amp; info</span>.lastCommittedPeriod</span> == 0</span>) {
            stakers.push(_staker);
            policyManager.register(_staker, getCurrentPeriod() - 1);
            <span class="marker" id="mapping-615"></span><span class="token add" data-title="block_statement/expression_statement">info.flags = info.flags.toggleBit(MIGRATED_INDEX);</span>
        }
        <span class="marker" id="mapping-616"></span><span class="token add" data-title="function_body/expression_statement"><span class="marker" id="mapping-617"></span><span class="token add" data-title="expression_statement/call_expression">require(<span class="marker" id="mapping-618"></span><span class="token add" data-title="call_expression/call_argument"><span class="marker" id="mapping-619"></span><span class="token add" data-title="call_argument/call_expression"><span class="marker" id="mapping-620"></span><span class="token add" data-title="call_expression/member_expression"><span class="marker" id="mapping-621"></span><span class="token mv" id="move-dst-119" data-title="member_expression/member_expression">info.flags</span>.bitSet</span>(<span class="marker" id="mapping-622"></span><span class="token add" data-title="call_expression/call_argument">MIGRATED_INDEX</span>)</span></span>)</span>;</span>
        token.safeTransferFrom(_payer, address(this), _value);
        info.value += _value;
        lock(_staker, _index, _value, <span class="marker" id="mapping-623"></span><span class="token upd" id="move-dst-145" data-title="call_argument/identifier"><span class="cupd">_</span>unlockingDu<span class="cupd">r</span>at<span class="cupd">io</span>n</span>);

        addSnapshot(info, int256(_value));
        if (_index &gt;= MAX_SUB_STAKES) {
            emit Deposited(_staker, _value, <span class="marker" id="mapping-624"></span><span class="token upd" id="move-dst-146" data-title="call_argument/identifier"><span class="cupd">_</span>unlockingDu<span class="cupd">r</span>at<span class="cupd">io</span>n</span>);
        } else {
            uint16 lastPeriod = getLastPeriodOfSubStake(_staker, _index);
            emit Deposited(_staker, _value, lastPeriod - getCurrentPeriod());
        }
    }

    <span class="marker" id="mapping-625"></span><span class="token add" data-title="contract_body/comment">/**
    * @notice Lock some tokens as a new sub-stake
    * @param _value Amount of tokens which will be locked
    * @param _unlockingDuration Amount of periods during which tokens will be unlocked when wind down is enabled
    */</span>
    <span class="marker" id="mapping-626"></span><span class="token add" data-title="contract_body/function_definition">function lockAndCreate(<span class="marker" id="mapping-627"></span><span class="token mv" id="move-dst-134" data-title="function_definition/parameter">uint256 _value</span>, <span class="marker" id="mapping-628"></span><span class="token mv" id="move-dst-181" data-title="function_definition/parameter">uint16 <span class="marker" id="mapping-629"></span><span class="token upd" id="move-dst-182" data-title="parameter/identifier"><span class="cupd">_</span>unlockingDu<span class="cupd">r</span>at<span class="cupd">io</span>n</span></span>) <span class="marker" id="mapping-630"></span><span class="token mv" id="move-dst-137" data-title="function_definition/visibility">external</span> <span class="marker" id="mapping-631"></span><span class="token mv" id="move-dst-154" data-title="function_definition/modifier_invocation">onlyStaker</span> <span class="marker" id="mapping-632"></span><span class="token add" data-title="function_definition/function_body">{
        <span class="marker" id="mapping-633"></span><span class="token mv" id="move-dst-127" data-title="function_body/expression_statement"><span class="marker" id="mapping-634"></span><span class="token add" data-title="call_expression/identifier">lock</span>(msg.sender, <span class="marker" id="mapping-635"></span><span class="token mv" id="move-dst-100" data-title="call_expression/call_argument">MAX_SUB_STAKES</span>, <span class="marker" id="mapping-636"></span><span class="token mv" id="move-dst-101" data-title="call_expression/call_argument">_value</span><span class="marker" id="mapping-637"></span><span class="token add" data-title="call_expression/,">,</span> <span class="marker" id="mapping-638"></span><span class="token upd" id="move-dst-128" data-title="call_argument/identifier">_<span class="cupd">u</span>n<span class="cupd">l</span>ockingDuration</span>);</span>
    }</span></span>

    /**
    * @notice Increase lock amount of an existing sub-stake
    * @param _index Index of the sub-stake
    * @param _value Amount of tokens which will be locked
    */
    function lockAndIncrease(uint256 _index, uint256 _value) external onlyStaker {
        require(_index &lt; MAX_SUB_STAKES);
        lock(msg.sender, _index, _value, 0);
    }

    <span class="marker" id="mapping-639"></span><span class="token add" data-title="contract_body/comment">/**
    * @notice Lock some tokens as a stake
    * @dev Specify either index and zero periods (for an existing sub-stake)
    * or index &gt;= MAX_SUB_STAKES and real value for periods (for a new sub-stake), not both
    * @param _staker Staker
    * @param _index Index of the sub stake
    * @param _value Amount of tokens which will be locked
    * @param _unlockingDuration Amount of periods during which tokens will be unlocked when wind down is enabled
    */</span>
    function lock(address _staker, uint256 _index, uint256 _value, <span class="marker" id="mapping-640"></span><span class="token mv" id="move-dst-189" data-title="function_definition/parameter">uint16 <span class="marker" id="mapping-641"></span><span class="token upd" id="move-dst-190" data-title="parameter/identifier"><span class="cupd">_</span>unlockingDu<span class="cupd">r</span>at<span class="cupd">io</span>n</span></span>) internal {
        if (_index &lt; MAX_SUB_STAKES) {
            require(_value &gt; 0);
        } else {
            require(_value &gt;= minAllowableLockedTokens &amp;&amp; <span class="marker" id="mapping-642"></span><span class="token upd" id="move-dst-164" data-title="binary_expression/identifier"><span class="cupd">_</span>unlockingDu<span class="cupd">r</span>at<span class="cupd">io</span>n</span> &gt;= minLockedPeriods);
        }

        uint16 currentPeriod = getCurrentPeriod();
        uint16 nextPeriod = currentPeriod + 1;
        StakerInfo storage info = stakerInfo[_staker];
        uint256 lockedTokens = getLockedTokens(info, currentPeriod, nextPeriod);
        uint256 requestedLockedTokens = _value.add(lockedTokens);
        require(requestedLockedTokens &lt;= info.value &amp;&amp; requestedLockedTokens &lt;= maxAllowableLockedTokens);

        // next period is committed
        if (info.nextCommittedPeriod == nextPeriod) {
            <span class="marker" id="mapping-643"></span><span class="token upd" id="move-dst-165" data-title="array_access/identifier">_<span class="cupd">lockedPerPeriod</span></span>[nextPeriod] += _value;
            emit CommitmentMade(_staker, nextPeriod, _value);
        }

        // if index was provided then increase existing sub-stake
        if (_index &lt; MAX_SUB_STAKES) {
            lockAndIncrease(info, currentPeriod, nextPeriod, _staker, _index, _value);
        // otherwise create new
        } else {
            lockAndCreate(info, nextPeriod, _staker, _value, <span class="marker" id="mapping-644"></span><span class="token upd" id="move-dst-166" data-title="call_argument/identifier"><span class="cupd">_</span>unlockingDu<span class="cupd">r</span>at<span class="cupd">io</span>n</span>);
        }
    }

    <span class="marker" id="mapping-645"></span><span class="token add" data-title="contract_body/comment">/**
    * @notice Lock some tokens as a new sub-stake
    * @param _info Staker structure
    * @param _nextPeriod Next period
    * @param _staker Staker
    * @param _value Amount of tokens which will be locked
    * @param _unlockingDuration Amount of periods during which tokens will be unlocked when wind down is enabled
    */</span>
    function lockAndCreate(
        StakerInfo storage _info,
        uint16 _nextPeriod,
        address _staker,
        uint256 _value,
        uint16 <span class="marker" id="mapping-646"></span><span class="token upd" id="move-dst-169" data-title="parameter/identifier"><span class="cupd">_</span>unlockingDu<span class="cupd">r</span>at<span class="cupd">io</span>n</span>
    )
        internal
    {
        uint16 duration = <span class="marker" id="mapping-647"></span><span class="token upd" id="move-dst-170" data-title="variable_declaration_statement/identifier"><span class="cupd">_</span>unlockingDu<span class="cupd">r</span>at<span class="cupd">io</span>n</span>;
        // if winding down is enabled and next period is committed
        // then sub-stakes duration were decreased
        if (_info.nextCommittedPeriod == _nextPeriod &amp;&amp; _info.flags.bitSet(WIND_DOWN_INDEX)) {
            duration -= 1;
        }
        saveSubStake(_info, _nextPeriod, 0, duration, _value);

        emit Locked(_staker, _value, _nextPeriod, <span class="marker" id="mapping-648"></span><span class="token upd" id="move-dst-171" data-title="call_argument/identifier"><span class="cupd">_</span>unlockingDu<span class="cupd">r</span>at<span class="cupd">io</span>n</span>);
    }

    /**
    * @notice Increase lock amount of an existing sub-stake
    * @dev Probably will be created a new sub-stake but it will be active only one period
    * @param _info Staker structure
    * @param _currentPeriod Current period
    * @param _nextPeriod Next period
    * @param _staker Staker
    * @param _index Index of the sub-stake
    * @param _value Amount of tokens which will be locked
    */
    function lockAndIncrease(
        StakerInfo storage _info,
        uint16 _currentPeriod,
        uint16 _nextPeriod,
        address _staker,
        uint256 _index,
        uint256 _value
    )
        internal
    {
        SubStakeInfo storage subStake = _info.subStakes[_index];
        (, uint16 lastPeriod) = checkLastPeriodOfSubStake(_info, subStake, _currentPeriod);

        // create temporary sub-stake for current or previous committed periods
        // to leave locked amount in this period unchanged
        if (_info.currentCommittedPeriod != 0 &amp;&amp;
            _info.currentCommittedPeriod &lt;= _currentPeriod ||
            _info.nextCommittedPeriod != 0 &amp;&amp;
            _info.nextCommittedPeriod &lt;= _currentPeriod)
        {
            saveSubStake(_info, subStake.firstPeriod, _currentPeriod, 0, subStake.lockedValue);
        }

        subStake.lockedValue += uint128(_value);
        // all new locks should start from the next period
        subStake.firstPeriod = _nextPeriod;

        emit Locked(_staker, _value, _nextPeriod, lastPeriod - _currentPeriod);
    }

    /**
    * @notice Checks that last period of sub-stake is greater than the current period
    * @param _info Staker structure
    * @param _subStake Sub-stake structure
    * @param _currentPeriod Current period
    * @return startPeriod Start period. Use in the calculation of the last period of the sub stake
    * @return lastPeriod Last period of the sub stake
    */
    function checkLastPeriodOfSubStake(
        StakerInfo storage _info,
        SubStakeInfo storage _subStake,
        uint16 _currentPeriod
    )
        internal view returns (uint16 startPeriod, uint16 lastPeriod)
    {
        startPeriod = getStartPeriod(_info, _currentPeriod);
        lastPeriod = getLastPeriodOfSubStake(_subStake, startPeriod);
        // The sub stake must be active at least in the next period
        require(lastPeriod &gt; _currentPeriod);
    }

    <span class="marker" id="mapping-649"></span><span class="token add" data-title="contract_body/comment">/**
    * @notice Save sub stake. First tries to override inactive sub stake
    * @dev Inactive sub stake means that last period of sub stake has been surpassed and already rewarded
    * @param _info Staker structure
    * @param _firstPeriod First period of the sub stake
    * @param _lastPeriod Last period of the sub stake
    * @param _unlockingDuration Duration of the sub stake in periods
    * @param _lockedValue Amount of locked tokens
    */</span>
    function saveSubStake(
        StakerInfo storage _info,
        uint16 _firstPeriod,
        uint16 _lastPeriod,
        <span class="marker" id="mapping-650"></span><span class="token mv" id="move-dst-152" data-title="function_definition/parameter">uint16 <span class="marker" id="mapping-651"></span><span class="token upd" id="move-dst-153" data-title="parameter/identifier"><span class="cupd">_</span>unlockingDu<span class="cupd">r</span>at<span class="cupd">io</span>n</span></span>,
        uint256 _lockedValue
    )
        internal
    {
        for (uint256 i = 0; i &lt; _info.subStakes.length; i++) {
            SubStakeInfo storage subStake = _info.subStakes[i];
            if (subStake.lastPeriod != 0 &amp;&amp;
                (_info.currentCommittedPeriod == 0 ||
                subStake.lastPeriod &lt; _info.currentCommittedPeriod) &amp;&amp;
                (_info.nextCommittedPeriod == 0 ||
                subStake.lastPeriod &lt; _info.nextCommittedPeriod))
            {
                subStake.firstPeriod = _firstPeriod;
                subStake.lastPeriod = _lastPeriod;
                subStake.<span class="marker" id="mapping-652"></span><span class="token upd" id="move-dst-176" data-title="member_expression/identifier">unlockingDu<span class="cupd">r</span>at<span class="cupd">io</span>n</span> = <span class="marker" id="mapping-653"></span><span class="token upd" id="move-dst-177" data-title="assignment_expression/identifier"><span class="cupd">_</span>unlockingDu<span class="cupd">r</span>at<span class="cupd">io</span>n</span>;
                subStake.lockedValue = uint128(_lockedValue);
                return;
            }
        }
        require(_info.subStakes.length &lt; MAX_SUB_STAKES);
        _info.subStakes.push(SubStakeInfo(_firstPeriod, _lastPeriod, <span class="marker" id="mapping-654"></span><span class="token upd" id="move-dst-178" data-title="call_argument/identifier"><span class="cupd">_</span>unlockingDu<span class="cupd">r</span>at<span class="cupd">io</span>n</span>, uint128(_lockedValue)));
    }

    <span class="marker" id="mapping-655"></span><span class="token add" data-title="contract_body/comment">/**
    * @notice Divide sub stake into two parts
    * @param _index Index of the sub stake
    * @param _newValue New sub stake value
    * @param _additionalDuration Amount of periods for extending sub stake
    */</span>
    function divideStake(uint256 _index, uint256 _newValue, <span class="marker" id="mapping-656"></span><span class="token mv" id="move-dst-142" data-title="function_definition/parameter">uint16 <span class="marker" id="mapping-657"></span><span class="token upd" id="move-dst-143" data-title="parameter/identifier"><span class="cupd">_</span>additionalDu<span class="cupd">r</span>at<span class="cupd">io</span>n</span></span>) external onlyStaker {
        StakerInfo storage info = stakerInfo[msg.sender];
        require(_newValue &gt;= minAllowableLockedTokens &amp;&amp; <span class="marker" id="mapping-658"></span><span class="token upd" id="move-dst-183" data-title="binary_expression/identifier"><span class="cupd">_</span>additionalDu<span class="cupd">r</span>at<span class="cupd">io</span>n</span> &gt; 0);
        SubStakeInfo storage subStake = info.subStakes[_index];
        uint16 currentPeriod = getCurrentPeriod();
        (, uint16 lastPeriod) = checkLastPeriodOfSubStake(info, subStake, currentPeriod);

        uint256 oldValue = subStake.lockedValue;
        subStake.lockedValue = uint128(oldValue.sub(_newValue));
        require(subStake.lockedValue &gt;= minAllowableLockedTokens);
        uint16 requestedPeriods = subStake.<span class="marker" id="mapping-659"></span><span class="token upd" id="move-dst-184" data-title="member_expression/identifier">unlockingDu<span class="cupd">r</span>at<span class="cupd">io</span>n</span>.add16(<span class="marker" id="mapping-660"></span><span class="token upd" id="move-dst-185" data-title="call_argument/identifier"><span class="cupd">_</span>additionalDu<span class="cupd">r</span>at<span class="cupd">io</span>n</span>);
        saveSubStake(info, subStake.firstPeriod, 0, requestedPeriods, _newValue);
        emit Divided(msg.sender, oldValue, lastPeriod, _newValue, <span class="marker" id="mapping-661"></span><span class="token upd" id="move-dst-186" data-title="call_argument/identifier"><span class="cupd">_</span>additionalDu<span class="cupd">r</span>at<span class="cupd">io</span>n</span>);
        emit Locked(msg.sender, _newValue, subStake.firstPeriod, requestedPeriods);
    }

    <span class="marker" id="mapping-662"></span><span class="token add" data-title="contract_body/comment">/**
    * @notice Prolong active sub stake
    * @param _index Index of the sub stake
    * @param _additionalDuration Amount of periods for extending sub stake
    */</span>
    function prolongStake(uint256 _index, <span class="marker" id="mapping-663"></span><span class="token mv" id="move-dst-78" data-title="function_definition/parameter">uint16 <span class="marker" id="mapping-664"></span><span class="token upd" id="move-dst-79" data-title="parameter/identifier"><span class="cupd">_</span>additionalDu<span class="cupd">r</span>at<span class="cupd">io</span>n</span></span>) external onlyStaker {
        StakerInfo storage info = stakerInfo[msg.sender];
        // Incorrect parameters
        require(<span class="marker" id="mapping-665"></span><span class="token upd" id="move-dst-191" data-title="binary_expression/identifier"><span class="cupd">_</span>additionalDu<span class="cupd">r</span>at<span class="cupd">io</span>n</span> &gt; 0);
        SubStakeInfo storage subStake = info.subStakes[_index];
        uint16 currentPeriod = getCurrentPeriod();
        (uint16 startPeriod, uint16 lastPeriod) = checkLastPeriodOfSubStake(info, subStake, currentPeriod);

        subStake.<span class="marker" id="mapping-666"></span><span class="token upd" id="move-dst-192" data-title="member_expression/identifier">unlockingDu<span class="cupd">r</span>at<span class="cupd">io</span>n</span> = subStake.<span class="marker" id="mapping-667"></span><span class="token upd" id="move-dst-193" data-title="member_expression/identifier">unlockingDu<span class="cupd">r</span>at<span class="cupd">io</span>n</span>.add16(<span class="marker" id="mapping-668"></span><span class="token upd" id="move-dst-194" data-title="call_argument/identifier"><span class="cupd">_</span>additionalDu<span class="cupd">r</span>at<span class="cupd">io</span>n</span>);
        // if the sub stake ends in the next committed period then reset the `lastPeriod` field
        if (lastPeriod == startPeriod) {
            subStake.lastPeriod = 0;
        }
        // The extended sub stake must not be less than the minimum value
        require(uint32(lastPeriod - currentPeriod) + <span class="marker" id="mapping-669"></span><span class="token upd" id="move-dst-195" data-title="binary_expression/identifier"><span class="cupd">_</span>additionalDu<span class="cupd">r</span>at<span class="cupd">io</span>n</span> &gt;= minLockedPeriods);
        emit Locked(msg.sender, subStake.lockedValue, lastPeriod + 1, <span class="marker" id="mapping-670"></span><span class="token upd" id="move-dst-196" data-title="call_argument/identifier"><span class="cupd">_</span>additionalDu<span class="cupd">r</span>at<span class="cupd">io</span>n</span>);
        emit Prolonged(msg.sender, subStake.lockedValue, lastPeriod, <span class="marker" id="mapping-671"></span><span class="token upd" id="move-dst-197" data-title="call_argument/identifier"><span class="cupd">_</span>additionalDu<span class="cupd">r</span>at<span class="cupd">io</span>n</span>);
    }

    /**
    * @notice Merge two sub-stakes into one if their last periods are equal
    * @dev It's possible that both sub-stakes will be active after this transaction.
    * But only one of them will be active until next call `commitToNextPeriod` (in the next period)
    * @param _index1 Index of the first sub-stake
    * @param _index2 Index of the second sub-stake
    */
    function mergeStake(uint256 _index1, uint256 _index2) external onlyStaker {
        require(_index1 != _index2); // must be different sub-stakes

        StakerInfo storage info = stakerInfo[msg.sender];
        SubStakeInfo storage subStake1 = info.subStakes[_index1];
        SubStakeInfo storage subStake2 = info.subStakes[_index2];
        uint16 currentPeriod = getCurrentPeriod();

        (, uint16 lastPeriod1) = checkLastPeriodOfSubStake(info, subStake1, currentPeriod);
        (, uint16 lastPeriod2) = checkLastPeriodOfSubStake(info, subStake2, currentPeriod);
        // both sub-stakes must have equal last period to be mergeable
        require(lastPeriod1 == lastPeriod2);
        emit Merged(msg.sender, subStake1.lockedValue, subStake2.lockedValue, lastPeriod1);

        if (subStake1.firstPeriod == subStake2.firstPeriod) {
            subStake1.lockedValue += subStake2.lockedValue;
            subStake2.lastPeriod = 1;
            subStake2.<span class="marker" id="mapping-672"></span><span class="token upd" id="move-dst-198" data-title="member_expression/identifier">unlockingDu<span class="cupd">r</span>at<span class="cupd">io</span>n</span> = 0;
        } else if (subStake1.firstPeriod &gt; subStake2.firstPeriod) {
            subStake1.lockedValue += subStake2.lockedValue;
            subStake2.lastPeriod = subStake1.firstPeriod - 1;
            subStake2.<span class="marker" id="mapping-673"></span><span class="token upd" id="move-dst-199" data-title="member_expression/identifier">unlockingDu<span class="cupd">r</span>at<span class="cupd">io</span>n</span> = 0;
        } else {
            subStake2.lockedValue += subStake1.lockedValue;
            subStake1.lastPeriod = subStake2.firstPeriod - 1;
            subStake1.<span class="marker" id="mapping-674"></span><span class="token upd" id="move-dst-200" data-title="member_expression/identifier">unlockingDu<span class="cupd">r</span>at<span class="cupd">io</span>n</span> = 0;
        }
    }

    /**
    * @notice Remove unused sub-stake to decrease gas cost for several methods
    */
    function removeUnusedSubStake(uint16 _index) external onlyStaker {
        StakerInfo storage info = stakerInfo[msg.sender];

        uint256 lastIndex = info.subStakes.length - 1;
        SubStakeInfo storage subStake = info.subStakes[_index];
        require(subStake.lastPeriod != 0 &amp;&amp;
                (info.currentCommittedPeriod == 0 ||
                subStake.lastPeriod &lt; info.currentCommittedPeriod) &amp;&amp;
                (info.nextCommittedPeriod == 0 ||
                subStake.lastPeriod &lt; info.nextCommittedPeriod));

        if (_index != lastIndex) {
            SubStakeInfo storage lastSubStake = info.subStakes[lastIndex];
            subStake.firstPeriod = lastSubStake.firstPeriod;
            subStake.lastPeriod = lastSubStake.lastPeriod;
            subStake.<span class="marker" id="mapping-675"></span><span class="token upd" id="move-dst-201" data-title="member_expression/identifier">unlockingDu<span class="cupd">r</span>at<span class="cupd">io</span>n</span> = lastSubStake.<span class="marker" id="mapping-676"></span><span class="token upd" id="move-dst-202" data-title="member_expression/identifier">unlockingDu<span class="cupd">r</span>at<span class="cupd">io</span>n</span>;
            subStake.lockedValue = lastSubStake.lockedValue;
        }
        info.subStakes.pop();
    }

    /**
    * @notice Withdraw available amount of tokens to staker
    * @param _value Amount of tokens to withdraw
    */
    function withdraw(uint256 _value) external onlyStaker {
        uint16 currentPeriod = getCurrentPeriod();
        uint16 nextPeriod = currentPeriod + 1;
        StakerInfo storage info = stakerInfo[msg.sender];
        // the max locked tokens in most cases will be in the current period
        // but when the staker locks more then we should use the next period
        uint256 lockedTokens = Math.max(getLockedTokens(info, currentPeriod, nextPeriod),
            getLockedTokens(info, currentPeriod, currentPeriod));
        require(_value &lt;= info.value.sub(lockedTokens));
        info.value -= _value;

        addSnapshot(info, - int256(_value));
        token.safeTransfer(msg.sender, _value);
        emit Withdrawn(msg.sender, _value);

        // unbond worker if staker withdraws last portion of NU
        if (info.value == 0 &amp;&amp;
            info.nextCommittedPeriod == 0 &amp;&amp;
            info.worker != address(0))
        {
            stakerFromWorker[info.worker] = address(0);
            info.worker = address(0);
            emit WorkerBonded(msg.sender, address(0), currentPeriod);
        }
    }

    /**
    * @notice Make a commitment to the next period and mint for the previous period
    */
    function commitToNextPeriod() external isInitialized {
        address staker = stakerFromWorker[msg.sender];
        StakerInfo storage info = stakerInfo[staker];
        // Staker must have a stake to make a commitment
        require(info.value &gt; 0);
        // Only worker with real address can make a commitment
        require(msg.sender == tx.origin);

        <span class="marker" id="mapping-677"></span><span class="token add" data-title="function_body/expression_statement"><span class="marker" id="mapping-678"></span><span class="token add" data-title="expression_statement/call_expression">migrate(<span class="marker" id="mapping-679"></span><span class="token mv" id="move-dst-120" data-title="call_expression/call_argument">staker</span>)</span>;</span>

        uint16 currentPeriod = getCurrentPeriod();
        uint16 nextPeriod = currentPeriod + 1;
        // the period has already been committed
        <span class="marker" id="mapping-680"></span><span class="token add" data-title="function_body/expression_statement">require(info.nextCommittedPeriod != nextPeriod);</span>

        <span class="marker" id="mapping-681"></span><span class="token mv" id="move-dst-203" data-title="function_body/variable_declaration_statement">uint16 lastCommittedPeriod = getLastCommittedPeriod(staker);</span>
        <span class="marker" id="mapping-682"></span><span class="token mv" id="move-dst-204" data-title="function_body/variable_declaration_statement">(uint16 processedPeriod1, uint16 processedPeriod2) = mint(staker);</span>

        uint256 lockedTokens = getLockedTokens(info, currentPeriod, nextPeriod);
        require(lockedTokens &gt; 0);
        <span class="marker" id="mapping-683"></span><span class="token upd" id="move-dst-206" data-title="array_access/identifier">_<span class="cupd">lockedPerPeriod</span></span>[nextPeriod] += lockedTokens;

        info.currentCommittedPeriod = info.nextCommittedPeriod;
        info.nextCommittedPeriod = nextPeriod;

        decreaseSubStakesDuration(info, nextPeriod);

        // staker was inactive for several periods
        if (lastCommittedPeriod &lt; currentPeriod) {
            info.pastDowntime.push(Downtime(lastCommittedPeriod + 1, currentPeriod));
        }

        policyManager.ping(staker, processedPeriod1, processedPeriod2, nextPeriod);
        emit CommitmentMade(staker, nextPeriod, lockedTokens);
    }

    <span class="marker" id="mapping-684"></span><span class="token add" data-title="contract_body/comment">/**
    * @notice Migrate from the old period length to the new one. Can be done only once
    * @param _staker Staker
    */</span>
    <span class="marker" id="mapping-685"></span><span class="token add" data-title="contract_body/function_definition">function migrate(<span class="marker" id="mapping-686"></span><span class="token mv" id="move-dst-85" data-title="function_definition/parameter">address _staker</span>) <span class="marker" id="mapping-687"></span><span class="token mv" id="move-dst-86" data-title="function_definition/visibility">public</span> <span class="marker" id="mapping-688"></span><span class="token add" data-title="function_definition/function_body">{
        <span class="marker" id="mapping-689"></span><span class="token add" data-title="function_body/variable_declaration_statement">StakerInfo storage info = stakerInfo[_staker];</span>
        // check that provided address is/was a staker
        <span class="marker" id="mapping-690"></span><span class="token add" data-title="function_body/expression_statement">require(info.subStakes.length != 0 || info.lastCommittedPeriod != 0);</span>
        <span class="marker" id="mapping-691"></span><span class="token mv" id="move-dst-205" data-title="function_body/if_statement">if (<span class="marker" id="mapping-692"></span><span class="token add" data-title="if_statement/call_expression">info.flags.bitSet(MIGRATED_INDEX)</span>) {
            return;
        }</span>

        // reset state
        <span class="marker" id="mapping-693"></span><span class="token add" data-title="function_body/expression_statement">info.currentCommittedPeriod = 0;</span>
        <span class="marker" id="mapping-694"></span><span class="token add" data-title="function_body/expression_statement">info.nextCommittedPeriod = 0;</span>
        // maintain case when no more sub-stakes and need to avoid re-registering this staker during deposit
        <span class="marker" id="mapping-695"></span><span class="token add" data-title="function_body/expression_statement">info.lastCommittedPeriod = 1;</span>
        <span class="marker" id="mapping-696"></span><span class="token add" data-title="function_body/expression_statement">info.workerStartPeriod = recalculatePeriod(info.workerStartPeriod);</span>
        <span class="marker" id="mapping-697"></span><span class="token add" data-title="function_body/expression_statement">delete info.pastDowntime;</span>

        // recalculate all sub-stakes
        <span class="marker" id="mapping-698"></span><span class="token add" data-title="function_body/variable_declaration_statement">uint16 currentPeriod = getCurrentPeriod();</span>
        <span class="marker" id="mapping-699"></span><span class="token add" data-title="function_body/for_statement">for (<span class="marker" id="mapping-700"></span><span class="token mv" id="move-dst-116" data-title="for_statement/variable_declaration_statement">uint256 i = 0;</span> <span class="marker" id="mapping-701"></span><span class="token mv" id="move-dst-123" data-title="for_statement/expression_statement"><span class="marker" id="mapping-702"></span><span class="token mv" id="move-dst-124" data-title="expression_statement/member_expression"><span class="marker" id="mapping-703"></span><span class="token add" data-title="member_expression/binary_expression">i &lt; <span class="marker" id="mapping-704"></span><span class="token mv" id="move-dst-125" data-title="binary_expression/member_expression">info.subStakes</span></span>.<span class="marker" id="mapping-705"></span><span class="token upd" id="move-dst-126" data-title="member_expression/identifier">length</span></span>;</span> <span class="marker" id="mapping-706"></span><span class="token mv" id="move-dst-117" data-title="for_statement/update_expression">i++</span>) <span class="marker" id="mapping-707"></span><span class="token add" data-title="for_statement/block_statement">{
            <span class="marker" id="mapping-708"></span><span class="token add" data-title="block_statement/variable_declaration_statement">SubStakeInfo storage subStake = info.subStakes[i];</span>
            <span class="marker" id="mapping-709"></span><span class="token add" data-title="block_statement/expression_statement">subStake.firstPeriod = recalculatePeriod(subStake.firstPeriod);</span>
            // sub-stake has fixed last period
            <span class="marker" id="mapping-710"></span><span class="token add" data-title="block_statement/if_statement">if (<span class="marker" id="mapping-711"></span><span class="token add" data-title="if_statement/binary_expression">subStake.lastPeriod != 0</span>) <span class="marker" id="mapping-712"></span><span class="token add" data-title="if_statement/block_statement">{
                subStake.lastPeriod = recalculatePeriod(subStake.lastPeriod);
                if (subStake.lastPeriod == 0) {
                    subStake.lastPeriod = 1;
                }
                subStake.unlockingDuration = 0;
            // sub-stake has no fixed ending but possible that with new period length will have
            }</span> else <span class="marker" id="mapping-713"></span><span class="token add" data-title="if_statement/block_statement">{
                <span class="marker" id="mapping-714"></span><span class="token mv" id="move-dst-113" data-title="block_statement/variable_declaration_statement">uint16 <span class="marker" id="mapping-715"></span><span class="token upd" id="move-dst-114" data-title="variable_declaration/identifier">oldCu<span class="cupd">r</span>r<span class="cupd">e</span>nt<span class="cupd">Period</span></span> = <span class="marker" id="mapping-716"></span><span class="token add" data-title="variable_declaration_statement/type_cast_expression">uint16(block.timestamp / genesisSecondsPerPeriod)</span>;</span>
                <span class="marker" id="mapping-717"></span><span class="token mv" id="move-dst-121" data-title="block_statement/variable_declaration_statement">uint16 <span class="marker" id="mapping-718"></span><span class="token upd" id="move-dst-122" data-title="variable_declaration/identifier">lastP<span class="cupd">eriod</span></span> = <span class="marker" id="mapping-719"></span><span class="token add" data-title="variable_declaration_statement/call_expression">recalculatePeriod(oldCurrentPeriod + subStake.unlockingDuration)</span>;</span>
                <span class="marker" id="mapping-720"></span><span class="token add" data-title="block_statement/expression_statement">subStake.unlockingDuration = lastPeriod - currentPeriod;</span>
                <span class="marker" id="mapping-721"></span><span class="token add" data-title="block_statement/if_statement">if (subStake.unlockingDuration == 0) {
                    subStake.lastPeriod = lastPeriod;
                }</span>
            }</span></span>
        }</span></span>

        <span class="marker" id="mapping-722"></span><span class="token add" data-title="function_body/expression_statement">policyManager.migrate(_staker);</span>
        <span class="marker" id="mapping-723"></span><span class="token add" data-title="function_body/expression_statement">info.flags = info.flags.toggleBit(MIGRATED_INDEX);</span>
        <span class="marker" id="mapping-724"></span><span class="token add" data-title="function_body/emit_statement">emit Migrated(_staker, currentPeriod);</span>
    }</span></span>

    /**
    * @notice Decrease sub-stakes duration if `windDown` is enabled
    */
    function decreaseSubStakesDuration(StakerInfo storage _info, uint16 _nextPeriod) internal {
        if (!_info.flags.bitSet(WIND_DOWN_INDEX)) {
            return;
        }
        for (uint256 index = 0; index &lt; _info.subStakes.length; index++) {
            SubStakeInfo storage subStake = _info.subStakes[index];
            if (subStake.lastPeriod != 0 || subStake.<span class="marker" id="mapping-725"></span><span class="token upd" id="move-dst-207" data-title="member_expression/identifier">unlockingDu<span class="cupd">r</span>at<span class="cupd">io</span>n</span> == 0) {
                continue;
            }
            subStake.<span class="marker" id="mapping-726"></span><span class="token upd" id="move-dst-208" data-title="member_expression/identifier">unlockingDu<span class="cupd">r</span>at<span class="cupd">io</span>n</span>--;
            if (subStake.<span class="marker" id="mapping-727"></span><span class="token upd" id="move-dst-209" data-title="member_expression/identifier">unlockingDu<span class="cupd">r</span>at<span class="cupd">io</span>n</span> == 0) {
                subStake.lastPeriod = _nextPeriod;
            }
        }
    }

    /**
    * @notice Mint tokens for previous periods if staker locked their tokens and made a commitment
    */
    function mint() external onlyStaker {
        // save last committed period to the storage if both periods will be empty after minting
        // because we won't be able to calculate last committed period
        // see getLastCommittedPeriod(address)
        StakerInfo storage info = stakerInfo[msg.sender];
        uint16 previousPeriod = getCurrentPeriod() - 1;
        if (info.nextCommittedPeriod &lt;= previousPeriod &amp;&amp; info.nextCommittedPeriod != 0) {
            info.lastCommittedPeriod = info.nextCommittedPeriod;
        }
        (uint16 processedPeriod1, uint16 processedPeriod2) = mint(msg.sender);

        if (processedPeriod1 != 0 || processedPeriod2 != 0) {
            policyManager.ping(msg.sender, processedPeriod1, processedPeriod2, 0);
        }
    }

    /**
    * @notice Mint tokens for previous periods if staker locked their tokens and made a commitment
    * @param _staker Staker
    * @return processedPeriod1 Processed period: currentCommittedPeriod or zero
    * @return processedPeriod2 Processed period: nextCommittedPeriod or zero
    */
    function mint(address _staker) internal returns (uint16 processedPeriod1, uint16 processedPeriod2) {
        uint16 currentPeriod = getCurrentPeriod();
        uint16 previousPeriod = currentPeriod - 1;
        StakerInfo storage info = stakerInfo[_staker];

        if (info.nextCommittedPeriod == 0 ||
            info.currentCommittedPeriod == 0 &amp;&amp;
            info.nextCommittedPeriod &gt; previousPeriod ||
            info.currentCommittedPeriod &gt; previousPeriod) {
            return (0, 0);
        }

        uint16 startPeriod = getStartPeriod(info, currentPeriod);
        uint256 reward = 0;
        bool reStake = !info.flags.bitSet(RE_STAKE_DISABLED_INDEX);

        if (info.currentCommittedPeriod != 0) {
            reward = mint(info, info.currentCommittedPeriod, currentPeriod, startPeriod, reStake);
            processedPeriod1 = info.currentCommittedPeriod;
            info.currentCommittedPeriod = 0;
            if (reStake) {
                <span class="marker" id="mapping-728"></span><span class="token upd" id="move-dst-210" data-title="array_access/identifier">_<span class="cupd">lockedPerPeriod</span></span>[info.nextCommittedPeriod] += reward;
            }
        }
        if (info.nextCommittedPeriod &lt;= previousPeriod) {
            reward += mint(info, info.nextCommittedPeriod, currentPeriod, startPeriod, reStake);
            processedPeriod2 = info.nextCommittedPeriod;
            info.nextCommittedPeriod = 0;
        }

        info.value += reward;
        if (info.flags.bitSet(MEASURE_WORK_INDEX)) {
            info.completedWork += reward;
        }

        addSnapshot(info, int256(reward));
        emit Minted(_staker, previousPeriod, reward);
    }

    /**
    * @notice Calculate reward for one period
    * @param _info Staker structure
    * @param _mintingPeriod Period for minting calculation
    * @param _currentPeriod Current period
    * @param _startPeriod Pre-calculated start period
    */
    function mint(
        StakerInfo storage _info,
        uint16 _mintingPeriod,
        uint16 _currentPeriod,
        uint16 _startPeriod,
        bool _reStake
    )
        internal returns (uint256 reward)
    {
        reward = 0;
        for (uint256 i = 0; i &lt; _info.subStakes.length; i++) {
            SubStakeInfo storage subStake =  _info.subStakes[i];
            uint16 lastPeriod = getLastPeriodOfSubStake(subStake, _startPeriod);
            if (subStake.firstPeriod &lt;= _mintingPeriod &amp;&amp; lastPeriod &gt;= _mintingPeriod) {
                uint256 subStakeReward = mint(
                    _currentPeriod,
                    subStake.lockedValue,
                    <span class="marker" id="mapping-729"></span><span class="token upd" id="move-dst-211" data-title="array_access/identifier">_<span class="cupd">lockedPerPeriod</span></span>[_mintingPeriod],
                    lastPeriod.sub16(_mintingPeriod));
                reward += subStakeReward;
                if (_reStake) {
                    subStake.lockedValue += uint128(subStakeReward);
                }
            }
        }
        return reward;
    }

    //-------------------------Slashing-------------------------
    /**
    * @notice Slash the staker's stake and reward the investigator
    * @param _staker Staker's address
    * @param _penalty Penalty
    * @param _investigator Investigator
    * @param _reward Reward for the investigator
    */
    function slashStaker(
        address _staker,
        uint256 _penalty,
        address _investigator,
        uint256 _reward
    )
        public isInitialized
    {
        require(msg.sender == address(adjudicator));
        require(_penalty &gt; 0);
        StakerInfo storage info = stakerInfo[_staker];
        <span class="marker" id="mapping-730"></span><span class="token add" data-title="function_body/expression_statement">require(info.flags.bitSet(MIGRATED_INDEX));</span>
        if (info.value &lt;= _penalty) {
            _penalty = info.value;
        }
        info.value -= _penalty;
        if (_reward &gt; _penalty) {
            _reward = _penalty;
        }

        uint16 currentPeriod = getCurrentPeriod();
        uint16 nextPeriod = currentPeriod + 1;
        uint16 startPeriod = getStartPeriod(info, currentPeriod);

        (uint256 currentLock, uint256 nextLock, uint256 currentAndNextLock, uint256 shortestSubStakeIndex) =
            getLockedTokensAndShortestSubStake(info, currentPeriod, nextPeriod, startPeriod);

        // Decrease the stake if amount of locked tokens in the current period more than staker has
        uint256 lockedTokens = currentLock + currentAndNextLock;
        if (info.value &lt; lockedTokens) {
           decreaseSubStakes(info, lockedTokens - info.value, currentPeriod, startPeriod, shortestSubStakeIndex);
        }
        // Decrease the stake if amount of locked tokens in the next period more than staker has
        if (nextLock &gt; 0) {
            lockedTokens = nextLock + currentAndNextLock -
                (currentAndNextLock &gt; info.value ? currentAndNextLock - info.value : 0);
            if (info.value &lt; lockedTokens) {
               decreaseSubStakes(info, lockedTokens - info.value, nextPeriod, startPeriod, MAX_SUB_STAKES);
            }
        }

        emit Slashed(_staker, _penalty, _investigator, _reward);
        if (_penalty &gt; _reward) {
            unMint(_penalty - _reward);
        }
        // TODO change to withdrawal pattern (#1499)
        if (_reward &gt; 0) {
            token.safeTransfer(_investigator, _reward);
        }

        addSnapshot(info, - int256(_penalty));

    }

    /**
    * @notice Get the value of locked tokens for a staker in the current and the next period
    * and find the shortest sub stake
    * @param _info Staker structure
    * @param _currentPeriod Current period
    * @param _nextPeriod Next period
    * @param _startPeriod Pre-calculated start period
    * @return currentLock Amount of tokens that locked in the current period and unlocked in the next period
    * @return nextLock Amount of tokens that locked in the next period and not locked in the current period
    * @return currentAndNextLock Amount of tokens that locked in the current period and in the next period
    * @return shortestSubStakeIndex Index of the shortest sub stake
    */
    function getLockedTokensAndShortestSubStake(
        StakerInfo storage _info,
        uint16 _currentPeriod,
        uint16 _nextPeriod,
        uint16 _startPeriod
    )
        internal view returns (
            uint256 currentLock,
            uint256 nextLock,
            uint256 currentAndNextLock,
            uint256 shortestSubStakeIndex
        )
    {
        uint16 minDuration = MAX_UINT16;
        uint16 minLastPeriod = MAX_UINT16;
        shortestSubStakeIndex = MAX_SUB_STAKES;
        currentLock = 0;
        nextLock = 0;
        currentAndNextLock = 0;

        for (uint256 i = 0; i &lt; _info.subStakes.length; i++) {
            SubStakeInfo storage subStake = _info.subStakes[i];
            uint16 lastPeriod = getLastPeriodOfSubStake(subStake, _startPeriod);
            if (lastPeriod &lt; subStake.firstPeriod) {
                continue;
            }
            if (subStake.firstPeriod &lt;= _currentPeriod &amp;&amp;
                lastPeriod &gt;= _nextPeriod) {
                currentAndNextLock += subStake.lockedValue;
            } else if (subStake.firstPeriod &lt;= _currentPeriod &amp;&amp;
                lastPeriod &gt;= _currentPeriod) {
                currentLock += subStake.lockedValue;
            } else if (subStake.firstPeriod &lt;= _nextPeriod &amp;&amp;
                lastPeriod &gt;= _nextPeriod) {
                nextLock += subStake.lockedValue;
            }
            uint16 duration = lastPeriod - subStake.firstPeriod;
            if (subStake.firstPeriod &lt;= _currentPeriod &amp;&amp;
                lastPeriod &gt;= _currentPeriod &amp;&amp;
                (lastPeriod &lt; minLastPeriod ||
                lastPeriod == minLastPeriod &amp;&amp; duration &lt; minDuration))
            {
                shortestSubStakeIndex = i;
                minDuration = duration;
                minLastPeriod = lastPeriod;
            }
        }
    }

    /**
    * @notice Decrease short sub stakes
    * @param _info Staker structure
    * @param _penalty Penalty rate
    * @param _decreasePeriod The period when the decrease begins
    * @param _startPeriod Pre-calculated start period
    * @param _shortestSubStakeIndex Index of the shortest period
    */
    function decreaseSubStakes(
        StakerInfo storage _info,
        uint256 _penalty,
        uint16 _decreasePeriod,
        uint16 _startPeriod,
        uint256 _shortestSubStakeIndex
    )
        internal
    {
        SubStakeInfo storage shortestSubStake = _info.subStakes[0];
        uint16 minSubStakeLastPeriod = MAX_UINT16;
        uint16 minSubStakeDuration = MAX_UINT16;
        while(_penalty &gt; 0) {
            if (_shortestSubStakeIndex &lt; MAX_SUB_STAKES) {
                shortestSubStake = _info.subStakes[_shortestSubStakeIndex];
                minSubStakeLastPeriod = getLastPeriodOfSubStake(shortestSubStake, _startPeriod);
                minSubStakeDuration = minSubStakeLastPeriod - shortestSubStake.firstPeriod;
                _shortestSubStakeIndex = MAX_SUB_STAKES;
            } else {
                (shortestSubStake, minSubStakeDuration, minSubStakeLastPeriod) =
                    getShortestSubStake(_info, _decreasePeriod, _startPeriod);
            }
            if (minSubStakeDuration == MAX_UINT16) {
                break;
            }
            uint256 appliedPenalty = _penalty;
            if (_penalty &lt; shortestSubStake.lockedValue) {
                shortestSubStake.lockedValue -= uint128(_penalty);
                saveOldSubStake(_info, shortestSubStake.firstPeriod, _penalty, _decreasePeriod);
                _penalty = 0;
            } else {
                shortestSubStake.lastPeriod = _decreasePeriod - 1;
                _penalty -= shortestSubStake.lockedValue;
                appliedPenalty = shortestSubStake.lockedValue;
            }
            if (_info.currentCommittedPeriod &gt;= _decreasePeriod &amp;&amp;
                _info.currentCommittedPeriod &lt;= minSubStakeLastPeriod)
            {
                <span class="marker" id="mapping-731"></span><span class="token upd" id="move-dst-212" data-title="array_access/identifier">_<span class="cupd">lockedPerPeriod</span></span>[_info.currentCommittedPeriod] -= appliedPenalty;
            }
            if (_info.nextCommittedPeriod &gt;= _decreasePeriod &amp;&amp;
                _info.nextCommittedPeriod &lt;= minSubStakeLastPeriod)
            {
                <span class="marker" id="mapping-732"></span><span class="token upd" id="move-dst-213" data-title="array_access/identifier">_<span class="cupd">lockedPerPeriod</span></span>[_info.nextCommittedPeriod] -= appliedPenalty;
            }
        }
    }

    /**
    * @notice Get the shortest sub stake
    * @param _info Staker structure
    * @param _currentPeriod Current period
    * @param _startPeriod Pre-calculated start period
    * @return shortestSubStake The shortest sub stake
    * @return minSubStakeDuration Duration of the shortest sub stake
    * @return minSubStakeLastPeriod Last period of the shortest sub stake
    */
    function getShortestSubStake(
        StakerInfo storage _info,
        uint16 _currentPeriod,
        uint16 _startPeriod
    )
        internal view returns (
            SubStakeInfo storage shortestSubStake,
            uint16 minSubStakeDuration,
            uint16 minSubStakeLastPeriod
        )
    {
        shortestSubStake = shortestSubStake;
        minSubStakeDuration = MAX_UINT16;
        minSubStakeLastPeriod = MAX_UINT16;
        for (uint256 i = 0; i &lt; _info.subStakes.length; i++) {
            SubStakeInfo storage subStake = _info.subStakes[i];
            uint16 lastPeriod = getLastPeriodOfSubStake(subStake, _startPeriod);
            if (lastPeriod &lt; subStake.firstPeriod) {
                continue;
            }
            uint16 duration = lastPeriod - subStake.firstPeriod;
            if (subStake.firstPeriod &lt;= _currentPeriod &amp;&amp;
                lastPeriod &gt;= _currentPeriod &amp;&amp;
                (lastPeriod &lt; minSubStakeLastPeriod ||
                lastPeriod == minSubStakeLastPeriod &amp;&amp; duration &lt; minSubStakeDuration))
            {
                shortestSubStake = subStake;
                minSubStakeDuration = duration;
                minSubStakeLastPeriod = lastPeriod;
            }
        }
    }

    /**
    * @notice Save the old sub stake values to prevent decreasing reward for the previous period
    * @dev Saving happens only if the previous period is committed
    * @param _info Staker structure
    * @param _firstPeriod First period of the old sub stake
    * @param _lockedValue Locked value of the old sub stake
    * @param _currentPeriod Current period, when the old sub stake is already unlocked
    */
    function saveOldSubStake(
        StakerInfo storage _info,
        uint16 _firstPeriod,
        uint256 _lockedValue,
        uint16 _currentPeriod
    )
        internal
    {
        // Check that the old sub stake should be saved
        bool oldCurrentCommittedPeriod = _info.currentCommittedPeriod != 0 &amp;&amp;
            _info.currentCommittedPeriod &lt; _currentPeriod;
        bool oldnextCommittedPeriod = _info.nextCommittedPeriod != 0 &amp;&amp;
            _info.nextCommittedPeriod &lt; _currentPeriod;
        bool crosscurrentCommittedPeriod = oldCurrentCommittedPeriod &amp;&amp; _info.currentCommittedPeriod &gt;= _firstPeriod;
        bool crossnextCommittedPeriod = oldnextCommittedPeriod &amp;&amp; _info.nextCommittedPeriod &gt;= _firstPeriod;
        if (!crosscurrentCommittedPeriod &amp;&amp; !crossnextCommittedPeriod) {
            return;
        }
        // Try to find already existent proper old sub stake
        uint16 previousPeriod = _currentPeriod - 1;
        for (uint256 i = 0; i &lt; _info.subStakes.length; i++) {
            SubStakeInfo storage subStake = _info.subStakes[i];
            if (subStake.lastPeriod == previousPeriod &amp;&amp;
                ((crosscurrentCommittedPeriod ==
                (oldCurrentCommittedPeriod &amp;&amp; _info.currentCommittedPeriod &gt;= subStake.firstPeriod)) &amp;&amp;
                (crossnextCommittedPeriod ==
                (oldnextCommittedPeriod &amp;&amp; _info.nextCommittedPeriod &gt;= subStake.firstPeriod))))
            {
                subStake.lockedValue += uint128(_lockedValue);
                return;
            }
        }
        saveSubStake(_info, _firstPeriod, previousPeriod, 0, _lockedValue);
    }

    //-------------Additional getters for stakers info-------------
    /**
    * @notice Return the length of the array of stakers
    */
    function getStakersLength() external view returns (uint256) {
        return stakers.length;
    }

    /**
    * @notice Return the length of the array of sub stakes
    */
    function getSubStakesLength(address _staker) external view returns (uint256) {
        return stakerInfo[_staker].subStakes.length;
    }

    /**
    * @notice Return the information about sub stake
    */
    function getSubStakeInfo(address _staker, uint256 _index)
    // TODO change to structure when ABIEncoderV2 is released (#1501)
//        public view returns (SubStakeInfo)
        // TODO "virtual" only for tests, probably will be removed after #1512
        external view virtual returns (
            uint16 firstPeriod,
            uint16 lastPeriod,
            uint16 <span class="marker" id="mapping-733"></span><span class="token upd" id="move-dst-214" data-title="parameter/identifier">unlockingDu<span class="cupd">r</span>at<span class="cupd">io</span>n</span>,
            uint128 lockedValue
        )
    {
        SubStakeInfo storage info = stakerInfo[_staker].subStakes[_index];
        firstPeriod = info.firstPeriod;
        lastPeriod = info.lastPeriod;
        <span class="marker" id="mapping-734"></span><span class="token upd" id="move-dst-215" data-title="assignment_expression/identifier">unlockingDu<span class="cupd">r</span>at<span class="cupd">io</span>n</span> = info.<span class="marker" id="mapping-735"></span><span class="token upd" id="move-dst-216" data-title="member_expression/identifier">unlockingDu<span class="cupd">r</span>at<span class="cupd">io</span>n</span>;
        lockedValue = info.lockedValue;
    }

    /**
    * @notice Return the length of the array of past downtime
    */
    function getPastDowntimeLength(address _staker) external view returns (uint256) {
        return stakerInfo[_staker].pastDowntime.length;
    }

    /**
    * @notice Return the information about past downtime
    */
    function  getPastDowntime(address _staker, uint256 _index)
    // TODO change to structure when ABIEncoderV2 is released (#1501)
//        public view returns (Downtime)
        external view returns (uint16 startPeriod, uint16 endPeriod)
    {
        Downtime storage downtime = stakerInfo[_staker].pastDowntime[_index];
        startPeriod = downtime.startPeriod;
        endPeriod = downtime.endPeriod;
    }

    //------------------ ERC900 connectors ----------------------

    function totalStakedForAt(address _owner, uint256 _blockNumber) public view override returns (uint256){
        return stakerInfo[_owner].history.getValueAt(_blockNumber);
    }

    function totalStakedAt(uint256 _blockNumber) public view override returns (uint256){
        return balanceHistory.getValueAt(_blockNumber);
    }

    function supportsHistory() external pure override returns (bool){
        return true;
    }

    //------------------------Upgradeable------------------------
    /**
    * @dev Get StakerInfo structure by delegatecall
    */
    function delegateGetStakerInfo(address _target, bytes32 _staker)
        internal returns (StakerInfo memory result)
    {
        bytes32 memoryAddress = delegateGetData(_target, this.stakerInfo.selector, 1, _staker, 0);
        assembly {
            result := memoryAddress
        }
    }

    /**
    * @dev Get SubStakeInfo structure by delegatecall
    */
    function delegateGetSubStakeInfo(address _target, bytes32 _staker, uint256 _index)
        internal returns (SubStakeInfo memory result)
    {
        bytes32 memoryAddress = delegateGetData(
            _target, this.getSubStakeInfo.selector, 2, _staker, bytes32(_index));
        assembly {
            result := memoryAddress
        }
    }

    /**
    * @dev Get Downtime structure by delegatecall
    */
    function delegateGetPastDowntime(address _target, bytes32 _staker, uint256 _index)
        internal returns (Downtime memory result)
    {
        bytes32 memoryAddress = delegateGetData(
            _target, this.getPastDowntime.selector, 2, _staker, bytes32(_index));
        assembly {
            result := memoryAddress
        }
    }

    /// @dev the `onlyWhileUpgrading` modifier works through a call to the parent `verifyState`
    function verifyState(address _testTarget) public override virtual {
        super.verifyState(_testTarget);
        require(<span class="marker" id="mapping-736"></span><span class="token mv" id="move-dst-221" data-title="call_argument/binary_expression">delegateGet(_testTarget, this.lockedPerPeriod.selector,
            bytes32(bytes2(RESERVED_PERIOD))) == <span class="marker" id="mapping-737"></span><span class="token add" data-title="binary_expression/call_expression">lockedPerPeriod(RESERVED_PERIOD)</span></span>);
        require(address(delegateGet(_testTarget, this.stakerFromWorker.selector, bytes32(0))) ==
            stakerFromWorker[address(0)]);

        require(delegateGet(_testTarget, this.getStakersLength.selector) == stakers.length);
        if (stakers.length == 0) {
            return;
        }
        address stakerAddress = stakers[0];
        require(address(uint160(delegateGet(_testTarget, this.stakers.selector, 0))) == stakerAddress);
        StakerInfo storage info = stakerInfo[stakerAddress];
        bytes32 staker = bytes32(uint256(stakerAddress));
        StakerInfo memory infoToCheck = delegateGetStakerInfo(_testTarget, staker);
        require(<span class="marker" id="mapping-738"></span><span class="token mv" id="move-dst-222" data-title="call_argument/binary_expression">infoToCheck.value == info.value &amp;&amp;
            infoToCheck.currentCommittedPeriod == info.currentCommittedPeriod &amp;&amp;
            infoToCheck.nextCommittedPeriod == info.nextCommittedPeriod &amp;&amp;
            infoToCheck.flags == info.flags &amp;&amp;
            infoToCheck.<span class="marker" id="mapping-739"></span><span class="token upd" id="move-dst-223" data-title="member_expression/identifier"><span class="cupd">l</span>astC<span class="cupd">o</span>mmi<span class="cupd">t</span>t<span class="cupd">e</span>d<span class="cupd">Period</span></span> == <span class="marker" id="mapping-740"></span><span class="token mv" id="move-dst-225" data-title="binary_expression/member_expression">info.lastCommittedPeriod</span> &amp;&amp;
            infoToCheck.<span class="marker" id="mapping-741"></span><span class="token upd" id="move-dst-224" data-title="member_expression/identifier">c<span class="cupd">om</span>ple<span class="cupd">t</span><span class="cupd">ed</span>Work</span> == <span class="marker" id="mapping-742"></span><span class="token mv" id="move-dst-227" data-title="binary_expression/member_expression">info.completedWork</span> &amp;&amp;
            infoToCheck.<span class="marker" id="mapping-743"></span><span class="token upd" id="move-dst-226" data-title="member_expression/identifier">w<span class="cupd">o</span>rk<span class="cupd">e</span>r</span> == <span class="marker" id="mapping-744"></span><span class="token mv" id="move-dst-229" data-title="binary_expression/member_expression">info.worker</span> &amp;&amp;
            infoToCheck.<span class="marker" id="mapping-745"></span><span class="token upd" id="move-dst-228" data-title="member_expression/identifier"><span class="cupd">worker</span>StartPeriod</span> == <span class="marker" id="mapping-746"></span><span class="token mv" id="move-dst-230" data-title="binary_expression/member_expression">info.workerStartPeriod</span></span>);

        require(delegateGet(_testTarget, this.getPastDowntimeLength.selector, staker) ==
            info.pastDowntime.length);
        for (uint256 i = 0; i &lt; info.pastDowntime.length &amp;&amp; i &lt; MAX_CHECKED_VALUES; i++) {
            Downtime storage downtime = info.pastDowntime[i];
            Downtime memory downtimeToCheck = delegateGetPastDowntime(_testTarget, staker, i);
            require(downtimeToCheck.startPeriod == downtime.startPeriod &amp;&amp;
                downtimeToCheck.endPeriod == downtime.endPeriod);
        }

        require(delegateGet(_testTarget, this.getSubStakesLength.selector, staker) == info.subStakes.length);
        for (uint256 i = 0; i &lt; info.subStakes.length &amp;&amp; i &lt; MAX_CHECKED_VALUES; i++) {
            SubStakeInfo storage subStakeInfo = info.subStakes[i];
            SubStakeInfo memory subStakeInfoToCheck = delegateGetSubStakeInfo(_testTarget, staker, i);
            require(subStakeInfoToCheck.firstPeriod == subStakeInfo.firstPeriod &amp;&amp;
                subStakeInfoToCheck.lastPeriod == subStakeInfo.lastPeriod &amp;&amp;
                subStakeInfoToCheck.<span class="marker" id="mapping-747"></span><span class="token upd" id="move-dst-231" data-title="member_expression/identifier">unlockingDu<span class="cupd">r</span>at<span class="cupd">io</span>n</span> == subStakeInfo.<span class="marker" id="mapping-748"></span><span class="token upd" id="move-dst-232" data-title="member_expression/identifier">unlockingDu<span class="cupd">r</span>at<span class="cupd">io</span>n</span> &amp;&amp;
                subStakeInfoToCheck.lockedValue == subStakeInfo.lockedValue);
        }

        // it's not perfect because checks not only slot value but also decoding
        // at least without additional functions
        require(delegateGet(_testTarget, this.totalStakedForAt.selector, staker, bytes32(block.number)) ==
            totalStakedForAt(stakerAddress, block.number));
        require(delegateGet(_testTarget, this.totalStakedAt.selector, bytes32(block.number)) ==
            totalStakedAt(block.number));

        if (info.worker != address(0)) {
            require(address(delegateGet(_testTarget, this.stakerFromWorker.selector, bytes32(uint256(info.worker)))) ==
                stakerFromWorker[info.worker]);
        }
    }

    /// @dev the `onlyWhileUpgrading` modifier works through a call to the parent `finishUpgrade`
    function finishUpgrade(address _target) public override virtual {
        super.finishUpgrade(_target);
        // Create fake period
        <span class="marker" id="mapping-749"></span><span class="token upd" id="move-dst-233" data-title="array_access/identifier">_<span class="cupd">lockedPerPeriod</span></span>[RESERVED_PERIOD] = 111;

        // Create fake worker
        stakerFromWorker[address(0)] = address(this);
    }
}
</pre></div></div></div></body></html>