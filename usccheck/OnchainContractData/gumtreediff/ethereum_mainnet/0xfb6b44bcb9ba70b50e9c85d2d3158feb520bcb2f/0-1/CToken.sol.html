<html lang="en"><head><meta charset="utf8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>GumTree</title><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css"><style type="text/css">/*
 * This file is part of GumTree.
 *
 * GumTree is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * GumTree is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with GumTree.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Copyright 2011-2015 Jean-Rémy Falleri <jr.falleri@gmail.com>
 * Copyright 2011-2015 Floréal Morandat <florealm@gmail.com>
 */

.add {
	border: 1px solid black;
	background-color: MediumSeaGreen;
}

.del {
	border: 1px solid black;
	background-color: IndianRed;
}

.mv {
	border: 1px solid black;
	background-color: Plum;
}

.upd {
	border: 1px solid black;
	background-color: DarkOrange;
	font-weight: bold;
}

.cupd {
	font-weight: normal;
	color: DimGray;
}

.selected {
	background-color: Gold;
}

.marker {
	margin: 0;
	padding: 0;
}

div {
	margin: 0px;
	padding: 0px;
}

.pre-scrollable {
	margin: 0px;
	padding: 0px;
	font-size: 10pt;
	color: black;
	max-height: 90vh;
	background-color: white;
	border: 1px solid black;
	font-family: "Hack, Inconsolata", "Consolas", "Liberation Sans Regular", "DejaVu Sans Mono", monospace;
}

.tooltip-inner {
    max-width: none;
}
</style><script type="text/javascript" src="https://code.jquery.com/jquery-3.4.1.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/js/bootstrap.bundle.min.js"></script><script type="text/javascript">/*
 * This file is part of GumTree.
 *
 * GumTree is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * GumTree is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with GumTree.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Copyright 2011-2015 Jean-Rémy Falleri <jr.falleri@gmail.com>
 * Copyright 2011-2015 Floréal Morandat <florealm@gmail.com>
 */

$(function(){
    let popoverTriggerList = [].slice.call(document.querySelectorAll('[data-bs-toggle="popover"]'))
    let popoverList = popoverTriggerList.map(function (popoverTriggerEl) {
      return new bootstrap.Popover(popoverTriggerEl)
    })

    $("body").keypress(function (event) {
        switch (event.which) {
            case 116:
                $('html, body').animate({scrollTop: 0}, 100);
                break;
            case 98:
                $("html, body").animate({ scrollTop: $(document).height() }, 100);
                break;
            case 113:
                window.location = "/quit";
                break;
            case 108:
                window.location = "/list";
                break;
        }
    });
});
</script><script type="text/javascript">/*
 * This file is part of GumTree.
 *
 * GumTree is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * GumTree is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with GumTree.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Copyright 2011-2015 Jean-Rémy Falleri <jr.falleri@gmail.com>
 * Copyright 2011-2015 Floréal Morandat <florealm@gmail.com>
 */

currentMapping = 0;

if (typeof String.prototype.startsWith != 'function') {
  String.prototype.startsWith = function (str){
    return this.slice(0, str.length) == str;
  };
}

function getMappedElement(eltId) {
	if (eltId.startsWith("move-src")) {
		return eltId.replace("src","dst");  	 	
  	}
  	else {
  		return eltId.replace("dst","src");
  	}
}

function nextMapping() {
	if (currentMapping == 0) {
		currentMapping = 1;
		return "#mapping-" + currentMapping.toString();
	} else {
		currentMapping++;
		
		if ($("#mapping-" + currentMapping.toString()).length > 0) {
			return "#mapping-" + currentMapping.toString();
		} else {
			currentMapping = 1;
			return "#mapping-" + currentMapping.toString();		
		}		
	}
}

function isSrc(eltId) {
	return eltId.startsWith("move-src");
}

$(function() {
    $("body").keypress(function (event) {
        switch(event.which) {
            case 110:
                const mapping = $(nextMapping());
                const pre = mapping.closest("pre");
                pre.animate({scrollTop: pre.scrollTop() + mapping.position().top - 200}, 100);
                break;
        }
    });

    // highlight
    $("span.mv.token, span.token.upd").click(function(event) {
        if ($(this).hasClass("selected")) {
            $("span.mv.token, span.token.upd").removeClass("selected");
        } else {
            $("span.mv.token, span.token.upd").removeClass("selected");
            const refElt = $("#" + getMappedElement($(this).attr("id")));
            $(this).addClass("selected");
            refElt.addClass("selected");
            const pre = refElt.closest("pre");
            console.log(pre);
            pre.animate({scrollTop: pre.scrollTop() + refElt.position().top - 200}, 100);
        }
        event.stopPropagation();
    });
    
    $("span.add.token, span.token.del").click(function(event) {
        $("span.mv.token, span.token.upd").removeClass("selected");
        event.stopPropagation();
    });

    // tooltip
    $("span.token").hover(
    	function (event) {
    		$(this).tooltip('show');
    		event.stopPropagation();
    	},
    	function (event) {
    		$(this).tooltip('hide');
    		event.stopPropagation();
    	}
    );
});
</script></head><body><div class="container-fluid"><div class="row"><div class="col"><div class="btn-toolbar justify-content-end"><div class="btn-group mr-2"><button class="btn btn-primary btn-sm" id="legend" data-bs-toggle="popover" data-bs-placement="bottom" data-bs-html="true" data-bs-content="<span class='del'>&nbsp;&nbsp;</span> deleted<br><span class='add'>&nbsp;&nbsp;</span> added<br><span class='mv'>&nbsp;&nbsp;</span> moved<br><span class='upd';>&nbsp;&nbsp;</span> updated<br>">Legend</button><button class="btn btn-primary btn-sm" id="shortcuts" data-bs-toggle="popover" data-bs-placement="bottom" data-bs-html="true" data-bs-content="<b>q</b> quit<br><b>l</b> list<br><b>n</b> next<br><b>t</b> top<br><b>b</b> bottom">Shortcuts</button></div><div class="btn-group"><a href="/list" class="btn btn-default btn-sm btn-primary">Back</a><a href="/quit" class="btn btn-default btn-sm btn-danger">Quit</a></div></div></div></div><div class="row"><div class="col-6"><h5>CToken.sol</h5><pre class="pre-scrollable">pragma solidity ^0.5.16;

import "./ComptrollerInterface.sol";
import "./CTokenInterfaces.sol";
import "./ErrorReporter.sol";
import "./Exponential.sol";
import "./EIP20Interface.sol";
import "./EIP20NonStandardInterface.sol";
import "./InterestRateModel.sol";

/**
 * @title Compound's CToken Contract
 * @notice Abstract base for CTokens
 * @author Compound
 */
contract CToken is CTokenInterface, Exponential, TokenErrorReporter {
    /**
     * @notice Initialize the money market
     * @param comptroller_ The address of the Comptroller
     * @param interestRateModel_ The address of the interest rate model
     * @param initialExchangeRateMantissa_ The initial exchange rate, scaled by 1e18
     * @param name_ EIP-20 name of this token
     * @param symbol_ EIP-20 symbol of this token
     * @param decimals_ EIP-20 decimal precision of this token
     */
    function initialize(ComptrollerInterface comptroller_,
                        InterestRateModel interestRateModel_,
                        uint initialExchangeRateMantissa_,
                        string memory name_,
                        string memory symbol_,
                        uint8 decimals_,
                        uint256 reserveFactorMantissa_,
                        uint256 adminFeeMantissa_) public {
        <span class="marker" id="mapping-1"></span><span class="token mv" id="move-src-1" data-title="function_body/expression_statement">require(hasAdminRights(), "only admin may initialize the market");</span>
        require(accrualBlockNumber == 0 &amp;&amp; borrowIndex == 0, "market may only be initialized once");

        // Set initial exchange rate
        initialExchangeRateMantissa = initialExchangeRateMantissa_;
        require(initialExchangeRateMantissa &gt; 0, "initial exchange rate must be greater than zero.");

        // Set the comptroller
        uint err = _setComptroller(comptroller_);
        require(err == uint(Error.NO_ERROR), "setting comptroller failed");

        // Initialize block number and borrow index (block number mocks depend on comptroller being set)
        accrualBlockNumber = getBlockNumber();
        borrowIndex = mantissaOne;

        // Set the interest rate model (depends on block number / borrow index)
        err = _setInterestRateModelFresh(interestRateModel_);
        require(err == uint(Error.NO_ERROR), "setting interest rate model failed");

        name = name_;
        symbol = symbol_;
        decimals = decimals_;

        // Set reserve factor
        err = _setReserveFactorFresh(reserveFactorMantissa_);
        require(err == uint(Error.NO_ERROR), "setting reserve factor failed");

        // Set admin fee
        err = _setAdminFeeFresh(adminFeeMantissa_);
        require(err == uint(Error.NO_ERROR), "setting admin fee failed");

        <span class="marker" id="mapping-2"></span><span class="token del" data-title="function_body/comment">// Set Fuse fee</span>
        <span class="marker" id="mapping-3"></span><span class="token del" data-title="function_body/expression_statement">err = _setFuseFeeFresh(getPendingFuseFeeFromAdmin());</span>
        <span class="marker" id="mapping-4"></span><span class="token del" data-title="function_body/expression_statement">require(err == uint(Error.NO_ERROR), "setting Fuse fee failed");</span>

        // The counter starts true to prevent changing it from zero to non-zero (i.e. smaller cost/refund)
        _notEntered = true;
    }
    
    /**
     * @dev Returns latest pending Fuse fee (to be set with `_setFuseFeeFresh`)
     */
    function getPendingFuseFeeFromAdmin() internal view returns (uint) {
        return fuseAdmin.interestFeeRate();
    }

    /**
     * @notice Transfer `tokens` tokens from `src` to `dst` by `spender`
     * @dev Called by both `transfer` and `transferFrom` internally
     * @param spender The address of the account performing the transfer
     * @param src The address of the source account
     * @param dst The address of the destination account
     * @param tokens The number of tokens to transfer
     * @return Whether or not the transfer succeeded
     */
    function transferTokens(address spender, address src, address dst, uint tokens) internal returns (uint) {
        /* Fail if transfer not allowed */
        uint allowed = comptroller.transferAllowed(address(this), src, dst, tokens);
        if (allowed != 0) {
            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.TRANSFER_COMPTROLLER_REJECTION, allowed);
        }

        /* Do not allow self-transfers */
        if (src == dst) {
            return fail(Error.BAD_INPUT, FailureInfo.TRANSFER_NOT_ALLOWED);
        }

        /* Get the allowance, infinite for the account owner */
        uint startingAllowance = 0;
        if (spender == src) {
            startingAllowance = uint(-1);
        } else {
            startingAllowance = transferAllowances[src][spender];
        }

        /* Do the calculations, checking for {under,over}flow */
        MathError mathErr;
        uint allowanceNew;
        uint srcTokensNew;
        uint dstTokensNew;

        (mathErr, allowanceNew) = subUInt(startingAllowance, tokens);
        if (mathErr != MathError.NO_ERROR) {
            return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_NOT_ALLOWED);
        }

        (mathErr, srcTokensNew) = subUInt(accountTokens[src], tokens);
        if (mathErr != MathError.NO_ERROR) {
            return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_NOT_ENOUGH);
        }

        (mathErr, dstTokensNew) = addUInt(accountTokens[dst], tokens);
        if (mathErr != MathError.NO_ERROR) {
            return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_TOO_MUCH);
        }

        /////////////////////////
        // EFFECTS &amp; INTERACTIONS
        // (No safe failures beyond this point)

        accountTokens[src] = srcTokensNew;
        accountTokens[dst] = dstTokensNew;

        /* Eat some of the allowance (if necessary) */
        if (startingAllowance != uint(-1)) {
            transferAllowances[src][spender] = allowanceNew;
        }

        /* We emit a Transfer event */
        emit Transfer(src, dst, tokens);

        <span class="marker" id="mapping-5"></span><span class="token del" data-title="function_body/expression_statement"><span class="marker" id="mapping-6"></span><span class="token del" data-title="expression_statement/call_expression"><span class="marker" id="mapping-7"></span><span class="token del" data-title="call_expression/member_expression">comptroller.transferVerify</span>(<span class="marker" id="mapping-8"></span><span class="token mv" id="move-src-2" data-title="call_expression/call_argument">address(this)</span>, <span class="marker" id="mapping-9"></span><span class="token del" data-title="call_expression/call_argument">src</span>, <span class="marker" id="mapping-10"></span><span class="token del" data-title="call_expression/call_argument">dst</span>, <span class="marker" id="mapping-11"></span><span class="token del" data-title="call_expression/call_argument">tokens</span>)</span>;</span>

        return uint(Error.NO_ERROR);
    }

    /**
     * @notice Transfer `amount` tokens from `msg.sender` to `dst`
     * @param dst The address of the destination account
     * @param amount The number of tokens to transfer
     * @return Whether or not the transfer succeeded
     */
    function transfer(address dst, uint256 amount) external nonReentrant returns (bool) {
        return transferTokens(msg.sender, msg.sender, dst, amount) == uint(Error.NO_ERROR);
    }

    /**
     * @notice Transfer `amount` tokens from `src` to `dst`
     * @param src The address of the source account
     * @param dst The address of the destination account
     * @param amount The number of tokens to transfer
     * @return Whether or not the transfer succeeded
     */
    function transferFrom(address src, address dst, uint256 amount) external nonReentrant returns (bool) {
        return transferTokens(msg.sender, src, dst, amount) == uint(Error.NO_ERROR);
    }

    /**
     * @notice Approve `spender` to transfer up to `amount` from `src`
     * @dev This will overwrite the approval amount for `spender`
     *  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)
     * @param spender The address of the account which may transfer tokens
     * @param amount The number of tokens that are approved (-1 means infinite)
     * @return Whether or not the approval succeeded
     */
    function approve(address spender, uint256 amount) external returns (bool) {
        address src = msg.sender;
        transferAllowances[src][spender] = amount;
        emit Approval(src, spender, amount);
        return true;
    }

    /**
     * @notice Get the current allowance from `owner` for `spender`
     * @param owner The address of the account which owns the tokens to be spent
     * @param spender The address of the account which may transfer tokens
     * @return The number of tokens allowed to be spent (-1 means infinite)
     */
    function allowance(address owner, address spender) external view returns (uint256) {
        return transferAllowances[owner][spender];
    }

    /**
     * @notice Get the token balance of the `owner`
     * @param owner The address of the account to query
     * @return The number of tokens owned by `owner`
     */
    function balanceOf(address owner) external view returns (uint256) {
        return accountTokens[owner];
    }

    /**
     * @notice Get the underlying balance of the `owner`
     * @dev This also accrues interest in a transaction
     * @param owner The address of the account to query
     * @return The amount of underlying owned by `owner`
     */
    function balanceOfUnderlying(address owner) external returns (uint) {
        Exp memory exchangeRate = Exp({mantissa: exchangeRateCurrent()});
        (MathError mErr, uint balance) = mulScalarTruncate(exchangeRate, accountTokens[owner]);
        require(mErr == MathError.NO_ERROR, "balance could not be calculated");
        return balance;
    }

    /**
     * @notice Get a snapshot of the account's balances, and the cached exchange rate
     * @dev This is used by comptroller to more efficiently perform liquidity checks.
     * @param account Address of the account to snapshot
     * @return (possible error, token balance, borrow balance, exchange rate mantissa)
     */
    function getAccountSnapshot(address account) external view returns (uint, uint, uint, uint) {
        uint cTokenBalance = accountTokens[account];
        uint borrowBalance;
        uint exchangeRateMantissa;

        MathError mErr;

        (mErr, borrowBalance) = borrowBalanceStoredInternal(account);
        if (mErr != MathError.NO_ERROR) {
            return (uint(Error.MATH_ERROR), 0, 0, 0);
        }

        (mErr, exchangeRateMantissa) = exchangeRateStoredInternal();
        if (mErr != MathError.NO_ERROR) {
            return (uint(Error.MATH_ERROR), 0, 0, 0);
        }

        return (uint(Error.NO_ERROR), cTokenBalance, borrowBalance, exchangeRateMantissa);
    }

    /**
     * @dev Function to simply retrieve block number
     *  This exists mainly for inheriting test contracts to stub this result.
     */
    function getBlockNumber() internal view returns (uint) {
        return block.number;
    }

    /**
     * @notice Returns the current per-block borrow interest rate for this cToken
     * @return The borrow interest rate per block, scaled by 1e18
     */
    function borrowRatePerBlock() external view returns (uint) {
        return interestRateModel.getBorrowRate(getCashPrior(), totalBorrows, <span class="marker" id="mapping-12"></span><span class="token del" data-title="call_argument/binary_expression">totalReserves + totalFuseFees + totalAdminFees</span>);
    }

    /**
     * @notice Returns the current per-block supply interest rate for this cToken
     * @return The supply interest rate per block, scaled by 1e18
     */
    function supplyRatePerBlock() external view returns (uint) {
        return interestRateModel.getSupplyRate(getCashPrior(), totalBorrows, <span class="marker" id="mapping-13"></span><span class="token del" data-title="call_argument/binary_expression">totalReserves + totalFuseFees + totalAdminFees</span>, reserveFactorMantissa + fuseFeeMantissa + adminFeeMantissa);
    }

    /**
     * @notice Returns the current total borrows plus accrued interest
     * @return The total borrows with interest
     */
    function totalBorrowsCurrent() external nonReentrant returns (uint) {
        require(accrueInterest() == uint(Error.NO_ERROR), "accrue interest failed");
        return totalBorrows;
    }

    /**
     * @notice Accrue interest to updated borrowIndex and then calculate account's borrow balance using the updated borrowIndex
     * @param account The address whose balance should be calculated after updating borrowIndex
     * @return The calculated balance
     */
    function borrowBalanceCurrent(address account) external nonReentrant returns (uint) {
        require(accrueInterest() == uint(Error.NO_ERROR), "accrue interest failed");
        return borrowBalanceStored(account);
    }

    /**
     * @notice Return the borrow balance of account based on stored data
     * @param account The address whose balance should be calculated
     * @return The calculated balance
     */
    function borrowBalanceStored(address account) public view returns (uint) {
        (MathError err, uint result) = borrowBalanceStoredInternal(account);
        require(err == MathError.NO_ERROR, "borrowBalanceStored: borrowBalanceStoredInternal failed");
        return result;
    }

    /**
     * @notice Return the borrow balance of account based on stored data
     * @param account The address whose balance should be calculated
     * @return (error code, the calculated balance or 0 if error code is non-zero)
     */
    function borrowBalanceStoredInternal(address account) internal view returns (MathError, uint) {
        /* Note: we do not assert that the market is up to date */
        MathError mathErr;
        uint principalTimesIndex;
        uint result;

        /* Get borrowBalance and borrowIndex */
        BorrowSnapshot storage borrowSnapshot = accountBorrows[account];

        /* If borrowBalance = 0 then borrowIndex is likely also 0.
         * Rather than failing the calculation with a division by 0, we immediately return 0 in this case.
         */
        if (borrowSnapshot.principal == 0) {
            return (MathError.NO_ERROR, 0);
        }

        /* Calculate new borrow balance using the interest index:
         *  recentBorrowBalance = borrower.borrowBalance * market.borrowIndex / borrower.borrowIndex
         */
        (mathErr, principalTimesIndex) = mulUInt(borrowSnapshot.principal, borrowIndex);
        if (mathErr != MathError.NO_ERROR) {
            return (mathErr, 0);
        }

        (mathErr, result) = divUInt(principalTimesIndex, borrowSnapshot.interestIndex);
        if (mathErr != MathError.NO_ERROR) {
            return (mathErr, 0);
        }

        return (MathError.NO_ERROR, result);
    }

    /**
     * @notice Accrue interest then return the up-to-date exchange rate
     * @return Calculated exchange rate scaled by 1e18
     */
    function exchangeRateCurrent() public nonReentrant returns (uint) {
        require(accrueInterest() == uint(Error.NO_ERROR), "accrue interest failed");
        return exchangeRateStored();
    }

    /**
     * @notice Calculates the exchange rate from the underlying to the CToken
     * @dev This function does not accrue interest before calculating the exchange rate
     * @return Calculated exchange rate scaled by 1e18
     */
    function exchangeRateStored() public view returns (uint) {
        (MathError err, uint result) = exchangeRateStoredInternal();
        require(err == MathError.NO_ERROR, "exchangeRateStored: exchangeRateStoredInternal failed");
        return result;
    }

    /**
     * @notice Calculates the exchange rate from the underlying to the CToken
     * @dev This function does not accrue interest before calculating the exchange rate
     * @return (error code, calculated exchange rate scaled by 1e18)
     */
    function exchangeRateStoredInternal() internal view returns (MathError, uint) {
        uint _totalSupply = totalSupply;
        if (_totalSupply == 0) {
            /*
             * If there are no tokens minted:
             *  exchangeRate = initialExchangeRate
             */
            return (MathError.NO_ERROR, initialExchangeRateMantissa);
        } else {
            /*
             * Otherwise:
             *  exchangeRate = (totalCash + totalBorrows - (totalReserves + totalFuseFees + totalAdminFees)) / totalSupply
             */
            uint totalCash = getCashPrior();
            uint cashPlusBorrowsMinusReserves;
            Exp memory exchangeRate;
            MathError mathErr;

            (mathErr, cashPlusBorrowsMinusReserves) = addThenSubUInt(totalCash, totalBorrows, <span class="marker" id="mapping-14"></span><span class="token del" data-title="call_argument/binary_expression">totalReserves + totalFuseFees + totalAdminFees</span>);
            if (mathErr != MathError.NO_ERROR) {
                return (mathErr, 0);
            }

            (mathErr, exchangeRate) = getExp(cashPlusBorrowsMinusReserves, _totalSupply);
            if (mathErr != MathError.NO_ERROR) {
                return (mathErr, 0);
            }

            return (MathError.NO_ERROR, exchangeRate.mantissa);
        }
    }

    /**
     * @notice Get cash balance of this cToken in the underlying asset
     * @return The quantity of underlying asset owned by this contract
     */
    function getCash() external view returns (uint) {
        return getCashPrior();
    }

    /**
     * @notice Applies accrued interest to total borrows and reserves
     * @dev This calculates interest accrued from the last checkpointed block
     *   up to the current block and writes new checkpoint to storage.
     */
    function accrueInterest() public returns (uint) {
        /* Remember the initial block number */
        uint currentBlockNumber = getBlockNumber();

        /* Short-circuit accumulating 0 interest */
        if (accrualBlockNumber == currentBlockNumber) {
            return uint(Error.NO_ERROR);
        }

        /* Read the previous values out of storage */
        uint cashPrior = getCashPrior();

        /* Calculate the current borrow interest rate */
        uint borrowRateMantissa = interestRateModel.getBorrowRate(cashPrior, totalBorrows, <span class="marker" id="mapping-15"></span><span class="token del" data-title="call_argument/binary_expression">totalReserves + totalFuseFees + totalAdminFees</span>);
        require(borrowRateMantissa &lt;= borrowRateMaxMantissa, "borrow rate is absurdly high");

        /* Calculate the number of blocks elapsed since the last accrual */
        (MathError mathErr, uint blockDelta) = subUInt(currentBlockNumber, accrualBlockNumber);
        require(mathErr == MathError.NO_ERROR, "could not calculate block delta");

        return finishInterestAccrual(currentBlockNumber, cashPrior, borrowRateMantissa, blockDelta);
    }

    function finishInterestAccrual(uint currentBlockNumber, uint cashPrior, uint borrowRateMantissa, uint blockDelta) private returns (uint) {
        /*
         * Calculate the interest accumulated into borrows and reserves and the new index:
         *  simpleInterestFactor = borrowRate * blockDelta
         *  interestAccumulated = simpleInterestFactor * totalBorrows
         *  totalBorrowsNew = interestAccumulated + totalBorrows
         *  totalReservesNew = interestAccumulated * reserveFactor + totalReserves
         *  totalFuseFeesNew = interestAccumulated * fuseFee + totalFuseFees
         *  totalAdminFeesNew = interestAccumulated * adminFee + totalAdminFees
         *  borrowIndexNew = simpleInterestFactor * borrowIndex + borrowIndex
         */

        <span class="marker" id="mapping-16"></span><span class="token del" data-title="function_body/variable_declaration_statement">MathError mathErr;</span>
        Exp memory simpleInterestFactor;
        uint interestAccumulated;
        uint totalBorrowsNew;
        <span class="marker" id="mapping-17"></span><span class="token del" data-title="function_body/variable_declaration_statement">uint totalReservesNew;</span>
        <span class="marker" id="mapping-18"></span><span class="token del" data-title="function_body/variable_declaration_statement">uint totalFuseFeesNew;</span>
        <span class="marker" id="mapping-19"></span><span class="token del" data-title="function_body/variable_declaration_statement">uint totalAdminFeesNew;</span>
        uint borrowIndexNew;

        <span class="marker" id="mapping-20"></span><span class="token del" data-title="function_body/expression_statement"><span class="marker" id="mapping-21"></span><span class="token del" data-title="expression_statement/assignment_expression"><span class="marker" id="mapping-22"></span><span class="token del" data-title="assignment_expression/tuple_expression">(mathErr, simpleInterestFactor)</span> = <span class="marker" id="mapping-23"></span><span class="token mv" id="move-src-3" data-title="assignment_expression/call_expression"><span class="marker" id="mapping-24"></span><span class="token upd" id="move-src-4" data-title="call_expression/identifier"><span class="cupd">mul</span>Scalar</span>(Exp({mantissa: borrowRateMantissa}), blockDelta)</span></span>;</span>
        <span class="marker" id="mapping-25"></span><span class="token del" data-title="function_body/if_statement">if (mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_SIMPLE_INTEREST_FACTOR_CALCULATION_FAILED, uint(mathErr));
        }</span>

        <span class="marker" id="mapping-26"></span><span class="token del" data-title="function_body/expression_statement"><span class="marker" id="mapping-27"></span><span class="token del" data-title="expression_statement/assignment_expression"><span class="marker" id="mapping-28"></span><span class="token del" data-title="assignment_expression/tuple_expression">(mathErr, interestAccumulated)</span> = <span class="marker" id="mapping-29"></span><span class="token mv" id="move-src-5" data-title="assignment_expression/call_expression"><span class="marker" id="mapping-30"></span><span class="token upd" id="move-src-6" data-title="call_expression/identifier"><span class="cupd">mul</span><span class="cupd">ScalarTruncate</span></span>(simpleInterestFactor, totalBorrows)</span></span>;</span>
        <span class="marker" id="mapping-31"></span><span class="token del" data-title="function_body/if_statement">if (mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_ACCUMULATED_INTEREST_CALCULATION_FAILED, uint(mathErr));
        }</span>

        <span class="marker" id="mapping-32"></span><span class="token del" data-title="function_body/expression_statement"><span class="marker" id="mapping-33"></span><span class="token del" data-title="expression_statement/assignment_expression"><span class="marker" id="mapping-34"></span><span class="token del" data-title="assignment_expression/tuple_expression">(mathErr, totalBorrowsNew)</span> = <span class="marker" id="mapping-35"></span><span class="token mv" id="move-src-7" data-title="assignment_expression/call_expression"><span class="marker" id="mapping-36"></span><span class="token upd" id="move-src-8" data-title="call_expression/identifier"><span class="cupd">add</span>UInt</span>(interestAccumulated, totalBorrows)</span></span>;</span>
        <span class="marker" id="mapping-37"></span><span class="token del" data-title="function_body/if_statement">if (mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_TOTAL_BORROWS_CALCULATION_FAILED, uint(mathErr));
        }</span>

        <span class="marker" id="mapping-38"></span><span class="token del" data-title="function_body/expression_statement"><span class="marker" id="mapping-39"></span><span class="token del" data-title="expression_statement/assignment_expression"><span class="marker" id="mapping-40"></span><span class="token del" data-title="assignment_expression/tuple_expression">(mathErr, totalReservesNew)</span> = <span class="marker" id="mapping-41"></span><span class="token mv" id="move-src-9" data-title="assignment_expression/call_expression"><span class="marker" id="mapping-42"></span><span class="token upd" id="move-src-10" data-title="call_expression/identifier"><span class="cupd">mul</span><span class="cupd">ScalarTruncateAddUInt</span></span>(Exp({mantissa: reserveFactorMantissa}), interestAccumulated, totalReserves)</span></span>;</span>
        <span class="marker" id="mapping-43"></span><span class="token del" data-title="function_body/if_statement">if (mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_TOTAL_RESERVES_CALCULATION_FAILED, uint(mathErr));
        }</span>

        <span class="marker" id="mapping-44"></span><span class="token del" data-title="function_body/expression_statement"><span class="marker" id="mapping-45"></span><span class="token del" data-title="expression_statement/assignment_expression"><span class="marker" id="mapping-46"></span><span class="token del" data-title="assignment_expression/tuple_expression">(mathErr, totalFuseFeesNew)</span> = <span class="marker" id="mapping-47"></span><span class="token mv" id="move-src-11" data-title="assignment_expression/call_expression"><span class="marker" id="mapping-48"></span><span class="token upd" id="move-src-12" data-title="call_expression/identifier"><span class="cupd">mul</span><span class="cupd">ScalarTruncateAddUInt</span></span>(Exp({mantissa: fuseFeeMantissa}), interestAccumulated, totalFuseFees)</span></span>;</span>
        <span class="marker" id="mapping-49"></span><span class="token del" data-title="function_body/if_statement">if (mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_TOTAL_FUSE_FEES_CALCULATION_FAILED, uint(mathErr));
        }</span>

        <span class="marker" id="mapping-50"></span><span class="token del" data-title="function_body/expression_statement"><span class="marker" id="mapping-51"></span><span class="token del" data-title="expression_statement/assignment_expression"><span class="marker" id="mapping-52"></span><span class="token del" data-title="assignment_expression/tuple_expression">(mathErr, totalAdminFeesNew)</span> = <span class="marker" id="mapping-53"></span><span class="token mv" id="move-src-13" data-title="assignment_expression/call_expression"><span class="marker" id="mapping-54"></span><span class="token upd" id="move-src-14" data-title="call_expression/identifier"><span class="cupd">mul</span><span class="cupd">ScalarTruncateAddUInt</span></span>(Exp({mantissa: adminFeeMantissa}), interestAccumulated, totalAdminFees)</span></span>;</span>
        <span class="marker" id="mapping-55"></span><span class="token del" data-title="function_body/if_statement">if (mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_TOTAL_ADMIN_FEES_CALCULATION_FAILED, uint(mathErr));
        }</span>

        <span class="marker" id="mapping-56"></span><span class="token del" data-title="function_body/expression_statement"><span class="marker" id="mapping-57"></span><span class="token del" data-title="expression_statement/assignment_expression"><span class="marker" id="mapping-58"></span><span class="token del" data-title="assignment_expression/tuple_expression">(mathErr, borrowIndexNew)</span> = <span class="marker" id="mapping-59"></span><span class="token mv" id="move-src-15" data-title="assignment_expression/call_expression"><span class="marker" id="mapping-60"></span><span class="token upd" id="move-src-16" data-title="call_expression/identifier"><span class="cupd">mul</span><span class="cupd">ScalarTruncateAddUInt</span></span>(simpleInterestFactor, borrowIndex, borrowIndex)</span></span>;</span>
        <span class="marker" id="mapping-61"></span><span class="token del" data-title="function_body/if_statement">if (mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_BORROW_INDEX_CALCULATION_FAILED, uint(mathErr));
        }</span>

        /////////////////////////
        // EFFECTS &amp; INTERACTIONS
        // (No safe failures beyond this point)

        /* We write the previously calculated values into storage */
        accrualBlockNumber = currentBlockNumber;
        borrowIndex = borrowIndexNew;
        totalBorrows = totalBorrowsNew;
        totalReserves = totalReservesNew;
        totalFuseFees = totalFuseFeesNew;
        totalAdminFees = totalAdminFeesNew;

        /* We emit an AccrueInterest event */
        emit AccrueInterest(cashPrior, interestAccumulated, borrowIndexNew, totalBorrowsNew);

        return uint(Error.NO_ERROR);
    }

    /**
     * @notice Sender supplies assets into the market and receives cTokens in exchange
     * @dev Accrues interest whether or not the operation succeeds, unless reverted
     * @param mintAmount The amount of the underlying asset to supply
     * @return (uint, uint) An error code (0=success, otherwise a failure, see ErrorReporter.sol), and the actual mint amount.
     */
    function mintInternal(uint mintAmount) internal nonReentrant returns (uint, uint) {
        uint error = accrueInterest();
        if (error != uint(Error.NO_ERROR)) {
            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed
            return (fail(Error(error), FailureInfo.MINT_ACCRUE_INTEREST_FAILED), 0);
        }
        // mintFresh emits the actual Mint event if successful and logs on errors, so we don't need to
        return mintFresh(msg.sender, mintAmount);
    }

    struct MintLocalVars {
        Error err;
        MathError mathErr;
        uint exchangeRateMantissa;
        uint mintTokens;
        uint totalSupplyNew;
        uint accountTokensNew;
        uint actualMintAmount;
    }

    /**
     * @notice User supplies assets into the market and receives cTokens in exchange
     * @dev Assumes interest has already been accrued up to the current block
     * @param minter The address of the account which is supplying the assets
     * @param mintAmount The amount of the underlying asset to supply
     * @return (uint, uint) An error code (0=success, otherwise a failure, see ErrorReporter.sol), and the actual mint amount.
     */
    function mintFresh(address minter, uint mintAmount) internal returns (uint, uint) {
        /* Fail if mint not allowed */
        uint allowed = comptroller.mintAllowed(address(this), minter, mintAmount);
        if (allowed != 0) {
            return (failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.MINT_COMPTROLLER_REJECTION, allowed), 0);
        }

        /* Verify market's block number equals current block number */
        if (accrualBlockNumber != getBlockNumber()) {
            return (fail(Error.MARKET_NOT_FRESH, FailureInfo.MINT_FRESHNESS_CHECK), 0);
        }

        MintLocalVars memory vars;

        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();
        if (vars.mathErr != MathError.NO_ERROR) {
            return (failOpaque(Error.MATH_ERROR, FailureInfo.MINT_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr)), 0);
        }

        // Check max supply
        <span class="marker" id="mapping-62"></span><span class="token del" data-title="function_body/expression_statement"><span class="marker" id="mapping-63"></span><span class="token del" data-title="expression_statement/assignment_expression">allowed = <span class="marker" id="mapping-64"></span><span class="token del" data-title="assignment_expression/call_expression"><span class="marker" id="mapping-65"></span><span class="token del" data-title="call_expression/member_expression">comptroller.mintWithinLimits</span>(<span class="marker" id="mapping-66"></span><span class="token del" data-title="call_expression/call_argument">address(this)</span>, <span class="marker" id="mapping-67"></span><span class="token mv" id="move-src-17" data-title="call_expression/call_argument"><span class="marker" id="mapping-68"></span><span class="token mv" id="move-src-18" data-title="call_argument/member_expression">vars.exchangeRateMantissa</span></span>, <span class="marker" id="mapping-69"></span><span class="token del" data-title="call_expression/call_argument">accountTokens[minter]</span>, <span class="marker" id="mapping-70"></span><span class="token del" data-title="call_expression/call_argument">mintAmount</span>)</span></span>;</span>
        <span class="marker" id="mapping-71"></span><span class="token del" data-title="function_body/if_statement">if (allowed != 0) {
            return (failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.MINT_COMPTROLLER_REJECTION, allowed), 0);
        }</span>

        /////////////////////////
        // EFFECTS &amp; INTERACTIONS
        // (No safe failures beyond this point)

        /*
         *  We call `doTransferIn` for the minter and the mintAmount.
         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.
         *  `doTransferIn` reverts if anything goes wrong, since we can't be sure if
         *  side-effects occurred. The function returns the amount actually transferred,
         *  in case of a fee. On success, the cToken holds an additional `actualMintAmount`
         *  of cash.
         */
        vars.actualMintAmount = doTransferIn(minter, mintAmount);

        /*
         * We get the current exchange rate and calculate the number of cTokens to be minted:
         *  mintTokens = actualMintAmount / exchangeRate
         */

        (vars.mathErr, vars.mintTokens) = divScalarByExpTruncate(vars.actualMintAmount, Exp({mantissa: vars.exchangeRateMantissa}));
        require(vars.mathErr == MathError.NO_ERROR, "MINT_EXCHANGE_CALCULATION_FAILED");

        /*
         * We calculate the new total supply of cTokens and minter token balance, checking for overflow:
         *  totalSupplyNew = totalSupply + mintTokens
         *  accountTokensNew = accountTokens[minter] + mintTokens
         */
        <span class="marker" id="mapping-72"></span><span class="token mv" id="move-src-19" data-title="assignment_expression/tuple_expression">(vars.mathErr, <span class="marker" id="mapping-73"></span><span class="token mv" id="move-src-20" data-title="tuple_expression/member_expression">vars.totalSupplyNew</span>)</span> = <span class="marker" id="mapping-74"></span><span class="token upd" id="move-src-21" data-title="call_expression/identifier"><span class="cupd">add</span>UInt</span>(totalSupply, vars.mintTokens);
        <span class="marker" id="mapping-75"></span><span class="token mv" id="move-src-22" data-title="function_body/expression_statement">require(vars.mathErr == MathError.NO_ERROR, "MINT_NEW_TOTAL_SUPPLY_CALCULATION_FAILED");</span>

        <span class="marker" id="mapping-76"></span><span class="token mv" id="move-src-23" data-title="assignment_expression/tuple_expression">(vars.mathErr, <span class="marker" id="mapping-77"></span><span class="token mv" id="move-src-24" data-title="tuple_expression/member_expression">vars.accountTokensNew</span>)</span> = <span class="marker" id="mapping-78"></span><span class="token upd" id="move-src-25" data-title="call_expression/identifier"><span class="cupd">add</span>UInt</span>(accountTokens[minter], vars.mintTokens);
        <span class="marker" id="mapping-79"></span><span class="token del" data-title="function_body/expression_statement">require(vars.mathErr == MathError.NO_ERROR, "MINT_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED");</span>

        /* We write previously calculated values into storage */
        totalSupply = vars.totalSupplyNew;
        accountTokens[minter] = vars.accountTokensNew;

        /* We emit a Mint event, and a Transfer event */
        emit Mint(minter, vars.actualMintAmount, vars.mintTokens);
        emit Transfer(address(this), minter, vars.mintTokens);

        /* We call the defense hook */
        comptroller.mintVerify(address(this), minter, vars.actualMintAmount, vars.mintTokens);

        return (uint(Error.NO_ERROR), vars.actualMintAmount);
    }

    /**
     * @notice Sender redeems cTokens in exchange for the underlying asset
     * @dev Accrues interest whether or not the operation succeeds, unless reverted
     * @param redeemTokens The number of cTokens to redeem into underlying
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function redeemInternal(uint redeemTokens) internal nonReentrant returns (uint) {
        uint error = accrueInterest();
        if (error != uint(Error.NO_ERROR)) {
            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted redeem failed
            return fail(Error(error), FailureInfo.REDEEM_ACCRUE_INTEREST_FAILED);
        }
        // redeemFresh emits redeem-specific logs on errors, so we don't need to
        return redeemFresh(msg.sender, redeemTokens, 0);
    }

    /**
     * @notice Sender redeems cTokens in exchange for a specified amount of underlying asset
     * @dev Accrues interest whether or not the operation succeeds, unless reverted
     * @param redeemAmount The amount of underlying to receive from redeeming cTokens
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function redeemUnderlyingInternal(uint redeemAmount) internal nonReentrant returns (uint) {
        uint error = accrueInterest();
        if (error != uint(Error.NO_ERROR)) {
            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted redeem failed
            return fail(Error(error), FailureInfo.REDEEM_ACCRUE_INTEREST_FAILED);
        }
        // redeemFresh emits redeem-specific logs on errors, so we don't need to
        return redeemFresh(msg.sender, 0, redeemAmount);
    }

    struct RedeemLocalVars {
        Error err;
        MathError mathErr;
        uint exchangeRateMantissa;
        uint redeemTokens;
        uint redeemAmount;
        uint totalSupplyNew;
        uint accountTokensNew;
    }

    /**
     * @notice User redeems cTokens in exchange for the underlying asset
     * @dev Assumes interest has already been accrued up to the current block
     * @param redeemer The address of the account which is redeeming the tokens
     * @param redeemTokensIn The number of cTokens to redeem into underlying (only one of redeemTokensIn or redeemAmountIn may be non-zero)
     * @param redeemAmountIn The number of underlying tokens to receive from redeeming cTokens (only one of redeemTokensIn or redeemAmountIn may be non-zero)
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {
        require(redeemTokensIn == 0 || redeemAmountIn == 0, "one of redeemTokensIn or redeemAmountIn must be zero");

        RedeemLocalVars memory vars;

        /* exchangeRate = invoke Exchange Rate Stored() */
        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));
        }

        /* If redeemTokensIn &gt; 0: */
        if (redeemTokensIn &gt; 0) {
            /*
             * We calculate the exchange rate and the amount of underlying to be redeemed:
             *  redeemTokens = redeemTokensIn
             *  redeemAmount = redeemTokensIn x exchangeRateCurrent
             */
            vars.redeemTokens = redeemTokensIn;

            (vars.mathErr, vars.redeemAmount) = mulScalarTruncate(Exp({mantissa: vars.exchangeRateMantissa}), redeemTokensIn);
            if (vars.mathErr != MathError.NO_ERROR) {
                return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_TOKENS_CALCULATION_FAILED, uint(vars.mathErr));
            }
        } else {
            /*
             * We get the current exchange rate and calculate the amount to be redeemed:
             *  redeemTokens = redeemAmountIn / exchangeRate
             *  redeemAmount = redeemAmountIn
             */

            (vars.mathErr, vars.redeemTokens) = divScalarByExpTruncate(redeemAmountIn, Exp({mantissa: vars.exchangeRateMantissa}));
            if (vars.mathErr != MathError.NO_ERROR) {
                return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_AMOUNT_CALCULATION_FAILED, uint(vars.mathErr));
            }

            vars.redeemAmount = redeemAmountIn;
        }

        /* Fail if redeem not allowed */
        uint allowed = comptroller.redeemAllowed(address(this), redeemer, vars.redeemTokens);
        if (allowed != 0) {
            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.REDEEM_COMPTROLLER_REJECTION, allowed);
        }

        /* Verify market's block number equals current block number */
        if (accrualBlockNumber != getBlockNumber()) {
            return fail(Error.MARKET_NOT_FRESH, FailureInfo.REDEEM_FRESHNESS_CHECK);
        }

        /*
         * We calculate the new total supply and redeemer balance, checking for underflow:
         *  totalSupplyNew = totalSupply - redeemTokens
         *  accountTokensNew = accountTokens[redeemer] - redeemTokens
         */
        (vars.mathErr, vars.totalSupplyNew) = subUInt(totalSupply, vars.redeemTokens);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_NEW_TOTAL_SUPPLY_CALCULATION_FAILED, uint(vars.mathErr));
        }

        (vars.mathErr, vars.accountTokensNew) = subUInt(accountTokens[redeemer], vars.redeemTokens);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));
        }

        /* Fail gracefully if protocol has insufficient cash */
        if (getCashPrior() &lt; vars.redeemAmount) {
            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.REDEEM_TRANSFER_OUT_NOT_POSSIBLE);
        }

        /////////////////////////
        // EFFECTS &amp; INTERACTIONS
        // (No safe failures beyond this point)

        /*
         * We invoke doTransferOut for the redeemer and the redeemAmount.
         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.
         *  On success, the cToken has redeemAmount less of cash.
         *  doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.
         */
        doTransferOut(redeemer, vars.redeemAmount);

        /* We write previously calculated values into storage */
        totalSupply = vars.totalSupplyNew;
        accountTokens[redeemer] = vars.accountTokensNew;

        /* We emit a Transfer event, and a Redeem event */
        emit Transfer(redeemer, address(this), vars.redeemTokens);
        emit Redeem(redeemer, vars.redeemAmount, vars.redeemTokens);

        /* We call the defense hook */
        comptroller.redeemVerify(address(this), redeemer, vars.redeemAmount, vars.redeemTokens);

        return uint(Error.NO_ERROR);
    }

    /**
      * @notice Sender borrows assets from the protocol to their own address
      * @param borrowAmount The amount of the underlying asset to borrow
      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
      */
    function borrowInternal(uint borrowAmount) internal nonReentrant returns (uint) {
        uint error = accrueInterest();
        if (error != uint(Error.NO_ERROR)) {
            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed
            return fail(Error(error), FailureInfo.BORROW_ACCRUE_INTEREST_FAILED);
        }
        // borrowFresh emits borrow-specific logs on errors, so we don't need to
        return borrowFresh(msg.sender, borrowAmount);
    }

    struct BorrowLocalVars {
        MathError mathErr;
        uint accountBorrows;
        uint accountBorrowsNew;
        uint totalBorrowsNew;
    }

    /**
      * @notice Users borrow assets from the protocol to their own address
      * @param borrowAmount The amount of the underlying asset to borrow
      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
      */
    function borrowFresh(address payable borrower, uint borrowAmount) internal returns (uint) {
        /* Fail if borrow not allowed */
        uint allowed = comptroller.borrowAllowed(address(this), borrower, borrowAmount);
        if (allowed != 0) {
            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.BORROW_COMPTROLLER_REJECTION, allowed);
        }

        /* Verify market's block number equals current block number */
        if (accrualBlockNumber != getBlockNumber()) {
            return fail(Error.MARKET_NOT_FRESH, FailureInfo.BORROW_FRESHNESS_CHECK);
        }

        /* Fail gracefully if protocol has insufficient underlying cash */
        uint cashPrior = getCashPrior();

        if (cashPrior &lt; borrowAmount) {
            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.BORROW_CASH_NOT_AVAILABLE);
        }

        BorrowLocalVars memory vars;

        /*
         * We calculate the new borrower and total borrow balances, failing on overflow:
         *  accountBorrowsNew = accountBorrows + borrowAmount
         *  totalBorrowsNew = totalBorrows + borrowAmount
         */
        (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));
        }

        (vars.mathErr, vars.accountBorrowsNew) = addUInt(vars.accountBorrows, borrowAmount);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));
        }

        // Check min borrow for this user for this asset
        allowed = comptroller.borrowWithinLimits(address(this), vars.accountBorrowsNew);
        if (allowed != 0) {
            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.BORROW_COMPTROLLER_REJECTION, allowed);
        }

        (vars.mathErr, vars.totalBorrowsNew) = addUInt(totalBorrows, borrowAmount);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));
        }

        <span class="marker" id="mapping-80"></span><span class="token mv" id="move-src-26" data-title="function_body/comment"><span class="marker" id="mapping-81"></span><span class="token upd" id="move-src-27" data-title="function_body/comment"><span class="cupd">// </span>Ch<span class="cupd">e</span>ck<span class="cupd"> </span>max <span class="cupd">u</span><span class="cupd">ti</span>lizati<span class="cupd">on</span> rate for this asset</span></span>
        <span class="marker" id="mapping-82"></span><span class="token del" data-title="function_body/variable_declaration_statement"><span class="marker" id="mapping-83"></span><span class="token mv" id="move-src-28" data-title="variable_declaration_statement/variable_declaration">uint <span class="marker" id="mapping-84"></span><span class="token upd" id="move-src-29" data-title="variable_declaration/identifier">m<span class="cupd">a</span>xUti<span class="cupd">l</span><span class="cupd">i</span>zatio<span class="cupd">n</span>Rate</span></span> = <span class="marker" id="mapping-85"></span><span class="token del" data-title="variable_declaration_statement/call_expression">fuseAdmin.maxUtilizationRate()</span>;</span>

        <span class="marker" id="mapping-86"></span><span class="token del" data-title="function_body/if_statement">if (<span class="marker" id="mapping-87"></span><span class="token mv" id="move-src-30" data-title="if_statement/binary_expression"><span class="marker" id="mapping-88"></span><span class="token upd" id="move-src-31" data-title="binary_expression/identifier"><span class="cupd">m</span>axUt<span class="cupd">i</span>liz<span class="cupd">a</span><span class="cupd">ti</span>onRate</span> <span class="marker" id="mapping-89"></span><span class="token del" data-title="binary_expression/<">&lt;</span> uint(-1)</span>) <span class="marker" id="mapping-90"></span><span class="token del" data-title="if_statement/block_statement">{
            uint256 utilizationRate = vars.totalBorrowsNew == 0 ? 0 : vars.totalBorrowsNew * 1e18 / (cashPrior + totalBorrows - (totalReserves + totalFuseFees + totalAdminFees));
            if (utilizationRate &gt; maxUtilizationRate) return fail(Error.UTILIZATION_ABOVE_MAX, FailureInfo.NEW_UTILIZATION_RATE_ABOVE_MAX);
        }</span></span>

        /////////////////////////
        // EFFECTS &amp; INTERACTIONS
        // (No safe failures beyond this point)

        /*
         * We invoke doTransferOut for the borrower and the borrowAmount.
         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.
         *  On success, the cToken borrowAmount less of cash.
         *  doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.
         */
        doTransferOut(borrower, borrowAmount);

        /* We write the previously calculated values into storage */
        accountBorrows[borrower].principal = vars.accountBorrowsNew;
        accountBorrows[borrower].interestIndex = borrowIndex;
        totalBorrows = vars.totalBorrowsNew;

        /* We emit a Borrow event */
        emit Borrow(borrower, borrowAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);

        /* We call the defense hook */
        <span class="marker" id="mapping-91"></span><span class="token del" data-title="function_body/expression_statement"><span class="marker" id="mapping-92"></span><span class="token del" data-title="expression_statement/call_expression"><span class="marker" id="mapping-93"></span><span class="token del" data-title="call_expression/member_expression">comptroller.borrowVerify</span>(<span class="marker" id="mapping-94"></span><span class="token mv" id="move-src-32" data-title="call_expression/call_argument">address(this)</span>, <span class="marker" id="mapping-95"></span><span class="token mv" id="move-src-33" data-title="call_expression/call_argument">borrower</span>, <span class="marker" id="mapping-96"></span><span class="token del" data-title="call_expression/call_argument">borrowAmount</span>)</span>;</span>

        return uint(Error.NO_ERROR);
    }

    /**
     * @notice Sender repays their own borrow
     * @param repayAmount The amount to repay
     * @return (uint, uint) An error code (0=success, otherwise a failure, see ErrorReporter.sol), and the actual repayment amount.
     */
    function repayBorrowInternal(uint repayAmount) internal nonReentrant returns (uint, uint) {
        uint error = accrueInterest();
        if (error != uint(Error.NO_ERROR)) {
            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed
            return (fail(Error(error), FailureInfo.REPAY_BORROW_ACCRUE_INTEREST_FAILED), 0);
        }
        // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don't need to
        return repayBorrowFresh(msg.sender, msg.sender, repayAmount);
    }

    /**
     * @notice Sender repays a borrow belonging to borrower
     * @param borrower the account with the debt being payed off
     * @param repayAmount The amount to repay
     * @return (uint, uint) An error code (0=success, otherwise a failure, see ErrorReporter.sol), and the actual repayment amount.
     */
    function repayBorrowBehalfInternal(address borrower, uint repayAmount) internal nonReentrant returns (uint, uint) {
        uint error = accrueInterest();
        if (error != uint(Error.NO_ERROR)) {
            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed
            return (fail(Error(error), FailureInfo.REPAY_BEHALF_ACCRUE_INTEREST_FAILED), 0);
        }
        // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don't need to
        return repayBorrowFresh(msg.sender, borrower, repayAmount);
    }

    struct RepayBorrowLocalVars {
        Error err;
        MathError mathErr;
        uint repayAmount;
        uint borrowerIndex;
        uint accountBorrows;
        uint accountBorrowsNew;
        uint totalBorrowsNew;
        uint actualRepayAmount;
    }

    /**
     * @notice Borrows are repaid by another user (possibly the borrower).
     * @param payer the account paying off the borrow
     * @param borrower the account with the debt being payed off
     * @param repayAmount the amount of undelrying tokens being returned
     * @return (uint, uint) An error code (0=success, otherwise a failure, see ErrorReporter.sol), and the actual repayment amount.
     */
    function repayBorrowFresh(address payer, address borrower, uint repayAmount) internal returns (uint, uint) {
        /* Fail if repayBorrow not allowed */
        uint allowed = comptroller.repayBorrowAllowed(address(this), payer, borrower, repayAmount);
        if (allowed != 0) {
            return (failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.REPAY_BORROW_COMPTROLLER_REJECTION, allowed), 0);
        }

        /* Verify market's block number equals current block number */
        if (accrualBlockNumber != getBlockNumber()) {
            return (fail(Error.MARKET_NOT_FRESH, FailureInfo.REPAY_BORROW_FRESHNESS_CHECK), 0);
        }

        RepayBorrowLocalVars memory vars;

        /* We remember the original borrowerIndex for verification purposes */
        vars.borrowerIndex = accountBorrows[borrower].interestIndex;

        /* We fetch the amount the borrower owes, with accumulated interest */
        (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);
        if (vars.mathErr != MathError.NO_ERROR) {
            return (failOpaque(Error.MATH_ERROR, FailureInfo.REPAY_BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED, uint(vars.mathErr)), 0);
        }

        /* If repayAmount == -1, repayAmount = accountBorrows */
        if (repayAmount == uint(-1)) {
            vars.repayAmount = vars.accountBorrows;
        } else {
            vars.repayAmount = repayAmount;
        }

        /////////////////////////
        // EFFECTS &amp; INTERACTIONS
        // (No safe failures beyond this point)

        /*
         * We call doTransferIn for the payer and the repayAmount
         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.
         *  On success, the cToken holds an additional repayAmount of cash.
         *  doTransferIn reverts if anything goes wrong, since we can't be sure if side effects occurred.
         *   it returns the amount actually transferred, in case of a fee.
         */
        vars.actualRepayAmount = doTransferIn(payer, vars.repayAmount);

        /*
         * We calculate the new borrower and total borrow balances, failing on underflow:
         *  accountBorrowsNew = accountBorrows - actualRepayAmount
         *  totalBorrowsNew = totalBorrows - actualRepayAmount
         */
        (vars.mathErr, vars.accountBorrowsNew) = subUInt(vars.accountBorrows, vars.actualRepayAmount);
        require(vars.mathErr == MathError.NO_ERROR, "REPAY_BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED");

        (vars.mathErr, vars.totalBorrowsNew) = subUInt(totalBorrows, vars.actualRepayAmount);
        require(vars.mathErr == MathError.NO_ERROR, "REPAY_BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED");

        /* We write the previously calculated values into storage */
        accountBorrows[borrower].principal = vars.accountBorrowsNew;
        accountBorrows[borrower].interestIndex = borrowIndex;
        totalBorrows = vars.totalBorrowsNew;

        /* We emit a RepayBorrow event */
        emit RepayBorrow(payer, borrower, vars.actualRepayAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);

        /* We call the defense hook */
        <span class="marker" id="mapping-97"></span><span class="token del" data-title="function_body/expression_statement">comptroller.repayBorrowVerify(address(this), payer, borrower, vars.actualRepayAmount, vars.borrowerIndex);</span>

        return (uint(Error.NO_ERROR), vars.actualRepayAmount);
    }

    /**
     * @notice The sender liquidates the borrowers collateral.
     *  The collateral seized is transferred to the liquidator.
     * @param borrower The borrower of this cToken to be liquidated
     * @param cTokenCollateral The market in which to seize collateral from the borrower
     * @param repayAmount The amount of the underlying borrowed asset to repay
     * @return (uint, uint) An error code (0=success, otherwise a failure, see ErrorReporter.sol), and the actual repayment amount.
     */
    function liquidateBorrowInternal(address borrower, uint repayAmount, CTokenInterface cTokenCollateral) internal nonReentrant returns (uint, uint) {
        uint error = accrueInterest();
        if (error != uint(Error.NO_ERROR)) {
            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted liquidation failed
            return (fail(Error(error), FailureInfo.LIQUIDATE_ACCRUE_BORROW_INTEREST_FAILED), 0);
        }

        error = cTokenCollateral.accrueInterest();
        if (error != uint(Error.NO_ERROR)) {
            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted liquidation failed
            return (fail(Error(error), FailureInfo.LIQUIDATE_ACCRUE_COLLATERAL_INTEREST_FAILED), 0);
        }

        // liquidateBorrowFresh emits borrow-specific logs on errors, so we don't need to
        return liquidateBorrowFresh(msg.sender, borrower, repayAmount, cTokenCollateral);
    }

    /**
     * @notice The liquidator liquidates the borrowers collateral.
     *  The collateral seized is transferred to the liquidator.
     * @param borrower The borrower of this cToken to be liquidated
     * @param liquidator The address repaying the borrow and seizing collateral
     * @param cTokenCollateral The market in which to seize collateral from the borrower
     * @param repayAmount The amount of the underlying borrowed asset to repay
     * @return (uint, uint) An error code (0=success, otherwise a failure, see ErrorReporter.sol), and the actual repayment amount.
     */
    function liquidateBorrowFresh(address liquidator, address borrower, uint repayAmount, CTokenInterface cTokenCollateral) internal returns (uint, uint) {
        /* Fail if liquidate not allowed */
        uint allowed = comptroller.liquidateBorrowAllowed(address(this), address(cTokenCollateral), liquidator, borrower, repayAmount);
        if (allowed != 0) {
            return (failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.LIQUIDATE_COMPTROLLER_REJECTION, allowed), 0);
        }

        /* Verify market's block number equals current block number */
        if (accrualBlockNumber != getBlockNumber()) {
            return (fail(Error.MARKET_NOT_FRESH, FailureInfo.LIQUIDATE_FRESHNESS_CHECK), 0);
        }

        /* Verify cTokenCollateral market's block number equals current block number */
        if (cTokenCollateral.accrualBlockNumber() != getBlockNumber()) {
            return (fail(Error.MARKET_NOT_FRESH, FailureInfo.LIQUIDATE_COLLATERAL_FRESHNESS_CHECK), 0);
        }

        /* Fail if borrower = liquidator */
        if (borrower == liquidator) {
            return (fail(Error.INVALID_ACCOUNT_PAIR, FailureInfo.LIQUIDATE_LIQUIDATOR_IS_BORROWER), 0);
        }

        /* Fail if repayAmount = 0 */
        if (repayAmount == 0) {
            return (fail(Error.INVALID_CLOSE_AMOUNT_REQUESTED, FailureInfo.LIQUIDATE_CLOSE_AMOUNT_IS_ZERO), 0);
        }

        /* Fail if repayAmount = -1 */
        if (repayAmount == uint(-1)) {
            return (fail(Error.INVALID_CLOSE_AMOUNT_REQUESTED, FailureInfo.LIQUIDATE_CLOSE_AMOUNT_IS_UINT_MAX), 0);
        }


        /* Fail if repayBorrow fails */
        (uint repayBorrowError, uint actualRepayAmount) = repayBorrowFresh(liquidator, borrower, repayAmount);
        if (repayBorrowError != uint(Error.NO_ERROR)) {
            return (fail(Error(repayBorrowError), FailureInfo.LIQUIDATE_REPAY_BORROW_FRESH_FAILED), 0);
        }

        /////////////////////////
        // EFFECTS &amp; INTERACTIONS
        // (No safe failures beyond this point)

        /* We calculate the number of collateral tokens that will be seized */
        (uint amountSeizeError, uint seizeTokens) = comptroller.liquidateCalculateSeizeTokens(address(this), address(cTokenCollateral), actualRepayAmount);
        require(amountSeizeError == uint(Error.NO_ERROR), "LIQUIDATE_COMPTROLLER_CALCULATE_AMOUNT_SEIZE_FAILED");

        /* Revert if borrower collateral token balance &lt; seizeTokens */
        require(cTokenCollateral.balanceOf(borrower) &gt;= seizeTokens, "LIQUIDATE_SEIZE_TOO_MUCH");

        // If this is also the collateral, run seizeInternal to avoid re-entrancy, otherwise make an external call
        uint seizeError;
        if (address(cTokenCollateral) == address(this)) {
            seizeError = seizeInternal(address(this), liquidator, borrower, seizeTokens);
        } else {
            seizeError = cTokenCollateral.seize(liquidator, borrower, seizeTokens);
        }

        /* Revert if seize tokens fails (since we cannot be sure of side effects) */
        require(seizeError == uint(Error.NO_ERROR), "token seizure failed");

        /* We emit a LiquidateBorrow event */
        emit LiquidateBorrow(liquidator, borrower, actualRepayAmount, address(cTokenCollateral), seizeTokens);

        /* We call the defense hook */
        <span class="marker" id="mapping-98"></span><span class="token del" data-title="function_body/expression_statement"><span class="marker" id="mapping-99"></span><span class="token del" data-title="expression_statement/call_expression"><span class="marker" id="mapping-100"></span><span class="token del" data-title="call_expression/member_expression">comptroller.liquidateBorrowVerify</span>(<span class="marker" id="mapping-101"></span><span class="token del" data-title="call_expression/call_argument">address(this)</span>, <span class="marker" id="mapping-102"></span><span class="token del" data-title="call_expression/call_argument"><span class="marker" id="mapping-103"></span><span class="token del" data-title="call_argument/type_cast_expression"><span class="marker" id="mapping-104"></span><span class="token mv" id="move-src-34" data-title="type_cast_expression/primitive_type">address</span>(<span class="marker" id="mapping-105"></span><span class="token del" data-title="type_cast_expression/call_argument">cTokenCollateral</span>)</span></span>, <span class="marker" id="mapping-106"></span><span class="token del" data-title="call_expression/call_argument">liquidator</span>, <span class="marker" id="mapping-107"></span><span class="token del" data-title="call_expression/call_argument">borrower</span>, <span class="marker" id="mapping-108"></span><span class="token del" data-title="call_expression/call_argument">actualRepayAmount</span>, <span class="marker" id="mapping-109"></span><span class="token del" data-title="call_expression/call_argument">seizeTokens</span>)</span>;</span>

        return (uint(Error.NO_ERROR), actualRepayAmount);
    }

    /**
     * @notice Transfers collateral tokens (this market) to the liquidator.
     * @dev Will fail unless called by another cToken during the process of liquidation.
     *  Its absolutely critical to use msg.sender as the borrowed cToken and not a parameter.
     * @param liquidator The account receiving seized collateral
     * @param borrower The account having collateral seized
     * @param seizeTokens The number of cTokens to seize
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function seize(address liquidator, address borrower, uint seizeTokens) external nonReentrant returns (uint) {
        return seizeInternal(msg.sender, liquidator, borrower, seizeTokens);
    }

    /**
     * @notice Transfers collateral tokens (this market) to the liquidator.
     * @dev Called only during an in-kind liquidation, or by liquidateBorrow during the liquidation of another CToken.
     *  Its absolutely critical to use msg.sender as the seizer cToken and not a parameter.
     * @param seizerToken The contract seizing the collateral (i.e. borrowed cToken)
     * @param liquidator The account receiving seized collateral
     * @param borrower The account having collateral seized
     * @param seizeTokens The number of cTokens to seize
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function seizeInternal(address seizerToken, address liquidator, address borrower, uint seizeTokens) internal returns (uint) {
        /* Fail if seize not allowed */
        uint allowed = comptroller.seizeAllowed(address(this), seizerToken, liquidator, borrower, seizeTokens);
        if (allowed != 0) {
            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.LIQUIDATE_SEIZE_COMPTROLLER_REJECTION, allowed);
        }

        /* Fail if borrower = liquidator */
        if (borrower == liquidator) {
            return fail(Error.INVALID_ACCOUNT_PAIR, FailureInfo.LIQUIDATE_SEIZE_LIQUIDATOR_IS_BORROWER);
        }

        <span class="marker" id="mapping-110"></span><span class="token del" data-title="function_body/variable_declaration_statement">MathError mathErr;</span>
        <span class="marker" id="mapping-111"></span><span class="token del" data-title="function_body/variable_declaration_statement"><span class="marker" id="mapping-112"></span><span class="token mv" id="move-src-35" data-title="variable_declaration_statement/variable_declaration">uint <span class="marker" id="mapping-113"></span><span class="token upd" id="move-src-36" data-title="variable_declaration/identifier">b<span class="cupd">o</span>rrow<span class="cupd">e</span>rTok<span class="cupd">e</span>n<span class="cupd">sNew</span></span></span>;</span>
        <span class="marker" id="mapping-114"></span><span class="token del" data-title="function_body/variable_declaration_statement"><span class="marker" id="mapping-115"></span><span class="token mv" id="move-src-37" data-title="variable_declaration_statement/variable_declaration">uint <span class="marker" id="mapping-116"></span><span class="token upd" id="move-src-38" data-title="variable_declaration/identifier">liquida<span class="cupd">to</span><span class="cupd">r</span>Tok<span class="cupd">e</span>n<span class="cupd">sNew</span></span></span>;</span>

        /*
         * We calculate the new borrower and liquidator token balances, failing on underflow/overflow:
         *  borrowerTokensNew = accountTokens[borrower] - seizeTokens
         *  liquidatorTokensNew = accountTokens[liquidator] + seizeTokens
         */
        <span class="marker" id="mapping-117"></span><span class="token del" data-title="assignment_expression/tuple_expression">(mathErr, borrowerTokensNew)</span> = subUInt(accountTokens[borrower], seizeTokens);
        if (<span class="marker" id="mapping-118"></span><span class="token del" data-title="binary_expression/identifier">mathErr</span> != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.LIQUIDATE_SEIZE_BALANCE_DECREMENT_FAILED, uint(<span class="marker" id="mapping-119"></span><span class="token del" data-title="call_argument/identifier">mathErr</span>));
        }

        <span class="marker" id="mapping-120"></span><span class="token del" data-title="assignment_expression/tuple_expression">(mathErr, liquidatorTokensNew)</span> = addUInt(accountTokens[liquidator], <span class="marker" id="mapping-121"></span><span class="token mv" id="move-src-39" data-title="call_expression/call_argument">seizeTokens</span>);
        if (<span class="marker" id="mapping-122"></span><span class="token del" data-title="binary_expression/identifier">mathErr</span> != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.LIQUIDATE_SEIZE_BALANCE_INCREMENT_FAILED, uint(<span class="marker" id="mapping-123"></span><span class="token del" data-title="call_argument/identifier">mathErr</span>));
        }

        /////////////////////////
        // EFFECTS &amp; INTERACTIONS
        // (No safe failures beyond this point)

        /* We write the previously calculated values into storage */
        accountTokens[borrower] = <span class="marker" id="mapping-124"></span><span class="token del" data-title="assignment_expression/identifier">borrowerTokensNew</span>;
        accountTokens[liquidator] = <span class="marker" id="mapping-125"></span><span class="token del" data-title="assignment_expression/identifier">liquidatorTokensNew</span>;

        /* Emit a Transfer event */
        emit Transfer(borrower, liquidator, <span class="marker" id="mapping-126"></span><span class="token del" data-title="call_argument/identifier">seizeTokens</span>);

        /* We call the defense hook */
        <span class="marker" id="mapping-127"></span><span class="token del" data-title="function_body/expression_statement"><span class="marker" id="mapping-128"></span><span class="token del" data-title="expression_statement/call_expression"><span class="marker" id="mapping-129"></span><span class="token del" data-title="call_expression/member_expression">comptroller.seizeVerify</span>(<span class="marker" id="mapping-130"></span><span class="token del" data-title="call_expression/call_argument">address(this)</span>, <span class="marker" id="mapping-131"></span><span class="token del" data-title="call_expression/call_argument">seizerToken</span>, <span class="marker" id="mapping-132"></span><span class="token del" data-title="call_expression/call_argument">liquidator</span>, <span class="marker" id="mapping-133"></span><span class="token del" data-title="call_expression/call_argument">borrower</span>, <span class="marker" id="mapping-134"></span><span class="token mv" id="move-src-40" data-title="call_expression/call_argument">seizeTokens</span>)</span>;</span>

        return uint(Error.NO_ERROR);
    }


    /*** Admin Functions ***/

    <span class="marker" id="mapping-135"></span><span class="token mv" id="move-src-41" data-title="contract_body/comment"><span class="marker" id="mapping-136"></span><span class="token upd" id="move-src-42" data-title="contract_body/comment"><span class="cupd">/**
    </span> <span class="cupd"> * @notice R</span>en<span class="cupd">o</span><span class="cupd">u</span>nc<span class="cupd">e</span> th<span class="cupd">e</span> Fu<span class="cupd">s</span>e<span class="cupd"> </span>adm<span class="cupd">in</span> <span class="cupd">r</span>ig<span class="cupd">h</span>ts.
      * @ret<span class="cupd">u</span><span class="cupd">r</span>n<span class="cupd"> </span>u<span class="cupd">i</span><span class="cupd">n</span>t <span class="cupd">0</span>=su<span class="cupd">c</span>cess, o<span class="cupd">th</span>erwi<span class="cupd">s</span><span class="cupd">e</span><span class="cupd"> </span>a<span class="cupd"> </span><span class="cupd">f</span>ailu<span class="cupd">r</span>e (see<span class="cupd"> </span>ErrorRep<span class="cupd">o</span>rte<span class="cupd">r</span>.s<span class="cupd">o</span>l f<span class="cupd">o</span>r detail<span class="cupd">s)
</span>   <span class="cupd">  </span> */</span></span>
    <span class="marker" id="mapping-137"></span><span class="token del" data-title="contract_body/function_definition">function _renounceFuseAdminRights() <span class="marker" id="mapping-138"></span><span class="token del" data-title="function_definition/visibility">external</span> <span class="marker" id="mapping-139"></span><span class="token del" data-title="function_definition/return_type_definition">returns (uint)</span> <span class="marker" id="mapping-140"></span><span class="token del" data-title="function_definition/function_body">{
        // Check caller = admin
        <span class="marker" id="mapping-141"></span><span class="token del" data-title="function_body/if_statement">if (!hasAdminRights()) {
            return fail(Error.UNAUTHORIZED, FailureInfo.RENOUNCE_ADMIN_RIGHTS_OWNER_CHECK);
        }</span>

        // Check that rights have not already been renounced
        <span class="marker" id="mapping-142"></span><span class="token del" data-title="function_body/if_statement">if (!fuseAdminHasRights) return uint(Error.NO_ERROR);</span>

        // Set fuseAdminHasRights to false
        <span class="marker" id="mapping-143"></span><span class="token del" data-title="function_body/expression_statement"><span class="marker" id="mapping-144"></span><span class="token del" data-title="expression_statement/assignment_expression">fuseAdminHasRights = <span class="marker" id="mapping-145"></span><span class="token mv" id="move-src-43" data-title="assignment_expression/boolean_literal">false</span></span>;</span>

        // Emit FuseAdminRightsRenounced()
        <span class="marker" id="mapping-146"></span><span class="token del" data-title="function_body/emit_statement">emit FuseAdminRightsRenounced();</span>

        <span class="marker" id="mapping-147"></span><span class="token del" data-title="function_body/return_statement">return uint(Error.NO_ERROR);</span>
    }</span></span>

    <span class="marker" id="mapping-148"></span><span class="token mv" id="move-src-44" data-title="contract_body/comment"><span class="marker" id="mapping-149"></span><span class="token upd" id="move-src-45" data-title="contract_body/comment"><span class="cupd">/**
    </span> <span class="cupd"> * </span>@noti<span class="cupd">c</span><span class="cupd">e</span> Renounce ad<span class="cupd">m</span>in rig<span class="cupd">h</span>ts<span class="cupd">.</span><span class="cupd"></span>
      *<span class="cupd"> </span>@retu<span class="cupd">r</span>n uint 0=<span class="cupd">su</span><span class="cupd">c</span>cess,<span class="cupd"> </span>o<span class="cupd">th</span>er<span class="cupd">w</span>i<span class="cupd">s</span>e<span class="cupd"> </span>a<span class="cupd"> </span><span class="cupd">f</span>ailu<span class="cupd">r</span>e<span class="cupd"> </span><span class="cupd">(s</span><span class="cupd">e</span>e<span class="cupd"> Err</span>orReport<span class="cupd">e</span>r.s<span class="cupd">o</span>l f<span class="cupd">o</span>r detail<span class="cupd">s)
</span>   <span class="cupd">  </span> */</span></span>
    <span class="marker" id="mapping-150"></span><span class="token del" data-title="contract_body/function_definition">function _renounceAdminRights() <span class="marker" id="mapping-151"></span><span class="token del" data-title="function_definition/visibility">external</span> <span class="marker" id="mapping-152"></span><span class="token del" data-title="function_definition/return_type_definition">returns (uint)</span> <span class="marker" id="mapping-153"></span><span class="token del" data-title="function_definition/function_body">{
        // Check caller = admin
        <span class="marker" id="mapping-154"></span><span class="token del" data-title="function_body/if_statement">if (!hasAdminRights()) {
            return fail(Error.UNAUTHORIZED, FailureInfo.RENOUNCE_ADMIN_RIGHTS_OWNER_CHECK);
        }</span>

        // Check that rights have not already been renounced
        <span class="marker" id="mapping-155"></span><span class="token del" data-title="function_body/if_statement">if (!adminHasRights) return uint(Error.NO_ERROR);</span>

        // Set adminHasRights to false
        <span class="marker" id="mapping-156"></span><span class="token del" data-title="function_body/expression_statement"><span class="marker" id="mapping-157"></span><span class="token del" data-title="expression_statement/assignment_expression">adminHasRights = <span class="marker" id="mapping-158"></span><span class="token mv" id="move-src-46" data-title="assignment_expression/boolean_literal">false</span></span>;</span>

        // Emit AdminRightsRenounced()
        <span class="marker" id="mapping-159"></span><span class="token del" data-title="function_body/emit_statement">emit AdminRightsRenounced();</span>

        <span class="marker" id="mapping-160"></span><span class="token del" data-title="function_body/return_statement">return uint(Error.NO_ERROR);</span>
    }</span></span>

    <span class="marker" id="mapping-161"></span><span class="token upd" id="move-src-47" data-title="contract_body/comment"><span class="cupd">/**
      * @notice</span> <span class="cupd">B</span>egins<span class="cupd"> </span>tra<span class="cupd">n</span>sfe<span class="cupd">r</span> of<span class="cupd"> </span>admi<span class="cupd">n</span> rights. The<span class="cupd"> ne</span>wPendingAdmi<span class="cupd">n</span><span class="cupd"> </span>mu<span class="cupd">s</span>t c<span class="cupd">al</span>l `_ac<span class="cupd">c</span>eptAdmin<span class="cupd">`</span> <span class="cupd">t</span><span class="cupd">o</span> finalize<span class="cupd"> the</span> <span class="cupd">t</span>rans<span class="cupd">f</span>er<span class="cupd">.
      * @de</span>v Ad<span class="cupd">m</span><span class="cupd">in function t</span>o<span class="cupd"> </span>beg<span class="cupd">i</span>n <span class="cupd">c</span>han<span class="cupd">g</span>e of ad<span class="cupd">m</span>in. <span class="cupd">T</span>he <span class="cupd">n</span>ewPendingAdm<span class="cupd">i</span><span class="cupd">n</span> must call `_ac<span class="cupd">ce</span>ptAdmin`<span class="cupd"> </span>to fi<span class="cupd">n</span>al<span class="cupd">i</span>ze the<span class="cupd"> </span>transfe<span class="cupd">r.
      </span>* <span class="cupd">@</span>para<span class="cupd">m</span> newPendingAdmin New pending admin.
      *<span class="cupd"> @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
   </span>   */</span>
    <span class="marker" id="mapping-162"></span><span class="token del" data-title="contract_body/function_definition">function _setPendingAdmin(<span class="marker" id="mapping-163"></span><span class="token del" data-title="function_definition/parameter">address payable newPendingAdmin</span>) <span class="marker" id="mapping-164"></span><span class="token del" data-title="function_definition/visibility">external</span> <span class="marker" id="mapping-165"></span><span class="token del" data-title="function_definition/return_type_definition">returns (uint)</span> <span class="marker" id="mapping-166"></span><span class="token del" data-title="function_definition/function_body">{
        // Check caller = admin
        <span class="marker" id="mapping-167"></span><span class="token del" data-title="function_body/if_statement">if (!hasAdminRights()) {
            return fail(Error.UNAUTHORIZED, FailureInfo.SET_PENDING_ADMIN_OWNER_CHECK);
        }</span>

        // Save current value, if any, for inclusion in log
        <span class="marker" id="mapping-168"></span><span class="token del" data-title="function_body/variable_declaration_statement"><span class="marker" id="mapping-169"></span><span class="token del" data-title="variable_declaration_statement/variable_declaration"><span class="marker" id="mapping-170"></span><span class="token mv" id="move-src-48" data-title="variable_declaration/type_name">address</span> oldPendingAdmin</span> = pendingAdmin;</span>

        // Store pendingAdmin with value newPendingAdmin
        <span class="marker" id="mapping-171"></span><span class="token del" data-title="function_body/expression_statement">pendingAdmin = newPendingAdmin;</span>

        // Emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin)
        <span class="marker" id="mapping-172"></span><span class="token del" data-title="function_body/emit_statement">emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin);</span>

        <span class="marker" id="mapping-173"></span><span class="token del" data-title="function_body/return_statement">return uint(Error.NO_ERROR);</span>
    }</span></span>

    <span class="marker" id="mapping-174"></span><span class="token mv" id="move-src-49" data-title="contract_body/comment"><span class="marker" id="mapping-175"></span><span class="token upd" id="move-src-50" data-title="contract_body/comment"><span class="cupd">/**
    </span> <span class="cupd"> * @notice</span> Acc<span class="cupd">e</span><span class="cupd">p</span><span class="cupd">ts </span>trans<span class="cupd">f</span>e<span class="cupd">r</span><span class="cupd"> </span>of adm<span class="cupd">in</span> rights<span class="cupd">.</span><span class="cupd"> </span>msg.<span class="cupd">s</span><span class="cupd">en</span>de<span class="cupd">r</span><span class="cupd"> </span>must<span class="cupd"> </span>b<span class="cupd">e</span> pendingAdmi<span class="cupd">n
  </span>  <span class="cupd">  * @dev Admin functio</span>n<span class="cupd"> </span>f<span class="cupd">o</span><span class="cupd">r</span><span class="cupd"> </span><span class="cupd">p</span>en<span class="cupd">d</span>i<span class="cupd">ng</span><span class="cupd"> </span><span class="cupd">a</span>d<span class="cupd">m</span><span class="cupd">in</span><span class="cupd"> </span><span class="cupd">t</span><span class="cupd">o</span> a<span class="cupd">c</span>c<span class="cupd">e</span><span class="cupd">p</span><span class="cupd">t</span><span class="cupd"> r</span><span class="cupd">ol</span>e<span class="cupd"> </span>a<span class="cupd">n</span>d up<span class="cupd">d</span><span class="cupd">a</span><span class="cupd">t</span>e <span class="cupd">a</span>dm<span class="cupd">i</span><span class="cupd">n</span><span class="cupd">
   </span><span class="cupd">   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
 </span> <span class="cupd">  </span>  */</span></span>
    <span class="marker" id="mapping-176"></span><span class="token del" data-title="contract_body/function_definition">function _acceptAdmin() <span class="marker" id="mapping-177"></span><span class="token del" data-title="function_definition/visibility">external</span> <span class="marker" id="mapping-178"></span><span class="token del" data-title="function_definition/return_type_definition">returns (uint)</span> <span class="marker" id="mapping-179"></span><span class="token del" data-title="function_definition/function_body">{
        // Check caller is pendingAdmin and pendingAdmin ≠ address(0)
        <span class="marker" id="mapping-180"></span><span class="token del" data-title="function_body/if_statement">if (<span class="marker" id="mapping-181"></span><span class="token mv" id="move-src-51" data-title="if_statement/binary_expression"><span class="marker" id="mapping-182"></span><span class="token del" data-title="binary_expression/member_expression"><span class="marker" id="mapping-183"></span><span class="token mv" id="move-src-52" data-title="member_expression/binary_expression">msg.sender <span class="marker" id="mapping-184"></span><span class="token del" data-title="binary_expression/!=">!=</span> <span class="marker" id="mapping-185"></span><span class="token del" data-title="binary_expression/identifier">pendingAdmin</span> <span class="marker" id="mapping-186"></span><span class="token del" data-title="binary_expression/||">||</span> <span class="marker" id="mapping-187"></span><span class="token del" data-title="binary_expression/identifier">msg</span></span>.sender</span> <span class="marker" id="mapping-188"></span><span class="token del" data-title="binary_expression/==">==</span> address(0)</span>) <span class="marker" id="mapping-189"></span><span class="token del" data-title="if_statement/block_statement">{
            return fail(Error.UNAUTHORIZED, FailureInfo.ACCEPT_ADMIN_PENDING_ADMIN_CHECK);
        }</span></span>

        // Save current values for inclusion in log
        <span class="marker" id="mapping-190"></span><span class="token del" data-title="function_body/variable_declaration_statement">address oldAdmin = admin;</span>
        <span class="marker" id="mapping-191"></span><span class="token del" data-title="function_body/variable_declaration_statement">address oldPendingAdmin = pendingAdmin;</span>

        // Store admin with value pendingAdmin
        <span class="marker" id="mapping-192"></span><span class="token del" data-title="function_body/expression_statement">admin = pendingAdmin;</span>

        // Clear the pending value
        <span class="marker" id="mapping-193"></span><span class="token del" data-title="function_body/expression_statement">pendingAdmin = address(0);</span>

        <span class="marker" id="mapping-194"></span><span class="token del" data-title="function_body/emit_statement">emit NewAdmin(oldAdmin, admin);</span>
        <span class="marker" id="mapping-195"></span><span class="token del" data-title="function_body/emit_statement">emit NewPendingAdmin(oldPendingAdmin, pendingAdmin);</span>

        <span class="marker" id="mapping-196"></span><span class="token del" data-title="function_body/return_statement">return uint(Error.NO_ERROR);</span>
    }</span></span>

    <span class="marker" id="mapping-197"></span><span class="token mv" id="move-src-53" data-title="contract_body/comment"><span class="marker" id="mapping-198"></span><span class="token upd" id="move-src-54" data-title="contract_body/comment"><span class="cupd">/**
    </span> <span class="cupd"> * </span>@noti<span class="cupd">c</span><span class="cupd">e </span>S<span class="cupd">e</span>t<span class="cupd">s</span> <span class="cupd">a</span><span class="cupd"> </span><span class="cupd">n</span>e<span class="cupd">w</span> com<span class="cupd">p</span>t<span class="cupd">r</span>ol<span class="cupd">l</span>e<span class="cupd">r</span> <span class="cupd">f</span><span class="cupd">o</span><span class="cupd">r</span><span class="cupd"> the</span><span class="cupd"> </span>mark<span class="cupd">e</span><span class="cupd">t
   </span> <span class="cupd">  </span>* <span class="cupd">@</span>d<span class="cupd">e</span>v Adm<span class="cupd">i</span><span class="cupd">n functio</span>n<span class="cupd"> </span><span class="cupd">t</span><span class="cupd">o</span><span class="cupd"> </span><span class="cupd">s</span><span class="cupd">e</span>t<span class="cupd"> </span><span class="cupd">a</span> <span class="cupd">n</span><span class="cupd">e</span>w <span class="cupd">c</span>omp<span class="cupd">t</span>ro<span class="cupd">ll</span><span class="cupd">er
  </span> <span class="cupd">  </span> * @re<span class="cupd">tu</span>r<span class="cupd">n</span> u<span class="cupd">i</span>nt<span class="cupd"> </span>0<span class="cupd">=</span><span class="cupd">s</span><span class="cupd">u</span>cc<span class="cupd">es</span>s<span class="cupd">, o</span>th<span class="cupd">e</span>rwi<span class="cupd">s</span><span class="cupd">e</span> <span class="cupd">a</span> fai<span class="cupd">l</span>ur<span class="cupd">e</span> (<span class="cupd">s</span>e<span class="cupd">e</span> <span class="cupd">E</span>rrorRe<span class="cupd">po</span>rt<span class="cupd">e</span><span class="cupd">r</span>.s<span class="cupd">o</span>l <span class="cupd">f</span>or<span class="cupd"> </span><span class="cupd">d</span>e<span class="cupd">t</span>ai<span class="cupd">l</span><span class="cupd">s</span><span class="cupd">)</span><span class="cupd">
  </span><span class="cupd">  </span>  */</span></span>
    function _setComptroller(ComptrollerInterface newComptroller) <span class="marker" id="mapping-199"></span><span class="token del" data-title="function_definition/visibility">public</span> returns (uint) {
        <span class="marker" id="mapping-200"></span><span class="token del" data-title="function_body/comment">// Check caller is admin</span>
        <span class="marker" id="mapping-201"></span><span class="token del" data-title="function_body/if_statement">if (!hasAdminRights()) {
            return fail(Error.UNAUTHORIZED, FailureInfo.SET_COMPTROLLER_OWNER_CHECK);
        }</span>

        ComptrollerInterface oldComptroller = comptroller;
        // Ensure invoke comptroller.isComptroller() returns true
        require(newComptroller.isComptroller(), "marker method returned false");

        // Set market's comptroller to newComptroller
        comptroller = newComptroller;

        // Emit NewComptroller(oldComptroller, newComptroller)
        emit NewComptroller(oldComptroller, newComptroller);

        return uint(Error.NO_ERROR);
    }

    /**
      * @notice accrues interest and sets a new admin fee for the protocol using _setAdminFeeFresh
      * @dev Admin function to accrue interest and set a new admin fee
      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
      */
    function _setAdminFee(uint newAdminFeeMantissa) external nonReentrant returns (uint) {
        uint error = accrueInterest();
        if (error != uint(Error.NO_ERROR)) {
            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted admin fee change failed.
            return fail(Error(error), FailureInfo.SET_ADMIN_FEE_ACCRUE_INTEREST_FAILED);
        }
        // _setAdminFeeFresh emits reserve-factor-specific logs on errors, so we don't need to.
        return _setAdminFeeFresh(newAdminFeeMantissa);
    }

    /**
      * @notice Sets a new admin fee for the protocol (*requires fresh interest accrual)
      * @dev Admin function to set a new admin fee
      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
      */
    function _setAdminFeeFresh(uint newAdminFeeMantissa) internal returns (uint) {
        <span class="marker" id="mapping-202"></span><span class="token mv" id="move-src-55" data-title="function_body/comment"><span class="marker" id="mapping-203"></span><span class="token upd" id="move-src-56" data-title="function_body/comment"><span class="cupd">// </span>Ch<span class="cupd">e</span>ck<span class="cupd"> </span>call<span class="cupd">e</span>r is a<span class="cupd">dmin</span></span></span>
        <span class="marker" id="mapping-204"></span><span class="token mv" id="move-src-57" data-title="function_body/if_statement">if (!hasAdminRights()) {
            return fail(Error.UNAUTHORIZED, FailureInfo.SET_ADMIN_FEE_ADMIN_CHECK);
        }</span>

        // Verify market's block number equals current block number
        if (accrualBlockNumber != getBlockNumber()) {
            return fail(Error.MARKET_NOT_FRESH, FailureInfo.SET_ADMIN_FEE_FRESH_CHECK);
        }

        <span class="marker" id="mapping-205"></span><span class="token upd" id="move-src-58" data-title="function_body/comment"><span class="cupd">// </span>Ch<span class="cupd">e</span>ck<span class="cupd"> </span>n<span class="cupd">e</span>wAdmin<span class="cupd">F</span><span class="cupd">e</span>e<span class="cupd"> </span>≤ maxAdminF<span class="cupd">ee</span>
</span>        if (<span class="marker" id="mapping-206"></span><span class="token del" data-title="binary_expression/binary_expression">reserveFactorMantissa + newAdminFeeMantissa + fuseFeeMantissa</span> &gt; reserveFactorPlusFeesMaxMantissa) {
            return fail(Error.BAD_INPUT, FailureInfo.SET_ADMIN_FEE_BOUNDS_CHECK);
        }

        <span class="marker" id="mapping-207"></span><span class="token mv" id="move-src-59" data-title="function_body/variable_declaration_statement">uint oldAdminFeeMantissa = adminFeeMantissa;</span>
        <span class="marker" id="mapping-208"></span><span class="token mv" id="move-src-60" data-title="function_body/expression_statement">adminFeeMantissa = newAdminFeeMantissa;</span>

        <span class="marker" id="mapping-209"></span><span class="token mv" id="move-src-61" data-title="function_body/emit_statement">emit NewAdminFee(oldAdminFeeMantissa, newAdminFeeMantissa);</span>

        return uint(Error.NO_ERROR);
    }

    <span class="marker" id="mapping-210"></span><span class="token mv" id="move-src-62" data-title="contract_body/comment"><span class="marker" id="mapping-211"></span><span class="token upd" id="move-src-63" data-title="contract_body/comment"><span class="cupd">/**
    </span> <span class="cupd"> * </span>@noti<span class="cupd">c</span><span class="cupd">e</span> ac<span class="cupd">c</span>rue<span class="cupd">s</span> <span class="cupd">i</span>n<span class="cupd">t</span>e<span class="cupd">r</span>e<span class="cupd">s</span>t<span class="cupd"> a</span>n<span class="cupd">d</span> s<span class="cupd">e</span>t<span class="cupd">s</span> a <span class="cupd">n</span>ew Fu<span class="cupd">s</span><span class="cupd">e</span> fee <span class="cupd">f</span><span class="cupd">o</span><span class="cupd">r</span><span class="cupd"> the</span> protoco<span class="cupd">l</span> <span class="cupd">us</span>in<span class="cupd">g</span> _s<span class="cupd">e</span>tFuseFeeFres<span class="cupd">h
   </span> <span class="cupd">  </span>* <span class="cupd">@</span>d<span class="cupd">e</span>v<span class="cupd"> </span><span class="cupd">Functio</span>n<span class="cupd"> </span><span class="cupd">t</span>o<span class="cupd"> </span>acc<span class="cupd">rue</span> inte<span class="cupd">r</span>e<span class="cupd">s</span>t<span class="cupd"> </span><span class="cupd">a</span><span class="cupd">n</span>d <span class="cupd">s</span><span class="cupd">e</span>t<span class="cupd"> </span><span class="cupd">a</span> <span class="cupd">n</span><span class="cupd">e</span>w F<span class="cupd">us</span><span class="cupd">e</span><span class="cupd"> </span>f<span class="cupd">ee
  </span> <span class="cupd">  </span> * @re<span class="cupd">tu</span>r<span class="cupd">n</span> u<span class="cupd">i</span>nt<span class="cupd"> </span>0<span class="cupd">=</span><span class="cupd">s</span><span class="cupd">u</span>cc<span class="cupd">es</span>s<span class="cupd">, o</span>th<span class="cupd">e</span>rwi<span class="cupd">s</span><span class="cupd">e</span> <span class="cupd">a</span> fai<span class="cupd">l</span>ur<span class="cupd">e</span> (<span class="cupd">s</span>e<span class="cupd">e</span> <span class="cupd">E</span>rrorRe<span class="cupd">po</span>rt<span class="cupd">e</span><span class="cupd">r</span>.s<span class="cupd">o</span>l <span class="cupd">f</span>or<span class="cupd"> </span><span class="cupd">d</span>e<span class="cupd">t</span>ai<span class="cupd">l</span><span class="cupd">s</span><span class="cupd">)</span><span class="cupd">
  </span><span class="cupd">  </span>  */</span></span>
    <span class="marker" id="mapping-212"></span><span class="token del" data-title="contract_body/function_definition">function _setFuseFee() <span class="marker" id="mapping-213"></span><span class="token mv" id="move-src-64" data-title="function_definition/visibility">external</span> <span class="marker" id="mapping-214"></span><span class="token del" data-title="function_definition/modifier_invocation">nonReentrant</span> <span class="marker" id="mapping-215"></span><span class="token del" data-title="function_definition/return_type_definition">returns (uint)</span> <span class="marker" id="mapping-216"></span><span class="token del" data-title="function_definition/function_body">{
        <span class="marker" id="mapping-217"></span><span class="token mv" id="move-src-65" data-title="function_body/variable_declaration_statement">uint <span class="marker" id="mapping-218"></span><span class="token upd" id="move-src-66" data-title="variable_declaration/identifier">error</span> = <span class="marker" id="mapping-219"></span><span class="token del" data-title="variable_declaration_statement/call_expression">accrueInterest()</span>;</span>
        <span class="marker" id="mapping-220"></span><span class="token del" data-title="function_body/if_statement">if (error != uint(Error.NO_ERROR)) {
            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted admin fee change failed.
            return fail(Error(error), FailureInfo.SET_FUSE_FEE_ACCRUE_INTEREST_FAILED);
        }</span>
        // _setAdminFeeFresh emits reserve-factor-specific logs on errors, so we don't need to.
        <span class="marker" id="mapping-221"></span><span class="token del" data-title="function_body/return_statement">return <span class="marker" id="mapping-222"></span><span class="token del" data-title="return_statement/call_expression">_setFuseFeeFresh(<span class="marker" id="mapping-223"></span><span class="token del" data-title="call_expression/call_argument"><span class="marker" id="mapping-224"></span><span class="token mv" id="move-src-67" data-title="call_argument/call_expression">getPendingFuseFeeFromAdmin()</span></span>)</span>;</span>
    }</span></span>

    <span class="marker" id="mapping-225"></span><span class="token mv" id="move-src-68" data-title="contract_body/comment"><span class="marker" id="mapping-226"></span><span class="token upd" id="move-src-69" data-title="contract_body/comment"><span class="cupd">/**
    </span> <span class="cupd"> * </span>@<span class="cupd">n</span><span class="cupd">o</span><span class="cupd">t</span><span class="cupd">i</span>c<span class="cupd">e</span> Se<span class="cupd">t</span><span class="cupd">s a</span> n<span class="cupd">ew</span> <span class="cupd">F</span><span class="cupd">u</span><span class="cupd">se</span> <span class="cupd">f</span><span class="cupd">e</span><span class="cupd">e for</span> th<span class="cupd">e</span> pr<span class="cupd">o</span><span class="cupd">t</span><span class="cupd">o</span>c<span class="cupd">o</span><span class="cupd">l</span> <span class="cupd">(</span>*re<span class="cupd">q</span><span class="cupd">u</span>i<span class="cupd">r</span>e<span class="cupd">s</span><span class="cupd"> </span><span class="cupd">f</span><span class="cupd">r</span><span class="cupd">e</span>s<span class="cupd">h</span><span class="cupd"> </span>i<span class="cupd">n</span><span class="cupd">t</span><span class="cupd">e</span><span class="cupd">r</span><span class="cupd">e</span><span class="cupd">st</span> acc<span class="cupd">r</span>u<span class="cupd">a</span>l<span class="cupd">)</span><span class="cupd"></span><span class="cupd">
</span><span class="cupd">    </span><span class="cupd">  </span>* @dev<span class="cupd"> Functio</span><span class="cupd">n</span><span class="cupd"> </span><span class="cupd">t</span><span class="cupd">o</span><span class="cupd"> s</span><span class="cupd">e</span><span class="cupd">t</span><span class="cupd"> </span><span class="cupd">a </span>n<span class="cupd">e</span>w F<span class="cupd">u</span><span class="cupd">s</span>e<span class="cupd"> </span><span class="cupd">f</span><span class="cupd">e</span><span class="cupd">e</span><span class="cupd">
   </span><span class="cupd">  </span> <span class="cupd">* </span><span class="cupd">@</span><span class="cupd">r</span>e<span class="cupd">t</span>ur<span class="cupd">n</span><span class="cupd"> </span><span class="cupd">u</span>in<span class="cupd">t</span> 0<span class="cupd">=</span><span class="cupd">s</span><span class="cupd">u</span>cces<span class="cupd">s</span><span class="cupd">,</span> oth<span class="cupd">e</span><span class="cupd">r</span><span class="cupd">w</span><span class="cupd">i</span><span class="cupd">s</span><span class="cupd">e</span> <span class="cupd">a</span> <span class="cupd">f</span>ai<span class="cupd">l</span><span class="cupd">u</span>r<span class="cupd">e</span><span class="cupd"> </span><span class="cupd">(s</span>e<span class="cupd">e</span> <span class="cupd">E</span>rr<span class="cupd">o</span>r<span class="cupd">R</span><span class="cupd">e</span><span class="cupd">p</span><span class="cupd">or</span>t<span class="cupd">e</span><span class="cupd">r</span>.<span class="cupd">s</span>ol<span class="cupd"> </span>fo<span class="cupd">r </span><span class="cupd">det</span>ai<span class="cupd">ls)
 </span> <span class="cupd">  </span>  */</span></span>
    <span class="marker" id="mapping-227"></span><span class="token del" data-title="contract_body/function_definition">function _setFuseFeeFresh(<span class="marker" id="mapping-228"></span><span class="token del" data-title="function_definition/parameter"><span class="marker" id="mapping-229"></span><span class="token mv" id="move-src-70" data-title="parameter/type_name">uint</span> newFuseFeeMantissa</span>) <span class="marker" id="mapping-230"></span><span class="token mv" id="move-src-71" data-title="function_definition/visibility">internal</span> <span class="marker" id="mapping-231"></span><span class="token del" data-title="function_definition/return_type_definition">returns (uint)</span> <span class="marker" id="mapping-232"></span><span class="token del" data-title="function_definition/function_body">{
        // Check newFuseFeeMantissa != fuseFeeMantissa
        <span class="marker" id="mapping-233"></span><span class="token del" data-title="function_body/if_statement">if (newFuseFeeMantissa == fuseFeeMantissa) {
            return uint(Error.NO_ERROR);
        }</span>

        // Verify market's block number equals current block number
        <span class="marker" id="mapping-234"></span><span class="token del" data-title="function_body/if_statement">if (accrualBlockNumber != getBlockNumber()) {
            return fail(Error.MARKET_NOT_FRESH, FailureInfo.SET_FUSE_FEE_FRESH_CHECK);
        }</span>

        // Check newAdminFee ≤ maxFuseFee
        <span class="marker" id="mapping-235"></span><span class="token del" data-title="function_body/if_statement">if (reserveFactorMantissa + adminFeeMantissa + newFuseFeeMantissa &gt; reserveFactorPlusFeesMaxMantissa) {
            return fail(Error.BAD_INPUT, FailureInfo.SET_FUSE_FEE_BOUNDS_CHECK);
        }</span>

        <span class="marker" id="mapping-236"></span><span class="token mv" id="move-src-72" data-title="function_body/variable_declaration_statement">uint oldFuseFeeMantissa = fuseFeeMantissa;</span>
        <span class="marker" id="mapping-237"></span><span class="token mv" id="move-src-73" data-title="function_body/expression_statement">fuseFeeMantissa = newFuseFeeMantissa;</span>

        <span class="marker" id="mapping-238"></span><span class="token mv" id="move-src-74" data-title="function_body/emit_statement">emit NewFuseFee(oldFuseFeeMantissa, newFuseFeeMantissa);</span>

        <span class="marker" id="mapping-239"></span><span class="token del" data-title="function_body/return_statement">return uint(Error.NO_ERROR);</span>
    }</span></span>

    /**
      * @notice accrues interest and sets a new reserve factor for the protocol using _setReserveFactorFresh
      * @dev Admin function to accrue interest and set a new reserve factor
      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
      */
    function _setReserveFactor(uint newReserveFactorMantissa) external nonReentrant returns (uint) {
        uint error = accrueInterest();
        if (error != uint(Error.NO_ERROR)) {
            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reserve factor change failed.
            return fail(Error(error), FailureInfo.SET_RESERVE_FACTOR_ACCRUE_INTEREST_FAILED);
        }
        // _setReserveFactorFresh emits reserve-factor-specific logs on errors, so we don't need to.
        return _setReserveFactorFresh(newReserveFactorMantissa);
    }

    /**
      * @notice Sets a new reserve factor for the protocol (*requires fresh interest accrual)
      * @dev Admin function to set a new reserve factor
      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
      */
    function _setReserveFactorFresh(uint newReserveFactorMantissa) internal returns (uint) {
        // Check caller is admin
        if (!hasAdminRights()) {
            return fail(Error.UNAUTHORIZED, FailureInfo.SET_RESERVE_FACTOR_ADMIN_CHECK);
        }

        // Verify market's block number equals current block number
        if (accrualBlockNumber != getBlockNumber()) {
            return fail(Error.MARKET_NOT_FRESH, FailureInfo.SET_RESERVE_FACTOR_FRESH_CHECK);
        }

        // Check newReserveFactor ≤ maxReserveFactor
        if (<span class="marker" id="mapping-240"></span><span class="token del" data-title="binary_expression/binary_expression">newReserveFactorMantissa + adminFeeMantissa + fuseFeeMantissa</span> &gt; reserveFactorPlusFeesMaxMantissa) {
            return fail(Error.BAD_INPUT, FailureInfo.SET_RESERVE_FACTOR_BOUNDS_CHECK);
        }

        uint oldReserveFactorMantissa = reserveFactorMantissa;
        reserveFactorMantissa = newReserveFactorMantissa;

        emit NewReserveFactor(oldReserveFactorMantissa, newReserveFactorMantissa);

        return uint(Error.NO_ERROR);
    }

    <span class="marker" id="mapping-241"></span><span class="token del" data-title="contract_body/comment">/**
     * @notice Accrues interest and reduces reserves by transferring from msg.sender
     * @param addAmount Amount of addition to reserves
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */</span>
    <span class="marker" id="mapping-242"></span><span class="token del" data-title="contract_body/function_definition">function _addReservesInternal(<span class="marker" id="mapping-243"></span><span class="token del" data-title="function_definition/parameter"><span class="marker" id="mapping-244"></span><span class="token mv" id="move-src-75" data-title="parameter/type_name">uint</span> addAmount</span>) <span class="marker" id="mapping-245"></span><span class="token mv" id="move-src-76" data-title="function_definition/visibility">internal</span> <span class="marker" id="mapping-246"></span><span class="token del" data-title="function_definition/modifier_invocation">nonReentrant</span> <span class="marker" id="mapping-247"></span><span class="token del" data-title="function_definition/return_type_definition">returns (uint)</span> <span class="marker" id="mapping-248"></span><span class="token del" data-title="function_definition/function_body">{
        <span class="marker" id="mapping-249"></span><span class="token del" data-title="function_body/variable_declaration_statement"><span class="marker" id="mapping-250"></span><span class="token del" data-title="variable_declaration_statement/variable_declaration"><span class="marker" id="mapping-251"></span><span class="token mv" id="move-src-77" data-title="variable_declaration/type_name">uint</span> error</span> = <span class="marker" id="mapping-252"></span><span class="token del" data-title="variable_declaration_statement/call_expression">accrueInterest()</span>;</span>
        <span class="marker" id="mapping-253"></span><span class="token del" data-title="function_body/if_statement">if (error != uint(Error.NO_ERROR)) {
            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reduce reserves failed.
            return fail(Error(error), FailureInfo.ADD_RESERVES_ACCRUE_INTEREST_FAILED);
        }</span>

        // _addReservesFresh emits reserve-addition-specific logs on errors, so we don't need to.
        <span class="marker" id="mapping-254"></span><span class="token del" data-title="function_body/expression_statement">(error, ) = _addReservesFresh(addAmount);</span>
        <span class="marker" id="mapping-255"></span><span class="token del" data-title="function_body/return_statement">return error;</span>
    }</span></span>

    <span class="marker" id="mapping-256"></span><span class="token del" data-title="contract_body/comment">/**
     * @notice Add reserves by transferring from caller
     * @dev Requires fresh interest accrual
     * @param addAmount Amount of addition to reserves
     * @return (uint, uint) An error code (0=success, otherwise a failure (see ErrorReporter.sol for details)) and the actual amount added, net token fees
     */</span>
    <span class="marker" id="mapping-257"></span><span class="token del" data-title="contract_body/function_definition">function _addReservesFresh(<span class="marker" id="mapping-258"></span><span class="token del" data-title="function_definition/parameter"><span class="marker" id="mapping-259"></span><span class="token mv" id="move-src-78" data-title="parameter/type_name">uint</span> addAmount</span>) <span class="marker" id="mapping-260"></span><span class="token mv" id="move-src-79" data-title="function_definition/visibility">internal</span> <span class="marker" id="mapping-261"></span><span class="token del" data-title="function_definition/return_type_definition">returns (uint, uint)</span> <span class="marker" id="mapping-262"></span><span class="token del" data-title="function_definition/function_body">{
        // totalReserves + actualAddAmount
        <span class="marker" id="mapping-263"></span><span class="token del" data-title="function_body/variable_declaration_statement">uint totalReservesNew;</span>
        <span class="marker" id="mapping-264"></span><span class="token del" data-title="function_body/variable_declaration_statement"><span class="marker" id="mapping-265"></span><span class="token del" data-title="variable_declaration_statement/variable_declaration"><span class="marker" id="mapping-266"></span><span class="token mv" id="move-src-80" data-title="variable_declaration/type_name">uint</span> actualAddAmount</span>;</span>

        // We fail gracefully unless market's block number equals current block number
        <span class="marker" id="mapping-267"></span><span class="token del" data-title="function_body/if_statement">if (accrualBlockNumber != getBlockNumber()) {
            return (fail(Error.MARKET_NOT_FRESH, FailureInfo.ADD_RESERVES_FRESH_CHECK), actualAddAmount);
        }</span>

        /////////////////////////
        // EFFECTS &amp; INTERACTIONS
        // (No safe failures beyond this point)

        /*
         * We call doTransferIn for the caller and the addAmount
         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.
         *  On success, the cToken holds an additional addAmount of cash.
         *  doTransferIn reverts if anything goes wrong, since we can't be sure if side effects occurred.
         *  it returns the amount actually transferred, in case of a fee.
         */

        <span class="marker" id="mapping-268"></span><span class="token mv" id="move-src-81" data-title="function_body/expression_statement"><span class="marker" id="mapping-269"></span><span class="token del" data-title="expression_statement/assignment_expression">actualAddAmount = <span class="marker" id="mapping-270"></span><span class="token mv" id="move-src-82" data-title="assignment_expression/call_expression"><span class="marker" id="mapping-271"></span><span class="token upd" id="move-src-83" data-title="call_expression/identifier"><span class="cupd">doTransfer</span>In</span>(msg.sender, <span class="marker" id="mapping-272"></span><span class="token del" data-title="call_expression/call_argument">addAmount</span>)</span></span>;</span>

        <span class="marker" id="mapping-273"></span><span class="token del" data-title="function_body/expression_statement">totalReservesNew = totalReserves + actualAddAmount;</span>

        /* Revert on overflow */
        <span class="marker" id="mapping-274"></span><span class="token mv" id="move-src-84" data-title="function_body/expression_statement">require(<span class="marker" id="mapping-275"></span><span class="token del" data-title="binary_expression/identifier">totalReservesNew</span> <span class="marker" id="mapping-276"></span><span class="token del" data-title="binary_expression/>=">&gt;=</span> <span class="marker" id="mapping-277"></span><span class="token del" data-title="binary_expression/identifier">totalReserves</span>, "add reserves unexpected overflow");</span>

        // Store reserves[n+1] = reserves[n] + actualAddAmount
        <span class="marker" id="mapping-278"></span><span class="token del" data-title="function_body/expression_statement">totalReserves = totalReservesNew;</span>

        /* Emit NewReserves(admin, actualAddAmount, reserves[n+1]) */
        <span class="marker" id="mapping-279"></span><span class="token mv" id="move-src-85" data-title="function_body/emit_statement">emit <span class="marker" id="mapping-280"></span><span class="token upd" id="move-src-86" data-title="emit_statement/identifier"><span class="cupd">Reserves</span>A<span class="cupd">d</span>d<span class="cupd">ed</span></span>(msg.sender, <span class="marker" id="mapping-281"></span><span class="token del" data-title="emit_statement/call_argument">actualAddAmount</span>, totalReservesNew);</span>

        /* Return (NO_ERROR, actualAddAmount) */
        <span class="marker" id="mapping-282"></span><span class="token del" data-title="function_body/return_statement">return (uint(Error.NO_ERROR), actualAddAmount);</span>
    }</span></span>

    /**
     * @notice Accrues interest and reduces reserves by transferring to admin
     * @param reduceAmount Amount of reduction to reserves
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function _reduceReserves(uint reduceAmount) external nonReentrant returns (uint) {
        uint error = accrueInterest();
        if (error != uint(Error.NO_ERROR)) {
            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reduce reserves failed.
            return fail(Error(error), FailureInfo.REDUCE_RESERVES_ACCRUE_INTEREST_FAILED);
        }
        // _reduceReservesFresh emits reserve-reduction-specific logs on errors, so we don't need to.
        return _reduceReservesFresh(reduceAmount);
    }

    /**
     * @notice Reduces reserves by transferring to admin
     * @dev Requires fresh interest accrual
     * @param reduceAmount Amount of reduction to reserves
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function _reduceReservesFresh(uint reduceAmount) internal returns (uint) {
        // totalReserves - reduceAmount
        uint totalReservesNew;

        // Check caller is admin
        if (!hasAdminRights()) {
            return fail(Error.UNAUTHORIZED, FailureInfo.REDUCE_RESERVES_ADMIN_CHECK);
        }

        // We fail gracefully unless market's block number equals current block number
        if (accrualBlockNumber != getBlockNumber()) {
            return fail(Error.MARKET_NOT_FRESH, FailureInfo.REDUCE_RESERVES_FRESH_CHECK);
        }

        // Fail gracefully if protocol has insufficient underlying cash
        if (getCashPrior() &lt; reduceAmount) {
            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.REDUCE_RESERVES_CASH_NOT_AVAILABLE);
        }

        // Check reduceAmount ≤ reserves[n] (totalReserves)
        if (reduceAmount &gt; totalReserves) {
            return fail(Error.BAD_INPUT, FailureInfo.REDUCE_RESERVES_VALIDATION);
        }

        /////////////////////////
        // EFFECTS &amp; INTERACTIONS
        // (No safe failures beyond this point)

        <span class="marker" id="mapping-283"></span><span class="token del" data-title="function_body/expression_statement">totalReservesNew = totalReserves - reduceAmount;</span>
        // We checked reduceAmount &lt;= totalReserves above, so this should never revert.
        <span class="marker" id="mapping-284"></span><span class="token mv" id="move-src-87" data-title="function_body/expression_statement"><span class="marker" id="mapping-285"></span><span class="token mv" id="move-src-88" data-title="expression_statement/call_expression"><span class="marker" id="mapping-286"></span><span class="token del" data-title="call_expression/identifier">require</span>(<span class="marker" id="mapping-287"></span><span class="token mv" id="move-src-89" data-title="call_expression/call_argument"><span class="marker" id="mapping-288"></span><span class="token del" data-title="call_argument/binary_expression">totalReservesNew &lt;= totalReserves</span></span><span class="marker" id="mapping-289"></span><span class="token mv" id="move-src-90" data-title="call_expression/,">,</span> "reduce reserves unexpected underflow")</span>;</span>

        // Store reserves[n+1] = reserves[n] - reduceAmount
        totalReserves = totalReservesNew;

        // doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.
        <span class="marker" id="mapping-290"></span><span class="token del" data-title="function_body/expression_statement"><span class="marker" id="mapping-291"></span><span class="token del" data-title="expression_statement/call_expression">doTransferOut(<span class="marker" id="mapping-292"></span><span class="token del" data-title="call_expression/call_argument">admin</span>, <span class="marker" id="mapping-293"></span><span class="token mv" id="move-src-91" data-title="call_expression/call_argument">reduceAmount</span>)</span>;</span>

        <span class="marker" id="mapping-294"></span><span class="token del" data-title="function_body/emit_statement">emit ReservesReduced(<span class="marker" id="mapping-295"></span><span class="token del" data-title="emit_statement/call_argument">admin</span>, <span class="marker" id="mapping-296"></span><span class="token mv" id="move-src-92" data-title="emit_statement/call_argument">reduceAmount</span>, <span class="marker" id="mapping-297"></span><span class="token del" data-title="emit_statement/call_argument">totalReservesNew</span>);</span>

        return uint(Error.NO_ERROR);
    }

    /**
     * @notice Accrues interest and reduces Fuse fees by transferring to Fuse
     * @param withdrawAmount Amount of fees to withdraw
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function _withdrawFuseFees(uint withdrawAmount) external nonReentrant returns (uint) {
        uint error = accrueInterest();
        if (error != uint(Error.NO_ERROR)) {
            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted Fuse fee withdrawal failed.
            return fail(Error(error), FailureInfo.WITHDRAW_FUSE_FEES_ACCRUE_INTEREST_FAILED);
        }
        // _withdrawFuseFeesFresh emits reserve-reduction-specific logs on errors, so we don't need to.
        return _withdrawFuseFeesFresh(withdrawAmount);
    }

    /**
     * @notice Reduces Fuse fees by transferring to Fuse
     * @dev Requires fresh interest accrual
     * @param withdrawAmount Amount of fees to withdraw
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function _withdrawFuseFeesFresh(uint withdrawAmount) internal returns (uint) {
        // totalFuseFees - reduceAmount
        uint totalFuseFeesNew;

        // We fail gracefully unless market's block number equals current block number
        if (accrualBlockNumber != getBlockNumber()) {
            return fail(Error.MARKET_NOT_FRESH, FailureInfo.WITHDRAW_FUSE_FEES_FRESH_CHECK);
        }

        // Fail gracefully if protocol has insufficient underlying cash
        if (getCashPrior() &lt; withdrawAmount) {
            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.WITHDRAW_FUSE_FEES_CASH_NOT_AVAILABLE);
        }

        // Check withdrawAmount ≤ fuseFees[n] (totalFuseFees)
        if (withdrawAmount &gt; totalFuseFees) {
            return fail(Error.BAD_INPUT, FailureInfo.WITHDRAW_FUSE_FEES_VALIDATION);
        }

        /////////////////////////
        // EFFECTS &amp; INTERACTIONS
        // (No safe failures beyond this point)

        <span class="marker" id="mapping-298"></span><span class="token mv" id="move-src-93" data-title="function_body/expression_statement">totalFuseFeesNew = <span class="marker" id="mapping-299"></span><span class="token del" data-title="assignment_expression/binary_expression">totalFuseFees - withdrawAmount</span>;</span>
        // We checked withdrawAmount &lt;= totalFuseFees above, so this should never revert.
        <span class="marker" id="mapping-300"></span><span class="token mv" id="move-src-94" data-title="function_body/expression_statement"><span class="marker" id="mapping-301"></span><span class="token mv" id="move-src-95" data-title="expression_statement/call_expression"><span class="marker" id="mapping-302"></span><span class="token del" data-title="call_expression/identifier">require</span>(<span class="marker" id="mapping-303"></span><span class="token del" data-title="call_expression/call_argument">totalFuseFeesNew &lt;= totalFuseFees</span><span class="marker" id="mapping-304"></span><span class="token del" data-title="call_expression/,">,</span> "withdraw Fuse fees unexpected underflow")</span>;</span>

        // Store fuseFees[n+1] = fuseFees[n] - withdrawAmount
        totalFuseFees = totalFuseFeesNew;

        // doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.
        doTransferOut(address(fuseAdmin), withdrawAmount);

        return uint(Error.NO_ERROR);
    }

    /**
     * @notice Accrues interest and reduces admin fees by transferring to admin
     * @param withdrawAmount Amount of fees to withdraw
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function _withdrawAdminFees(uint withdrawAmount) external nonReentrant returns (uint) {
        uint error = accrueInterest();
        if (error != uint(Error.NO_ERROR)) {
            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted admin fee withdrawal failed.
            return fail(Error(error), FailureInfo.WITHDRAW_ADMIN_FEES_ACCRUE_INTEREST_FAILED);
        }
        // _withdrawAdminFeesFresh emits reserve-reduction-specific logs on errors, so we don't need to.
        return _withdrawAdminFeesFresh(withdrawAmount);
    }

    /**
     * @notice Reduces admin fees by transferring to admin
     * @dev Requires fresh interest accrual
     * @param withdrawAmount Amount of fees to withdraw
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function _withdrawAdminFeesFresh(uint withdrawAmount) internal returns (uint) {
        // totalAdminFees - reduceAmount
        uint totalAdminFeesNew;

        // We fail gracefully unless market's block number equals current block number
        if (accrualBlockNumber != getBlockNumber()) {
            return fail(Error.MARKET_NOT_FRESH, FailureInfo.WITHDRAW_ADMIN_FEES_FRESH_CHECK);
        }

        // Fail gracefully if protocol has insufficient underlying cash
        if (getCashPrior() &lt; withdrawAmount) {
            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.WITHDRAW_ADMIN_FEES_CASH_NOT_AVAILABLE);
        }

        // Check withdrawAmount ≤ adminFees[n] (totalAdminFees)
        if (withdrawAmount &gt; totalAdminFees) {
            return fail(Error.BAD_INPUT, FailureInfo.WITHDRAW_ADMIN_FEES_VALIDATION);
        }

        /////////////////////////
        // EFFECTS &amp; INTERACTIONS
        // (No safe failures beyond this point)

        <span class="marker" id="mapping-305"></span><span class="token del" data-title="function_body/expression_statement">totalAdminFeesNew = totalAdminFees - withdrawAmount;</span>
        // We checked withdrawAmount &lt;= totalAdminFees above, so this should never revert.
        <span class="marker" id="mapping-306"></span><span class="token mv" id="move-src-96" data-title="function_body/expression_statement"><span class="marker" id="mapping-307"></span><span class="token mv" id="move-src-97" data-title="expression_statement/call_expression"><span class="marker" id="mapping-308"></span><span class="token del" data-title="call_expression/identifier">require</span>(<span class="marker" id="mapping-309"></span><span class="token del" data-title="call_expression/call_argument">totalAdminFeesNew &lt;= totalAdminFees</span><span class="marker" id="mapping-310"></span><span class="token del" data-title="call_expression/,">,</span> "withdraw admin fees unexpected underflow")</span>;</span>

        // Store adminFees[n+1] = adminFees[n] - withdrawAmount
        totalAdminFees = totalAdminFeesNew;

        // doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.
        <span class="marker" id="mapping-311"></span><span class="token del" data-title="function_body/expression_statement"><span class="marker" id="mapping-312"></span><span class="token del" data-title="expression_statement/call_expression">doTransferOut(<span class="marker" id="mapping-313"></span><span class="token del" data-title="call_expression/call_argument">admin</span>, <span class="marker" id="mapping-314"></span><span class="token mv" id="move-src-98" data-title="call_expression/call_argument">withdrawAmount</span>)</span>;</span>

        return uint(Error.NO_ERROR);
    }

    /**
     * @notice accrues interest and updates the interest rate model using _setInterestRateModelFresh
     * @dev Admin function to accrue interest and update the interest rate model
     * @param newInterestRateModel the new interest rate model to use
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function _setInterestRateModel(InterestRateModel newInterestRateModel) public returns (uint) {
        uint error = accrueInterest();
        if (error != uint(Error.NO_ERROR)) {
            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted change of interest rate model failed
            return fail(Error(error), FailureInfo.SET_INTEREST_RATE_MODEL_ACCRUE_INTEREST_FAILED);
        }
        // _setInterestRateModelFresh emits interest-rate-model-update-specific logs on errors, so we don't need to.
        return _setInterestRateModelFresh(newInterestRateModel);
    }

    /**
     * @notice updates the interest rate model (*requires fresh interest accrual)
     * @dev Admin function to update the interest rate model
     * @param newInterestRateModel the new interest rate model to use
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function _setInterestRateModelFresh(InterestRateModel newInterestRateModel) internal returns (uint) {

        // Used to store old model for use in the event that is emitted on success
        InterestRateModel oldInterestRateModel;

        // Check caller is admin
        if (!hasAdminRights()) {
            return fail(Error.UNAUTHORIZED, FailureInfo.SET_INTEREST_RATE_MODEL_OWNER_CHECK);
        }

        // We fail gracefully unless market's block number equals current block number
        if (accrualBlockNumber != getBlockNumber()) {
            return fail(Error.MARKET_NOT_FRESH, FailureInfo.SET_INTEREST_RATE_MODEL_FRESH_CHECK);
        }

        // Track the market's current interest rate model
        oldInterestRateModel = interestRateModel;

        // Ensure invoke newInterestRateModel.isInterestRateModel() returns true
        require(newInterestRateModel.isInterestRateModel(), "marker method returned false");

        // Set the interest rate model to newInterestRateModel
        interestRateModel = newInterestRateModel;

        // Emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel)
        emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel);

        return uint(Error.NO_ERROR);
    }

    /*** Safe Token ***/

    /**
     * @notice Gets balance of this contract in terms of the underlying
     * @dev This excludes the value of the current message, if any
     * @return The quantity of underlying owned by this contract
     */
    function getCashPrior() internal view returns (uint);

    /**
     * @dev Performs a transfer in, reverting upon failure. Returns the amount actually transferred to the protocol, in case of a fee.
     *  This may revert due to insufficient balance or insufficient allowance.
     */
    function doTransferIn(address from, uint amount) internal returns (uint);

    /**
     * @dev Performs a transfer out, ideally returning an explanatory error code upon failure tather than reverting.
     *  If caller has not called checked protocol's balance, may revert due to insufficient cash held in the contract.
     *  If caller has checked protocol's balance, and verified it is &gt;= amount, this should not revert in normal conditions.
     */
    function doTransferOut(address payable to, uint amount) internal;


    /*** Reentrancy Guard ***/

    /**
     * @dev Prevents a contract from calling itself, directly or indirectly.
     */
    modifier nonReentrant() <span class="marker" id="mapping-315"></span><span class="token mv" id="move-src-99" data-title="modifier_definition/function_body">{
        require(_notEntered, "re-entered");
        _notEntered = false;
        <span class="marker" id="mapping-316"></span><span class="token mv" id="move-src-100" data-title="function_body/expression_statement">_;</span>
        <span class="marker" id="mapping-317"></span><span class="token mv" id="move-src-101" data-title="function_body/expression_statement">_notEntered = true;</span> <span class="marker" id="mapping-318"></span><span class="token del" data-title="function_body/comment">// get a gas-refund post-Istanbul</span>
    }</span>
}
</pre></div><div class="col-6"><h5>CToken.sol</h5><pre class="pre-scrollable">pragma solidity ^0.5.16;

import "./ComptrollerInterface.sol";
import "./CTokenInterfaces.sol";
import "./ErrorReporter.sol";
import "./Exponential.sol";
import "./EIP20Interface.sol";
import "./EIP20NonStandardInterface.sol";
import "./InterestRateModel.sol";

/**
 * @title Compound's CToken Contract
 * @notice Abstract base for CTokens
 * @author Compound
 */
contract CToken is CTokenInterface, Exponential, TokenErrorReporter {
    <span class="marker" id="mapping-319"></span><span class="token mv" id="move-dst-42" data-title="contract_body/comment"><span class="marker" id="mapping-320"></span><span class="token upd" id="move-dst-42" data-title="contract_body/comment"><span class="cupd">/**
    </span><span class="cupd"> * @notice R</span>e<span class="cupd">t</span>u<span class="cupd">r</span>n<span class="cupd">s</span> <span class="cupd">a</span> boo<span class="cupd">l</span><span class="cupd">e</span><span class="cupd">an</span><span class="cupd"> </span>indic<span class="cupd">a</span>t<span class="cupd">i</span>n<span class="cupd">g</span><span class="cupd"> </span>if<span class="cupd"> </span>th<span class="cupd">e</span><span class="cupd"> </span><span class="cupd">s</span>en<span class="cupd">de</span><span class="cupd">r</span> <span class="cupd">h</span>a<span class="cupd">s</span><span class="cupd"> </span>ad<span class="cupd">m</span>i<span class="cupd">n</span><span class="cupd"> </span>rig<span class="cupd">h</span><span class="cupd">t</span><span class="cupd">s</span><span class="cupd"></span><span class="cupd">
   </span><span class="cupd">  </span>*/</span></span>
    <span class="marker" id="mapping-321"></span><span class="token add" data-title="contract_body/function_definition">function hasAdminRights() <span class="marker" id="mapping-322"></span><span class="token mv" id="move-dst-76" data-title="function_definition/visibility">internal</span> <span class="marker" id="mapping-323"></span><span class="token add" data-title="function_definition/state_mutability">view</span> <span class="marker" id="mapping-324"></span><span class="token add" data-title="function_definition/return_type_definition">returns (bool)</span> <span class="marker" id="mapping-325"></span><span class="token add" data-title="function_definition/function_body">{
        <span class="marker" id="mapping-326"></span><span class="token add" data-title="function_body/variable_declaration_statement">ComptrollerV3Storage comptrollerStorage = ComptrollerV3Storage(address(comptroller));</span>
        <span class="marker" id="mapping-327"></span><span class="token add" data-title="function_body/return_statement">return <span class="marker" id="mapping-328"></span><span class="token add" data-title="return_statement/binary_expression"><span class="marker" id="mapping-329"></span><span class="token add" data-title="binary_expression/parenthesized_expression">(<span class="marker" id="mapping-330"></span><span class="token mv" id="move-dst-52" data-title="parenthesized_expression/binary_expression">msg.sender <span class="marker" id="mapping-331"></span><span class="token add" data-title="binary_expression/==">==</span> <span class="marker" id="mapping-332"></span><span class="token add" data-title="binary_expression/call_expression">comptrollerStorage.admin()</span> <span class="marker" id="mapping-333"></span><span class="token add" data-title="binary_expression/&&">&amp;&amp;</span> <span class="marker" id="mapping-334"></span><span class="token add" data-title="binary_expression/call_expression">comptrollerStorage.adminHasRights()</span></span>)</span> || <span class="marker" id="mapping-335"></span><span class="token add" data-title="binary_expression/parenthesized_expression">(msg.sender == address(fuseAdmin) &amp;&amp; comptrollerStorage.fuseAdminHasRights())</span></span>;</span>
    }</span></span>

    /**
     * @notice Initialize the money market
     * @param comptroller_ The address of the Comptroller
     * @param interestRateModel_ The address of the interest rate model
     * @param initialExchangeRateMantissa_ The initial exchange rate, scaled by 1e18
     * @param name_ EIP-20 name of this token
     * @param symbol_ EIP-20 symbol of this token
     * @param decimals_ EIP-20 decimal precision of this token
     */
    function initialize(ComptrollerInterface comptroller_,
                        InterestRateModel interestRateModel_,
                        uint initialExchangeRateMantissa_,
                        string memory name_,
                        string memory symbol_,
                        uint8 decimals_,
                        uint256 reserveFactorMantissa_,
                        uint256 adminFeeMantissa_) public {
        <span class="marker" id="mapping-336"></span><span class="token mv" id="move-dst-84" data-title="function_body/expression_statement">require(<span class="marker" id="mapping-337"></span><span class="token add" data-title="binary_expression/member_expression">msg.sender</span> <span class="marker" id="mapping-338"></span><span class="token add" data-title="binary_expression/==">==</span> <span class="marker" id="mapping-339"></span><span class="token add" data-title="binary_expression/type_cast_expression">address(fuseAdmin)</span>, "only Fuse admin may initialize the market");</span>
        require(accrualBlockNumber == 0 &amp;&amp; borrowIndex == 0, "market may only be initialized once");

        // Set initial exchange rate
        initialExchangeRateMantissa = initialExchangeRateMantissa_;
        require(initialExchangeRateMantissa &gt; 0, "initial exchange rate must be greater than zero.");

        // Set the comptroller
        uint err = _setComptroller(comptroller_);
        require(err == uint(Error.NO_ERROR), "setting comptroller failed");

        // Initialize block number and borrow index (block number mocks depend on comptroller being set)
        accrualBlockNumber = getBlockNumber();
        borrowIndex = mantissaOne;

        // Set the interest rate model (depends on block number / borrow index)
        err = _setInterestRateModelFresh(interestRateModel_);
        require(err == uint(Error.NO_ERROR), "setting interest rate model failed");

        name = name_;
        symbol = symbol_;
        decimals = decimals_;

        // Set reserve factor
        err = _setReserveFactorFresh(reserveFactorMantissa_);
        require(err == uint(Error.NO_ERROR), "setting reserve factor failed");

        // Set admin fee
        err = _setAdminFeeFresh(adminFeeMantissa_);
        require(err == uint(Error.NO_ERROR), "setting admin fee failed");

        // The counter starts true to prevent changing it from zero to non-zero (i.e. smaller cost/refund)
        _notEntered = true;
    }
    
    /**
     * @dev Returns latest pending Fuse fee (to be set with `_setFuseFeeFresh`)
     */
    function getPendingFuseFeeFromAdmin() internal view returns (uint) {
        return fuseAdmin.interestFeeRate();
    }

    /**
     * @notice Transfer `tokens` tokens from `src` to `dst` by `spender`
     * @dev Called by both `transfer` and `transferFrom` internally
     * @param spender The address of the account performing the transfer
     * @param src The address of the source account
     * @param dst The address of the destination account
     * @param tokens The number of tokens to transfer
     * @return Whether or not the transfer succeeded
     */
    function transferTokens(address spender, address src, address dst, uint tokens) internal returns (uint) {
        /* Fail if transfer not allowed */
        uint allowed = comptroller.transferAllowed(address(this), src, dst, tokens);
        if (allowed != 0) {
            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.TRANSFER_COMPTROLLER_REJECTION, allowed);
        }

        /* Do not allow self-transfers */
        if (src == dst) {
            return fail(Error.BAD_INPUT, FailureInfo.TRANSFER_NOT_ALLOWED);
        }

        /* Get the allowance, infinite for the account owner */
        uint startingAllowance = 0;
        if (spender == src) {
            startingAllowance = uint(-1);
        } else {
            startingAllowance = transferAllowances[src][spender];
        }

        /* Do the calculations, checking for {under,over}flow */
        MathError mathErr;
        uint allowanceNew;
        uint srcTokensNew;
        uint dstTokensNew;

        (mathErr, allowanceNew) = subUInt(startingAllowance, tokens);
        if (mathErr != MathError.NO_ERROR) {
            return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_NOT_ALLOWED);
        }

        (mathErr, srcTokensNew) = subUInt(accountTokens[src], tokens);
        if (mathErr != MathError.NO_ERROR) {
            return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_NOT_ENOUGH);
        }

        (mathErr, dstTokensNew) = addUInt(accountTokens[dst], tokens);
        if (mathErr != MathError.NO_ERROR) {
            return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_TOO_MUCH);
        }

        /////////////////////////
        // EFFECTS &amp; INTERACTIONS
        // (No safe failures beyond this point)

        accountTokens[src] = srcTokensNew;
        accountTokens[dst] = dstTokensNew;

        /* Eat some of the allowance (if necessary) */
        if (startingAllowance != uint(-1)) {
            transferAllowances[src][spender] = allowanceNew;
        }

        /* We emit a Transfer event */
        emit Transfer(src, dst, tokens);

        <span class="marker" id="mapping-340"></span><span class="token add" data-title="function_body/comment">/* We call the defense hook */</span>
        <span class="marker" id="mapping-341"></span><span class="token add" data-title="function_body/comment">// unused function</span>
        <span class="marker" id="mapping-342"></span><span class="token add" data-title="function_body/comment">// comptroller.transferVerify(address(this), src, dst, tokens);</span>

        return uint(Error.NO_ERROR);
    }

    /**
     * @notice Transfer `amount` tokens from `msg.sender` to `dst`
     * @param dst The address of the destination account
     * @param amount The number of tokens to transfer
     * @return Whether or not the transfer succeeded
     */
    function transfer(address dst, uint256 amount) external nonReentrant<span class="marker" id="mapping-343"></span><span class="token add" data-title="modifier_invocation/(">(</span><span class="marker" id="mapping-344"></span><span class="token add" data-title="modifier_invocation/call_argument"><span class="marker" id="mapping-345"></span><span class="token mv" id="move-dst-43" data-title="call_argument/boolean_literal">false</span></span><span class="marker" id="mapping-346"></span><span class="token add" data-title="modifier_invocation/)">)</span> returns (bool) {
        return transferTokens(msg.sender, msg.sender, dst, amount) == uint(Error.NO_ERROR);
    }

    /**
     * @notice Transfer `amount` tokens from `src` to `dst`
     * @param src The address of the source account
     * @param dst The address of the destination account
     * @param amount The number of tokens to transfer
     * @return Whether or not the transfer succeeded
     */
    function transferFrom(address src, address dst, uint256 amount) external nonReentrant<span class="marker" id="mapping-347"></span><span class="token add" data-title="modifier_invocation/(">(</span><span class="marker" id="mapping-348"></span><span class="token add" data-title="modifier_invocation/call_argument"><span class="marker" id="mapping-349"></span><span class="token mv" id="move-dst-46" data-title="call_argument/boolean_literal">false</span></span><span class="marker" id="mapping-350"></span><span class="token add" data-title="modifier_invocation/)">)</span> returns (bool) {
        return transferTokens(msg.sender, src, dst, amount) == uint(Error.NO_ERROR);
    }

    /**
     * @notice Approve `spender` to transfer up to `amount` from `src`
     * @dev This will overwrite the approval amount for `spender`
     *  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)
     * @param spender The address of the account which may transfer tokens
     * @param amount The number of tokens that are approved (-1 means infinite)
     * @return Whether or not the approval succeeded
     */
    function approve(address spender, uint256 amount) external returns (bool) {
        address src = msg.sender;
        transferAllowances[src][spender] = amount;
        emit Approval(src, spender, amount);
        return true;
    }

    /**
     * @notice Get the current allowance from `owner` for `spender`
     * @param owner The address of the account which owns the tokens to be spent
     * @param spender The address of the account which may transfer tokens
     * @return The number of tokens allowed to be spent (-1 means infinite)
     */
    function allowance(address owner, address spender) external view returns (uint256) {
        return transferAllowances[owner][spender];
    }

    /**
     * @notice Get the token balance of the `owner`
     * @param owner The address of the account to query
     * @return The number of tokens owned by `owner`
     */
    function balanceOf(address owner) external view returns (uint256) {
        return accountTokens[owner];
    }

    /**
     * @notice Get the underlying balance of the `owner`
     * @dev This also accrues interest in a transaction
     * @param owner The address of the account to query
     * @return The amount of underlying owned by `owner`
     */
    function balanceOfUnderlying(address owner) external returns (uint) {
        Exp memory exchangeRate = Exp({mantissa: exchangeRateCurrent()});
        (MathError mErr, uint balance) = mulScalarTruncate(exchangeRate, accountTokens[owner]);
        require(mErr == MathError.NO_ERROR, "balance could not be calculated");
        return balance;
    }

    /**
     * @notice Get a snapshot of the account's balances, and the cached exchange rate
     * @dev This is used by comptroller to more efficiently perform liquidity checks.
     * @param account Address of the account to snapshot
     * @return (possible error, token balance, borrow balance, exchange rate mantissa)
     */
    function getAccountSnapshot(address account) external view returns (uint, uint, uint, uint) {
        uint cTokenBalance = accountTokens[account];
        uint borrowBalance;
        uint exchangeRateMantissa;

        MathError mErr;

        (mErr, borrowBalance) = borrowBalanceStoredInternal(account);
        if (mErr != MathError.NO_ERROR) {
            return (uint(Error.MATH_ERROR), 0, 0, 0);
        }

        (mErr, exchangeRateMantissa) = exchangeRateStoredInternal();
        if (mErr != MathError.NO_ERROR) {
            return (uint(Error.MATH_ERROR), 0, 0, 0);
        }

        return (uint(Error.NO_ERROR), cTokenBalance, borrowBalance, exchangeRateMantissa);
    }

    /**
     * @dev Function to simply retrieve block number
     *  This exists mainly for inheriting test contracts to stub this result.
     */
    function getBlockNumber() internal view returns (uint) {
        return block.number;
    }

    /**
     * @notice Returns the current per-block borrow interest rate for this cToken
     * @return The borrow interest rate per block, scaled by 1e18
     */
    function borrowRatePerBlock() external view returns (uint) {
        return interestRateModel.getBorrowRate(getCashPrior(), totalBorrows, <span class="marker" id="mapping-351"></span><span class="token add" data-title="call_argument/call_expression">add_(totalReserves, add_(totalAdminFees, totalFuseFees))</span>);
    }

    /**
     * @notice Returns the current per-block supply interest rate for this cToken
     * @return The supply interest rate per block, scaled by 1e18
     */
    function supplyRatePerBlock() external view returns (uint) {
        return interestRateModel.getSupplyRate(getCashPrior(), totalBorrows, <span class="marker" id="mapping-352"></span><span class="token add" data-title="call_argument/call_expression">add_(totalReserves, add_(totalAdminFees, totalFuseFees))</span>, reserveFactorMantissa + fuseFeeMantissa + adminFeeMantissa);
    }

    /**
     * @notice Returns the current total borrows plus accrued interest
     * @return The total borrows with interest
     */
    function totalBorrowsCurrent() external nonReentrant<span class="marker" id="mapping-353"></span><span class="token add" data-title="modifier_invocation/(">(</span><span class="marker" id="mapping-354"></span><span class="token add" data-title="modifier_invocation/call_argument">false</span><span class="marker" id="mapping-355"></span><span class="token add" data-title="modifier_invocation/)">)</span> returns (uint) {
        require(accrueInterest() == uint(Error.NO_ERROR), "accrue interest failed");
        return totalBorrows;
    }

    /**
     * @notice Accrue interest to updated borrowIndex and then calculate account's borrow balance using the updated borrowIndex
     * @param account The address whose balance should be calculated after updating borrowIndex
     * @return The calculated balance
     */
    function borrowBalanceCurrent(address account) external nonReentrant<span class="marker" id="mapping-356"></span><span class="token add" data-title="modifier_invocation/(">(</span><span class="marker" id="mapping-357"></span><span class="token add" data-title="modifier_invocation/call_argument">false</span><span class="marker" id="mapping-358"></span><span class="token add" data-title="modifier_invocation/)">)</span> returns (uint) {
        require(accrueInterest() == uint(Error.NO_ERROR), "accrue interest failed");
        return borrowBalanceStored(account);
    }

    /**
     * @notice Return the borrow balance of account based on stored data
     * @param account The address whose balance should be calculated
     * @return The calculated balance
     */
    function borrowBalanceStored(address account) public view returns (uint) {
        (MathError err, uint result) = borrowBalanceStoredInternal(account);
        require(err == MathError.NO_ERROR, "borrowBalanceStored: borrowBalanceStoredInternal failed");
        return result;
    }

    /**
     * @notice Return the borrow balance of account based on stored data
     * @param account The address whose balance should be calculated
     * @return (error code, the calculated balance or 0 if error code is non-zero)
     */
    function borrowBalanceStoredInternal(address account) internal view returns (MathError, uint) {
        /* Note: we do not assert that the market is up to date */
        MathError mathErr;
        uint principalTimesIndex;
        uint result;

        /* Get borrowBalance and borrowIndex */
        BorrowSnapshot storage borrowSnapshot = accountBorrows[account];

        /* If borrowBalance = 0 then borrowIndex is likely also 0.
         * Rather than failing the calculation with a division by 0, we immediately return 0 in this case.
         */
        if (borrowSnapshot.principal == 0) {
            return (MathError.NO_ERROR, 0);
        }

        /* Calculate new borrow balance using the interest index:
         *  recentBorrowBalance = borrower.borrowBalance * market.borrowIndex / borrower.borrowIndex
         */
        (mathErr, principalTimesIndex) = mulUInt(borrowSnapshot.principal, borrowIndex);
        if (mathErr != MathError.NO_ERROR) {
            return (mathErr, 0);
        }

        (mathErr, result) = divUInt(principalTimesIndex, borrowSnapshot.interestIndex);
        if (mathErr != MathError.NO_ERROR) {
            return (mathErr, 0);
        }

        return (MathError.NO_ERROR, result);
    }

    /**
     * @notice Accrue interest then return the up-to-date exchange rate
     * @return Calculated exchange rate scaled by 1e18
     */
    function exchangeRateCurrent() public nonReentrant<span class="marker" id="mapping-359"></span><span class="token add" data-title="modifier_invocation/(">(</span><span class="marker" id="mapping-360"></span><span class="token add" data-title="modifier_invocation/call_argument">false</span><span class="marker" id="mapping-361"></span><span class="token add" data-title="modifier_invocation/)">)</span> returns (uint) {
        require(accrueInterest() == uint(Error.NO_ERROR), "accrue interest failed");
        return exchangeRateStored();
    }

    /**
     * @notice Calculates the exchange rate from the underlying to the CToken
     * @dev This function does not accrue interest before calculating the exchange rate
     * @return Calculated exchange rate scaled by 1e18
     */
    function exchangeRateStored() public view returns (uint) {
        (MathError err, uint result) = exchangeRateStoredInternal();
        require(err == MathError.NO_ERROR, "exchangeRateStored: exchangeRateStoredInternal failed");
        return result;
    }

    /**
     * @notice Calculates the exchange rate from the underlying to the CToken
     * @dev This function does not accrue interest before calculating the exchange rate
     * @return (error code, calculated exchange rate scaled by 1e18)
     */
    function exchangeRateStoredInternal() internal view returns (MathError, uint) {
        uint _totalSupply = totalSupply;
        if (_totalSupply == 0) {
            /*
             * If there are no tokens minted:
             *  exchangeRate = initialExchangeRate
             */
            return (MathError.NO_ERROR, initialExchangeRateMantissa);
        } else {
            /*
             * Otherwise:
             *  exchangeRate = (totalCash + totalBorrows - (totalReserves + totalFuseFees + totalAdminFees)) / totalSupply
             */
            uint totalCash = getCashPrior();
            uint cashPlusBorrowsMinusReserves;
            Exp memory exchangeRate;
            MathError mathErr;

            (mathErr, cashPlusBorrowsMinusReserves) = addThenSubUInt(totalCash, totalBorrows, <span class="marker" id="mapping-362"></span><span class="token add" data-title="call_argument/call_expression">add_(totalReserves, add_(totalAdminFees, totalFuseFees))</span>);
            if (mathErr != MathError.NO_ERROR) {
                return (mathErr, 0);
            }

            (mathErr, exchangeRate) = getExp(cashPlusBorrowsMinusReserves, _totalSupply);
            if (mathErr != MathError.NO_ERROR) {
                return (mathErr, 0);
            }

            return (MathError.NO_ERROR, exchangeRate.mantissa);
        }
    }

    /**
     * @notice Get cash balance of this cToken in the underlying asset
     * @return The quantity of underlying asset owned by this contract
     */
    function getCash() external view returns (uint) {
        return getCashPrior();
    }

    /**
     * @notice Applies accrued interest to total borrows and reserves
     * @dev This calculates interest accrued from the last checkpointed block
     *   up to the current block and writes new checkpoint to storage.
     */
    function accrueInterest() public returns (uint) {
        /* Remember the initial block number */
        uint currentBlockNumber = getBlockNumber();

        /* Short-circuit accumulating 0 interest */
        if (accrualBlockNumber == currentBlockNumber) {
            return uint(Error.NO_ERROR);
        }

        /* Read the previous values out of storage */
        uint cashPrior = getCashPrior();

        /* Calculate the current borrow interest rate */
        uint borrowRateMantissa = interestRateModel.getBorrowRate(cashPrior, totalBorrows, <span class="marker" id="mapping-363"></span><span class="token add" data-title="call_argument/call_expression">add_(totalReserves, add_(totalAdminFees, totalFuseFees))</span>);
        require(borrowRateMantissa &lt;= borrowRateMaxMantissa, "borrow rate is absurdly high");

        /* Calculate the number of blocks elapsed since the last accrual */
        (MathError mathErr, uint blockDelta) = subUInt(currentBlockNumber, accrualBlockNumber);
        require(mathErr == MathError.NO_ERROR, "could not calculate block delta");

        return finishInterestAccrual(currentBlockNumber, cashPrior, borrowRateMantissa, blockDelta);
    }

    <span class="marker" id="mapping-364"></span><span class="token mv" id="move-dst-45" data-title="contract_body/comment"><span class="marker" id="mapping-365"></span><span class="token upd" id="move-dst-45" data-title="contract_body/comment"><span class="cupd">/**
    </span><span class="cupd"> * </span>@<span class="cupd">d</span>e<span class="cupd">v</span> Sp<span class="cupd">l</span><span class="cupd">i</span><span class="cupd">t</span> of<span class="cupd">f</span> <span class="cupd">f</span>ro<span class="cupd">m</span> `<span class="cupd">ac</span>cr<span class="cupd">u</span>eI<span class="cupd">n</span><span class="cupd">te</span>r<span class="cupd">e</span>st<span class="cupd">`</span> t<span class="cupd">o</span><span class="cupd"> </span>av<span class="cupd">o</span>i<span class="cupd">d</span> <span class="cupd">"</span>stack too <span class="cupd">de</span>ep<span class="cupd">"</span> <span class="cupd">erro</span>r<span class="cupd">"</span><span class="cupd">.</span><span class="cupd"></span><span class="cupd">
   </span><span class="cupd">  </span>*/</span></span>
    function finishInterestAccrual(uint currentBlockNumber, uint cashPrior, uint borrowRateMantissa, uint blockDelta) private returns (uint) {
        /*
         * Calculate the interest accumulated into borrows and reserves and the new index:
         *  simpleInterestFactor = borrowRate * blockDelta
         *  interestAccumulated = simpleInterestFactor * totalBorrows
         *  totalBorrowsNew = interestAccumulated + totalBorrows
         *  totalReservesNew = interestAccumulated * reserveFactor + totalReserves
         *  totalFuseFeesNew = interestAccumulated * fuseFee + totalFuseFees
         *  totalAdminFeesNew = interestAccumulated * adminFee + totalAdminFees
         *  borrowIndexNew = simpleInterestFactor * borrowIndex + borrowIndex
         */

        Exp memory simpleInterestFactor <span class="marker" id="mapping-366"></span><span class="token add" data-title="variable_declaration_statement/=">=</span> <span class="marker" id="mapping-367"></span><span class="token mv" id="move-dst-3" data-title="variable_declaration_statement/call_expression"><span class="marker" id="mapping-368"></span><span class="token upd" id="move-dst-4" data-title="call_expression/identifier"><span class="cupd">mul</span>_</span>(Exp({mantissa: borrowRateMantissa}), blockDelta)</span>;
        uint interestAccumulated <span class="marker" id="mapping-369"></span><span class="token add" data-title="variable_declaration_statement/=">=</span> <span class="marker" id="mapping-370"></span><span class="token mv" id="move-dst-5" data-title="variable_declaration_statement/call_expression"><span class="marker" id="mapping-371"></span><span class="token upd" id="move-dst-6" data-title="call_expression/identifier"><span class="cupd">mul</span>_<span class="cupd">ScalarTruncate</span></span>(simpleInterestFactor, totalBorrows)</span>;
        uint totalBorrowsNew <span class="marker" id="mapping-372"></span><span class="token add" data-title="variable_declaration_statement/=">=</span> <span class="marker" id="mapping-373"></span><span class="token mv" id="move-dst-7" data-title="variable_declaration_statement/call_expression"><span class="marker" id="mapping-374"></span><span class="token upd" id="move-dst-8" data-title="call_expression/identifier"><span class="cupd">add</span>_</span>(interestAccumulated, totalBorrows)</span>;
        <span class="marker" id="mapping-375"></span><span class="token add" data-title="function_body/variable_declaration_statement"><span class="marker" id="mapping-376"></span><span class="token mv" id="move-dst-37" data-title="variable_declaration_statement/variable_declaration">uint <span class="marker" id="mapping-377"></span><span class="token upd" id="move-dst-38" data-title="variable_declaration/identifier"><span class="cupd">to</span>talRese<span class="cupd">r</span>v<span class="cupd">e</span><span class="cupd">sNew</span></span></span> = <span class="marker" id="mapping-378"></span><span class="token mv" id="move-dst-9" data-title="variable_declaration_statement/call_expression"><span class="marker" id="mapping-379"></span><span class="token upd" id="move-dst-10" data-title="call_expression/identifier"><span class="cupd">mul</span>_<span class="cupd">ScalarTruncateAddUInt</span></span>(Exp({mantissa: reserveFactorMantissa}), interestAccumulated, totalReserves)</span>;</span>
        <span class="marker" id="mapping-380"></span><span class="token add" data-title="function_body/variable_declaration_statement"><span class="marker" id="mapping-381"></span><span class="token mv" id="move-dst-35" data-title="variable_declaration_statement/variable_declaration">uint <span class="marker" id="mapping-382"></span><span class="token upd" id="move-dst-36" data-title="variable_declaration/identifier">t<span class="cupd">o</span>talFus<span class="cupd">e</span>F<span class="cupd">e</span>e<span class="cupd">sNew</span></span></span> = <span class="marker" id="mapping-383"></span><span class="token mv" id="move-dst-11" data-title="variable_declaration_statement/call_expression"><span class="marker" id="mapping-384"></span><span class="token upd" id="move-dst-12" data-title="call_expression/identifier"><span class="cupd">mul</span>_<span class="cupd">ScalarTruncateAddUInt</span></span>(Exp({mantissa: fuseFeeMantissa}), interestAccumulated, totalFuseFees)</span>;</span>
        <span class="marker" id="mapping-385"></span><span class="token add" data-title="function_body/variable_declaration_statement"><span class="marker" id="mapping-386"></span><span class="token mv" id="move-dst-28" data-title="variable_declaration_statement/variable_declaration">uint <span class="marker" id="mapping-387"></span><span class="token upd" id="move-dst-29" data-title="variable_declaration/identifier">tot<span class="cupd">a</span><span class="cupd">l</span>Adm<span class="cupd">i</span><span class="cupd">n</span>FeesNew</span></span> = <span class="marker" id="mapping-388"></span><span class="token mv" id="move-dst-13" data-title="variable_declaration_statement/call_expression"><span class="marker" id="mapping-389"></span><span class="token upd" id="move-dst-14" data-title="call_expression/identifier"><span class="cupd">mul</span>_<span class="cupd">ScalarTruncateAddUInt</span></span>(Exp({mantissa: adminFeeMantissa}), interestAccumulated, totalAdminFees)</span>;</span>
        uint borrowIndexNew <span class="marker" id="mapping-390"></span><span class="token add" data-title="variable_declaration_statement/=">=</span> <span class="marker" id="mapping-391"></span><span class="token mv" id="move-dst-15" data-title="variable_declaration_statement/call_expression"><span class="marker" id="mapping-392"></span><span class="token upd" id="move-dst-16" data-title="call_expression/identifier"><span class="cupd">mul</span>_<span class="cupd">ScalarTruncateAddUInt</span></span>(simpleInterestFactor, borrowIndex, borrowIndex)</span>;

        /////////////////////////
        // EFFECTS &amp; INTERACTIONS
        // (No safe failures beyond this point)

        /* We write the previously calculated values into storage */
        accrualBlockNumber = currentBlockNumber;
        borrowIndex = borrowIndexNew;
        totalBorrows = totalBorrowsNew;
        totalReserves = totalReservesNew;
        totalFuseFees = totalFuseFeesNew;
        totalAdminFees = totalAdminFeesNew;

        /* We emit an AccrueInterest event */
        emit AccrueInterest(cashPrior, interestAccumulated, borrowIndexNew, totalBorrowsNew);

        <span class="marker" id="mapping-393"></span><span class="token add" data-title="function_body/comment">// Attempt to add interest checkpoint</span>
        <span class="marker" id="mapping-394"></span><span class="token mv" id="move-dst-87" data-title="function_body/expression_statement"><span class="marker" id="mapping-395"></span><span class="token add" data-title="expression_statement/call_expression"><span class="marker" id="mapping-396"></span><span class="token add" data-title="call_expression/member_expression">address(interestRateModel).call</span>(<span class="marker" id="mapping-397"></span><span class="token add" data-title="call_expression/call_argument"><span class="marker" id="mapping-398"></span><span class="token mv" id="move-dst-88" data-title="call_argument/call_expression"><span class="marker" id="mapping-399"></span><span class="token add" data-title="call_expression/member_expression">abi.encodeWithSignature</span>("checkpointInterest(uint256)"<span class="marker" id="mapping-400"></span><span class="token mv" id="move-dst-90" data-title="call_expression/,">,</span> <span class="marker" id="mapping-401"></span><span class="token mv" id="move-dst-89" data-title="call_expression/call_argument"><span class="marker" id="mapping-402"></span><span class="token add" data-title="call_argument/identifier">borrowRateMantissa</span></span>)</span></span>)</span>;</span>

        return uint(Error.NO_ERROR);
    }

    /**
     * @notice Sender supplies assets into the market and receives cTokens in exchange
     * @dev Accrues interest whether or not the operation succeeds, unless reverted
     * @param mintAmount The amount of the underlying asset to supply
     * @return (uint, uint) An error code (0=success, otherwise a failure, see ErrorReporter.sol), and the actual mint amount.
     */
    function mintInternal(uint mintAmount) internal nonReentrant<span class="marker" id="mapping-403"></span><span class="token add" data-title="modifier_invocation/(">(</span><span class="marker" id="mapping-404"></span><span class="token add" data-title="modifier_invocation/call_argument">false</span><span class="marker" id="mapping-405"></span><span class="token add" data-title="modifier_invocation/)">)</span> returns (uint, uint) {
        uint error = accrueInterest();
        if (error != uint(Error.NO_ERROR)) {
            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed
            return (fail(Error(error), FailureInfo.MINT_ACCRUE_INTEREST_FAILED), 0);
        }
        // mintFresh emits the actual Mint event if successful and logs on errors, so we don't need to
        return mintFresh(msg.sender, mintAmount);
    }

    struct MintLocalVars {
        Error err;
        MathError mathErr;
        uint exchangeRateMantissa;
        uint mintTokens;
        uint totalSupplyNew;
        uint accountTokensNew;
        uint actualMintAmount;
    }

    /**
     * @notice User supplies assets into the market and receives cTokens in exchange
     * @dev Assumes interest has already been accrued up to the current block
     * @param minter The address of the account which is supplying the assets
     * @param mintAmount The amount of the underlying asset to supply
     * @return (uint, uint) An error code (0=success, otherwise a failure, see ErrorReporter.sol), and the actual mint amount.
     */
    function mintFresh(address minter, uint mintAmount) internal returns (uint, uint) {
        /* Fail if mint not allowed */
        uint allowed = comptroller.mintAllowed(address(this), minter, mintAmount);
        if (allowed != 0) {
            return (failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.MINT_COMPTROLLER_REJECTION, allowed), 0);
        }

        /* Verify market's block number equals current block number */
        if (accrualBlockNumber != getBlockNumber()) {
            return (fail(Error.MARKET_NOT_FRESH, FailureInfo.MINT_FRESHNESS_CHECK), 0);
        }

        MintLocalVars memory vars;

        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();
        if (vars.mathErr != MathError.NO_ERROR) {
            return (failOpaque(Error.MATH_ERROR, FailureInfo.MINT_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr)), 0);
        }

        // Check max supply
        <span class="marker" id="mapping-406"></span><span class="token add" data-title="function_body/comment">// unused function</span>
        <span class="marker" id="mapping-407"></span><span class="token add" data-title="function_body/comment">/* allowed = comptroller.mintWithinLimits(address(this), vars.exchangeRateMantissa, accountTokens[minter], mintAmount);
        if (allowed != 0) {
            return (failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.MINT_COMPTROLLER_REJECTION, allowed), 0);
        } */</span>

        /////////////////////////
        // EFFECTS &amp; INTERACTIONS
        // (No safe failures beyond this point)

        /*
         *  We call `doTransferIn` for the minter and the mintAmount.
         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.
         *  `doTransferIn` reverts if anything goes wrong, since we can't be sure if
         *  side-effects occurred. The function returns the amount actually transferred,
         *  in case of a fee. On success, the cToken holds an additional `actualMintAmount`
         *  of cash.
         */
        vars.actualMintAmount = doTransferIn(minter, mintAmount);

        /*
         * We get the current exchange rate and calculate the number of cTokens to be minted:
         *  mintTokens = actualMintAmount / exchangeRate
         */

        (vars.mathErr, vars.mintTokens) = divScalarByExpTruncate(vars.actualMintAmount, Exp({mantissa: vars.exchangeRateMantissa}));
        require(vars.mathErr == MathError.NO_ERROR, "MINT_EXCHANGE_CALCULATION_FAILED");

        /*
         * We calculate the new total supply of cTokens and minter token balance, checking for overflow:
         *  totalSupplyNew = totalSupply + mintTokens
         *  accountTokensNew = accountTokens[minter] + mintTokens
         */
        <span class="marker" id="mapping-408"></span><span class="token mv" id="move-dst-20" data-title="assignment_expression/member_expression">vars.totalSupplyNew</span> = <span class="marker" id="mapping-409"></span><span class="token upd" id="move-dst-21" data-title="call_expression/identifier"><span class="cupd">add</span>_</span>(totalSupply, vars.mintTokens);

        <span class="marker" id="mapping-410"></span><span class="token mv" id="move-dst-24" data-title="assignment_expression/member_expression">vars.accountTokensNew</span> = <span class="marker" id="mapping-411"></span><span class="token upd" id="move-dst-25" data-title="call_expression/identifier"><span class="cupd">add</span>_</span>(accountTokens[minter], vars.mintTokens);

        /* We write previously calculated values into storage */
        totalSupply = vars.totalSupplyNew;
        accountTokens[minter] = vars.accountTokensNew;

        /* We emit a Mint event, and a Transfer event */
        emit Mint(minter, vars.actualMintAmount, vars.mintTokens);
        emit Transfer(address(this), minter, vars.mintTokens);

        /* We call the defense hook */
        comptroller.mintVerify(address(this), minter, vars.actualMintAmount, vars.mintTokens);

        return (uint(Error.NO_ERROR), vars.actualMintAmount);
    }

    /**
     * @notice Sender redeems cTokens in exchange for the underlying asset
     * @dev Accrues interest whether or not the operation succeeds, unless reverted
     * @param redeemTokens The number of cTokens to redeem into underlying
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function redeemInternal(uint redeemTokens) internal nonReentrant<span class="marker" id="mapping-412"></span><span class="token add" data-title="modifier_invocation/(">(</span><span class="marker" id="mapping-413"></span><span class="token add" data-title="modifier_invocation/call_argument">false</span><span class="marker" id="mapping-414"></span><span class="token add" data-title="modifier_invocation/)">)</span> returns (uint) {
        uint error = accrueInterest();
        if (error != uint(Error.NO_ERROR)) {
            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted redeem failed
            return fail(Error(error), FailureInfo.REDEEM_ACCRUE_INTEREST_FAILED);
        }
        // redeemFresh emits redeem-specific logs on errors, so we don't need to
        return redeemFresh(msg.sender, redeemTokens, 0);
    }

    /**
     * @notice Sender redeems cTokens in exchange for a specified amount of underlying asset
     * @dev Accrues interest whether or not the operation succeeds, unless reverted
     * @param redeemAmount The amount of underlying to receive from redeeming cTokens
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function redeemUnderlyingInternal(uint redeemAmount) internal nonReentrant<span class="marker" id="mapping-415"></span><span class="token add" data-title="modifier_invocation/(">(</span><span class="marker" id="mapping-416"></span><span class="token add" data-title="modifier_invocation/call_argument">false</span><span class="marker" id="mapping-417"></span><span class="token add" data-title="modifier_invocation/)">)</span> returns (uint) {
        uint error = accrueInterest();
        if (error != uint(Error.NO_ERROR)) {
            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted redeem failed
            return fail(Error(error), FailureInfo.REDEEM_ACCRUE_INTEREST_FAILED);
        }
        // redeemFresh emits redeem-specific logs on errors, so we don't need to
        return redeemFresh(msg.sender, 0, redeemAmount);
    }

    struct RedeemLocalVars {
        Error err;
        MathError mathErr;
        uint exchangeRateMantissa;
        uint redeemTokens;
        uint redeemAmount;
        uint totalSupplyNew;
        uint accountTokensNew;
    }

    /**
     * @notice User redeems cTokens in exchange for the underlying asset
     * @dev Assumes interest has already been accrued up to the current block
     * @param redeemer The address of the account which is redeeming the tokens
     * @param redeemTokensIn The number of cTokens to redeem into underlying (only one of redeemTokensIn or redeemAmountIn may be non-zero)
     * @param redeemAmountIn The number of underlying tokens to receive from redeeming cTokens (only one of redeemTokensIn or redeemAmountIn may be non-zero)
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {
        require(redeemTokensIn == 0 || redeemAmountIn == 0, "one of redeemTokensIn or redeemAmountIn must be zero");

        RedeemLocalVars memory vars;

        /* exchangeRate = invoke Exchange Rate Stored() */
        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));
        }

        /* If redeemTokensIn &gt; 0: */
        if (redeemTokensIn &gt; 0) {
            /*
             * We calculate the exchange rate and the amount of underlying to be redeemed:
             *  redeemTokens = redeemTokensIn
             *  redeemAmount = redeemTokensIn x exchangeRateCurrent
             */
            vars.redeemTokens = redeemTokensIn;

            (vars.mathErr, vars.redeemAmount) = mulScalarTruncate(Exp({mantissa: vars.exchangeRateMantissa}), redeemTokensIn);
            if (vars.mathErr != MathError.NO_ERROR) {
                return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_TOKENS_CALCULATION_FAILED, uint(vars.mathErr));
            }
        } else {
            /*
             * We get the current exchange rate and calculate the amount to be redeemed:
             *  redeemTokens = redeemAmountIn / exchangeRate
             *  redeemAmount = redeemAmountIn
             */

            (vars.mathErr, vars.redeemTokens) = divScalarByExpTruncate(redeemAmountIn, Exp({mantissa: vars.exchangeRateMantissa}));
            if (vars.mathErr != MathError.NO_ERROR) {
                return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_AMOUNT_CALCULATION_FAILED, uint(vars.mathErr));
            }

            vars.redeemAmount = redeemAmountIn;
        }

        /* Fail if redeem not allowed */
        uint allowed = comptroller.redeemAllowed(address(this), redeemer, vars.redeemTokens);
        if (allowed != 0) {
            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.REDEEM_COMPTROLLER_REJECTION, allowed);
        }

        /* Verify market's block number equals current block number */
        if (accrualBlockNumber != getBlockNumber()) {
            return fail(Error.MARKET_NOT_FRESH, FailureInfo.REDEEM_FRESHNESS_CHECK);
        }

        /*
         * We calculate the new total supply and redeemer balance, checking for underflow:
         *  totalSupplyNew = totalSupply - redeemTokens
         *  accountTokensNew = accountTokens[redeemer] - redeemTokens
         */
        (vars.mathErr, vars.totalSupplyNew) = subUInt(totalSupply, vars.redeemTokens);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_NEW_TOTAL_SUPPLY_CALCULATION_FAILED, uint(vars.mathErr));
        }

        (vars.mathErr, vars.accountTokensNew) = subUInt(accountTokens[redeemer], vars.redeemTokens);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));
        }

        /* Fail gracefully if protocol has insufficient cash */
        if (getCashPrior() &lt; vars.redeemAmount) {
            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.REDEEM_TRANSFER_OUT_NOT_POSSIBLE);
        }

        /////////////////////////
        // EFFECTS &amp; INTERACTIONS
        // (No safe failures beyond this point)

        /*
         * We invoke doTransferOut for the redeemer and the redeemAmount.
         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.
         *  On success, the cToken has redeemAmount less of cash.
         *  doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.
         */
        doTransferOut(redeemer, vars.redeemAmount);

        /* We write previously calculated values into storage */
        totalSupply = vars.totalSupplyNew;
        accountTokens[redeemer] = vars.accountTokensNew;

        /* We emit a Transfer event, and a Redeem event */
        emit Transfer(redeemer, address(this), vars.redeemTokens);
        emit Redeem(redeemer, vars.redeemAmount, vars.redeemTokens);

        /* We call the defense hook */
        comptroller.redeemVerify(address(this), redeemer, vars.redeemAmount, vars.redeemTokens);

        return uint(Error.NO_ERROR);
    }

    /**
      * @notice Sender borrows assets from the protocol to their own address
      * @param borrowAmount The amount of the underlying asset to borrow
      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
      */
    function borrowInternal(uint borrowAmount) internal nonReentrant<span class="marker" id="mapping-418"></span><span class="token add" data-title="modifier_invocation/(">(</span><span class="marker" id="mapping-419"></span><span class="token add" data-title="modifier_invocation/call_argument">false</span><span class="marker" id="mapping-420"></span><span class="token add" data-title="modifier_invocation/)">)</span> returns (uint) {
        uint error = accrueInterest();
        if (error != uint(Error.NO_ERROR)) {
            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed
            return fail(Error(error), FailureInfo.BORROW_ACCRUE_INTEREST_FAILED);
        }
        // borrowFresh emits borrow-specific logs on errors, so we don't need to
        return borrowFresh(msg.sender, borrowAmount);
    }

    struct BorrowLocalVars {
        MathError mathErr;
        uint accountBorrows;
        uint accountBorrowsNew;
        uint totalBorrowsNew;
    }

    /**
      * @notice Users borrow assets from the protocol to their own address
      * @param borrowAmount The amount of the underlying asset to borrow
      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
      */
    function borrowFresh(address payable borrower, uint borrowAmount) internal returns (uint) {
        /* Fail if borrow not allowed */
        uint allowed = comptroller.borrowAllowed(address(this), borrower, borrowAmount);
        if (allowed != 0) {
            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.BORROW_COMPTROLLER_REJECTION, allowed);
        }

        /* Verify market's block number equals current block number */
        if (accrualBlockNumber != getBlockNumber()) {
            return fail(Error.MARKET_NOT_FRESH, FailureInfo.BORROW_FRESHNESS_CHECK);
        }

        /* Fail gracefully if protocol has insufficient underlying cash */
        uint cashPrior = getCashPrior();

        if (cashPrior &lt; borrowAmount) {
            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.BORROW_CASH_NOT_AVAILABLE);
        }

        BorrowLocalVars memory vars;

        /*
         * We calculate the new borrower and total borrow balances, failing on overflow:
         *  accountBorrowsNew = accountBorrows + borrowAmount
         *  totalBorrowsNew = totalBorrows + borrowAmount
         */
        (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));
        }

        (vars.mathErr, vars.accountBorrowsNew) = addUInt(vars.accountBorrows, borrowAmount);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));
        }

        // Check min borrow for this user for this asset
        allowed = comptroller.borrowWithinLimits(address(this), vars.accountBorrowsNew);
        if (allowed != 0) {
            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.BORROW_COMPTROLLER_REJECTION, allowed);
        }

        (vars.mathErr, vars.totalBorrowsNew) = addUInt(totalBorrows, borrowAmount);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));
        }

        /////////////////////////
        // EFFECTS &amp; INTERACTIONS
        // (No safe failures beyond this point)

        /*
         * We invoke doTransferOut for the borrower and the borrowAmount.
         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.
         *  On success, the cToken borrowAmount less of cash.
         *  doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.
         */
        doTransferOut(borrower, borrowAmount);

        /* We write the previously calculated values into storage */
        accountBorrows[borrower].principal = vars.accountBorrowsNew;
        accountBorrows[borrower].interestIndex = borrowIndex;
        totalBorrows = vars.totalBorrowsNew;

        /* We emit a Borrow event */
        emit Borrow(borrower, borrowAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);

        /* We call the defense hook */
        <span class="marker" id="mapping-421"></span><span class="token mv" id="move-dst-27" data-title="function_body/comment"><span class="marker" id="mapping-422"></span><span class="token upd" id="move-dst-27" data-title="function_body/comment"><span class="cupd">// </span>unus<span class="cupd">e</span>d<span class="cupd"> </span>f<span class="cupd">u</span>nc<span class="cupd">ti</span><span class="cupd">on</span></span></span>
        <span class="marker" id="mapping-423"></span><span class="token add" data-title="function_body/comment">// comptroller.borrowVerify(address(this), borrower, borrowAmount);</span>

        return uint(Error.NO_ERROR);
    }

    /**
     * @notice Sender repays their own borrow
     * @param repayAmount The amount to repay
     * @return (uint, uint) An error code (0=success, otherwise a failure, see ErrorReporter.sol), and the actual repayment amount.
     */
    function repayBorrowInternal(uint repayAmount) internal nonReentrant<span class="marker" id="mapping-424"></span><span class="token add" data-title="modifier_invocation/(">(</span><span class="marker" id="mapping-425"></span><span class="token add" data-title="modifier_invocation/call_argument">false</span><span class="marker" id="mapping-426"></span><span class="token add" data-title="modifier_invocation/)">)</span> returns (uint, uint) {
        uint error = accrueInterest();
        if (error != uint(Error.NO_ERROR)) {
            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed
            return (fail(Error(error), FailureInfo.REPAY_BORROW_ACCRUE_INTEREST_FAILED), 0);
        }
        // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don't need to
        return repayBorrowFresh(msg.sender, msg.sender, repayAmount);
    }

    /**
     * @notice Sender repays a borrow belonging to borrower
     * @param borrower the account with the debt being payed off
     * @param repayAmount The amount to repay
     * @return (uint, uint) An error code (0=success, otherwise a failure, see ErrorReporter.sol), and the actual repayment amount.
     */
    function repayBorrowBehalfInternal(address borrower, uint repayAmount) internal nonReentrant<span class="marker" id="mapping-427"></span><span class="token add" data-title="modifier_invocation/(">(</span><span class="marker" id="mapping-428"></span><span class="token add" data-title="modifier_invocation/call_argument">false</span><span class="marker" id="mapping-429"></span><span class="token add" data-title="modifier_invocation/)">)</span> returns (uint, uint) {
        uint error = accrueInterest();
        if (error != uint(Error.NO_ERROR)) {
            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed
            return (fail(Error(error), FailureInfo.REPAY_BEHALF_ACCRUE_INTEREST_FAILED), 0);
        }
        // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don't need to
        return repayBorrowFresh(msg.sender, borrower, repayAmount);
    }

    struct RepayBorrowLocalVars {
        Error err;
        MathError mathErr;
        uint repayAmount;
        uint borrowerIndex;
        uint accountBorrows;
        uint accountBorrowsNew;
        uint totalBorrowsNew;
        uint actualRepayAmount;
    }

    /**
     * @notice Borrows are repaid by another user (possibly the borrower).
     * @param payer the account paying off the borrow
     * @param borrower the account with the debt being payed off
     * @param repayAmount the amount of undelrying tokens being returned
     * @return (uint, uint) An error code (0=success, otherwise a failure, see ErrorReporter.sol), and the actual repayment amount.
     */
    function repayBorrowFresh(address payer, address borrower, uint repayAmount) internal returns (uint, uint) {
        /* Fail if repayBorrow not allowed */
        uint allowed = comptroller.repayBorrowAllowed(address(this), payer, borrower, repayAmount);
        if (allowed != 0) {
            return (failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.REPAY_BORROW_COMPTROLLER_REJECTION, allowed), 0);
        }

        /* Verify market's block number equals current block number */
        if (accrualBlockNumber != getBlockNumber()) {
            return (fail(Error.MARKET_NOT_FRESH, FailureInfo.REPAY_BORROW_FRESHNESS_CHECK), 0);
        }

        RepayBorrowLocalVars memory vars;

        /* We remember the original borrowerIndex for verification purposes */
        vars.borrowerIndex = accountBorrows[borrower].interestIndex;

        /* We fetch the amount the borrower owes, with accumulated interest */
        (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);
        if (vars.mathErr != MathError.NO_ERROR) {
            return (failOpaque(Error.MATH_ERROR, FailureInfo.REPAY_BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED, uint(vars.mathErr)), 0);
        }

        /* If repayAmount == -1, repayAmount = accountBorrows */
        if (repayAmount == uint(-1)) {
            vars.repayAmount = vars.accountBorrows;
        } else {
            vars.repayAmount = repayAmount;
        }

        /////////////////////////
        // EFFECTS &amp; INTERACTIONS
        // (No safe failures beyond this point)

        /*
         * We call doTransferIn for the payer and the repayAmount
         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.
         *  On success, the cToken holds an additional repayAmount of cash.
         *  doTransferIn reverts if anything goes wrong, since we can't be sure if side effects occurred.
         *   it returns the amount actually transferred, in case of a fee.
         */
        vars.actualRepayAmount = doTransferIn(payer, vars.repayAmount);

        /*
         * We calculate the new borrower and total borrow balances, failing on underflow:
         *  accountBorrowsNew = accountBorrows - actualRepayAmount
         *  totalBorrowsNew = totalBorrows - actualRepayAmount
         */
        (vars.mathErr, vars.accountBorrowsNew) = subUInt(vars.accountBorrows, vars.actualRepayAmount);
        require(vars.mathErr == MathError.NO_ERROR, "REPAY_BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED");

        (vars.mathErr, vars.totalBorrowsNew) = subUInt(totalBorrows, vars.actualRepayAmount);
        require(vars.mathErr == MathError.NO_ERROR, "REPAY_BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED");

        /* We write the previously calculated values into storage */
        accountBorrows[borrower].principal = vars.accountBorrowsNew;
        accountBorrows[borrower].interestIndex = borrowIndex;
        totalBorrows = vars.totalBorrowsNew;

        /* We emit a RepayBorrow event */
        emit RepayBorrow(payer, borrower, vars.actualRepayAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);

        /* We call the defense hook */
        <span class="marker" id="mapping-430"></span><span class="token add" data-title="function_body/comment">// unused function</span>
        <span class="marker" id="mapping-431"></span><span class="token add" data-title="function_body/comment">// comptroller.repayBorrowVerify(address(this), payer, borrower, vars.actualRepayAmount, vars.borrowerIndex);</span>

        return (uint(Error.NO_ERROR), vars.actualRepayAmount);
    }

    /**
     * @notice The sender liquidates the borrowers collateral.
     *  The collateral seized is transferred to the liquidator.
     * @param borrower The borrower of this cToken to be liquidated
     * @param cTokenCollateral The market in which to seize collateral from the borrower
     * @param repayAmount The amount of the underlying borrowed asset to repay
     * @return (uint, uint) An error code (0=success, otherwise a failure, see ErrorReporter.sol), and the actual repayment amount.
     */
    function liquidateBorrowInternal(address borrower, uint repayAmount, CTokenInterface cTokenCollateral) internal nonReentrant<span class="marker" id="mapping-432"></span><span class="token add" data-title="modifier_invocation/(">(</span><span class="marker" id="mapping-433"></span><span class="token add" data-title="modifier_invocation/call_argument">false</span><span class="marker" id="mapping-434"></span><span class="token add" data-title="modifier_invocation/)">)</span> returns (uint, uint) {
        uint error = accrueInterest();
        if (error != uint(Error.NO_ERROR)) {
            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted liquidation failed
            return (fail(Error(error), FailureInfo.LIQUIDATE_ACCRUE_BORROW_INTEREST_FAILED), 0);
        }

        error = cTokenCollateral.accrueInterest();
        if (error != uint(Error.NO_ERROR)) {
            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted liquidation failed
            return (fail(Error(error), FailureInfo.LIQUIDATE_ACCRUE_COLLATERAL_INTEREST_FAILED), 0);
        }

        // liquidateBorrowFresh emits borrow-specific logs on errors, so we don't need to
        return liquidateBorrowFresh(msg.sender, borrower, repayAmount, cTokenCollateral);
    }

    /**
     * @notice The liquidator liquidates the borrowers collateral.
     *  The collateral seized is transferred to the liquidator.
     * @param borrower The borrower of this cToken to be liquidated
     * @param liquidator The address repaying the borrow and seizing collateral
     * @param cTokenCollateral The market in which to seize collateral from the borrower
     * @param repayAmount The amount of the underlying borrowed asset to repay
     * @return (uint, uint) An error code (0=success, otherwise a failure, see ErrorReporter.sol), and the actual repayment amount.
     */
    function liquidateBorrowFresh(address liquidator, address borrower, uint repayAmount, CTokenInterface cTokenCollateral) internal returns (uint, uint) {
        /* Fail if liquidate not allowed */
        uint allowed = comptroller.liquidateBorrowAllowed(address(this), address(cTokenCollateral), liquidator, borrower, repayAmount);
        if (allowed != 0) {
            return (failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.LIQUIDATE_COMPTROLLER_REJECTION, allowed), 0);
        }

        /* Verify market's block number equals current block number */
        if (accrualBlockNumber != getBlockNumber()) {
            return (fail(Error.MARKET_NOT_FRESH, FailureInfo.LIQUIDATE_FRESHNESS_CHECK), 0);
        }

        /* Verify cTokenCollateral market's block number equals current block number */
        if (cTokenCollateral.accrualBlockNumber() != getBlockNumber()) {
            return (fail(Error.MARKET_NOT_FRESH, FailureInfo.LIQUIDATE_COLLATERAL_FRESHNESS_CHECK), 0);
        }

        /* Fail if borrower = liquidator */
        if (borrower == liquidator) {
            return (fail(Error.INVALID_ACCOUNT_PAIR, FailureInfo.LIQUIDATE_LIQUIDATOR_IS_BORROWER), 0);
        }

        /* Fail if repayAmount = 0 */
        if (repayAmount == 0) {
            return (fail(Error.INVALID_CLOSE_AMOUNT_REQUESTED, FailureInfo.LIQUIDATE_CLOSE_AMOUNT_IS_ZERO), 0);
        }

        /* Fail if repayAmount = -1 */
        if (repayAmount == uint(-1)) {
            return (fail(Error.INVALID_CLOSE_AMOUNT_REQUESTED, FailureInfo.LIQUIDATE_CLOSE_AMOUNT_IS_UINT_MAX), 0);
        }


        /* Fail if repayBorrow fails */
        (uint repayBorrowError, uint actualRepayAmount) = repayBorrowFresh(liquidator, borrower, repayAmount);
        if (repayBorrowError != uint(Error.NO_ERROR)) {
            return (fail(Error(repayBorrowError), FailureInfo.LIQUIDATE_REPAY_BORROW_FRESH_FAILED), 0);
        }

        /////////////////////////
        // EFFECTS &amp; INTERACTIONS
        // (No safe failures beyond this point)

        /* We calculate the number of collateral tokens that will be seized */
        (uint amountSeizeError, uint seizeTokens) = comptroller.liquidateCalculateSeizeTokens(address(this), address(cTokenCollateral), actualRepayAmount);
        require(amountSeizeError == uint(Error.NO_ERROR), "LIQUIDATE_COMPTROLLER_CALCULATE_AMOUNT_SEIZE_FAILED");

        /* Revert if borrower collateral token balance &lt; seizeTokens */
        require(cTokenCollateral.balanceOf(borrower) &gt;= seizeTokens, "LIQUIDATE_SEIZE_TOO_MUCH");

        // If this is also the collateral, run seizeInternal to avoid re-entrancy, otherwise make an external call
        uint seizeError;
        if (address(cTokenCollateral) == address(this)) {
            seizeError = seizeInternal(address(this), liquidator, borrower, seizeTokens);
        } else {
            seizeError = cTokenCollateral.seize(liquidator, borrower, seizeTokens);
        }

        /* Revert if seize tokens fails (since we cannot be sure of side effects) */
        require(seizeError == uint(Error.NO_ERROR), "token seizure failed");

        /* We emit a LiquidateBorrow event */
        emit LiquidateBorrow(liquidator, borrower, actualRepayAmount, address(cTokenCollateral), seizeTokens);

        /* We call the defense hook */
        <span class="marker" id="mapping-435"></span><span class="token add" data-title="function_body/comment">// unused function</span>
        <span class="marker" id="mapping-436"></span><span class="token add" data-title="function_body/comment">// comptroller.liquidateBorrowVerify(address(this), address(cTokenCollateral), liquidator, borrower, actualRepayAmount, seizeTokens);</span>

        return (uint(Error.NO_ERROR), actualRepayAmount);
    }

    /**
     * @notice Transfers collateral tokens (this market) to the liquidator.
     * @dev Will fail unless called by another cToken during the process of liquidation.
     *  Its absolutely critical to use msg.sender as the borrowed cToken and not a parameter.
     * @param liquidator The account receiving seized collateral
     * @param borrower The account having collateral seized
     * @param seizeTokens The number of cTokens to seize
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function seize(address liquidator, address borrower, uint seizeTokens) external nonReentrant<span class="marker" id="mapping-437"></span><span class="token add" data-title="modifier_invocation/(">(</span><span class="marker" id="mapping-438"></span><span class="token add" data-title="modifier_invocation/call_argument">true</span><span class="marker" id="mapping-439"></span><span class="token add" data-title="modifier_invocation/)">)</span> returns (uint) {
        return seizeInternal(msg.sender, liquidator, borrower, seizeTokens);
    }

    <span class="marker" id="mapping-440"></span><span class="token add" data-title="contract_body/struct_declaration">struct SeizeInternalLocalVars {
        <span class="marker" id="mapping-441"></span><span class="token add" data-title="struct_declaration/struct_member">MathError mathErr;</span>
        <span class="marker" id="mapping-442"></span><span class="token add" data-title="struct_declaration/struct_member"><span class="marker" id="mapping-443"></span><span class="token mv" id="move-dst-70" data-title="struct_member/type_name">uint</span> borrowerTokensNew;</span>
        <span class="marker" id="mapping-444"></span><span class="token add" data-title="struct_declaration/struct_member"><span class="marker" id="mapping-445"></span><span class="token mv" id="move-dst-75" data-title="struct_member/type_name">uint</span> liquidatorTokensNew;</span>
        <span class="marker" id="mapping-446"></span><span class="token add" data-title="struct_declaration/struct_member"><span class="marker" id="mapping-447"></span><span class="token mv" id="move-dst-78" data-title="struct_member/type_name">uint</span> liquidatorSeizeTokens;</span>
        <span class="marker" id="mapping-448"></span><span class="token add" data-title="struct_declaration/struct_member"><span class="marker" id="mapping-449"></span><span class="token mv" id="move-dst-77" data-title="struct_member/type_name">uint</span> protocolSeizeTokens;</span>
        <span class="marker" id="mapping-450"></span><span class="token add" data-title="struct_declaration/struct_member"><span class="marker" id="mapping-451"></span><span class="token mv" id="move-dst-80" data-title="struct_member/type_name">uint</span> protocolSeizeAmount;</span>
        <span class="marker" id="mapping-452"></span><span class="token add" data-title="struct_declaration/struct_member">uint exchangeRateMantissa;</span>
        <span class="marker" id="mapping-453"></span><span class="token add" data-title="struct_declaration/struct_member">uint totalReservesNew;</span>
        <span class="marker" id="mapping-454"></span><span class="token add" data-title="struct_declaration/struct_member">uint totalSupplyNew;</span>
    }</span>

    /**
     * @notice Transfers collateral tokens (this market) to the liquidator.
     * @dev Called only during an in-kind liquidation, or by liquidateBorrow during the liquidation of another CToken.
     *  Its absolutely critical to use msg.sender as the seizer cToken and not a parameter.
     * @param seizerToken The contract seizing the collateral (i.e. borrowed cToken)
     * @param liquidator The account receiving seized collateral
     * @param borrower The account having collateral seized
     * @param seizeTokens The number of cTokens to seize
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function seizeInternal(address seizerToken, address liquidator, address borrower, uint seizeTokens) internal returns (uint) {
        /* Fail if seize not allowed */
        uint allowed = comptroller.seizeAllowed(address(this), seizerToken, liquidator, borrower, seizeTokens);
        if (allowed != 0) {
            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.LIQUIDATE_SEIZE_COMPTROLLER_REJECTION, allowed);
        }

        /* Fail if borrower = liquidator */
        if (borrower == liquidator) {
            return fail(Error.INVALID_ACCOUNT_PAIR, FailureInfo.LIQUIDATE_SEIZE_LIQUIDATOR_IS_BORROWER);
        }

        <span class="marker" id="mapping-455"></span><span class="token add" data-title="function_body/variable_declaration_statement">SeizeInternalLocalVars memory vars;</span>

        /*
         * We calculate the new borrower and liquidator token balances, failing on underflow/overflow:
         *  borrowerTokensNew = accountTokens[borrower] - seizeTokens
         *  liquidatorTokensNew = accountTokens[liquidator] + seizeTokens
         */
        <span class="marker" id="mapping-456"></span><span class="token mv" id="move-dst-23" data-title="assignment_expression/tuple_expression">(vars.mathErr, <span class="marker" id="mapping-457"></span><span class="token add" data-title="tuple_expression/member_expression">vars.borrowerTokensNew</span>)</span> = subUInt(accountTokens[borrower], seizeTokens);
        if (<span class="marker" id="mapping-458"></span><span class="token add" data-title="binary_expression/member_expression">vars.mathErr</span> != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.LIQUIDATE_SEIZE_BALANCE_DECREMENT_FAILED, uint(<span class="marker" id="mapping-459"></span><span class="token add" data-title="call_argument/member_expression">vars.mathErr</span>));
        }

        <span class="marker" id="mapping-460"></span><span class="token add" data-title="function_body/expression_statement"><span class="marker" id="mapping-461"></span><span class="token add" data-title="expression_statement/assignment_expression"><span class="marker" id="mapping-462"></span><span class="token add" data-title="assignment_expression/member_expression">vars.protocolSeizeTokens</span> = <span class="marker" id="mapping-463"></span><span class="token add" data-title="assignment_expression/call_expression">mul_(<span class="marker" id="mapping-464"></span><span class="token mv" id="move-dst-40" data-title="call_expression/call_argument">seizeTokens</span>, <span class="marker" id="mapping-465"></span><span class="token add" data-title="call_expression/call_argument">Exp({mantissa: protocolSeizeShareMantissa})</span>)</span></span>;</span>
        <span class="marker" id="mapping-466"></span><span class="token add" data-title="function_body/expression_statement"><span class="marker" id="mapping-467"></span><span class="token add" data-title="expression_statement/assignment_expression"><span class="marker" id="mapping-468"></span><span class="token add" data-title="assignment_expression/member_expression">vars.liquidatorSeizeTokens</span> = <span class="marker" id="mapping-469"></span><span class="token add" data-title="assignment_expression/call_expression">sub_(<span class="marker" id="mapping-470"></span><span class="token mv" id="move-dst-39" data-title="call_expression/call_argument">seizeTokens</span>, <span class="marker" id="mapping-471"></span><span class="token add" data-title="call_expression/call_argument">vars.protocolSeizeTokens</span>)</span></span>;</span>

        <span class="marker" id="mapping-472"></span><span class="token add" data-title="function_body/expression_statement">(vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();</span>
        <span class="marker" id="mapping-473"></span><span class="token mv" id="move-dst-22" data-title="function_body/expression_statement">require(vars.mathErr == MathError.NO_ERROR, "exchange rate math error");</span>

        <span class="marker" id="mapping-474"></span><span class="token add" data-title="function_body/expression_statement"><span class="marker" id="mapping-475"></span><span class="token add" data-title="expression_statement/assignment_expression"><span class="marker" id="mapping-476"></span><span class="token add" data-title="assignment_expression/member_expression">vars.protocolSeizeAmount</span> = <span class="marker" id="mapping-477"></span><span class="token add" data-title="assignment_expression/call_expression">mul_ScalarTruncate(<span class="marker" id="mapping-478"></span><span class="token add" data-title="call_expression/call_argument"><span class="marker" id="mapping-479"></span><span class="token add" data-title="call_argument/call_expression">Exp(<span class="marker" id="mapping-480"></span><span class="token mv" id="move-dst-17" data-title="call_expression/call_argument"><span class="marker" id="mapping-481"></span><span class="token add" data-title="call_argument/{">{</span><span class="marker" id="mapping-482"></span><span class="token add" data-title="call_argument/call_struct_argument">mantissa: <span class="marker" id="mapping-483"></span><span class="token mv" id="move-dst-18" data-title="call_struct_argument/member_expression">vars.exchangeRateMantissa</span></span><span class="marker" id="mapping-484"></span><span class="token add" data-title="call_argument/}">}</span></span>)</span></span>, <span class="marker" id="mapping-485"></span><span class="token add" data-title="call_expression/call_argument">vars.protocolSeizeTokens</span>)</span></span>;</span>

        <span class="marker" id="mapping-486"></span><span class="token add" data-title="function_body/expression_statement">vars.totalReservesNew = add_(totalReserves, vars.protocolSeizeAmount);</span>
        <span class="marker" id="mapping-487"></span><span class="token add" data-title="function_body/expression_statement">vars.totalSupplyNew = sub_(totalSupply, vars.protocolSeizeTokens);</span>

        <span class="marker" id="mapping-488"></span><span class="token mv" id="move-dst-19" data-title="assignment_expression/tuple_expression">(vars.mathErr, <span class="marker" id="mapping-489"></span><span class="token add" data-title="tuple_expression/member_expression">vars.liquidatorTokensNew</span>)</span> = addUInt(accountTokens[liquidator], <span class="marker" id="mapping-490"></span><span class="token add" data-title="call_expression/call_argument">vars.liquidatorSeizeTokens</span>);
        if (<span class="marker" id="mapping-491"></span><span class="token add" data-title="binary_expression/member_expression">vars.mathErr</span> != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.LIQUIDATE_SEIZE_BALANCE_INCREMENT_FAILED, uint(<span class="marker" id="mapping-492"></span><span class="token add" data-title="call_argument/member_expression">vars.mathErr</span>));
        }

        /////////////////////////
        // EFFECTS &amp; INTERACTIONS
        // (No safe failures beyond this point)

        /* We write the previously calculated values into storage */
        <span class="marker" id="mapping-493"></span><span class="token add" data-title="function_body/expression_statement">totalReserves = vars.totalReservesNew;</span>
        <span class="marker" id="mapping-494"></span><span class="token add" data-title="function_body/expression_statement">totalSupply = vars.totalSupplyNew;</span>
        accountTokens[borrower] = <span class="marker" id="mapping-495"></span><span class="token add" data-title="assignment_expression/member_expression">vars.borrowerTokensNew</span>;
        accountTokens[liquidator] = <span class="marker" id="mapping-496"></span><span class="token add" data-title="assignment_expression/member_expression">vars.liquidatorTokensNew</span>;

        /* Emit a Transfer event */
        emit Transfer(borrower, liquidator, <span class="marker" id="mapping-497"></span><span class="token add" data-title="call_argument/member_expression">vars.liquidatorSeizeTokens</span>);
        <span class="marker" id="mapping-498"></span><span class="token add" data-title="function_body/emit_statement">emit Transfer(<span class="marker" id="mapping-499"></span><span class="token mv" id="move-dst-33" data-title="emit_statement/call_argument">borrower</span>, <span class="marker" id="mapping-500"></span><span class="token mv" id="move-dst-2" data-title="emit_statement/call_argument">address(this)</span>, <span class="marker" id="mapping-501"></span><span class="token add" data-title="emit_statement/call_argument">vars.protocolSeizeTokens</span>);</span>
        <span class="marker" id="mapping-502"></span><span class="token add" data-title="function_body/emit_statement">emit ReservesAdded(<span class="marker" id="mapping-503"></span><span class="token mv" id="move-dst-32" data-title="emit_statement/call_argument">address(this)</span>, <span class="marker" id="mapping-504"></span><span class="token add" data-title="emit_statement/call_argument">vars.protocolSeizeAmount</span>, <span class="marker" id="mapping-505"></span><span class="token add" data-title="emit_statement/call_argument">vars.totalReservesNew</span>);</span>

        /* We call the defense hook */
        <span class="marker" id="mapping-506"></span><span class="token add" data-title="function_body/comment">// unused function</span>
        <span class="marker" id="mapping-507"></span><span class="token add" data-title="function_body/comment">// comptroller.seizeVerify(address(this), seizerToken, liquidator, borrower, seizeTokens);</span>

        return uint(Error.NO_ERROR);
    }


    /*** Admin Functions ***/

    <span class="marker" id="mapping-508"></span><span class="token upd" id="move-dst-47" data-title="contract_body/comment"><span class="cupd">/**
      * @notice</span> <span class="cupd">S</span><span class="cupd">e</span><span class="cupd">t</span><span class="cupd">s</span><span class="cupd"> </span><span class="cupd">a</span><span class="cupd"> ne</span><span class="cupd">w</span> c<span class="cupd">o</span>m<span class="cupd">p</span>tr<span class="cupd">ol</span><span class="cupd">l</span>e<span class="cupd">r</span> <span class="cupd">f</span>o<span class="cupd">r</span><span class="cupd"> the</span> m<span class="cupd">a</span>r<span class="cupd">k</span>e<span class="cupd">t
      * @de</span>v<span class="cupd"> </span>Intern<span class="cupd">al function t</span>o<span class="cupd"> </span>s<span class="cupd">e</span><span class="cupd">t</span><span class="cupd"> </span><span class="cupd">a</span><span class="cupd"> </span><span class="cupd">n</span><span class="cupd">e</span>w <span class="cupd">c</span><span class="cupd">om</span>p<span class="cupd">t</span><span class="cupd">r</span>o<span class="cupd">l</span><span class="cupd">l</span><span class="cupd">er
      </span><span class="cupd">*</span><span class="cupd"> </span><span class="cupd">@return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
    </span>  */</span>
    function _setComptroller(ComptrollerInterface newComptroller) <span class="marker" id="mapping-509"></span><span class="token mv" id="move-dst-71" data-title="function_definition/visibility">internal</span> returns (uint) {
        ComptrollerInterface oldComptroller = comptroller;
        // Ensure invoke comptroller.isComptroller() returns true
        require(newComptroller.isComptroller(), "marker method returned false");

        // Set market's comptroller to newComptroller
        comptroller = newComptroller;

        // Emit NewComptroller(oldComptroller, newComptroller)
        emit NewComptroller(oldComptroller, newComptroller);

        return uint(Error.NO_ERROR);
    }

    /**
      * @notice accrues interest and sets a new admin fee for the protocol using _setAdminFeeFresh
      * @dev Admin function to accrue interest and set a new admin fee
      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
      */
    function _setAdminFee(uint newAdminFeeMantissa) external nonReentrant<span class="marker" id="mapping-510"></span><span class="token add" data-title="modifier_invocation/(">(</span><span class="marker" id="mapping-511"></span><span class="token add" data-title="modifier_invocation/call_argument">false</span><span class="marker" id="mapping-512"></span><span class="token add" data-title="modifier_invocation/)">)</span> returns (uint) {
        uint error = accrueInterest();
        if (error != uint(Error.NO_ERROR)) {
            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted admin fee change failed.
            return fail(Error(error), FailureInfo.SET_ADMIN_FEE_ACCRUE_INTEREST_FAILED);
        }
        // _setAdminFeeFresh emits reserve-factor-specific logs on errors, so we don't need to.
        return _setAdminFeeFresh(newAdminFeeMantissa);
    }

    /**
      * @notice Sets a new admin fee for the protocol (*requires fresh interest accrual)
      * @dev Admin function to set a new admin fee
      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
      */
    function _setAdminFeeFresh(uint newAdminFeeMantissa) internal returns (uint) {
        // Verify market's block number equals current block number
        if (accrualBlockNumber != getBlockNumber()) {
            return fail(Error.MARKET_NOT_FRESH, FailureInfo.SET_ADMIN_FEE_FRESH_CHECK);
        }

        <span class="marker" id="mapping-513"></span><span class="token mv" id="move-dst-56" data-title="function_body/comment"><span class="marker" id="mapping-514"></span><span class="token upd" id="move-dst-56" data-title="function_body/comment"><span class="cupd">// </span>Sanitiz<span class="cupd">e</span><span class="cupd"> </span>n<span class="cupd">e</span>wA<span class="cupd">dmin</span>FeeMantissa</span></span>
        <span class="marker" id="mapping-515"></span><span class="token add" data-title="function_body/if_statement">if (<span class="marker" id="mapping-516"></span><span class="token mv" id="move-dst-30" data-title="if_statement/binary_expression"><span class="marker" id="mapping-517"></span><span class="token upd" id="move-dst-31" data-title="binary_expression/identifier">newAd<span class="cupd">m</span><span class="cupd">i</span>nFeeM<span class="cupd">a</span>n<span class="cupd">ti</span>ssa</span> <span class="marker" id="mapping-518"></span><span class="token add" data-title="binary_expression/==">==</span> uint(-1)</span>) <span class="marker" id="mapping-519"></span><span class="token add" data-title="if_statement/expression_statement">newAdminFeeMantissa = adminFeeMantissa;</span></span>

        <span class="marker" id="mapping-520"></span><span class="token upd" id="move-dst-58" data-title="function_body/comment"><span class="cupd">// </span>G<span class="cupd">e</span>t<span class="cupd"> </span>lat<span class="cupd">e</span>st <span class="cupd">F</span>us<span class="cupd">e</span><span class="cupd"> </span>f<span class="cupd">ee</span></span>
        <span class="marker" id="mapping-521"></span><span class="token mv" id="move-dst-65" data-title="function_body/variable_declaration_statement">uint <span class="marker" id="mapping-522"></span><span class="token upd" id="move-dst-66" data-title="variable_declaration/identifier">newFuseFeeMantissa</span> = <span class="marker" id="mapping-523"></span><span class="token mv" id="move-dst-67" data-title="variable_declaration_statement/call_expression">getPendingFuseFeeFromAdmin()</span>;</span>

        <span class="marker" id="mapping-524"></span><span class="token add" data-title="function_body/comment">// Check reserveFactorMantissa + newAdminFeeMantissa + newFuseFeeMantissa ≤ reserveFactorPlusFeesMaxMantissa
</span>        if (<span class="marker" id="mapping-525"></span><span class="token add" data-title="binary_expression/call_expression">add_(add_(reserveFactorMantissa, newAdminFeeMantissa), newFuseFeeMantissa)</span> &gt; reserveFactorPlusFeesMaxMantissa) {
            return fail(Error.BAD_INPUT, FailureInfo.SET_ADMIN_FEE_BOUNDS_CHECK);
        }

        <span class="marker" id="mapping-526"></span><span class="token add" data-title="function_body/comment">// If setting admin fee</span>
        <span class="marker" id="mapping-527"></span><span class="token add" data-title="function_body/if_statement">if (<span class="marker" id="mapping-528"></span><span class="token add" data-title="if_statement/binary_expression">adminFeeMantissa != newAdminFeeMantissa</span>) <span class="marker" id="mapping-529"></span><span class="token add" data-title="if_statement/block_statement">{
            // Check caller is admin
            <span class="marker" id="mapping-530"></span><span class="token mv" id="move-dst-57" data-title="block_statement/if_statement">if (!hasAdminRights()) {
                return fail(Error.UNAUTHORIZED, FailureInfo.SET_ADMIN_FEE_ADMIN_CHECK);
            }</span>

            // Set admin fee
            <span class="marker" id="mapping-531"></span><span class="token mv" id="move-dst-59" data-title="block_statement/variable_declaration_statement">uint oldAdminFeeMantissa = adminFeeMantissa;</span>
            <span class="marker" id="mapping-532"></span><span class="token mv" id="move-dst-60" data-title="block_statement/expression_statement">adminFeeMantissa = newAdminFeeMantissa;</span>

            // Emit event
            <span class="marker" id="mapping-533"></span><span class="token mv" id="move-dst-61" data-title="block_statement/emit_statement">emit NewAdminFee(oldAdminFeeMantissa, newAdminFeeMantissa);</span>
        }</span></span>

        <span class="marker" id="mapping-534"></span><span class="token add" data-title="function_body/comment">// If setting Fuse fee</span>
        <span class="marker" id="mapping-535"></span><span class="token add" data-title="function_body/if_statement">if (<span class="marker" id="mapping-536"></span><span class="token add" data-title="if_statement/binary_expression">fuseFeeMantissa != newFuseFeeMantissa</span>) <span class="marker" id="mapping-537"></span><span class="token add" data-title="if_statement/block_statement">{
            // Set Fuse fee
            <span class="marker" id="mapping-538"></span><span class="token mv" id="move-dst-72" data-title="block_statement/variable_declaration_statement">uint oldFuseFeeMantissa = fuseFeeMantissa;</span>
            <span class="marker" id="mapping-539"></span><span class="token mv" id="move-dst-73" data-title="block_statement/expression_statement">fuseFeeMantissa = newFuseFeeMantissa;</span>

            // Emit event
            <span class="marker" id="mapping-540"></span><span class="token mv" id="move-dst-74" data-title="block_statement/emit_statement">emit NewFuseFee(oldFuseFeeMantissa, newFuseFeeMantissa);</span>
        }</span></span>

        return uint(Error.NO_ERROR);
    }

    /**
      * @notice accrues interest and sets a new reserve factor for the protocol using _setReserveFactorFresh
      * @dev Admin function to accrue interest and set a new reserve factor
      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
      */
    function _setReserveFactor(uint newReserveFactorMantissa) external nonReentrant<span class="marker" id="mapping-541"></span><span class="token add" data-title="modifier_invocation/(">(</span><span class="marker" id="mapping-542"></span><span class="token add" data-title="modifier_invocation/call_argument">false</span><span class="marker" id="mapping-543"></span><span class="token add" data-title="modifier_invocation/)">)</span> returns (uint) {
        uint error = accrueInterest();
        if (error != uint(Error.NO_ERROR)) {
            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reserve factor change failed.
            return fail(Error(error), FailureInfo.SET_RESERVE_FACTOR_ACCRUE_INTEREST_FAILED);
        }
        // _setReserveFactorFresh emits reserve-factor-specific logs on errors, so we don't need to.
        return _setReserveFactorFresh(newReserveFactorMantissa);
    }

    /**
      * @notice Sets a new reserve factor for the protocol (*requires fresh interest accrual)
      * @dev Admin function to set a new reserve factor
      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
      */
    function _setReserveFactorFresh(uint newReserveFactorMantissa) internal returns (uint) {
        // Check caller is admin
        if (!hasAdminRights()) {
            return fail(Error.UNAUTHORIZED, FailureInfo.SET_RESERVE_FACTOR_ADMIN_CHECK);
        }

        // Verify market's block number equals current block number
        if (accrualBlockNumber != getBlockNumber()) {
            return fail(Error.MARKET_NOT_FRESH, FailureInfo.SET_RESERVE_FACTOR_FRESH_CHECK);
        }

        // Check newReserveFactor ≤ maxReserveFactor
        if (<span class="marker" id="mapping-544"></span><span class="token add" data-title="binary_expression/call_expression">add_(add_(newReserveFactorMantissa, adminFeeMantissa), fuseFeeMantissa)</span> &gt; reserveFactorPlusFeesMaxMantissa) {
            return fail(Error.BAD_INPUT, FailureInfo.SET_RESERVE_FACTOR_BOUNDS_CHECK);
        }

        uint oldReserveFactorMantissa = reserveFactorMantissa;
        reserveFactorMantissa = newReserveFactorMantissa;

        emit NewReserveFactor(oldReserveFactorMantissa, newReserveFactorMantissa);

        return uint(Error.NO_ERROR);
    }

    /**
     * @notice Accrues interest and reduces reserves by transferring to admin
     * @param reduceAmount Amount of reduction to reserves
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function _reduceReserves(uint reduceAmount) external nonReentrant<span class="marker" id="mapping-545"></span><span class="token add" data-title="modifier_invocation/(">(</span><span class="marker" id="mapping-546"></span><span class="token add" data-title="modifier_invocation/call_argument">false</span><span class="marker" id="mapping-547"></span><span class="token add" data-title="modifier_invocation/)">)</span> returns (uint) {
        uint error = accrueInterest();
        if (error != uint(Error.NO_ERROR)) {
            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reduce reserves failed.
            return fail(Error(error), FailureInfo.REDUCE_RESERVES_ACCRUE_INTEREST_FAILED);
        }
        // _reduceReservesFresh emits reserve-reduction-specific logs on errors, so we don't need to.
        return _reduceReservesFresh(reduceAmount);
    }

    /**
     * @notice Reduces reserves by transferring to admin
     * @dev Requires fresh interest accrual
     * @param reduceAmount Amount of reduction to reserves
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function _reduceReservesFresh(uint reduceAmount) internal returns (uint) {
        // totalReserves - reduceAmount
        uint totalReservesNew;

        // Check caller is admin
        if (!hasAdminRights()) {
            return fail(Error.UNAUTHORIZED, FailureInfo.REDUCE_RESERVES_ADMIN_CHECK);
        }

        // We fail gracefully unless market's block number equals current block number
        if (accrualBlockNumber != getBlockNumber()) {
            return fail(Error.MARKET_NOT_FRESH, FailureInfo.REDUCE_RESERVES_FRESH_CHECK);
        }

        // Fail gracefully if protocol has insufficient underlying cash
        if (getCashPrior() &lt; reduceAmount) {
            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.REDUCE_RESERVES_CASH_NOT_AVAILABLE);
        }

        // Check reduceAmount ≤ reserves[n] (totalReserves)
        if (reduceAmount &gt; totalReserves) {
            return fail(Error.BAD_INPUT, FailureInfo.REDUCE_RESERVES_VALIDATION);
        }

        /////////////////////////
        // EFFECTS &amp; INTERACTIONS
        // (No safe failures beyond this point)

        // We checked reduceAmount &lt;= totalReserves above, so this should never revert.
        <span class="marker" id="mapping-548"></span><span class="token add" data-title="function_body/expression_statement">totalReservesNew = sub_(totalReserves, reduceAmount);</span>

        // Store reserves[n+1] = reserves[n] - reduceAmount
        totalReserves = totalReservesNew;

        // doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.
        <span class="marker" id="mapping-549"></span><span class="token mv" id="move-dst-81" data-title="function_body/expression_statement"><span class="marker" id="mapping-550"></span><span class="token mv" id="move-dst-82" data-title="expression_statement/call_expression"><span class="marker" id="mapping-551"></span><span class="token upd" id="move-dst-83" data-title="call_expression/identifier"><span class="cupd">doTransfer</span>Out</span>(msg.sender, <span class="marker" id="mapping-552"></span><span class="token mv" id="move-dst-91" data-title="call_expression/call_argument">reduceAmount</span>)</span>;</span>

        <span class="marker" id="mapping-553"></span><span class="token mv" id="move-dst-85" data-title="function_body/emit_statement">emit <span class="marker" id="mapping-554"></span><span class="token upd" id="move-dst-86" data-title="emit_statement/identifier"><span class="cupd">Reserves</span>Re<span class="cupd">d</span>uc<span class="cupd">ed</span></span>(msg.sender, <span class="marker" id="mapping-555"></span><span class="token mv" id="move-dst-92" data-title="emit_statement/call_argument">reduceAmount</span>, totalReservesNew);</span>

        return uint(Error.NO_ERROR);
    }

    /**
     * @notice Accrues interest and reduces Fuse fees by transferring to Fuse
     * @param withdrawAmount Amount of fees to withdraw
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function _withdrawFuseFees(uint withdrawAmount) external nonReentrant<span class="marker" id="mapping-556"></span><span class="token add" data-title="modifier_invocation/(">(</span><span class="marker" id="mapping-557"></span><span class="token add" data-title="modifier_invocation/call_argument">false</span><span class="marker" id="mapping-558"></span><span class="token add" data-title="modifier_invocation/)">)</span> returns (uint) {
        uint error = accrueInterest();
        if (error != uint(Error.NO_ERROR)) {
            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted Fuse fee withdrawal failed.
            return fail(Error(error), FailureInfo.WITHDRAW_FUSE_FEES_ACCRUE_INTEREST_FAILED);
        }
        // _withdrawFuseFeesFresh emits reserve-reduction-specific logs on errors, so we don't need to.
        return _withdrawFuseFeesFresh(withdrawAmount);
    }

    /**
     * @notice Reduces Fuse fees by transferring to Fuse
     * @dev Requires fresh interest accrual
     * @param withdrawAmount Amount of fees to withdraw
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function _withdrawFuseFeesFresh(uint withdrawAmount) internal returns (uint) {
        // totalFuseFees - reduceAmount
        uint totalFuseFeesNew;

        // We fail gracefully unless market's block number equals current block number
        if (accrualBlockNumber != getBlockNumber()) {
            return fail(Error.MARKET_NOT_FRESH, FailureInfo.WITHDRAW_FUSE_FEES_FRESH_CHECK);
        }

        // Fail gracefully if protocol has insufficient underlying cash
        if (getCashPrior() &lt; withdrawAmount) {
            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.WITHDRAW_FUSE_FEES_CASH_NOT_AVAILABLE);
        }

        // Check withdrawAmount ≤ fuseFees[n] (totalFuseFees)
        if (withdrawAmount &gt; totalFuseFees) {
            return fail(Error.BAD_INPUT, FailureInfo.WITHDRAW_FUSE_FEES_VALIDATION);
        }

        /////////////////////////
        // EFFECTS &amp; INTERACTIONS
        // (No safe failures beyond this point)

        // We checked withdrawAmount &lt;= totalFuseFees above, so this should never revert.
        <span class="marker" id="mapping-559"></span><span class="token mv" id="move-dst-93" data-title="function_body/expression_statement">totalFuseFeesNew = <span class="marker" id="mapping-560"></span><span class="token add" data-title="assignment_expression/call_expression">sub_(totalFuseFees, withdrawAmount)</span>;</span>

        // Store fuseFees[n+1] = fuseFees[n] - withdrawAmount
        totalFuseFees = totalFuseFeesNew;

        // doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.
        doTransferOut(address(fuseAdmin), withdrawAmount);

        return uint(Error.NO_ERROR);
    }

    /**
     * @notice Accrues interest and reduces admin fees by transferring to admin
     * @param withdrawAmount Amount of fees to withdraw
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function _withdrawAdminFees(uint withdrawAmount) external nonReentrant<span class="marker" id="mapping-561"></span><span class="token add" data-title="modifier_invocation/(">(</span><span class="marker" id="mapping-562"></span><span class="token add" data-title="modifier_invocation/call_argument">false</span><span class="marker" id="mapping-563"></span><span class="token add" data-title="modifier_invocation/)">)</span> returns (uint) {
        uint error = accrueInterest();
        if (error != uint(Error.NO_ERROR)) {
            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted admin fee withdrawal failed.
            return fail(Error(error), FailureInfo.WITHDRAW_ADMIN_FEES_ACCRUE_INTEREST_FAILED);
        }
        // _withdrawAdminFeesFresh emits reserve-reduction-specific logs on errors, so we don't need to.
        return _withdrawAdminFeesFresh(withdrawAmount);
    }

    /**
     * @notice Reduces admin fees by transferring to admin
     * @dev Requires fresh interest accrual
     * @param withdrawAmount Amount of fees to withdraw
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function _withdrawAdminFeesFresh(uint withdrawAmount) internal returns (uint) {
        // totalAdminFees - reduceAmount
        uint totalAdminFeesNew;

        // We fail gracefully unless market's block number equals current block number
        if (accrualBlockNumber != getBlockNumber()) {
            return fail(Error.MARKET_NOT_FRESH, FailureInfo.WITHDRAW_ADMIN_FEES_FRESH_CHECK);
        }

        // Fail gracefully if protocol has insufficient underlying cash
        if (getCashPrior() &lt; withdrawAmount) {
            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.WITHDRAW_ADMIN_FEES_CASH_NOT_AVAILABLE);
        }

        // Check withdrawAmount ≤ adminFees[n] (totalAdminFees)
        if (withdrawAmount &gt; totalAdminFees) {
            return fail(Error.BAD_INPUT, FailureInfo.WITHDRAW_ADMIN_FEES_VALIDATION);
        }

        /////////////////////////
        // EFFECTS &amp; INTERACTIONS
        // (No safe failures beyond this point)

        // We checked withdrawAmount &lt;= totalAdminFees above, so this should never revert.
        <span class="marker" id="mapping-564"></span><span class="token add" data-title="function_body/expression_statement">totalAdminFeesNew = sub_(totalAdminFees, withdrawAmount);</span>

        // Store adminFees[n+1] = adminFees[n] - withdrawAmount
        totalAdminFees = totalAdminFeesNew;

        // doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.
        <span class="marker" id="mapping-565"></span><span class="token add" data-title="function_body/expression_statement"><span class="marker" id="mapping-566"></span><span class="token add" data-title="expression_statement/call_expression">doTransferOut(<span class="marker" id="mapping-567"></span><span class="token add" data-title="call_expression/call_argument"><span class="marker" id="mapping-568"></span><span class="token add" data-title="call_argument/type_cast_expression"><span class="marker" id="mapping-569"></span><span class="token mv" id="move-dst-34" data-title="type_cast_expression/primitive_type">address</span>(<span class="marker" id="mapping-570"></span><span class="token add" data-title="type_cast_expression/call_argument">uint160(UnitrollerAdminStorage(address(comptroller)).admin())</span>)</span></span>, <span class="marker" id="mapping-571"></span><span class="token mv" id="move-dst-98" data-title="call_expression/call_argument">withdrawAmount</span>)</span>;</span>

        return uint(Error.NO_ERROR);
    }

    /**
     * @notice accrues interest and updates the interest rate model using _setInterestRateModelFresh
     * @dev Admin function to accrue interest and update the interest rate model
     * @param newInterestRateModel the new interest rate model to use
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function _setInterestRateModel(InterestRateModel newInterestRateModel) public returns (uint) {
        uint error = accrueInterest();
        if (error != uint(Error.NO_ERROR)) {
            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted change of interest rate model failed
            return fail(Error(error), FailureInfo.SET_INTEREST_RATE_MODEL_ACCRUE_INTEREST_FAILED);
        }
        // _setInterestRateModelFresh emits interest-rate-model-update-specific logs on errors, so we don't need to.
        return _setInterestRateModelFresh(newInterestRateModel);
    }

    /**
     * @notice updates the interest rate model (*requires fresh interest accrual)
     * @dev Admin function to update the interest rate model
     * @param newInterestRateModel the new interest rate model to use
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function _setInterestRateModelFresh(InterestRateModel newInterestRateModel) internal returns (uint) {
        // Used to store old model for use in the event that is emitted on success
        InterestRateModel oldInterestRateModel;

        // Check caller is admin
        if (!hasAdminRights()) {
            return fail(Error.UNAUTHORIZED, FailureInfo.SET_INTEREST_RATE_MODEL_OWNER_CHECK);
        }

        // We fail gracefully unless market's block number equals current block number
        if (accrualBlockNumber != getBlockNumber()) {
            return fail(Error.MARKET_NOT_FRESH, FailureInfo.SET_INTEREST_RATE_MODEL_FRESH_CHECK);
        }

        // Track the market's current interest rate model
        oldInterestRateModel = interestRateModel;

        // Ensure invoke newInterestRateModel.isInterestRateModel() returns true
        require(newInterestRateModel.isInterestRateModel(), "marker method returned false");

        // Set the interest rate model to newInterestRateModel
        interestRateModel = newInterestRateModel;

        // Emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel)
        emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel);

        <span class="marker" id="mapping-572"></span><span class="token add" data-title="function_body/comment">// Attempt to reset interest checkpoints on old IRM</span>
        <span class="marker" id="mapping-573"></span><span class="token add" data-title="function_body/if_statement">if (<span class="marker" id="mapping-574"></span><span class="token mv" id="move-dst-51" data-title="if_statement/binary_expression"><span class="marker" id="mapping-575"></span><span class="token add" data-title="binary_expression/type_cast_expression">address(oldInterestRateModel)</span> <span class="marker" id="mapping-576"></span><span class="token add" data-title="binary_expression/!=">!=</span> address(0)</span>) <span class="marker" id="mapping-577"></span><span class="token mv" id="move-dst-96" data-title="if_statement/expression_statement"><span class="marker" id="mapping-578"></span><span class="token add" data-title="expression_statement/call_expression"><span class="marker" id="mapping-579"></span><span class="token add" data-title="call_expression/member_expression">address(oldInterestRateModel).call</span>(<span class="marker" id="mapping-580"></span><span class="token add" data-title="call_expression/call_argument"><span class="marker" id="mapping-581"></span><span class="token mv" id="move-dst-97" data-title="call_argument/call_expression"><span class="marker" id="mapping-582"></span><span class="token add" data-title="call_expression/member_expression">abi.encodeWithSignature</span>("resetInterestCheckpoints()")</span></span>)</span>;</span></span>

        <span class="marker" id="mapping-583"></span><span class="token add" data-title="function_body/comment">// Attempt to add first interest checkpoint on new IRM</span>
        <span class="marker" id="mapping-584"></span><span class="token mv" id="move-dst-94" data-title="function_body/expression_statement"><span class="marker" id="mapping-585"></span><span class="token add" data-title="expression_statement/call_expression"><span class="marker" id="mapping-586"></span><span class="token add" data-title="call_expression/member_expression">address(newInterestRateModel).call</span>(<span class="marker" id="mapping-587"></span><span class="token add" data-title="call_expression/call_argument"><span class="marker" id="mapping-588"></span><span class="token mv" id="move-dst-95" data-title="call_argument/call_expression"><span class="marker" id="mapping-589"></span><span class="token add" data-title="call_expression/member_expression">abi.encodeWithSignature</span>("checkpointInterest()")</span></span>)</span>;</span>

        return uint(Error.NO_ERROR);
    }

    <span class="marker" id="mapping-590"></span><span class="token mv" id="move-dst-50" data-title="contract_body/comment"><span class="marker" id="mapping-591"></span><span class="token upd" id="move-dst-50" data-title="contract_body/comment"><span class="cupd">/**
    </span><span class="cupd"> * @notice</span> <span class="cupd">u</span>pd<span class="cupd">a</span>t<span class="cupd">es </span>t<span class="cupd">h</span><span class="cupd">e</span> c<span class="cupd">T</span>ok<span class="cupd">en</span> ERC2<span class="cupd">0</span> n<span class="cupd">a</span><span class="cupd">m</span>e <span class="cupd">an</span><span class="cupd">d</span> s<span class="cupd">y</span><span class="cupd">m</span>bo<span class="cupd">l</span><span class="cupd">
   </span><span class="cupd">  * @dev Admin functio</span>n<span class="cupd"> </span><span class="cupd">t</span>o<span class="cupd"> </span>upd<span class="cupd">a</span>te the cTo<span class="cupd">k</span>en ERC2<span class="cupd">0</span> na<span class="cupd">me</span> <span class="cupd">a</span>nd <span class="cupd">s</span>ymbol
     * @para<span class="cupd">m</span> _n<span class="cupd">am</span>e the new ERC2<span class="cupd">0</span> to<span class="cupd">k</span>e<span class="cupd">n</span> <span class="cupd">n</span>a<span class="cupd">m</span>e<span class="cupd"> </span>to use
     *<span class="cupd"> </span>@param _<span class="cupd">sy</span>mbo<span class="cupd">l </span><span class="cupd">t</span>he<span class="cupd"> </span>new ER<span class="cupd">C</span>20<span class="cupd"> </span>t<span class="cupd">o</span>ke<span class="cupd">n</span> sy<span class="cupd">m</span>bo<span class="cupd">l</span> to<span class="cupd"> use</span>
<span class="cupd">     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)</span><span class="cupd">
 </span>    */</span></span>
    <span class="marker" id="mapping-592"></span><span class="token add" data-title="contract_body/function_definition">function _setNameAndSymbol(<span class="marker" id="mapping-593"></span><span class="token add" data-title="function_definition/parameter">string calldata _name</span>, <span class="marker" id="mapping-594"></span><span class="token add" data-title="function_definition/parameter">string calldata _symbol</span>) <span class="marker" id="mapping-595"></span><span class="token mv" id="move-dst-64" data-title="function_definition/visibility">external</span> <span class="marker" id="mapping-596"></span><span class="token add" data-title="function_definition/function_body">{
        // Check caller is admin
        <span class="marker" id="mapping-597"></span><span class="token mv" id="move-dst-1" data-title="function_body/expression_statement">require(hasAdminRights(), "caller not admin");</span>

        // Set ERC20 name and symbol
        <span class="marker" id="mapping-598"></span><span class="token add" data-title="function_body/expression_statement">name = _name;</span>
        <span class="marker" id="mapping-599"></span><span class="token add" data-title="function_body/expression_statement">symbol = _symbol;</span>
    }</span></span>

    /*** Safe Token ***/

    /**
     * @notice Gets balance of this contract in terms of the underlying
     * @dev This excludes the value of the current message, if any
     * @return The quantity of underlying owned by this contract
     */
    function getCashPrior() internal view returns (uint);

    /**
     * @dev Performs a transfer in, reverting upon failure. Returns the amount actually transferred to the protocol, in case of a fee.
     *  This may revert due to insufficient balance or insufficient allowance.
     */
    function doTransferIn(address from, uint amount) internal returns (uint);

    /**
     * @dev Performs a transfer out, ideally returning an explanatory error code upon failure tather than reverting.
     *  If caller has not called checked protocol's balance, may revert due to insufficient cash held in the contract.
     *  If caller has checked protocol's balance, and verified it is &gt;= amount, this should not revert in normal conditions.
     */
    function doTransferOut(address payable to, uint amount) internal;


    /*** Reentrancy Guard ***/

    /**
     * @dev Prevents a contract from calling itself, directly or indirectly.
     */
    modifier nonReentrant(<span class="marker" id="mapping-600"></span><span class="token add" data-title="modifier_definition/parameter">bool localOnly</span>) <span class="marker" id="mapping-601"></span><span class="token add" data-title="modifier_definition/function_body">{
        <span class="marker" id="mapping-602"></span><span class="token add" data-title="function_body/expression_statement">_beforeNonReentrant(localOnly);</span>
        <span class="marker" id="mapping-603"></span><span class="token mv" id="move-dst-100" data-title="function_body/expression_statement">_;</span>
        <span class="marker" id="mapping-604"></span><span class="token add" data-title="function_body/expression_statement">_afterNonReentrant(localOnly);</span>
    }</span>

    <span class="marker" id="mapping-605"></span><span class="token mv" id="move-dst-54" data-title="contract_body/comment"><span class="marker" id="mapping-606"></span><span class="token upd" id="move-dst-54" data-title="contract_body/comment"><span class="cupd">/**
    </span><span class="cupd"> * </span>@<span class="cupd">d</span>e<span class="cupd">v </span>Spl<span class="cupd">i</span><span class="cupd">t</span> of<span class="cupd">f</span> from <span class="cupd">`</span>non<span class="cupd">R</span>eentrant<span class="cupd">`</span><span class="cupd"> </span><span class="cupd">t</span>o <span class="cupd">k</span>ee<span class="cupd">p</span> <span class="cupd">c</span>on<span class="cupd">t</span>rac<span class="cupd">t</span> below<span class="cupd"> the</span> 24 KB size l<span class="cupd">i</span>m<span class="cupd">i</span>t<span class="cupd">.
   </span><span class="cupd">  </span>* S<span class="cupd">a</span>v<span class="cupd">e</span>s spa<span class="cupd">c</span>e becaus<span class="cupd">e functio</span>n<span class="cupd"> </span>modifi<span class="cupd">e</span>r code<span class="cupd"> </span>is "inl<span class="cupd">i</span>ned" <span class="cupd">i</span>n<span class="cupd">t</span>o eve<span class="cupd">r</span>y <span class="cupd">f</span>unctio<span class="cupd">n</span> wi<span class="cupd">t</span>h th<span class="cupd">e</span><span class="cupd"> </span>modi<span class="cupd">fi</span>er<span class="cupd">).
  </span><span class="cupd">  </span> <span class="cupd">* </span>In<span class="cupd"> </span>t<span class="cupd">h</span><span class="cupd">i</span>s <span class="cupd">s</span>pec<span class="cupd">i</span>fic <span class="cupd">c</span><span class="cupd">as</span><span class="cupd">e, </span>the <span class="cupd">o</span>pti<span class="cupd">m</span>izat<span class="cupd">i</span>o<span class="cupd">n</span> <span class="cupd">s</span><span class="cupd">a</span><span class="cupd">v</span>e<span class="cupd">s</span><span class="cupd"> </span>around 1500<span class="cupd"> b</span><span class="cupd">y</span>t<span class="cupd">e</span><span class="cupd">s</span><span class="cupd"> </span><span class="cupd">o</span>f<span class="cupd"> </span>that<span class="cupd"> </span>valua<span class="cupd">b</span>le<span class="cupd"> </span>24<span class="cupd"> </span>KB lim<span class="cupd">it.</span>
 <span class="cupd">  </span>  */</span></span>
    <span class="marker" id="mapping-607"></span><span class="token add" data-title="contract_body/function_definition">function _beforeNonReentrant(<span class="marker" id="mapping-608"></span><span class="token add" data-title="function_definition/parameter">bool localOnly</span>) <span class="marker" id="mapping-609"></span><span class="token add" data-title="function_definition/visibility">private</span> <span class="marker" id="mapping-610"></span><span class="token mv" id="move-dst-99" data-title="function_definition/function_body">{
        require(_notEntered, "re-entered");
        <span class="marker" id="mapping-611"></span><span class="token add" data-title="function_body/if_statement">if (!localOnly) comptroller._beforeNonReentrant();</span>
        _notEntered = false;
    }</span></span>

    <span class="marker" id="mapping-612"></span><span class="token mv" id="move-dst-63" data-title="contract_body/comment"><span class="marker" id="mapping-613"></span><span class="token upd" id="move-dst-63" data-title="contract_body/comment"><span class="cupd">/**
    </span><span class="cupd"> * </span>@<span class="cupd">d</span>e<span class="cupd">v</span> Split off <span class="cupd">f</span>ro<span class="cupd">m</span> <span class="cupd">`</span>non<span class="cupd">R</span><span class="cupd">e</span>e<span class="cupd">n</span>t<span class="cupd">ra</span>nt<span class="cupd">`</span><span class="cupd"> </span>t<span class="cupd">o</span> <span class="cupd">k</span><span class="cupd">e</span>e<span class="cupd">p</span> <span class="cupd">c</span>on<span class="cupd">t</span>rac<span class="cupd">t</span> below<span class="cupd"> the</span> 2<span class="cupd">4</span> KB<span class="cupd"> s</span>iz<span class="cupd">e</span> lim<span class="cupd">i</span>t<span class="cupd">.
   </span><span class="cupd">  </span>* S<span class="cupd">a</span>v<span class="cupd">e</span>s space be<span class="cupd">c</span>ause <span class="cupd">functio</span>n<span class="cupd"> </span>modifi<span class="cupd">e</span><span class="cupd">r</span> c<span class="cupd">ode</span><span class="cupd"> </span><span class="cupd">i</span>s <span class="cupd">"</span>inli<span class="cupd">n</span>e<span class="cupd">d</span>" <span class="cupd">i</span>n<span class="cupd">t</span>o eve<span class="cupd">r</span>y <span class="cupd">f</span>unctio<span class="cupd">n</span> wi<span class="cupd">t</span>h <span class="cupd">th</span>e mo<span class="cupd">d</span>i<span class="cupd">f</span>ier<span class="cupd">).
  </span><span class="cupd">  </span> <span class="cupd">* </span>In<span class="cupd"> </span>t<span class="cupd">h</span><span class="cupd">i</span>s <span class="cupd">s</span>pec<span class="cupd">i</span>fic <span class="cupd">c</span><span class="cupd">as</span><span class="cupd">e, </span>the <span class="cupd">o</span>pti<span class="cupd">m</span>izat<span class="cupd">i</span>o<span class="cupd">n</span> <span class="cupd">s</span><span class="cupd">a</span><span class="cupd">v</span>e<span class="cupd">s</span><span class="cupd"> </span>around 150<span class="cupd"> b</span><span class="cupd">y</span>t<span class="cupd">e</span><span class="cupd">s</span><span class="cupd"> </span><span class="cupd">o</span>f<span class="cupd"> </span>that<span class="cupd"> </span>valua<span class="cupd">b</span>le<span class="cupd"> </span>24<span class="cupd"> </span>KB lim<span class="cupd">it.</span>
 <span class="cupd">  </span>  */</span></span>
    <span class="marker" id="mapping-614"></span><span class="token add" data-title="contract_body/function_definition">function _afterNonReentrant(<span class="marker" id="mapping-615"></span><span class="token add" data-title="function_definition/parameter">bool localOnly</span>) <span class="marker" id="mapping-616"></span><span class="token add" data-title="function_definition/visibility">private</span> <span class="marker" id="mapping-617"></span><span class="token add" data-title="function_definition/function_body">{
        <span class="marker" id="mapping-618"></span><span class="token mv" id="move-dst-101" data-title="function_body/expression_statement">_notEntered = true;</span> // get a gas-refund post-Istanbul
        <span class="marker" id="mapping-619"></span><span class="token add" data-title="function_body/if_statement">if (!localOnly) comptroller._afterNonReentrant();</span>
    }</span></span>

    <span class="marker" id="mapping-620"></span><span class="token mv" id="move-dst-69" data-title="contract_body/comment"><span class="marker" id="mapping-621"></span><span class="token upd" id="move-dst-69" data-title="contract_body/comment"><span class="cupd">/**
    </span><span class="cupd"> * </span>@dev Per<span class="cupd">f</span>orms a Solid<span class="cupd">i</span>ty func<span class="cupd">t</span>ion<span class="cupd"> </span>cal<span class="cupd">l</span> <span class="cupd">u</span>sin<span class="cupd">g a</span> l<span class="cupd">ow</span> level `call`. A
     * plain `call` is a<span class="cupd">n</span> <span class="cupd">u</span>ns<span class="cupd">af</span>e<span class="cupd"> </span>repl<span class="cupd">a</span>ceme<span class="cupd">nt fo</span>r<span class="cupd"> </span>a fu<span class="cupd">n</span>c<span class="cupd">t</span>io<span class="cupd">n</span> <span class="cupd">c</span>al<span class="cupd">l</span>: use this
  <span class="cupd"> </span>  <span class="cupd">*</span> fu<span class="cupd">n</span>ction i<span class="cupd">n</span>ste<span class="cupd">a</span>d.
    <span class="cupd"> </span>* If<span class="cupd"> </span>`<span class="cupd">t</span>arget` re<span class="cupd">v</span><span class="cupd">e</span>r<span class="cupd">t</span><span class="cupd">s</span> with<span class="cupd"> </span>a <span class="cupd">r</span>eve<span class="cupd">r</span>t<span class="cupd"> </span>reaso<span class="cupd">n,</span> it <span class="cupd">i</span>s <span class="cupd">b</span>ub<span class="cupd">b</span>le<span class="cupd">d</span> u<span class="cupd">p</span> by <span class="cupd">this</span>
<span class="cupd">  </span> <span class="cupd">  * func</span>tion (like regular S<span class="cupd">o</span>lidity f<span class="cupd">u</span>n<span class="cupd">c</span>tion<span class="cupd"> </span>calls).
  <span class="cupd">  </span> * R<span class="cupd">e</span>turns<span class="cupd"> </span>t<span class="cupd">h</span>e raw<span class="cupd"> r</span>e<span class="cupd">t</span>urned data. T<span class="cupd">o</span> c<span class="cupd">o</span>nvert<span class="cupd"> </span>t<span class="cupd">o</span> the ex<span class="cupd">p</span>ected <span class="cupd">r</span>eturn <span class="cupd">value</span>,<span class="cupd">
</span>     * use https://so<span class="cupd">li</span>di<span class="cupd">t</span>y.readthedocs.io/en/<span class="cupd">l</span><span class="cupd">a</span><span class="cupd">t</span>est/<span class="cupd">u</span>nits-and-global-vari<span class="cupd">a</span>bles.html?hi<span class="cupd">g</span>hlight<span class="cupd">=</span>abi.decode<span class="cupd">#</span>abi-encodin<span class="cupd">g</span>-<span class="cupd">a</span>nd-decodi<span class="cupd">n</span><span class="cupd">g</span>-f<span class="cupd">u</span>nctions<span class="cupd">[</span>`abi.de<span class="cupd">c</span>ode`].
 <span class="cupd"> </span>   <span class="cupd">*</span> <span class="cupd">@</span>param dat<span class="cupd">a</span> The cal<span class="cupd">l</span> data <span class="cupd">(</span>e<span class="cupd">n</span>coded us<span class="cupd">i</span>ng a<span class="cupd">bi</span>.<span class="cupd">e</span>n<span class="cupd">c</span>o<span class="cupd">d</span>e<span class="cupd"> </span>or one o<span class="cupd">f</span> it<span class="cupd">s</span> variants).
     <span class="cupd">* </span>@para<span class="cupd">m</span> errorMessage The revert<span class="cupd"> </span><span class="cupd">s</span><span class="cupd">t</span><span class="cupd">ri</span>ng to re<span class="cupd">tur</span>n on<span class="cupd"> failu</span><span class="cupd">re</span>.
     */</span></span>
    <span class="marker" id="mapping-622"></span><span class="token add" data-title="contract_body/function_definition">function _functionCall(<span class="marker" id="mapping-623"></span><span class="token add" data-title="function_definition/parameter"><span class="marker" id="mapping-624"></span><span class="token mv" id="move-dst-48" data-title="parameter/type_name">address</span> target</span>, <span class="marker" id="mapping-625"></span><span class="token add" data-title="function_definition/parameter">bytes memory data</span>, <span class="marker" id="mapping-626"></span><span class="token add" data-title="function_definition/parameter">string memory errorMessage</span>) <span class="marker" id="mapping-627"></span><span class="token mv" id="move-dst-79" data-title="function_definition/visibility">internal</span> <span class="marker" id="mapping-628"></span><span class="token add" data-title="function_definition/return_type_definition">returns (bytes memory)</span> <span class="marker" id="mapping-629"></span><span class="token add" data-title="function_definition/function_body">{
        (bool success, bytes memory returndata) = target.call(data);

        if (!success) {
            // Look for revert reason and bubble it up if present
            if (returndata.length &gt; 0) {
                // The easiest way to bubble the revert reason is using memory via assembly

                // solhint-disable-next-line no-inline-assembly
                assembly {
                    let returndata_size := mload(returndata)
                    revert(add(32, returndata), returndata_size)
                }
            } else {
                revert(errorMessage);
            }
        }

        return returndata;
    }</span></span>
}
</pre></div></div></div></body></html>