<html lang="en"><head><meta charset="utf8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>GumTree</title><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css"><style type="text/css">/*
 * This file is part of GumTree.
 *
 * GumTree is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * GumTree is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with GumTree.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Copyright 2011-2015 Jean-Rémy Falleri <jr.falleri@gmail.com>
 * Copyright 2011-2015 Floréal Morandat <florealm@gmail.com>
 */

.add {
	border: 1px solid black;
	background-color: MediumSeaGreen;
}

.del {
	border: 1px solid black;
	background-color: IndianRed;
}

.mv {
	border: 1px solid black;
	background-color: Plum;
}

.upd {
	border: 1px solid black;
	background-color: DarkOrange;
	font-weight: bold;
}

.cupd {
	font-weight: normal;
	color: DimGray;
}

.selected {
	background-color: Gold;
}

.marker {
	margin: 0;
	padding: 0;
}

div {
	margin: 0px;
	padding: 0px;
}

.pre-scrollable {
	margin: 0px;
	padding: 0px;
	font-size: 10pt;
	color: black;
	max-height: 90vh;
	background-color: white;
	border: 1px solid black;
	font-family: "Hack, Inconsolata", "Consolas", "Liberation Sans Regular", "DejaVu Sans Mono", monospace;
}

.tooltip-inner {
    max-width: none;
}
</style><script type="text/javascript" src="https://code.jquery.com/jquery-3.4.1.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/js/bootstrap.bundle.min.js"></script><script type="text/javascript">/*
 * This file is part of GumTree.
 *
 * GumTree is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * GumTree is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with GumTree.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Copyright 2011-2015 Jean-Rémy Falleri <jr.falleri@gmail.com>
 * Copyright 2011-2015 Floréal Morandat <florealm@gmail.com>
 */

$(function(){
    let popoverTriggerList = [].slice.call(document.querySelectorAll('[data-bs-toggle="popover"]'))
    let popoverList = popoverTriggerList.map(function (popoverTriggerEl) {
      return new bootstrap.Popover(popoverTriggerEl)
    })

    $("body").keypress(function (event) {
        switch (event.which) {
            case 116:
                $('html, body').animate({scrollTop: 0}, 100);
                break;
            case 98:
                $("html, body").animate({ scrollTop: $(document).height() }, 100);
                break;
            case 113:
                window.location = "/quit";
                break;
            case 108:
                window.location = "/list";
                break;
        }
    });
});
</script><script type="text/javascript">/*
 * This file is part of GumTree.
 *
 * GumTree is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * GumTree is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with GumTree.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Copyright 2011-2015 Jean-Rémy Falleri <jr.falleri@gmail.com>
 * Copyright 2011-2015 Floréal Morandat <florealm@gmail.com>
 */

currentMapping = 0;

if (typeof String.prototype.startsWith != 'function') {
  String.prototype.startsWith = function (str){
    return this.slice(0, str.length) == str;
  };
}

function getMappedElement(eltId) {
	if (eltId.startsWith("move-src")) {
		return eltId.replace("src","dst");  	 	
  	}
  	else {
  		return eltId.replace("dst","src");
  	}
}

function nextMapping() {
	if (currentMapping == 0) {
		currentMapping = 1;
		return "#mapping-" + currentMapping.toString();
	} else {
		currentMapping++;
		
		if ($("#mapping-" + currentMapping.toString()).length > 0) {
			return "#mapping-" + currentMapping.toString();
		} else {
			currentMapping = 1;
			return "#mapping-" + currentMapping.toString();		
		}		
	}
}

function isSrc(eltId) {
	return eltId.startsWith("move-src");
}

$(function() {
    $("body").keypress(function (event) {
        switch(event.which) {
            case 110:
                const mapping = $(nextMapping());
                const pre = mapping.closest("pre");
                pre.animate({scrollTop: pre.scrollTop() + mapping.position().top - 200}, 100);
                break;
        }
    });

    // highlight
    $("span.mv.token, span.token.upd").click(function(event) {
        if ($(this).hasClass("selected")) {
            $("span.mv.token, span.token.upd").removeClass("selected");
        } else {
            $("span.mv.token, span.token.upd").removeClass("selected");
            const refElt = $("#" + getMappedElement($(this).attr("id")));
            $(this).addClass("selected");
            refElt.addClass("selected");
            const pre = refElt.closest("pre");
            console.log(pre);
            pre.animate({scrollTop: pre.scrollTop() + refElt.position().top - 200}, 100);
        }
        event.stopPropagation();
    });
    
    $("span.add.token, span.token.del").click(function(event) {
        $("span.mv.token, span.token.upd").removeClass("selected");
        event.stopPropagation();
    });

    // tooltip
    $("span.token").hover(
    	function (event) {
    		$(this).tooltip('show');
    		event.stopPropagation();
    	},
    	function (event) {
    		$(this).tooltip('hide');
    		event.stopPropagation();
    	}
    );
});
</script></head><body><div class="container-fluid"><div class="row"><div class="col"><div class="btn-toolbar justify-content-end"><div class="btn-group mr-2"><button class="btn btn-primary btn-sm" id="legend" data-bs-toggle="popover" data-bs-placement="bottom" data-bs-html="true" data-bs-content="<span class='del'>&nbsp;&nbsp;</span> deleted<br><span class='add'>&nbsp;&nbsp;</span> added<br><span class='mv'>&nbsp;&nbsp;</span> moved<br><span class='upd';>&nbsp;&nbsp;</span> updated<br>">Legend</button><button class="btn btn-primary btn-sm" id="shortcuts" data-bs-toggle="popover" data-bs-placement="bottom" data-bs-html="true" data-bs-content="<b>q</b> quit<br><b>l</b> list<br><b>n</b> next<br><b>t</b> top<br><b>b</b> bottom">Shortcuts</button></div><div class="btn-group"><a href="/list" class="btn btn-default btn-sm btn-primary">Back</a><a href="/quit" class="btn btn-default btn-sm btn-danger">Quit</a></div></div></div></div><div class="row"><div class="col-6"><h5>StkTruToken.sol</h5><pre class="pre-scrollable">// SPDX-License-Identifier: MIT
pragma solidity ^0.8.10;

import {IERC20} from "IERC20.sol";
import {SafeERC20} from "SafeERC20.sol";
import {SafeCast} from "SafeCast.sol";
import {Math} from "Math.sol";
import {ReentrancyGuard} from "ReentrancyGuard.sol";

import {VoteToken} from "VoteToken.sol";
import {ITrueDistributor} from "ITrueDistributor.sol";
import {StkClaimableContract} from "StkClaimableContract.sol";
import {IPauseableContract} from "IPauseableContract.sol";

/**
 * @title stkTRU
 * @dev Staking contract for TrueFi
 * TRU is staked and stored in the contract
 * stkTRU is minted when staking
 * Holders of stkTRU accrue rewards over time
 * Rewards are paid in TRU and tfUSD
 * stkTRU can be used to vote in governance
 * stkTRU can be used to rate and approve loans
 */
contract StkTruToken is VoteToken, StkClaimableContract, IPauseableContract, ReentrancyGuard {
    using SafeERC20 for IERC20;

    uint256 private constant PRECISION = 1e30;
    uint256 private constant MIN_DISTRIBUTED_AMOUNT = 100e8;
    uint256 private constant MAX_COOLDOWN = 100 * 365 days;
    uint256 private constant MAX_UNSTAKE_PERIOD = 100 * 365 days;
    uint32 private constant SCHEDULED_REWARDS_BATCH_SIZE = 32;

    struct FarmRewards {
        // track overall cumulative rewards
        uint256 cumulativeRewardPerToken;
        // track previous cumulate rewards for accounts
        mapping(address =&gt; uint256) previousCumulatedRewardPerToken;
        // track claimable rewards for accounts
        mapping(address =&gt; uint256) claimableReward;
        // track total rewards
        uint256 totalClaimedRewards;
        uint256 totalFarmRewards;
    }

    struct ScheduledTfUsdRewards {
        uint64 timestamp;
        uint96 amount;
    }

    // ================ WARNING ==================
    // ===== THIS CONTRACT IS INITIALIZABLE ======
    // === STORAGE VARIABLES ARE DECLARED BELOW ==
    // REMOVAL OR REORDER OF VARIABLES WILL RESULT
    // ========= IN STORAGE CORRUPTION ===========

    IERC20 public tru;
    IERC20 public tfusd;
    ITrueDistributor public distributor;
    address public liquidator;

    uint256 public stakeSupply;

    mapping(address =&gt; uint256) internal cooldowns;
    uint256 public cooldownTime;
    uint256 public unstakePeriodDuration;

    mapping(IERC20 =&gt; FarmRewards) public farmRewards;

    uint32[] public sortedScheduledRewardIndices;
    ScheduledTfUsdRewards[] public scheduledRewards;
    uint256 public undistributedTfusdRewards;
    uint32 public nextDistributionIndex;

    mapping(address =&gt; bool) public whitelistedFeePayers;

    mapping(address =&gt; uint256) public receivedDuringCooldown;

    // allow pausing of deposits
    bool public pauseStatus;

    IERC20 public feeToken;

    Checkpoint[] internal _totalSupplyCheckpoints;

    // ======= STORAGE DECLARATION END ============

    event Stake(address indexed staker, uint256 amount);
    event Unstake(address indexed staker, uint256 burntAmount);
    event Claim(address indexed who, IERC20 indexed token, uint256 amountClaimed);
    event Withdraw(uint256 amount);
    event Cooldown(address indexed who, uint256 endTime);
    event CooldownTimeChanged(uint256 newUnstakePeriodDuration);
    event UnstakePeriodDurationChanged(uint256 newUnstakePeriodDuration);
    event FeePayerWhitelistingStatusChanged(address payer, bool status);
    event PauseStatusChanged(bool pauseStatus);
    event FeeTokenChanged(IERC20 token);
    event LiquidatorChanged(address liquidator);

    /**
     * Get TRU from distributor
     */
    modifier distribute() {
        // pull TRU from distributor
        // do not pull small amounts to save some gas
        // only pull if there is distribution and distributor farm is set to this farm
        if (distributor.nextDistribution() &gt;= MIN_DISTRIBUTED_AMOUNT &amp;&amp; distributor.farm() == address(this)) {
            distributor.distribute();
        }
        _;
    }

    /**
     * Update all rewards when an account changes state
     * @param account Account to update rewards for
     */
    modifier update(address account) {
        _update(account);
        _;
    }

    function _update(address account) internal {
        updateTotalRewards(tru);
        updateClaimableRewards(tru, account);
        updateTotalRewards(tfusd);
        updateClaimableRewards(tfusd, account);
        updateTotalRewards(feeToken);
        updateClaimableRewards(feeToken, account);
    }

    /**
     * Update rewards for a specific token when an account changes state
     * @param account Account to update rewards for
     * @param token Token to update rewards for
     */
    modifier updateRewards(address account, IERC20 token) {
        if (token == tru || token == tfusd || token == feeToken) {
            updateTotalRewards(token);
            updateClaimableRewards(token, account);
        }
        _;
    }

    constructor() {
        initalized = true;
    }

    /**
     * @dev Initialize contract and set default values
     * @param _tru TRU token
     * @param _tfusd tfUSD token
     * @param _feeToken Token for fees, currently tfUSDC
     * @param _distributor Distributor for this contract
     * @param _liquidator Liquidator for staked TRU
     */
    function initialize(
        IERC20 _tru,
        IERC20 _tfusd,
        IERC20 _feeToken,
        ITrueDistributor _distributor,
        address _liquidator
    ) public {
        require(!initalized, "StkTruToken: Already initialized");
        require(address(_tru) != address(0), "StkTruToken: TRU token address must not be 0");
        require(address(_tfusd) != address(0), "StkTruToken: tfUSD token address must not be 0");
        require(address(_feeToken) != address(0), "StkTruToken: fee token address must not be 0");
        tru = _tru;
        tfusd = _tfusd;
        feeToken = _feeToken;
        distributor = _distributor;
        liquidator = _liquidator;

        cooldownTime = 14 days;
        unstakePeriodDuration = 2 days;

        initTotalSupplyCheckpoints();

        owner_ = msg.sender;
        initalized = true;
    }

    function initTotalSupplyCheckpoints() public onlyOwner {
        require(_totalSupplyCheckpoints.length == 0, "StakeTruToken: Total supply checkpoints already initialized");
        _totalSupplyCheckpoints.push(Checkpoint({fromBlock: SafeCast.toUint32(block.number), votes: SafeCast.toUint96(totalSupply)}));
    }

    function _mint(address account, uint256 amount) internal virtual override {
        super._mint(account, amount);
        _writeTotalSupplyCheckpoint(_add, amount);
    }

    function _burn(address account, uint256 amount) internal virtual override {
        super._burn(account, amount);
        _writeTotalSupplyCheckpoint(_subtract, amount);
    }

    /**
     * @dev Set tfUSDC address
     * @param _feeToken Address of tfUSDC to be set
     */
    function setFeeToken(IERC20 _feeToken) external onlyOwner {
        require(address(_feeToken) != address(0), "StkTruToken: fee token address must not be 0");
        require(rewardBalance(feeToken) == 0, "StkTruToken: Cannot replace fee token with underlying rewards");
        feeToken = _feeToken;
        emit FeeTokenChanged(_feeToken);
    }

    /**
     * @dev Set liquidator address
     * @param _liquidator Address of liquidator to be set
     */
    function setLiquidator(address _liquidator) external onlyOwner {
        liquidator = _liquidator;
        emit LiquidatorChanged(_liquidator);
    }

    /**
     * @dev Owner can use this function to add new addresses to payers whitelist
     * Only whitelisted payers can call payFee method
     * @param payer Address that is being added to or removed from whitelist
     * @param status New whitelisting status
     */
    function setPayerWhitelistingStatus(address payer, bool status) external onlyOwner {
        whitelistedFeePayers[payer] = status;
        emit FeePayerWhitelistingStatusChanged(payer, status);
    }

    /**
     * @dev Owner can use this function to set cooldown time
     * Cooldown time defines how long a staker waits to unstake TRU
     * @param newCooldownTime New cooldown time for stakers
     */
    function setCooldownTime(uint256 newCooldownTime) external onlyOwner {
        // Avoid overflow
        require(newCooldownTime &lt;= MAX_COOLDOWN, "StkTruToken: Cooldown too large");

        cooldownTime = newCooldownTime;
        emit CooldownTimeChanged(newCooldownTime);
    }

    /**
     * @dev Allow pausing of deposits in case of emergency
     * @param status New deposit status
     */
    function setPauseStatus(bool status) external override onlyOwner {
        pauseStatus = status;
        emit PauseStatusChanged(status);
    }

    /**
     * @dev Owner can set unstake period duration
     * Unstake period defines how long after cooldown a user has to withdraw stake
     * @param newUnstakePeriodDuration New unstake period
     */
    function setUnstakePeriodDuration(uint256 newUnstakePeriodDuration) external onlyOwner {
        require(newUnstakePeriodDuration &gt; 0, "StkTruToken: Unstake period cannot be 0");
        // Avoid overflow
        require(newUnstakePeriodDuration &lt;= MAX_UNSTAKE_PERIOD, "StkTruToken: Unstake period too large");

        unstakePeriodDuration = newUnstakePeriodDuration;
        emit UnstakePeriodDurationChanged(newUnstakePeriodDuration);
    }

    /**
     * @dev Stake TRU for stkTRU
     * Updates rewards when staking
     * @param amount Amount of TRU to stake for stkTRU
     */
    function stake(uint256 amount) external distribute update(msg.sender) {
        require(!pauseStatus, "StkTruToken: Can be called only when not paused");
        _stakeWithoutTransfer(amount);
        tru.safeTransferFrom(msg.sender, address(this), amount);
    }

    /**
     * @dev Unstake stkTRU for TRU
     * Can only unstake when cooldown complete and within unstake period
     * Claims rewards when unstaking
     * @param amount Amount of stkTRU to unstake for TRU
     */
    // slither-disable-next-line reentrancy-eth
    function unstake(uint256 amount) external distribute update(msg.sender) nonReentrant {
        require(amount &gt; 0, "StkTruToken: Cannot unstake 0");

        require(unstakable(msg.sender) &gt;= amount, "StkTruToken: Insufficient balance");
        require(unlockTime(msg.sender) &lt;= block.timestamp, "StkTruToken: Stake on cooldown");

        _claim(tru);
        _claim(tfusd);
        _claim(feeToken);

        uint256 amountToTransfer = (amount * stakeSupply) / totalSupply;

        _burn(msg.sender, amount);
        stakeSupply = stakeSupply - amountToTransfer;

        tru.safeTransfer(msg.sender, amountToTransfer);

        emit Unstake(msg.sender, amount);
    }

    /**
     * @dev Initiate cooldown period
     */
    function cooldown() public {
        cooldowns[msg.sender] = block.timestamp;
        receivedDuringCooldown[msg.sender] = 0;

        emit Cooldown(msg.sender, block.timestamp + cooldownTime);
    }

    /**
     * @dev Withdraw TRU from the contract for liquidation
     * @param amount Amount to withdraw for liquidation
     */
    function withdraw(uint256 amount) external {
        require(msg.sender == liquidator, "StkTruToken: Can be called only by the liquidator");
        require(amount &lt;= stakeSupply, "StkTruToken: Insufficient stake supply");
        stakeSupply = stakeSupply - amount;
        tru.safeTransfer(liquidator, amount);

        emit Withdraw(amount);
    }

    /**
     * @dev View function to get unlock time for an account
     * @param account Account to get unlock time for
     * @return Unlock time for account
     */
    function unlockTime(address account) public view returns (uint256) {
        uint256 cooldownStart = cooldowns[account];
        if (cooldownStart == 0 || cooldownStart + cooldownTime + unstakePeriodDuration &lt; block.timestamp) {
            return type(uint256).max;
        }
        return cooldownStart + cooldownTime;
    }

    /**
     * @dev Give tfUSD as origination fee to stake.this
     * 50% are given immediately and 50% after `endTime` passes
     */
    function payFee(uint256 amount, uint256 endTime) external {
        require(whitelistedFeePayers[msg.sender], "StkTruToken: Can be called only by whitelisted payers");
        require(endTime &lt;= type(uint64).max, "StkTruToken: time overflow");
        require(amount &lt;= type(uint96).max, "StkTruToken: amount overflow");

        tfusd.safeTransferFrom(msg.sender, address(this), amount);
        uint256 halfAmount = amount / 2;
        undistributedTfusdRewards = undistributedTfusdRewards + halfAmount;
        scheduledRewards.push(ScheduledTfUsdRewards({amount: uint96(amount - halfAmount), timestamp: uint64(endTime)}));

        uint32 newIndex = findPositionForTimestamp(endTime);
        insertAt(newIndex, uint32(scheduledRewards.length) - 1);
    }

    /**
     * @dev Claim all rewards
     */
    // slither-disable-next-line reentrancy-eth
    function claim() external distribute update(msg.sender) {
        _claim(tru);
        _claim(tfusd);
        _claim(feeToken);
    }

    /**
     * @dev Claim rewards for specific token
     * Allows account to claim specific token to save gas
     * @param token Token to claim rewards for
     */
    function claimRewards(IERC20 token) external distribute updateRewards(msg.sender, token) {
        require(token == tfusd || token == tru || token == feeToken, "Token not supported for rewards");
        _claim(token);
    }

    /**
     * @dev Claim TRU rewards, transfer in extraStakeAmount, and
     * stake both the rewards and the new amount.
     * Allows account to save more gas by avoiding out-and-back transfers of rewards
     */
    function claimRestake(uint256 extraStakeAmount) external distribute update(msg.sender) {
        uint256 amount = _claimWithoutTransfer(tru) + extraStakeAmount;
        _stakeWithoutTransfer(amount);
        if (extraStakeAmount &gt; 0) {
            tru.safeTransferFrom(msg.sender, address(this), extraStakeAmount);
        }
    }

    /**
     * @dev View to estimate the claimable reward for an account
     * @param account Account to get claimable reward for
     * @param token Token to get rewards for
     * @return claimable rewards for account
     */
    function claimable(address account, IERC20 token) external view returns (uint256) {
        FarmRewards storage rewards = farmRewards[token];
        // estimate pending reward from distributor
        uint256 pendingReward = token == tru ? distributor.nextDistribution() : 0;
        // calculate total rewards (including pending)
        uint256 newTotalFarmRewards = (rewardBalance(token) +
            (pendingReward &gt;= MIN_DISTRIBUTED_AMOUNT ? pendingReward : 0) +
            (rewards.totalClaimedRewards)) * PRECISION;
        // calculate block reward
        uint256 totalBlockReward = newTotalFarmRewards - rewards.totalFarmRewards;
        // calculate next cumulative reward per token
        uint256 nextCumulativeRewardPerToken = rewards.cumulativeRewardPerToken + (totalBlockReward / totalSupply);
        // return claimable reward for this account
        return
            rewards.claimableReward[account] +
            ((balanceOf[account] * (nextCumulativeRewardPerToken - (rewards.previousCumulatedRewardPerToken[account]))) / PRECISION);
    }

    /**
     * @dev max amount of stkTRU than can be unstaked after current cooldown period is over
     */
    function unstakable(address staker) public view returns (uint256) {
        uint256 stakerBalance = balanceOf[staker];

        if (unlockTime(staker) == type(uint256).max) {
            return stakerBalance;
        }

        if (receivedDuringCooldown[staker] &gt; stakerBalance) {
            return 0;
        }
        return stakerBalance - receivedDuringCooldown[staker];
    }

    /**
     * @dev Prior votes votes are calculated as priorVotes * stakedSupply / totalSupply
     * This dilutes voting power when TRU is liquidated
     * @param account Account to get current voting power for
     * @param blockNumber Block to get prior votes at
     * @return prior voting power for account and block
     */
    function getPriorVotes(address account, uint256 blockNumber) public view override returns (uint96) {
        uint96 votes = super.getPriorVotes(account, blockNumber);
        return safe96((stakeSupply * votes) / totalSupply, "StkTruToken: uint96 overflow");
    }

    function getPastVotes(address account, uint256 blockNumber) public view returns (uint96) {
        return super.getPriorVotes(account, blockNumber);
    }

    function getPastTotalSupply(uint256 blockNumber) public view returns (uint256) {
        require(blockNumber &lt; block.number, "ERC20Votes: block not yet mined");
        return _checkpointsLookup(_totalSupplyCheckpoints, blockNumber);
    }

    /**
     * @dev Current votes are calculated as votes * stakedSupply / totalSupply
     * This dilutes voting power when TRU is liquidated
     * @param account Account to get current voting power for
     * @return voting power for account
     */
    function getCurrentVotes(address account) public view override returns (uint96) {
        uint96 votes = super.getCurrentVotes(account);
        return safe96((stakeSupply * votes) / totalSupply, "StkTruToken: uint96 overflow");
    }

    function decimals() public pure override returns (uint8) {
        return 8;
    }

    function rounding() public pure returns (uint8) {
        return 8;
    }

    function name() public pure override returns (string memory) {
        return "Staked TrueFi";
    }

    function symbol() public pure override returns (string memory) {
        return "stkTRU";
    }

    function _transfer(
        address sender,
        address recipient,
        uint256 amount
    ) internal override distribute update(sender) {
        updateClaimableRewards(tru, recipient);
        updateClaimableRewards(tfusd, recipient);
        updateClaimableRewards(feeToken, recipient);
        // unlockTime returns MAX_UINT256 when there's no ongoing cooldown for the address
        if (unlockTime(recipient) != type(uint256).max) {
            receivedDuringCooldown[recipient] = receivedDuringCooldown[recipient] + amount;
        }
        if (unlockTime(sender) != type(uint256).max) {
            receivedDuringCooldown[sender] = receivedDuringCooldown[sender] - min(receivedDuringCooldown[sender], amount);
        }
        super._transfer(sender, recipient, amount);
    }

    function min(uint256 a, uint256 b) internal pure returns (uint256) {
        return a &lt; b ? a : b;
    }

    /**
     * @dev Internal claim function
     * Claim rewards for a specific ERC20 token
     * @param token Token to claim rewards for
     */
    function _claim(IERC20 token) internal {
        uint256 rewardToClaim = _claimWithoutTransfer(token);
        if (rewardToClaim &gt; 0) {
            token.safeTransfer(msg.sender, rewardToClaim);
        }
    }

    /**
     * @dev Internal claim function that returns the transfer value
     * Claim rewards for a specific ERC20 token to return in a uint256
     * @param token Token to claim rewards for
     */
    function _claimWithoutTransfer(IERC20 token) internal returns (uint256) {
        FarmRewards storage rewards = farmRewards[token];

        uint256 rewardToClaim = rewards.claimableReward[msg.sender];
        rewards.totalClaimedRewards = rewards.totalClaimedRewards + rewardToClaim;
        rewards.claimableReward[msg.sender] = 0;
        emit Claim(msg.sender, token, rewardToClaim);
        return rewardToClaim;
    }

    /**
     * @dev Internal stake of TRU for stkTRU from a uint256
     * Caller is responsible for ensuring amount is transferred from a valid source
     * @param amount Amount of TRU to stake for stkTRU
     */
    function _stakeWithoutTransfer(uint256 amount) internal {
        require(amount &gt; 0, "StkTruToken: Cannot stake 0");

        if (cooldowns[msg.sender] != 0 &amp;&amp; cooldowns[msg.sender] + cooldownTime + unstakePeriodDuration <span class="marker" id="mapping-1"></span><span class="token del" data-title="binary_expression/>">&gt;</span> block.timestamp) {
            cooldown();
        }

        <span class="marker" id="mapping-2"></span><span class="token mv" id="move-src-1" data-title="function_body/if_statement">if (<span class="marker" id="mapping-3"></span><span class="token mv" id="move-src-2" data-title="if_statement/binary_expression">delegates[<span class="marker" id="mapping-4"></span><span class="token del" data-title="array_access/member_expression">msg.sender</span>] == address(0)</span>) {
            <span class="marker" id="mapping-5"></span><span class="token del" data-title="expression_statement/assignment_expression">delegates[msg.sender] = msg.sender</span>;
        }</span>

        uint256 amountToMint = stakeSupply == 0 ? amount : (amount * totalSupply) / stakeSupply;
        _mint(msg.sender, amountToMint);
        stakeSupply = stakeSupply + amount;
        emit Stake(msg.sender, amount);
    }

    /**
     * @dev Get reward balance of this contract for a token
     * @param token Token to get reward balance for
     * @return Reward balance for token
     */
    function rewardBalance(IERC20 token) internal view returns (uint256) {
        if (token == tru) {
            return token.balanceOf(address(this)) - stakeSupply;
        }
        if (token == tfusd) {
            return token.balanceOf(address(this)) - undistributedTfusdRewards;
        }
        if (token == feeToken) {
            return token.balanceOf(address(this));
        }
        return 0;
    }

    /**
     * @dev Check if any scheduled rewards should be distributed
     */
    function distributeScheduledRewards() internal {
        uint32 index = nextDistributionIndex;
        uint32 batchLimitIndex = index + SCHEDULED_REWARDS_BATCH_SIZE;
        uint32 end = batchLimitIndex &lt; scheduledRewards.length ? batchLimitIndex : uint32(scheduledRewards.length);
        uint256 _undistributedTfusdRewards = undistributedTfusdRewards;

        while (index &lt; end) {
            ScheduledTfUsdRewards storage rewards = scheduledRewards[sortedScheduledRewardIndices[index]];
            if (rewards.timestamp &gt;= block.timestamp) {
                break;
            }
            _undistributedTfusdRewards = _undistributedTfusdRewards - rewards.amount;
            index++;
        }

        undistributedTfusdRewards = _undistributedTfusdRewards;

        if (nextDistributionIndex != index) {
            nextDistributionIndex = index;
        }
    }

    /**
     * @dev Update rewards state for `token`
     */
    function updateTotalRewards(IERC20 token) internal {
        if (token == tfusd) {
            distributeScheduledRewards();
        }
        FarmRewards storage rewards = farmRewards[token];

        // calculate total rewards
        uint256 newTotalFarmRewards = (rewardBalance(token) + rewards.totalClaimedRewards) * PRECISION;
        if (newTotalFarmRewards == rewards.totalFarmRewards) {
            return;
        }
        // calculate block reward
        uint256 totalBlockReward = newTotalFarmRewards - rewards.totalFarmRewards;
        // update farm rewards
        rewards.totalFarmRewards = newTotalFarmRewards;
        // if there are stakers
        if (totalSupply &gt; 0) {
            rewards.cumulativeRewardPerToken = rewards.cumulativeRewardPerToken + totalBlockReward / totalSupply;
        }
    }

    /**
     * @dev Update claimable rewards for a token and account
     * @param token Token to update claimable rewards for
     * @param user Account to update claimable rewards for
     */
    function updateClaimableRewards(IERC20 token, address user) internal {
        FarmRewards storage rewards = farmRewards[token];

        // update claimable reward for sender
        if (balanceOf[user] &gt; 0) {
            rewards.claimableReward[user] =
                rewards.claimableReward[user] +
                (balanceOf[user] * (rewards.cumulativeRewardPerToken - rewards.previousCumulatedRewardPerToken[user])) /
                PRECISION;
        }

        // update previous cumulative for sender
        rewards.previousCumulatedRewardPerToken[user] = rewards.cumulativeRewardPerToken;
    }

    /**
     * @dev Find next distribution index given a timestamp
     * @param timestamp Timestamp to find next distribution index for
     */
    function findPositionForTimestamp(uint256 timestamp) internal view returns (uint32 i) {
        uint256 length = sortedScheduledRewardIndices.length;
        for (i = nextDistributionIndex; i &lt; length; i++) {
            if (scheduledRewards[sortedScheduledRewardIndices[i]].timestamp &gt; timestamp) {
                return i;
            }
        }
        return i;
    }

    /**
     * @dev internal function to insert distribution index in a sorted list
     * @param index Index to insert at
     * @param value Value at index
     */
    function insertAt(uint32 index, uint32 value) internal {
        sortedScheduledRewardIndices.push(0);
        for (uint32 j = uint32(sortedScheduledRewardIndices.length) - 1; j &gt; index; j--) {
            sortedScheduledRewardIndices[j] = sortedScheduledRewardIndices[j - 1];
        }
        sortedScheduledRewardIndices[index] = value;
    }

    function _writeTotalSupplyCheckpoint(function(uint256, uint256) view returns (uint256) op, uint256 delta)
        internal
        returns (uint256 oldWeight, uint256 newWeight)
    {
        uint256 checkpointsNumber = _totalSupplyCheckpoints.length;
        require(checkpointsNumber &gt; 0, "StakeTruToken: total supply checkpoints not initialized");
        Checkpoint storage lastCheckpoint = _totalSupplyCheckpoints[checkpointsNumber - 1];

        oldWeight = lastCheckpoint.votes;
        newWeight = op(oldWeight, delta);

        if (lastCheckpoint.fromBlock == block.number) {
            lastCheckpoint.votes = SafeCast.toUint96(newWeight);
        } else {
            _totalSupplyCheckpoints.push(
                Checkpoint({fromBlock: SafeCast.toUint32(block.number), votes: SafeCast.toUint96(newWeight)})
            );
        }
    }

    function _add(uint256 a, uint256 b) private pure returns (uint256) {
        return a + b;
    }

    function _subtract(uint256 a, uint256 b) private pure returns (uint256) {
        return a - b;
    }

    /**
     * @dev Lookup a value in a list of (sorted) checkpoints.
     */
    function _checkpointsLookup(Checkpoint[] storage checkpoints, uint256 blockNumber) internal view returns (uint256) {
        // We run a binary search to look for the earliest checkpoint taken after `blockNumber`.
        //
        // During the loop, the index of the wanted checkpoint remains in the range [low-1, high).
        // With each iteration, either `low` or `high` is moved towards the middle of the range to maintain the invariant.
        // - If the middle checkpoint is after `blockNumber`, we look in [low, mid)
        // - If the middle checkpoint is before or equal to `blockNumber`, we look in [mid+1, high)
        // Once we reach a single value (when low == high), we've found the right checkpoint at the index high-1, if not
        // out of bounds (in which case we're looking too far in the past and the result is 0).
        // Note that if the latest checkpoint available is exactly for `blockNumber`, we end up with an index that is
        // past the end of the array, so we technically don't find a checkpoint after `blockNumber`, but it works out
        // the same.
        uint256 high = checkpoints.length;
        uint256 low = 0;
        while (low &lt; high) {
            uint256 mid = Math.average(low, high);
            if (checkpoints[mid].fromBlock &gt; blockNumber) {
                high = mid;
            } else {
                low = mid + 1;
            }
        }

        return high == 0 ? 0 : checkpoints[high - 1].votes;
    }
}
</pre></div><div class="col-6"><h5>StkTruToken.sol</h5><pre class="pre-scrollable">// SPDX-License-Identifier: MIT
pragma solidity ^0.8.10;

import {IERC20} from "IERC20.sol";
import {SafeERC20} from "SafeERC20.sol";
import {SafeCast} from "SafeCast.sol";
import {Math} from "Math.sol";
import {ReentrancyGuard} from "ReentrancyGuard.sol";

import {VoteToken} from "VoteToken.sol";
import {ITrueDistributor} from "ITrueDistributor.sol";
import {StkClaimableContract} from "StkClaimableContract.sol";
import {IPauseableContract} from "IPauseableContract.sol";

/**
 * @title stkTRU
 * @dev Staking contract for TrueFi
 * TRU is staked and stored in the contract
 * stkTRU is minted when staking
 * Holders of stkTRU accrue rewards over time
 * Rewards are paid in TRU and tfUSD
 * stkTRU can be used to vote in governance
 * stkTRU can be used to rate and approve loans
 */
contract StkTruToken is VoteToken, StkClaimableContract, IPauseableContract, ReentrancyGuard {
    using SafeERC20 for IERC20;

    uint256 private constant PRECISION = 1e30;
    uint256 private constant MIN_DISTRIBUTED_AMOUNT = 100e8;
    uint256 private constant MAX_COOLDOWN = 100 * 365 days;
    uint256 private constant MAX_UNSTAKE_PERIOD = 100 * 365 days;
    uint32 private constant SCHEDULED_REWARDS_BATCH_SIZE = 32;

    struct FarmRewards {
        // track overall cumulative rewards
        uint256 cumulativeRewardPerToken;
        // track previous cumulate rewards for accounts
        mapping(address =&gt; uint256) previousCumulatedRewardPerToken;
        // track claimable rewards for accounts
        mapping(address =&gt; uint256) claimableReward;
        // track total rewards
        uint256 totalClaimedRewards;
        uint256 totalFarmRewards;
    }

    struct ScheduledTfUsdRewards {
        uint64 timestamp;
        uint96 amount;
    }

    // ================ WARNING ==================
    // ===== THIS CONTRACT IS INITIALIZABLE ======
    // === STORAGE VARIABLES ARE DECLARED BELOW ==
    // REMOVAL OR REORDER OF VARIABLES WILL RESULT
    // ========= IN STORAGE CORRUPTION ===========

    IERC20 public tru;
    IERC20 public tfusd;
    ITrueDistributor public distributor;
    address public liquidator;

    uint256 public stakeSupply;

    mapping(address =&gt; uint256) internal cooldowns;
    uint256 public cooldownTime;
    uint256 public unstakePeriodDuration;

    mapping(IERC20 =&gt; FarmRewards) public farmRewards;

    uint32[] public sortedScheduledRewardIndices;
    ScheduledTfUsdRewards[] public scheduledRewards;
    uint256 public undistributedTfusdRewards;
    uint32 public nextDistributionIndex;

    mapping(address =&gt; bool) public whitelistedFeePayers;

    mapping(address =&gt; uint256) public receivedDuringCooldown;

    // allow pausing of deposits
    bool public pauseStatus;

    IERC20 public feeToken;

    Checkpoint[] internal _totalSupplyCheckpoints;

    // ======= STORAGE DECLARATION END ============

    event Stake(address indexed staker, uint256 amount);
    event Unstake(address indexed staker, uint256 burntAmount);
    event Claim(address indexed who, IERC20 indexed token, uint256 amountClaimed);
    event Withdraw(uint256 amount);
    event Cooldown(address indexed who, uint256 endTime);
    event CooldownTimeChanged(uint256 newUnstakePeriodDuration);
    event UnstakePeriodDurationChanged(uint256 newUnstakePeriodDuration);
    event FeePayerWhitelistingStatusChanged(address payer, bool status);
    event PauseStatusChanged(bool pauseStatus);
    event FeeTokenChanged(IERC20 token);
    event LiquidatorChanged(address liquidator);

    /**
     * Get TRU from distributor
     */
    modifier distribute() {
        // pull TRU from distributor
        // do not pull small amounts to save some gas
        // only pull if there is distribution and distributor farm is set to this farm
        if (distributor.nextDistribution() &gt;= MIN_DISTRIBUTED_AMOUNT &amp;&amp; distributor.farm() == address(this)) {
            distributor.distribute();
        }
        _;
    }

    /**
     * Update all rewards when an account changes state
     * @param account Account to update rewards for
     */
    modifier update(address account) {
        _update(account);
        _;
    }

    function _update(address account) internal {
        updateTotalRewards(tru);
        updateClaimableRewards(tru, account);
        updateTotalRewards(tfusd);
        updateClaimableRewards(tfusd, account);
        updateTotalRewards(feeToken);
        updateClaimableRewards(feeToken, account);
    }

    /**
     * Update rewards for a specific token when an account changes state
     * @param account Account to update rewards for
     * @param token Token to update rewards for
     */
    modifier updateRewards(address account, IERC20 token) {
        if (token == tru || token == tfusd || token == feeToken) {
            updateTotalRewards(token);
            updateClaimableRewards(token, account);
        }
        _;
    }

    constructor() {
        initalized = true;
    }

    /**
     * @dev Initialize contract and set default values
     * @param _tru TRU token
     * @param _tfusd tfUSD token
     * @param _feeToken Token for fees, currently tfUSDC
     * @param _distributor Distributor for this contract
     * @param _liquidator Liquidator for staked TRU
     */
    function initialize(
        IERC20 _tru,
        IERC20 _tfusd,
        IERC20 _feeToken,
        ITrueDistributor _distributor,
        address _liquidator
    ) public {
        require(!initalized, "StkTruToken: Already initialized");
        require(address(_tru) != address(0), "StkTruToken: TRU token address must not be 0");
        require(address(_tfusd) != address(0), "StkTruToken: tfUSD token address must not be 0");
        require(address(_feeToken) != address(0), "StkTruToken: fee token address must not be 0");
        tru = _tru;
        tfusd = _tfusd;
        feeToken = _feeToken;
        distributor = _distributor;
        liquidator = _liquidator;

        cooldownTime = 14 days;
        unstakePeriodDuration = 2 days;

        initTotalSupplyCheckpoints();

        owner_ = msg.sender;
        initalized = true;
    }

    function initTotalSupplyCheckpoints() public onlyOwner {
        require(_totalSupplyCheckpoints.length == 0, "StakeTruToken: Total supply checkpoints already initialized");
        _totalSupplyCheckpoints.push(Checkpoint({fromBlock: SafeCast.toUint32(block.number), votes: SafeCast.toUint96(totalSupply)}));
    }

    function _mint(address account, uint256 amount) internal virtual override {
        super._mint(account, amount);
        _writeTotalSupplyCheckpoint(_add, amount);
    }

    function _burn(address account, uint256 amount) internal virtual override {
        super._burn(account, amount);
        _writeTotalSupplyCheckpoint(_subtract, amount);
    }

    /**
     * @dev Set tfUSDC address
     * @param _feeToken Address of tfUSDC to be set
     */
    function setFeeToken(IERC20 _feeToken) external onlyOwner {
        require(address(_feeToken) != address(0), "StkTruToken: fee token address must not be 0");
        require(rewardBalance(feeToken) == 0, "StkTruToken: Cannot replace fee token with underlying rewards");
        feeToken = _feeToken;
        emit FeeTokenChanged(_feeToken);
    }

    /**
     * @dev Set liquidator address
     * @param _liquidator Address of liquidator to be set
     */
    function setLiquidator(address _liquidator) external onlyOwner {
        liquidator = _liquidator;
        emit LiquidatorChanged(_liquidator);
    }

    /**
     * @dev Owner can use this function to add new addresses to payers whitelist
     * Only whitelisted payers can call payFee method
     * @param payer Address that is being added to or removed from whitelist
     * @param status New whitelisting status
     */
    function setPayerWhitelistingStatus(address payer, bool status) external onlyOwner {
        whitelistedFeePayers[payer] = status;
        emit FeePayerWhitelistingStatusChanged(payer, status);
    }

    /**
     * @dev Owner can use this function to set cooldown time
     * Cooldown time defines how long a staker waits to unstake TRU
     * @param newCooldownTime New cooldown time for stakers
     */
    function setCooldownTime(uint256 newCooldownTime) external onlyOwner {
        // Avoid overflow
        require(newCooldownTime &lt;= MAX_COOLDOWN, "StkTruToken: Cooldown too large");

        cooldownTime = newCooldownTime;
        emit CooldownTimeChanged(newCooldownTime);
    }

    /**
     * @dev Allow pausing of deposits in case of emergency
     * @param status New deposit status
     */
    function setPauseStatus(bool status) external override onlyOwner {
        pauseStatus = status;
        emit PauseStatusChanged(status);
    }

    /**
     * @dev Owner can set unstake period duration
     * Unstake period defines how long after cooldown a user has to withdraw stake
     * @param newUnstakePeriodDuration New unstake period
     */
    function setUnstakePeriodDuration(uint256 newUnstakePeriodDuration) external onlyOwner {
        require(newUnstakePeriodDuration &gt; 0, "StkTruToken: Unstake period cannot be 0");
        // Avoid overflow
        require(newUnstakePeriodDuration &lt;= MAX_UNSTAKE_PERIOD, "StkTruToken: Unstake period too large");

        unstakePeriodDuration = newUnstakePeriodDuration;
        emit UnstakePeriodDurationChanged(newUnstakePeriodDuration);
    }

    /**
     * @dev Stake TRU for stkTRU
     * Updates rewards when staking
     * @param amount Amount of TRU to stake for stkTRU
     */
    function stake(uint256 amount) external distribute update(msg.sender) {
        require(!pauseStatus, "StkTruToken: Can be called only when not paused");
        _stakeWithoutTransfer(amount);
        tru.safeTransferFrom(msg.sender, address(this), amount);
    }

    /**
     * @dev Unstake stkTRU for TRU
     * Can only unstake when cooldown complete and within unstake period
     * Claims rewards when unstaking
     * @param amount Amount of stkTRU to unstake for TRU
     */
    // slither-disable-next-line reentrancy-eth
    function unstake(uint256 amount) external distribute update(msg.sender) nonReentrant {
        require(amount &gt; 0, "StkTruToken: Cannot unstake 0");

        require(unstakable(msg.sender) &gt;= amount, "StkTruToken: Insufficient balance");
        require(unlockTime(msg.sender) &lt;= block.timestamp, "StkTruToken: Stake on cooldown");

        _claim(tru);
        _claim(tfusd);
        _claim(feeToken);

        uint256 amountToTransfer = (amount * stakeSupply) / totalSupply;

        _burn(msg.sender, amount);
        stakeSupply = stakeSupply - amountToTransfer;

        tru.safeTransfer(msg.sender, amountToTransfer);

        emit Unstake(msg.sender, amount);
    }

    /**
     * @dev Initiate cooldown period
     */
    function cooldown() public {
        cooldowns[msg.sender] = block.timestamp;
        receivedDuringCooldown[msg.sender] = 0;

        emit Cooldown(msg.sender, block.timestamp + cooldownTime);
    }

    /**
     * @dev Withdraw TRU from the contract for liquidation
     * @param amount Amount to withdraw for liquidation
     */
    function withdraw(uint256 amount) external {
        require(msg.sender == liquidator, "StkTruToken: Can be called only by the liquidator");
        require(amount &lt;= stakeSupply, "StkTruToken: Insufficient stake supply");
        stakeSupply = stakeSupply - amount;
        tru.safeTransfer(liquidator, amount);

        emit Withdraw(amount);
    }

    /**
     * @dev View function to get unlock time for an account
     * @param account Account to get unlock time for
     * @return Unlock time for account
     */
    function unlockTime(address account) public view returns (uint256) {
        uint256 cooldownStart = cooldowns[account];
        if (cooldownStart == 0 || cooldownStart + cooldownTime + unstakePeriodDuration &lt; block.timestamp) {
            return type(uint256).max;
        }
        return cooldownStart + cooldownTime;
    }

    /**
     * @dev Give tfUSD as origination fee to stake.this
     * 50% are given immediately and 50% after `endTime` passes
     */
    function payFee(uint256 amount, uint256 endTime) external {
        require(whitelistedFeePayers[msg.sender], "StkTruToken: Can be called only by whitelisted payers");
        require(endTime &lt;= type(uint64).max, "StkTruToken: time overflow");
        require(amount &lt;= type(uint96).max, "StkTruToken: amount overflow");

        tfusd.safeTransferFrom(msg.sender, address(this), amount);
        uint256 halfAmount = amount / 2;
        undistributedTfusdRewards = undistributedTfusdRewards + halfAmount;
        scheduledRewards.push(ScheduledTfUsdRewards({amount: uint96(amount - halfAmount), timestamp: uint64(endTime)}));

        uint32 newIndex = findPositionForTimestamp(endTime);
        insertAt(newIndex, uint32(scheduledRewards.length) - 1);
    }

    /**
     * @dev Claim all rewards
     */
    // slither-disable-next-line reentrancy-eth
    function claim() external distribute update(msg.sender) {
        _claim(tru);
        _claim(tfusd);
        _claim(feeToken);
    }

    /**
     * @dev Claim rewards for specific token
     * Allows account to claim specific token to save gas
     * @param token Token to claim rewards for
     */
    function claimRewards(IERC20 token) external distribute updateRewards(msg.sender, token) {
        require(token == tfusd || token == tru || token == feeToken, "Token not supported for rewards");
        _claim(token);
    }

    /**
     * @dev Claim TRU rewards, transfer in extraStakeAmount, and
     * stake both the rewards and the new amount.
     * Allows account to save more gas by avoiding out-and-back transfers of rewards
     */
    function claimRestake(uint256 extraStakeAmount) external distribute update(msg.sender) {
        uint256 amount = _claimWithoutTransfer(tru) + extraStakeAmount;
        _stakeWithoutTransfer(amount);
        if (extraStakeAmount &gt; 0) {
            tru.safeTransferFrom(msg.sender, address(this), extraStakeAmount);
        }
    }

    /**
     * @dev View to estimate the claimable reward for an account
     * @param account Account to get claimable reward for
     * @param token Token to get rewards for
     * @return claimable rewards for account
     */
    function claimable(address account, IERC20 token) external view returns (uint256) {
        FarmRewards storage rewards = farmRewards[token];
        // estimate pending reward from distributor
        uint256 pendingReward = token == tru ? distributor.nextDistribution() : 0;
        // calculate total rewards (including pending)
        uint256 newTotalFarmRewards = (rewardBalance(token) +
            (pendingReward &gt;= MIN_DISTRIBUTED_AMOUNT ? pendingReward : 0) +
            (rewards.totalClaimedRewards)) * PRECISION;
        // calculate block reward
        uint256 totalBlockReward = newTotalFarmRewards - rewards.totalFarmRewards;
        // calculate next cumulative reward per token
        uint256 nextCumulativeRewardPerToken = rewards.cumulativeRewardPerToken + (totalBlockReward / totalSupply);
        // return claimable reward for this account
        return
            rewards.claimableReward[account] +
            ((balanceOf[account] * (nextCumulativeRewardPerToken - (rewards.previousCumulatedRewardPerToken[account]))) / PRECISION);
    }

    /**
     * @dev max amount of stkTRU than can be unstaked after current cooldown period is over
     */
    function unstakable(address staker) public view returns (uint256) {
        uint256 stakerBalance = balanceOf[staker];

        if (unlockTime(staker) == type(uint256).max) {
            return stakerBalance;
        }

        if (receivedDuringCooldown[staker] &gt; stakerBalance) {
            return 0;
        }
        return stakerBalance - receivedDuringCooldown[staker];
    }

    /**
     * @dev Prior votes votes are calculated as priorVotes * stakedSupply / totalSupply
     * This dilutes voting power when TRU is liquidated
     * @param account Account to get current voting power for
     * @param blockNumber Block to get prior votes at
     * @return prior voting power for account and block
     */
    function getPriorVotes(address account, uint256 blockNumber) public view override returns (uint96) {
        uint96 votes = super.getPriorVotes(account, blockNumber);
        return safe96((stakeSupply * votes) / totalSupply, "StkTruToken: uint96 overflow");
    }

    function getPastVotes(address account, uint256 blockNumber) public view returns (uint96) {
        return super.getPriorVotes(account, blockNumber);
    }

    function getPastTotalSupply(uint256 blockNumber) public view returns (uint256) {
        require(blockNumber &lt; block.number, "ERC20Votes: block not yet mined");
        return _checkpointsLookup(_totalSupplyCheckpoints, blockNumber);
    }

    /**
     * @dev Current votes are calculated as votes * stakedSupply / totalSupply
     * This dilutes voting power when TRU is liquidated
     * @param account Account to get current voting power for
     * @return voting power for account
     */
    function getCurrentVotes(address account) public view override returns (uint96) {
        uint96 votes = super.getCurrentVotes(account);
        return safe96((stakeSupply * votes) / totalSupply, "StkTruToken: uint96 overflow");
    }

    function decimals() public pure override returns (uint8) {
        return 8;
    }

    function rounding() public pure returns (uint8) {
        return 8;
    }

    function name() public pure override returns (string memory) {
        return "Staked TrueFi";
    }

    function symbol() public pure override returns (string memory) {
        return "stkTRU";
    }

    function _transfer(
        address sender,
        address recipient,
        uint256 amount
    ) internal override distribute update(sender) {
        updateClaimableRewards(tru, recipient);
        updateClaimableRewards(tfusd, recipient);
        updateClaimableRewards(feeToken, recipient);
        // unlockTime returns MAX_UINT256 when there's no ongoing cooldown for the address
        if (unlockTime(recipient) != type(uint256).max) {
            receivedDuringCooldown[recipient] = receivedDuringCooldown[recipient] + amount;
        }
        if (unlockTime(sender) != type(uint256).max) {
            receivedDuringCooldown[sender] = receivedDuringCooldown[sender] - min(receivedDuringCooldown[sender], amount);
        }
        super._transfer(sender, recipient, amount);
    }

    function min(uint256 a, uint256 b) internal pure returns (uint256) {
        return a &lt; b ? a : b;
    }

    /**
     * @dev Internal claim function
     * Claim rewards for a specific ERC20 token
     * @param token Token to claim rewards for
     */
    function _claim(IERC20 token) internal {
        uint256 rewardToClaim = _claimWithoutTransfer(token);
        if (rewardToClaim &gt; 0) {
            token.safeTransfer(msg.sender, rewardToClaim);
        }
    }

    /**
     * @dev Internal claim function that returns the transfer value
     * Claim rewards for a specific ERC20 token to return in a uint256
     * @param token Token to claim rewards for
     */
    function _claimWithoutTransfer(IERC20 token) internal returns (uint256) {
        FarmRewards storage rewards = farmRewards[token];

        uint256 rewardToClaim = rewards.claimableReward[msg.sender];
        rewards.totalClaimedRewards = rewards.totalClaimedRewards + rewardToClaim;
        rewards.claimableReward[msg.sender] = 0;
        emit Claim(msg.sender, token, rewardToClaim);
        return rewardToClaim;
    }

    /**
     * @dev Internal stake of TRU for stkTRU from a uint256
     * Caller is responsible for ensuring amount is transferred from a valid source
     * @param amount Amount of TRU to stake for stkTRU
     */
    function _stakeWithoutTransfer(uint256 amount) internal {
        require(amount &gt; 0, "StkTruToken: Cannot stake 0");

        if (cooldowns[msg.sender] != 0 &amp;&amp; cooldowns[msg.sender] + cooldownTime + unstakePeriodDuration <span class="marker" id="mapping-6"></span><span class="token add" data-title="binary_expression/>=">&gt;=</span> block.timestamp) {
            cooldown();
        }

        uint256 amountToMint = stakeSupply == 0 ? amount : (amount * totalSupply) / stakeSupply;
        _mint(msg.sender, amountToMint);
        stakeSupply = stakeSupply + amount;
        emit Stake(msg.sender, amount);
    }

    /**
     * @dev Get reward balance of this contract for a token
     * @param token Token to get reward balance for
     * @return Reward balance for token
     */
    function rewardBalance(IERC20 token) internal view returns (uint256) {
        if (token == tru) {
            return token.balanceOf(address(this)) - stakeSupply;
        }
        if (token == tfusd) {
            return token.balanceOf(address(this)) - undistributedTfusdRewards;
        }
        if (token == feeToken) {
            return token.balanceOf(address(this));
        }
        return 0;
    }

    /**
     * @dev Check if any scheduled rewards should be distributed
     */
    function distributeScheduledRewards() internal {
        uint32 index = nextDistributionIndex;
        uint32 batchLimitIndex = index + SCHEDULED_REWARDS_BATCH_SIZE;
        uint32 end = batchLimitIndex &lt; scheduledRewards.length ? batchLimitIndex : uint32(scheduledRewards.length);
        uint256 _undistributedTfusdRewards = undistributedTfusdRewards;

        while (index &lt; end) {
            ScheduledTfUsdRewards storage rewards = scheduledRewards[sortedScheduledRewardIndices[index]];
            if (rewards.timestamp &gt;= block.timestamp) {
                break;
            }
            _undistributedTfusdRewards = _undistributedTfusdRewards - rewards.amount;
            index++;
        }

        undistributedTfusdRewards = _undistributedTfusdRewards;

        if (nextDistributionIndex != index) {
            nextDistributionIndex = index;
        }
    }

    /**
     * @dev Update rewards state for `token`
     */
    function updateTotalRewards(IERC20 token) internal {
        if (token == tfusd) {
            distributeScheduledRewards();
        }
        FarmRewards storage rewards = farmRewards[token];

        // calculate total rewards
        uint256 newTotalFarmRewards = (rewardBalance(token) + rewards.totalClaimedRewards) * PRECISION;
        if (newTotalFarmRewards == rewards.totalFarmRewards) {
            return;
        }
        // calculate block reward
        uint256 totalBlockReward = newTotalFarmRewards - rewards.totalFarmRewards;
        // update farm rewards
        rewards.totalFarmRewards = newTotalFarmRewards;
        // if there are stakers
        if (totalSupply &gt; 0) {
            rewards.cumulativeRewardPerToken = rewards.cumulativeRewardPerToken + totalBlockReward / totalSupply;
        }
    }

    /**
     * @dev Update claimable rewards for a token and account
     * @param token Token to update claimable rewards for
     * @param user Account to update claimable rewards for
     */
    function updateClaimableRewards(IERC20 token, address user) internal {
        FarmRewards storage rewards = farmRewards[token];

        // update claimable reward for sender
        if (balanceOf[user] &gt; 0) {
            rewards.claimableReward[user] =
                rewards.claimableReward[user] +
                (balanceOf[user] * (rewards.cumulativeRewardPerToken - rewards.previousCumulatedRewardPerToken[user])) /
                PRECISION;
        }

        // update previous cumulative for sender
        rewards.previousCumulatedRewardPerToken[user] = rewards.cumulativeRewardPerToken;
    }

    /**
     * @dev Find next distribution index given a timestamp
     * @param timestamp Timestamp to find next distribution index for
     */
    function findPositionForTimestamp(uint256 timestamp) internal view returns (uint32 i) {
        uint256 length = sortedScheduledRewardIndices.length;
        for (i = nextDistributionIndex; i &lt; length; i++) {
            if (scheduledRewards[sortedScheduledRewardIndices[i]].timestamp &gt; timestamp) {
                return i;
            }
        }
        return i;
    }

    /**
     * @dev internal function to insert distribution index in a sorted list
     * @param index Index to insert at
     * @param value Value at index
     */
    function insertAt(uint32 index, uint32 value) internal {
        sortedScheduledRewardIndices.push(0);
        for (uint32 j = uint32(sortedScheduledRewardIndices.length) - 1; j &gt; index; j--) {
            sortedScheduledRewardIndices[j] = sortedScheduledRewardIndices[j - 1];
        }
        sortedScheduledRewardIndices[index] = value;
    }

    function _writeTotalSupplyCheckpoint(function(uint256, uint256) view returns (uint256) op, uint256 delta)
        internal
        returns (uint256 oldWeight, uint256 newWeight)
    {
        uint256 checkpointsNumber = _totalSupplyCheckpoints.length;
        require(checkpointsNumber &gt; 0, "StakeTruToken: total supply checkpoints not initialized");
        Checkpoint storage lastCheckpoint = _totalSupplyCheckpoints[checkpointsNumber - 1];

        oldWeight = lastCheckpoint.votes;
        newWeight = op(oldWeight, delta);

        if (lastCheckpoint.fromBlock == block.number) {
            lastCheckpoint.votes = SafeCast.toUint96(newWeight);
        } else {
            _totalSupplyCheckpoints.push(
                Checkpoint({fromBlock: SafeCast.toUint32(block.number), votes: SafeCast.toUint96(newWeight)})
            );
        }
    }

    function _add(uint256 a, uint256 b) private pure returns (uint256) {
        return a + b;
    }

    function _subtract(uint256 a, uint256 b) private pure returns (uint256) {
        return a - b;
    }

    /**
     * @dev Lookup a value in a list of (sorted) checkpoints.
     */
    function _checkpointsLookup(Checkpoint[] storage checkpoints, uint256 blockNumber) internal view returns (uint256) {
        // We run a binary search to look for the earliest checkpoint taken after `blockNumber`.
        //
        // During the loop, the index of the wanted checkpoint remains in the range [low-1, high).
        // With each iteration, either `low` or `high` is moved towards the middle of the range to maintain the invariant.
        // - If the middle checkpoint is after `blockNumber`, we look in [low, mid)
        // - If the middle checkpoint is before or equal to `blockNumber`, we look in [mid+1, high)
        // Once we reach a single value (when low == high), we've found the right checkpoint at the index high-1, if not
        // out of bounds (in which case we're looking too far in the past and the result is 0).
        // Note that if the latest checkpoint available is exactly for `blockNumber`, we end up with an index that is
        // past the end of the array, so we technically don't find a checkpoint after `blockNumber`, but it works out
        // the same.
        uint256 high = checkpoints.length;
        uint256 low = 0;
        while (low &lt; high) {
            uint256 mid = Math.average(low, high);
            if (checkpoints[mid].fromBlock &gt; blockNumber) {
                high = mid;
            } else {
                low = mid + 1;
            }
        }

        return high == 0 ? 0 : checkpoints[high - 1].votes;
    }

    <span class="marker" id="mapping-7"></span><span class="token add" data-title="contract_body/function_definition">function matchVotesToBalance() external onlyOwner {
        address[7] memory accounts = [
            // corrupted voting power
            0xD68C599A549E8518b2E0daB9cD437C930ac2f12B,
            0x4b1A187d7e6D8f2Eb3AC46961DB3468fB824E991,
            // undelegated voting power
            0x57dCb790617D6b8fBe4cDBb3d9b14328A448904f,
            0xF80E102624Eb7A3925Cf807A870FbEf3C760d520,
            0xFe713259F66673076571DfDfbF62F77C138e41A5,
            0x4a88FB2A8A5b7B27ad9E8F7728492485744A1e3f,
            0x4DE8eDFFbDc8eC8b6b8399731D7a9340F90C7663
        ];

        for (uint256 i = 0; i &lt; accounts.length; i++) {
            _matchVotesToBalance(accounts[i]);
        }

        _matchVotesToBalanceAndDelegatorBalance();
    }</span>

    <span class="marker" id="mapping-8"></span><span class="token add" data-title="contract_body/function_definition">function _matchVotesToBalance(address account) internal {
        uint96 currentVotes = getCurrentVotes(account);
        uint96 balance = safe96(this.balanceOf(account), "StakeTruToken: balance exceeds 96 bits");
        address delegatee = delegates[account];
        if ((delegatee == account || delegatee == address(0)) &amp;&amp; currentVotes &lt; balance) {
            _writeCheckpoint(account, numCheckpoints[account], currentVotes, balance);
        }
    }</span>

    <span class="marker" id="mapping-9"></span><span class="token add" data-title="contract_body/function_definition">function _matchVotesToBalanceAndDelegatorBalance() <span class="marker" id="mapping-10"></span><span class="token add" data-title="function_definition/visibility">internal</span> <span class="marker" id="mapping-11"></span><span class="token add" data-title="function_definition/function_body">{
        <span class="marker" id="mapping-12"></span><span class="token add" data-title="function_body/variable_declaration_statement">address account = 0xe5D0Ef77AED07C302634dC370537126A2CD26590;</span>
        <span class="marker" id="mapping-13"></span><span class="token add" data-title="function_body/variable_declaration_statement">address delegator = 0xd2c3385f511575851e5bbCd87C59A26Da9Ff71F2;</span>

        <span class="marker" id="mapping-14"></span><span class="token add" data-title="function_body/variable_declaration_statement">uint96 accountBalance = safe96(this.balanceOf(account), "StakeTruToken: balance exceeds 96 bits");</span>
        <span class="marker" id="mapping-15"></span><span class="token add" data-title="function_body/variable_declaration_statement">uint96 delegatorBalance = safe96(this.balanceOf(delegator), "StakeTruToken: balance exceeds 96 bits");</span>

        <span class="marker" id="mapping-16"></span><span class="token add" data-title="function_body/variable_declaration_statement">uint96 currentVotes = getCurrentVotes(account);</span>
        <span class="marker" id="mapping-17"></span><span class="token add" data-title="function_body/variable_declaration_statement">uint96 totalBalance = accountBalance + delegatorBalance;</span>
        <span class="marker" id="mapping-18"></span><span class="token mv" id="move-dst-1" data-title="function_body/if_statement">if (<span class="marker" id="mapping-19"></span><span class="token add" data-title="if_statement/binary_expression"><span class="marker" id="mapping-20"></span><span class="token mv" id="move-dst-2" data-title="binary_expression/binary_expression">delegates[<span class="marker" id="mapping-21"></span><span class="token add" data-title="array_access/identifier">account</span>] == address(0)</span> &amp;&amp; <span class="marker" id="mapping-22"></span><span class="token add" data-title="binary_expression/binary_expression">currentVotes &lt; totalBalance</span></span>) {
            <span class="marker" id="mapping-23"></span><span class="token add" data-title="expression_statement/call_expression">_writeCheckpoint(account, numCheckpoints[account], currentVotes, totalBalance)</span>;
        }</span>
    }</span></span>
}
</pre></div></div></div></body></html>