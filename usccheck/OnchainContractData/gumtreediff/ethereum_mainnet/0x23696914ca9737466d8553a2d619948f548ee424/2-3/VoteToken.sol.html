<html lang="en"><head><meta charset="utf8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>GumTree</title><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css"><style type="text/css">/*
 * This file is part of GumTree.
 *
 * GumTree is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * GumTree is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with GumTree.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Copyright 2011-2015 Jean-Rémy Falleri <jr.falleri@gmail.com>
 * Copyright 2011-2015 Floréal Morandat <florealm@gmail.com>
 */

.add {
	border: 1px solid black;
	background-color: MediumSeaGreen;
}

.del {
	border: 1px solid black;
	background-color: IndianRed;
}

.mv {
	border: 1px solid black;
	background-color: Plum;
}

.upd {
	border: 1px solid black;
	background-color: DarkOrange;
	font-weight: bold;
}

.cupd {
	font-weight: normal;
	color: DimGray;
}

.selected {
	background-color: Gold;
}

.marker {
	margin: 0;
	padding: 0;
}

div {
	margin: 0px;
	padding: 0px;
}

.pre-scrollable {
	margin: 0px;
	padding: 0px;
	font-size: 10pt;
	color: black;
	max-height: 90vh;
	background-color: white;
	border: 1px solid black;
	font-family: "Hack, Inconsolata", "Consolas", "Liberation Sans Regular", "DejaVu Sans Mono", monospace;
}

.tooltip-inner {
    max-width: none;
}
</style><script type="text/javascript" src="https://code.jquery.com/jquery-3.4.1.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/js/bootstrap.bundle.min.js"></script><script type="text/javascript">/*
 * This file is part of GumTree.
 *
 * GumTree is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * GumTree is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with GumTree.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Copyright 2011-2015 Jean-Rémy Falleri <jr.falleri@gmail.com>
 * Copyright 2011-2015 Floréal Morandat <florealm@gmail.com>
 */

$(function(){
    let popoverTriggerList = [].slice.call(document.querySelectorAll('[data-bs-toggle="popover"]'))
    let popoverList = popoverTriggerList.map(function (popoverTriggerEl) {
      return new bootstrap.Popover(popoverTriggerEl)
    })

    $("body").keypress(function (event) {
        switch (event.which) {
            case 116:
                $('html, body').animate({scrollTop: 0}, 100);
                break;
            case 98:
                $("html, body").animate({ scrollTop: $(document).height() }, 100);
                break;
            case 113:
                window.location = "/quit";
                break;
            case 108:
                window.location = "/list";
                break;
        }
    });
});
</script><script type="text/javascript">/*
 * This file is part of GumTree.
 *
 * GumTree is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * GumTree is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with GumTree.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Copyright 2011-2015 Jean-Rémy Falleri <jr.falleri@gmail.com>
 * Copyright 2011-2015 Floréal Morandat <florealm@gmail.com>
 */

currentMapping = 0;

if (typeof String.prototype.startsWith != 'function') {
  String.prototype.startsWith = function (str){
    return this.slice(0, str.length) == str;
  };
}

function getMappedElement(eltId) {
	if (eltId.startsWith("move-src")) {
		return eltId.replace("src","dst");  	 	
  	}
  	else {
  		return eltId.replace("dst","src");
  	}
}

function nextMapping() {
	if (currentMapping == 0) {
		currentMapping = 1;
		return "#mapping-" + currentMapping.toString();
	} else {
		currentMapping++;
		
		if ($("#mapping-" + currentMapping.toString()).length > 0) {
			return "#mapping-" + currentMapping.toString();
		} else {
			currentMapping = 1;
			return "#mapping-" + currentMapping.toString();		
		}		
	}
}

function isSrc(eltId) {
	return eltId.startsWith("move-src");
}

$(function() {
    $("body").keypress(function (event) {
        switch(event.which) {
            case 110:
                const mapping = $(nextMapping());
                const pre = mapping.closest("pre");
                pre.animate({scrollTop: pre.scrollTop() + mapping.position().top - 200}, 100);
                break;
        }
    });

    // highlight
    $("span.mv.token, span.token.upd").click(function(event) {
        if ($(this).hasClass("selected")) {
            $("span.mv.token, span.token.upd").removeClass("selected");
        } else {
            $("span.mv.token, span.token.upd").removeClass("selected");
            const refElt = $("#" + getMappedElement($(this).attr("id")));
            $(this).addClass("selected");
            refElt.addClass("selected");
            const pre = refElt.closest("pre");
            console.log(pre);
            pre.animate({scrollTop: pre.scrollTop() + refElt.position().top - 200}, 100);
        }
        event.stopPropagation();
    });
    
    $("span.add.token, span.token.del").click(function(event) {
        $("span.mv.token, span.token.upd").removeClass("selected");
        event.stopPropagation();
    });

    // tooltip
    $("span.token").hover(
    	function (event) {
    		$(this).tooltip('show');
    		event.stopPropagation();
    	},
    	function (event) {
    		$(this).tooltip('hide');
    		event.stopPropagation();
    	}
    );
});
</script></head><body><div class="container-fluid"><div class="row"><div class="col"><div class="btn-toolbar justify-content-end"><div class="btn-group mr-2"><button class="btn btn-primary btn-sm" id="legend" data-bs-toggle="popover" data-bs-placement="bottom" data-bs-html="true" data-bs-content="<span class='del'>&nbsp;&nbsp;</span> deleted<br><span class='add'>&nbsp;&nbsp;</span> added<br><span class='mv'>&nbsp;&nbsp;</span> moved<br><span class='upd';>&nbsp;&nbsp;</span> updated<br>">Legend</button><button class="btn btn-primary btn-sm" id="shortcuts" data-bs-toggle="popover" data-bs-placement="bottom" data-bs-html="true" data-bs-content="<b>q</b> quit<br><b>l</b> list<br><b>n</b> next<br><b>t</b> top<br><b>b</b> bottom">Shortcuts</button></div><div class="btn-group"><a href="/list" class="btn btn-default btn-sm btn-primary">Back</a><a href="/quit" class="btn btn-default btn-sm btn-danger">Quit</a></div></div></div></div><div class="row"><div class="col-6"><h5>VoteToken.sol</h5><pre class="pre-scrollable">// SPDX-License-Identifier: MIT
// AND COPIED FROM https://github.com/compound-finance/compound-protocol/blob/c5fcc34222693ad5f547b14ed01ce719b5f4b000/contracts/Governance/Comp.sol
// Copyright 2020 Compound Labs, Inc.
// Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
// 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
// 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
// Ctrl+f for OLD to see all the modifications.

pragma solidity ^0.8.10;

import {ERC20} from "ERC20.sol";
import {IVoteToken} from "IVoteToken.sol";

/**
 * @title VoteToken
 * @notice Custom token which tracks voting power for governance
 * @dev This is an abstraction of a fork of the Compound governance contract
 * VoteToken is used by TRU and stkTRU to allow tracking voting power
 * Checkpoints are created every time state is changed which record voting power
 * Inherits standard ERC20 behavior
 */
abstract contract VoteToken is ERC20, IVoteToken {
    bytes32 public constant DOMAIN_TYPEHASH = keccak256("EIP712Domain(string name,uint256 chainId,address verifyingContract)");
    bytes32 public constant DELEGATION_TYPEHASH = keccak256("Delegation(address delegatee,uint256 nonce,uint256 expiry)");

    event DelegateChanged(address indexed delegator, address indexed fromDelegate, address indexed toDelegate);
    event DelegateVotesChanged(address indexed delegate, uint256 previousBalance, uint256 newBalance);

    function delegate(address delegatee) public override {
        return _delegate(msg.sender, delegatee);
    }

    /**
     * @dev Delegate votes using signature
     */
    function delegateBySig(
        address delegatee,
        uint256 nonce,
        uint256 expiry,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) public override {
        require(block.timestamp &lt;= expiry, "TrustToken::delegateBySig: signature expired");
        bytes32 domainSeparator = keccak256(abi.encode(DOMAIN_TYPEHASH, keccak256(bytes(name())), block.chainid, address(this)));
        bytes32 structHash = keccak256(abi.encode(DELEGATION_TYPEHASH, delegatee, nonce, expiry));
        bytes32 digest = keccak256(abi.encodePacked("\x19\x01", domainSeparator, structHash));
        address signatory = ecrecover(digest, v, r, s);
        require(signatory != address(0), "TrustToken::delegateBySig: invalid signature");
        require(nonce == nonces[signatory]++, "TrustToken::delegateBySig: invalid nonce");
        return _delegate(signatory, delegatee);
    }

    /**
     * @dev Get current voting power for an account
     * @param account Account to get voting power for
     * @return Voting power for an account
     */
    function getCurrentVotes(address account) public view virtual override returns (uint96) {
        uint32 nCheckpoints = numCheckpoints[account];
        return nCheckpoints &gt; 0 ? checkpoints[account][nCheckpoints - 1].votes : 0;
    }

    /**
     * @dev Get voting power at a specific block for an account
     * @param account Account to get voting power for
     * @param blockNumber Block to get voting power at
     * @return Voting power for an account at specific block
     */
    function getPriorVotes(address account, uint256 blockNumber) public view virtual override returns (uint96) {
        require(blockNumber &lt; block.number, "TrustToken::getPriorVotes: not yet determined");

        uint32 checkpointsNumber = numCheckpoints[account];
        if (checkpointsNumber == 0) {
            return 0;
        }

        mapping(uint32 =&gt; Checkpoint) storage userCheckpoints = checkpoints[account];

        // First check most recent balance
        if (userCheckpoints[checkpointsNumber - 1].fromBlock &lt;= blockNumber) {
            return userCheckpoints[checkpointsNumber - 1].votes;
        }

        // Next check implicit zero balance
        if (userCheckpoints[0].fromBlock &gt; blockNumber) {
            return 0;
        }

        uint32 lower = 0;
        uint32 upper = checkpointsNumber - 1;
        while (upper &gt; lower) {
            uint32 center = upper - (upper - lower) / 2; // ceil, avoiding overflow
            Checkpoint memory checkpoint = userCheckpoints[center];
            if (checkpoint.fromBlock == blockNumber) {
                return checkpoint.votes;
            } else if (checkpoint.fromBlock &lt; blockNumber) {
                lower = center;
            } else {
                upper = center - 1;
            }
        }
        return userCheckpoints[lower].votes;
    }

    /**
     * @dev Internal function to delegate voting power to an account
     * @param delegator Account to delegate votes from
     * @param delegatee Account to delegate votes to
     */
    function _delegate(address delegator, address delegatee) internal {
        address currentDelegate = <span class="marker" id="mapping-1"></span><span class="token del" data-title="variable_declaration_statement/array_access">delegates[delegator]</span>;
        <span class="marker" id="mapping-2"></span><span class="token del" data-title="function_body/comment">// OLD: uint96 delegatorBalance = balanceOf(delegator);</span>
        uint96 delegatorBalance = safe96(_balanceOf(delegator), "StkTruToken: uint96 overflow");
        delegates[delegator] = delegatee;

        emit DelegateChanged(delegator, currentDelegate, delegatee);

        _moveDelegates(currentDelegate, delegatee, delegatorBalance);
    }

    function _balanceOf(address account) internal view virtual returns (uint256) {
        return balanceOf[account];
    }

    function _transfer(
        address _from,
        address _to,
        uint256 _value
    ) internal virtual override {
        super._transfer(_from, _to, _value);
        _moveDelegates(<span class="marker" id="mapping-3"></span><span class="token del" data-title="call_expression/call_argument">delegates[_from]</span>, <span class="marker" id="mapping-4"></span><span class="token del" data-title="call_expression/call_argument">delegates[_to]</span>, safe96(_value, "StkTruToken: uint96 overflow"));
    }

    <span class="marker" id="mapping-5"></span><span class="token mv" id="move-src-1" data-title="contract_body/function_definition">function <span class="marker" id="mapping-6"></span><span class="token upd" id="move-src-2" data-title="function_definition/identifier"><span class="cupd">_</span>mint</span>(address account, uint256 amount) internal virtual override {
        <span class="marker" id="mapping-7"></span><span class="token mv" id="move-src-3" data-title="function_body/expression_statement">super._mint(account, amount);</span>
        _moveDelegates(<span class="marker" id="mapping-8"></span><span class="token mv" id="move-src-4" data-title="call_expression/call_argument">address(0)</span><span class="marker" id="mapping-9"></span><span class="token mv" id="move-src-5" data-title="call_expression/,">,</span> <span class="marker" id="mapping-10"></span><span class="token mv" id="move-src-6" data-title="call_argument/array_access">delegates[account]</span>, safe96(amount, "StkTruToken: uint96 overflow"));
    }</span>

    function <span class="marker" id="mapping-11"></span><span class="token upd" id="move-src-7" data-title="function_definition/identifier"><span class="cupd">_</span>burn</span>(address account, uint256 amount) internal virtual override {
        <span class="marker" id="mapping-12"></span><span class="token mv" id="move-src-8" data-title="function_body/expression_statement">super._burn(account, amount);</span>
        _moveDelegates(<span class="marker" id="mapping-13"></span><span class="token mv" id="move-src-9" data-title="call_expression/call_argument"><span class="marker" id="mapping-14"></span><span class="token del" data-title="call_argument/array_access">delegates[account]</span></span><span class="marker" id="mapping-15"></span><span class="token mv" id="move-src-10" data-title="call_expression/,">,</span> address(0), safe96(amount, "StkTruToken: uint96 overflow"));
    }

    /**
     * @dev internal function to move delegates between accounts
     */
    function _moveDelegates(
        address source,
        address destination,
        uint96 amount
    ) internal {
        if (source != destination &amp;&amp; amount &gt; 0) {
            if (source != address(0)) {
                uint32 sourceCheckpointsNumber = numCheckpoints[source];
                uint96 sourceOldVotes = sourceCheckpointsNumber &gt; 0 ? checkpoints[source][sourceCheckpointsNumber - 1].votes : 0;
                uint96 sourceNewVotes = sourceOldVotes - amount;
                _writeCheckpoint(source, sourceCheckpointsNumber, sourceOldVotes, sourceNewVotes);
            }

            if (destination != address(0)) {
                uint32 destinationCheckpointsNumber = numCheckpoints[destination];
                uint96 destinationOldVotes = destinationCheckpointsNumber &gt; 0
                    ? checkpoints[destination][destinationCheckpointsNumber - 1].votes
                    : 0;
                uint96 destinationNewVotes = destinationOldVotes + amount;
                _writeCheckpoint(destination, destinationCheckpointsNumber, destinationOldVotes, destinationNewVotes);
            }
        }
    }

    /**
     * @dev internal function to write a checkpoint for voting power
     */
    function _writeCheckpoint(
        address delegatee,
        uint32 nCheckpoints,
        uint96 oldVotes,
        uint96 newVotes
    ) internal {
        uint32 blockNumber = safe32(block.number, "TrustToken::_writeCheckpoint: block number exceeds 32 bits");

        if (nCheckpoints &gt; 0 &amp;&amp; checkpoints[delegatee][nCheckpoints - 1].fromBlock == blockNumber) {
            checkpoints[delegatee][nCheckpoints - 1].votes = newVotes;
        } else {
            checkpoints[delegatee][nCheckpoints] = Checkpoint(blockNumber, newVotes);
            numCheckpoints[delegatee] = nCheckpoints + 1;
        }

        emit DelegateVotesChanged(delegatee, oldVotes, newVotes);
    }

    /**
     * @dev internal function to convert from uint256 to uint32
     */
    function safe32(uint256 n, string memory errorMessage) internal pure returns (uint32) {
        require(n &lt; 2**32, errorMessage);
        return uint32(n);
    }

    /**
     * @dev internal function to convert from uint256 to uint96
     */
    function safe96(uint256 n, string memory errorMessage) internal pure returns (uint96) {
        require(n &lt; 2**96, errorMessage);
        return uint96(n);
    }
}
</pre></div><div class="col-6"><h5>VoteToken.sol</h5><pre class="pre-scrollable">// SPDX-License-Identifier: MIT
// AND COPIED FROM https://github.com/compound-finance/compound-protocol/blob/c5fcc34222693ad5f547b14ed01ce719b5f4b000/contracts/Governance/Comp.sol
// Copyright 2020 Compound Labs, Inc.
// Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
// 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
// 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
// Ctrl+f for OLD to see all the modifications.

pragma solidity ^0.8.10;

import {ERC20} from "ERC20.sol";
import {IVoteToken} from "IVoteToken.sol";

/**
 * @title VoteToken
 * @notice Custom token which tracks voting power for governance
 * @dev This is an abstraction of a fork of the Compound governance contract
 * VoteToken is used by TRU and stkTRU to allow tracking voting power
 * Checkpoints are created every time state is changed which record voting power
 * Inherits standard ERC20 behavior
 */
abstract contract VoteToken is ERC20, IVoteToken {
    bytes32 public constant DOMAIN_TYPEHASH = keccak256("EIP712Domain(string name,uint256 chainId,address verifyingContract)");
    bytes32 public constant DELEGATION_TYPEHASH = keccak256("Delegation(address delegatee,uint256 nonce,uint256 expiry)");

    event DelegateChanged(address indexed delegator, address indexed fromDelegate, address indexed toDelegate);
    event DelegateVotesChanged(address indexed delegate, uint256 previousBalance, uint256 newBalance);

    function delegate(address delegatee) public override {
        return _delegate(msg.sender, delegatee);
    }

    /**
     * @dev Delegate votes using signature
     */
    function delegateBySig(
        address delegatee,
        uint256 nonce,
        uint256 expiry,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) public override {
        require(block.timestamp &lt;= expiry, "TrustToken::delegateBySig: signature expired");
        bytes32 domainSeparator = keccak256(abi.encode(DOMAIN_TYPEHASH, keccak256(bytes(name())), block.chainid, address(this)));
        bytes32 structHash = keccak256(abi.encode(DELEGATION_TYPEHASH, delegatee, nonce, expiry));
        bytes32 digest = keccak256(abi.encodePacked("\x19\x01", domainSeparator, structHash));
        address signatory = ecrecover(digest, v, r, s);
        require(signatory != address(0), "TrustToken::delegateBySig: invalid signature");
        require(nonce == nonces[signatory]++, "TrustToken::delegateBySig: invalid nonce");
        return _delegate(signatory, delegatee);
    }

    /**
     * @dev Get current voting power for an account
     * @param account Account to get voting power for
     * @return Voting power for an account
     */
    function getCurrentVotes(address account) public view virtual override returns (uint96) {
        uint32 nCheckpoints = numCheckpoints[account];
        return nCheckpoints &gt; 0 ? checkpoints[account][nCheckpoints - 1].votes : 0;
    }

    <span class="marker" id="mapping-16"></span><span class="token add" data-title="contract_body/function_definition">function getDelegate(<span class="marker" id="mapping-17"></span><span class="token add" data-title="function_definition/parameter">address account</span>) <span class="marker" id="mapping-18"></span><span class="token add" data-title="function_definition/visibility">public</span> <span class="marker" id="mapping-19"></span><span class="token add" data-title="function_definition/state_mutability">view</span> <span class="marker" id="mapping-20"></span><span class="token add" data-title="function_definition/return_type_definition">returns (address)</span> <span class="marker" id="mapping-21"></span><span class="token add" data-title="function_definition/function_body">{
        <span class="marker" id="mapping-22"></span><span class="token add" data-title="function_body/return_statement">return <span class="marker" id="mapping-23"></span><span class="token add" data-title="return_statement/array_access"><span class="marker" id="mapping-24"></span><span class="token add" data-title="array_access/ternary_expression"><span class="marker" id="mapping-25"></span><span class="token add" data-title="ternary_expression/binary_expression"><span class="marker" id="mapping-26"></span><span class="token mv" id="move-dst-6" data-title="binary_expression/array_access">delegates[account]</span> == <span class="marker" id="mapping-27"></span><span class="token add" data-title="binary_expression/type_cast_expression">address(0)</span></span> ? account : delegates</span>[account]</span>;</span>
    }</span></span>

    /**
     * @dev Get voting power at a specific block for an account
     * @param account Account to get voting power for
     * @param blockNumber Block to get voting power at
     * @return Voting power for an account at specific block
     */
    function getPriorVotes(address account, uint256 blockNumber) public view virtual override returns (uint96) {
        require(blockNumber &lt; block.number, "TrustToken::getPriorVotes: not yet determined");

        uint32 checkpointsNumber = numCheckpoints[account];
        if (checkpointsNumber == 0) {
            return 0;
        }

        mapping(uint32 =&gt; Checkpoint) storage userCheckpoints = checkpoints[account];

        // First check most recent balance
        if (userCheckpoints[checkpointsNumber - 1].fromBlock &lt;= blockNumber) {
            return userCheckpoints[checkpointsNumber - 1].votes;
        }

        // Next check implicit zero balance
        if (userCheckpoints[0].fromBlock &gt; blockNumber) {
            return 0;
        }

        uint32 lower = 0;
        uint32 upper = checkpointsNumber - 1;
        while (upper &gt; lower) {
            uint32 center = upper - (upper - lower) / 2; // ceil, avoiding overflow
            Checkpoint memory checkpoint = userCheckpoints[center];
            if (checkpoint.fromBlock == blockNumber) {
                return checkpoint.votes;
            } else if (checkpoint.fromBlock &lt; blockNumber) {
                lower = center;
            } else {
                upper = center - 1;
            }
        }
        return userCheckpoints[lower].votes;
    }

    /**
     * @dev Internal function to delegate voting power to an account
     * @param delegator Account to delegate votes from
     * @param delegatee Account to delegate votes to
     */
    function _delegate(address delegator, address delegatee) internal {
        <span class="marker" id="mapping-28"></span><span class="token add" data-title="function_body/expression_statement">require(delegatee != address(0), "StkTruToken: cannot delegate to AddressZero");</span>
        address currentDelegate = <span class="marker" id="mapping-29"></span><span class="token add" data-title="variable_declaration_statement/call_expression">getDelegate(delegator)</span>;

        uint96 delegatorBalance = safe96(_balanceOf(delegator), "StkTruToken: uint96 overflow");
        delegates[delegator] = delegatee;

        emit DelegateChanged(delegator, currentDelegate, delegatee);

        _moveDelegates(currentDelegate, delegatee, delegatorBalance);
    }

    function _balanceOf(address account) internal view virtual returns (uint256) {
        return balanceOf[account];
    }

    function _transfer(
        address _from,
        address _to,
        uint256 _value
    ) internal virtual override {
        super._transfer(_from, _to, _value);
        _moveDelegates(<span class="marker" id="mapping-30"></span><span class="token add" data-title="call_expression/call_argument">getDelegate(_from)</span>, <span class="marker" id="mapping-31"></span><span class="token add" data-title="call_expression/call_argument">getDelegate(_to)</span>, safe96(_value, "StkTruToken: uint96 overflow"));
    }

    function <span class="marker" id="mapping-32"></span><span class="token upd" id="move-dst-7" data-title="function_definition/identifier"><span class="cupd">_</span>mint</span>(address account, uint256 amount) internal virtual override {
        <span class="marker" id="mapping-33"></span><span class="token mv" id="move-dst-3" data-title="function_body/expression_statement">super._mint(account, amount);</span>
        _moveDelegates(address(0)<span class="marker" id="mapping-34"></span><span class="token mv" id="move-dst-10" data-title="call_expression/,">,</span> <span class="marker" id="mapping-35"></span><span class="token mv" id="move-dst-9" data-title="call_expression/call_argument"><span class="marker" id="mapping-36"></span><span class="token add" data-title="call_argument/call_expression">getDelegate(account)</span></span>, safe96(amount, "StkTruToken: uint96 overflow"));
    }

    <span class="marker" id="mapping-37"></span><span class="token mv" id="move-dst-1" data-title="contract_body/function_definition">function <span class="marker" id="mapping-38"></span><span class="token upd" id="move-dst-2" data-title="function_definition/identifier"><span class="cupd">_</span>burn</span>(address account, uint256 amount) internal virtual override {
        <span class="marker" id="mapping-39"></span><span class="token mv" id="move-dst-8" data-title="function_body/expression_statement">super._burn(account, amount);</span>
        _moveDelegates(<span class="marker" id="mapping-40"></span><span class="token add" data-title="call_argument/call_expression">getDelegate(account)</span><span class="marker" id="mapping-41"></span><span class="token mv" id="move-dst-5" data-title="call_expression/,">,</span> <span class="marker" id="mapping-42"></span><span class="token mv" id="move-dst-4" data-title="call_expression/call_argument">address(0)</span>, safe96(amount, "StkTruToken: uint96 overflow"));
    }</span>

    /**
     * @dev internal function to move delegates between accounts
     */
    function _moveDelegates(
        address source,
        address destination,
        uint96 amount
    ) internal {
        if (source != destination &amp;&amp; amount &gt; 0) {
            if (source != address(0)) {
                uint32 sourceCheckpointsNumber = numCheckpoints[source];
                uint96 sourceOldVotes = sourceCheckpointsNumber &gt; 0 ? checkpoints[source][sourceCheckpointsNumber - 1].votes : 0;
                uint96 sourceNewVotes = sourceOldVotes - amount;
                _writeCheckpoint(source, sourceCheckpointsNumber, sourceOldVotes, sourceNewVotes);
            }

            if (destination != address(0)) {
                uint32 destinationCheckpointsNumber = numCheckpoints[destination];
                uint96 destinationOldVotes = destinationCheckpointsNumber &gt; 0
                    ? checkpoints[destination][destinationCheckpointsNumber - 1].votes
                    : 0;
                uint96 destinationNewVotes = destinationOldVotes + amount;
                _writeCheckpoint(destination, destinationCheckpointsNumber, destinationOldVotes, destinationNewVotes);
            }
        }
    }

    /**
     * @dev internal function to write a checkpoint for voting power
     */
    function _writeCheckpoint(
        address delegatee,
        uint32 nCheckpoints,
        uint96 oldVotes,
        uint96 newVotes
    ) internal {
        uint32 blockNumber = safe32(block.number, "TrustToken::_writeCheckpoint: block number exceeds 32 bits");

        if (nCheckpoints &gt; 0 &amp;&amp; checkpoints[delegatee][nCheckpoints - 1].fromBlock == blockNumber) {
            checkpoints[delegatee][nCheckpoints - 1].votes = newVotes;
        } else {
            checkpoints[delegatee][nCheckpoints] = Checkpoint(blockNumber, newVotes);
            numCheckpoints[delegatee] = nCheckpoints + 1;
        }

        emit DelegateVotesChanged(delegatee, oldVotes, newVotes);
    }

    /**
     * @dev internal function to convert from uint256 to uint32
     */
    function safe32(uint256 n, string memory errorMessage) internal pure returns (uint32) {
        require(n &lt; 2**32, errorMessage);
        return uint32(n);
    }

    /**
     * @dev internal function to convert from uint256 to uint96
     */
    function safe96(uint256 n, string memory errorMessage) internal pure returns (uint96) {
        require(n &lt; 2**96, errorMessage);
        return uint96(n);
    }
}
</pre></div></div></div></body></html>