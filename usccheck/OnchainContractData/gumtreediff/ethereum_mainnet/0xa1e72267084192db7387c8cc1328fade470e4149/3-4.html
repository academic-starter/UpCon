<html lang="en"><head><meta charset="utf8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>GumTree</title><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css"><style type="text/css">/*
 * This file is part of GumTree.
 *
 * GumTree is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * GumTree is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with GumTree.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Copyright 2011-2015 Jean-Rémy Falleri <jr.falleri@gmail.com>
 * Copyright 2011-2015 Floréal Morandat <florealm@gmail.com>
 */

.add {
	border: 1px solid black;
	background-color: MediumSeaGreen;
}

.del {
	border: 1px solid black;
	background-color: IndianRed;
}

.mv {
	border: 1px solid black;
	background-color: Plum;
}

.upd {
	border: 1px solid black;
	background-color: DarkOrange;
	font-weight: bold;
}

.cupd {
	font-weight: normal;
	color: DimGray;
}

.selected {
	background-color: Gold;
}

.marker {
	margin: 0;
	padding: 0;
}

div {
	margin: 0px;
	padding: 0px;
}

.pre-scrollable {
	margin: 0px;
	padding: 0px;
	font-size: 10pt;
	color: black;
	max-height: 90vh;
	background-color: white;
	border: 1px solid black;
	font-family: "Hack, Inconsolata", "Consolas", "Liberation Sans Regular", "DejaVu Sans Mono", monospace;
}

.tooltip-inner {
    max-width: none;
}
</style><script type="text/javascript" src="https://code.jquery.com/jquery-3.4.1.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/js/bootstrap.bundle.min.js"></script><script type="text/javascript">/*
 * This file is part of GumTree.
 *
 * GumTree is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * GumTree is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with GumTree.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Copyright 2011-2015 Jean-Rémy Falleri <jr.falleri@gmail.com>
 * Copyright 2011-2015 Floréal Morandat <florealm@gmail.com>
 */

$(function(){
    let popoverTriggerList = [].slice.call(document.querySelectorAll('[data-bs-toggle="popover"]'))
    let popoverList = popoverTriggerList.map(function (popoverTriggerEl) {
      return new bootstrap.Popover(popoverTriggerEl)
    })

    $("body").keypress(function (event) {
        switch (event.which) {
            case 116:
                $('html, body').animate({scrollTop: 0}, 100);
                break;
            case 98:
                $("html, body").animate({ scrollTop: $(document).height() }, 100);
                break;
            case 113:
                window.location = "/quit";
                break;
            case 108:
                window.location = "/list";
                break;
        }
    });
});
</script><script type="text/javascript">/*
 * This file is part of GumTree.
 *
 * GumTree is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * GumTree is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with GumTree.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Copyright 2011-2015 Jean-Rémy Falleri <jr.falleri@gmail.com>
 * Copyright 2011-2015 Floréal Morandat <florealm@gmail.com>
 */

currentMapping = 0;

if (typeof String.prototype.startsWith != 'function') {
  String.prototype.startsWith = function (str){
    return this.slice(0, str.length) == str;
  };
}

function getMappedElement(eltId) {
	if (eltId.startsWith("move-src")) {
		return eltId.replace("src","dst");  	 	
  	}
  	else {
  		return eltId.replace("dst","src");
  	}
}

function nextMapping() {
	if (currentMapping == 0) {
		currentMapping = 1;
		return "#mapping-" + currentMapping.toString();
	} else {
		currentMapping++;
		
		if ($("#mapping-" + currentMapping.toString()).length > 0) {
			return "#mapping-" + currentMapping.toString();
		} else {
			currentMapping = 1;
			return "#mapping-" + currentMapping.toString();		
		}		
	}
}

function isSrc(eltId) {
	return eltId.startsWith("move-src");
}

$(function() {
    $("body").keypress(function (event) {
        switch(event.which) {
            case 110:
                const mapping = $(nextMapping());
                const pre = mapping.closest("pre");
                pre.animate({scrollTop: pre.scrollTop() + mapping.position().top - 200}, 100);
                break;
        }
    });

    // highlight
    $("span.mv.token, span.token.upd").click(function(event) {
        if ($(this).hasClass("selected")) {
            $("span.mv.token, span.token.upd").removeClass("selected");
        } else {
            $("span.mv.token, span.token.upd").removeClass("selected");
            const refElt = $("#" + getMappedElement($(this).attr("id")));
            $(this).addClass("selected");
            refElt.addClass("selected");
            const pre = refElt.closest("pre");
            console.log(pre);
            pre.animate({scrollTop: pre.scrollTop() + refElt.position().top - 200}, 100);
        }
        event.stopPropagation();
    });
    
    $("span.add.token, span.token.del").click(function(event) {
        $("span.mv.token, span.token.upd").removeClass("selected");
        event.stopPropagation();
    });

    // tooltip
    $("span.token").hover(
    	function (event) {
    		$(this).tooltip('show');
    		event.stopPropagation();
    	},
    	function (event) {
    		$(this).tooltip('hide');
    		event.stopPropagation();
    	}
    );
});
</script></head><body><div class="container-fluid"><div class="row"><div class="col"><div class="btn-toolbar justify-content-end"><div class="btn-group mr-2"><button class="btn btn-primary btn-sm" id="legend" data-bs-toggle="popover" data-bs-placement="bottom" data-bs-html="true" data-bs-content="<span class='del'>&nbsp;&nbsp;</span> deleted<br><span class='add'>&nbsp;&nbsp;</span> added<br><span class='mv'>&nbsp;&nbsp;</span> moved<br><span class='upd';>&nbsp;&nbsp;</span> updated<br>">Legend</button><button class="btn btn-primary btn-sm" id="shortcuts" data-bs-toggle="popover" data-bs-placement="bottom" data-bs-html="true" data-bs-content="<b>q</b> quit<br><b>l</b> list<br><b>n</b> next<br><b>t</b> top<br><b>b</b> bottom">Shortcuts</button></div><div class="btn-group"><a href="/list" class="btn btn-default btn-sm btn-primary">Back</a><a href="/quit" class="btn btn-default btn-sm btn-danger">Quit</a></div></div></div></div><div class="row"><div class="col-6"><h5>0x3fe853e7e5f78c00405fc80daf7f7bade2e53e46.etherscan.io-TrueFiPool.sol</h5><pre class="pre-scrollable">/*
    .'''''''''''..     ..''''''''''''''''..       ..'''''''''''''''..
    .;;;;;;;;;;;'.   .';;;;;;;;;;;;;;;;;;,.     .,;;;;;;;;;;;;;;;;;,.
    .;;;;;;;;;;,.   .,;;;;;;;;;;;;;;;;;;;,.    .,;;;;;;;;;;;;;;;;;;,.
    .;;;;;;;;;,.   .,;;;;;;;;;;;;;;;;;;;;,.   .;;;;;;;;;;;;;;;;;;;;,.
    ';;;;;;;;'.  .';;;;;;;;;;;;;;;;;;;;;;,. .';;;;;;;;;;;;;;;;;;;;;,.
    ';;;;;,..   .';;;;;;;;;;;;;;;;;;;;;;;,..';;;;;;;;;;;;;;;;;;;;;;,.
    ......     .';;;;;;;;;;;;;,'''''''''''.,;;;;;;;;;;;;;,'''''''''..
              .,;;;;;;;;;;;;;.           .,;;;;;;;;;;;;;.
             .,;;;;;;;;;;;;,.           .,;;;;;;;;;;;;,.
            .,;;;;;;;;;;;;,.           .,;;;;;;;;;;;;,.
           .,;;;;;;;;;;;;,.           .;;;;;;;;;;;;;,.     .....
          .;;;;;;;;;;;;;'.         ..';;;;;;;;;;;;;'.    .',;;;;,'.
        .';;;;;;;;;;;;;'.         .';;;;;;;;;;;;;;'.   .';;;;;;;;;;.
       .';;;;;;;;;;;;;'.         .';;;;;;;;;;;;;;'.    .;;;;;;;;;;;,.
      .,;;;;;;;;;;;;;'...........,;;;;;;;;;;;;;;.      .;;;;;;;;;;;,.
     .,;;;;;;;;;;;;,..,;;;;;;;;;;;;;;;;;;;;;;;,.       ..;;;;;;;;;,.
    .,;;;;;;;;;;;;,. .,;;;;;;;;;;;;;;;;;;;;;;,.          .',;;;,,..
   .,;;;;;;;;;;;;,.  .,;;;;;;;;;;;;;;;;;;;;;,.              ....
    ..',;;;;;;;;,.   .,;;;;;;;;;;;;;;;;;;;;,.
       ..',;;;;'.    .,;;;;;;;;;;;;;;;;;;;'.
          ...'..     .';;;;;;;;;;;;;;,,,'.
                       ...............
*/

// Dependency file: @openzeppelin/contracts/token/ERC20/IERC20.sol

// SPDX-License-Identifier: MIT

// pragma solidity ^0.6.0;

/**
 * @dev Interface of the ERC20 standard as defined in the EIP.
 */
interface IERC20 {
    /**
     * @dev Returns the amount of tokens in existence.
     */
    function totalSupply() external view returns (uint256);

    /**
     * @dev Returns the amount of tokens owned by `account`.
     */
    function balanceOf(address account) external view returns (uint256);

    /**
     * @dev Moves `amount` tokens from the caller's account to `recipient`.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * Emits a {Transfer} event.
     */
    function transfer(address recipient, uint256 amount) external returns (bool);

    /**
     * @dev Returns the remaining number of tokens that `spender` will be
     * allowed to spend on behalf of `owner` through {transferFrom}. This is
     * zero by default.
     *
     * This value changes when {approve} or {transferFrom} are called.
     */
    function allowance(address owner, address spender) external view returns (uint256);

    /**
     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * // importANT: Beware that changing an allowance with this method brings the risk
     * that someone may use both the old and the new allowance by unfortunate
     * transaction ordering. One possible solution to mitigate this race
     * condition is to first reduce the spender's allowance to 0 and set the
     * desired value afterwards:
     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
     *
     * Emits an {Approval} event.
     */
    function approve(address spender, uint256 amount) external returns (bool);

    /**
     * @dev Moves `amount` tokens from `sender` to `recipient` using the
     * allowance mechanism. `amount` is then deducted from the caller's
     * allowance.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * Emits a {Transfer} event.
     */
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);

    /**
     * @dev Emitted when `value` tokens are moved from one account (`from`) to
     * another (`to`).
     *
     * Note that `value` may be zero.
     */
    event Transfer(address indexed from, address indexed to, uint256 value);

    /**
     * @dev Emitted when the allowance of a `spender` for an `owner` is set by
     * a call to {approve}. `value` is the new allowance.
     */
    event Approval(address indexed owner, address indexed spender, uint256 value);
}


// Dependency file: @openzeppelin/contracts/utils/ReentrancyGuard.sol


// pragma solidity ^0.6.0;

/**
 * @dev Contract module that helps prevent reentrant calls to a function.
 *
 * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier
 * available, which can be applied to functions to make sure there are no nested
 * (reentrant) calls to them.
 *
 * Note that because there is a single `nonReentrant` guard, functions marked as
 * `nonReentrant` may not call one another. This can be worked around by making
 * those functions `private`, and then adding `external` `nonReentrant` entry
 * points to them.
 *
 * TIP: If you would like to learn more about reentrancy and alternative ways
 * to protect against it, check out our blog post
 * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].
 */
contract ReentrancyGuard {
    // Booleans are more expensive than uint256 or any type that takes up a full
    // word because each write operation emits an extra SLOAD to first read the
    // slot's contents, replace the bits taken up by the boolean, and then write
    // back. This is the compiler's defense against contract upgrades and
    // pointer aliasing, and it cannot be disabled.

    // The values being non-zero value makes deployment a bit more expensive,
    // but in exchange the refund on every call to nonReentrant will be lower in
    // amount. Since refunds are capped to a percentage of the total
    // transaction's gas, it is best to keep them low in cases like this one, to
    // increase the likelihood of the full refund coming into effect.
    uint256 private constant _NOT_ENTERED = 1;
    uint256 private constant _ENTERED = 2;

    uint256 private _status;

    constructor () internal {
        _status = _NOT_ENTERED;
    }

    /**
     * @dev Prevents a contract from calling itself, directly or indirectly.
     * Calling a `nonReentrant` function from another `nonReentrant`
     * function is not supported. It is possible to prevent this from happening
     * by making the `nonReentrant` function external, and make it call a
     * `private` function that does the actual work.
     */
    modifier nonReentrant() {
        // On the first call to nonReentrant, _notEntered will be true
        require(_status != _ENTERED, "ReentrancyGuard: reentrant call");

        // Any calls to nonReentrant after this point will fail
        _status = _ENTERED;

        _;

        // By storing the original value once again, a refund is triggered (see
        // https://eips.ethereum.org/EIPS/eip-2200)
        _status = _NOT_ENTERED;
    }
}


// Dependency file: @openzeppelin/contracts/math/SafeMath.sol


// pragma solidity ^0.6.0;

/**
 * @dev Wrappers over Solidity's arithmetic operations with added overflow
 * checks.
 *
 * Arithmetic operations in Solidity wrap on overflow. This can easily result
 * in bugs, because programmers usually assume that an overflow raises an
 * error, which is the standard behavior in high level programming languages.
 * `SafeMath` restores this intuition by reverting the transaction when an
 * operation overflows.
 *
 * Using this library instead of the unchecked operations eliminates an entire
 * class of bugs, so it's recommended to use it always.
 */
library SafeMath {
    /**
     * @dev Returns the addition of two unsigned integers, reverting on
     * overflow.
     *
     * Counterpart to Solidity's `+` operator.
     *
     * Requirements:
     *
     * - Addition cannot overflow.
     */
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c &gt;= a, "SafeMath: addition overflow");

        return c;
    }

    /**
     * @dev Returns the subtraction of two unsigned integers, reverting on
     * overflow (when the result is negative).
     *
     * Counterpart to Solidity's `-` operator.
     *
     * Requirements:
     *
     * - Subtraction cannot overflow.
     */
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        return sub(a, b, "SafeMath: subtraction overflow");
    }

    /**
     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on
     * overflow (when the result is negative).
     *
     * Counterpart to Solidity's `-` operator.
     *
     * Requirements:
     *
     * - Subtraction cannot overflow.
     */
    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
        require(b &lt;= a, errorMessage);
        uint256 c = a - b;

        return c;
    }

    /**
     * @dev Returns the multiplication of two unsigned integers, reverting on
     * overflow.
     *
     * Counterpart to Solidity's `*` operator.
     *
     * Requirements:
     *
     * - Multiplication cannot overflow.
     */
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the
        // benefit is lost if 'b' is also tested.
        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522
        if (a == 0) {
            return 0;
        }

        uint256 c = a * b;
        require(c / a == b, "SafeMath: multiplication overflow");

        return c;
    }

    /**
     * @dev Returns the integer division of two unsigned integers. Reverts on
     * division by zero. The result is rounded towards zero.
     *
     * Counterpart to Solidity's `/` operator. Note: this function uses a
     * `revert` opcode (which leaves remaining gas untouched) while Solidity
     * uses an invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     *
     * - The divisor cannot be zero.
     */
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        return div(a, b, "SafeMath: division by zero");
    }

    /**
     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on
     * division by zero. The result is rounded towards zero.
     *
     * Counterpart to Solidity's `/` operator. Note: this function uses a
     * `revert` opcode (which leaves remaining gas untouched) while Solidity
     * uses an invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     *
     * - The divisor cannot be zero.
     */
    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
        require(b &gt; 0, errorMessage);
        uint256 c = a / b;
        // assert(a == b * c + a % b); // There is no case in which this doesn't hold

        return c;
    }

    /**
     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),
     * Reverts when dividing by zero.
     *
     * Counterpart to Solidity's `%` operator. This function uses a `revert`
     * opcode (which leaves remaining gas untouched) while Solidity uses an
     * invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     *
     * - The divisor cannot be zero.
     */
    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
        return mod(a, b, "SafeMath: modulo by zero");
    }

    /**
     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),
     * Reverts with custom message when dividing by zero.
     *
     * Counterpart to Solidity's `%` operator. This function uses a `revert`
     * opcode (which leaves remaining gas untouched) while Solidity uses an
     * invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     *
     * - The divisor cannot be zero.
     */
    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
        require(b != 0, errorMessage);
        return a % b;
    }
}


// Dependency file: @openzeppelin/contracts/utils/Address.sol


// pragma solidity ^0.6.2;

/**
 * @dev Collection of functions related to the address type
 */
library Address {
    /**
     * @dev Returns true if `account` is a contract.
     *
     * [// importANT]
     * ====
     * It is unsafe to assume that an address for which this function returns
     * false is an externally-owned account (EOA) and not a contract.
     *
     * Among others, `isContract` will return false for the following
     * types of addresses:
     *
     *  - an externally-owned account
     *  - a contract in construction
     *  - an address where a contract will be created
     *  - an address where a contract lived, but was destroyed
     * ====
     */
    function isContract(address account) internal view returns (bool) {
        // This method relies in extcodesize, which returns 0 for contracts in
        // construction, since the code is only stored at the end of the
        // constructor execution.

        uint256 size;
        // solhint-disable-next-line no-inline-assembly
        assembly { size := extcodesize(account) }
        return size &gt; 0;
    }

    /**
     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to
     * `recipient`, forwarding all available gas and reverting on errors.
     *
     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost
     * of certain opcodes, possibly making contracts go over the 2300 gas limit
     * imposed by `transfer`, making them unable to receive funds via
     * `transfer`. {sendValue} removes this limitation.
     *
     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].
     *
     * // importANT: because control is transferred to `recipient`, care must be
     * taken to not create reentrancy vulnerabilities. Consider using
     * {ReentrancyGuard} or the
     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].
     */
    function sendValue(address payable recipient, uint256 amount) internal {
        require(address(this).balance &gt;= amount, "Address: insufficient balance");

        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value
        (bool success, ) = recipient.call{ value: amount }("");
        require(success, "Address: unable to send value, recipient may have reverted");
    }

    /**
     * @dev Performs a Solidity function call using a low level `call`. A
     * plain`call` is an unsafe replacement for a function call: use this
     * function instead.
     *
     * If `target` reverts with a revert reason, it is bubbled up by this
     * function (like regular Solidity function calls).
     *
     * Returns the raw returned data. To convert to the expected return value,
     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].
     *
     * Requirements:
     *
     * - `target` must be a contract.
     * - calling `target` with `data` must not revert.
     *
     * _Available since v3.1._
     */
    function functionCall(address target, bytes memory data) internal returns (bytes memory) {
      return functionCall(target, data, "Address: low-level call failed");
    }

    /**
     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with
     * `errorMessage` as a fallback revert reason when `target` reverts.
     *
     * _Available since v3.1._
     */
    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {
        return _functionCallWithValue(target, data, 0, errorMessage);
    }

    /**
     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],
     * but also transferring `value` wei to `target`.
     *
     * Requirements:
     *
     * - the calling contract must have an ETH balance of at least `value`.
     * - the called Solidity function must be `payable`.
     *
     * _Available since v3.1._
     */
    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {
        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");
    }

    /**
     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but
     * with `errorMessage` as a fallback revert reason when `target` reverts.
     *
     * _Available since v3.1._
     */
    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {
        require(address(this).balance &gt;= value, "Address: insufficient balance for call");
        return _functionCallWithValue(target, data, value, errorMessage);
    }

    function _functionCallWithValue(address target, bytes memory data, uint256 weiValue, string memory errorMessage) private returns (bytes memory) {
        require(isContract(target), "Address: call to non-contract");

        // solhint-disable-next-line avoid-low-level-calls
        (bool success, bytes memory returndata) = target.call{ value: weiValue }(data);
        if (success) {
            return returndata;
        } else {
            // Look for revert reason and bubble it up if present
            if (returndata.length &gt; 0) {
                // The easiest way to bubble the revert reason is using memory via assembly

                // solhint-disable-next-line no-inline-assembly
                assembly {
                    let returndata_size := mload(returndata)
                    revert(add(32, returndata), returndata_size)
                }
            } else {
                revert(errorMessage);
            }
        }
    }
}


// Dependency file: @openzeppelin/contracts/GSN/Context.sol


// pragma solidity ^0.6.0;

/*
 * @dev Provides information about the current execution context, including the
 * sender of the transaction and its data. While these are generally available
 * via msg.sender and msg.data, they should not be accessed in such a direct
 * manner, since when dealing with GSN meta-transactions the account sending and
 * paying for execution may not be the actual sender (as far as an application
 * is concerned).
 *
 * This contract is only required for intermediate, library-like contracts.
 */
abstract contract Context {
    function _msgSender() internal view virtual returns (address payable) {
        return msg.sender;
    }

    function _msgData() internal view virtual returns (bytes memory) {
        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691
        return msg.data;
    }
}


// Dependency file: contracts/truefi/common/Initializable.sol

// Copied from https://github.com/OpenZeppelin/openzeppelin-contracts-ethereum-package/blob/v3.0.0/contracts/Initializable.sol

// pragma solidity 0.6.10;

/**
 * @title Initializable
 *
 * @dev Helper contract to support initializer functions. To use it, replace
 * the constructor with a function that has the `initializer` modifier.
 * WARNING: Unlike constructors, initializer functions must be manually
 * invoked. This applies both to deploying an Initializable contract, as well
 * as extending an Initializable contract via inheritance.
 * WARNING: When used with inheritance, manual care must be taken to not invoke
 * a parent initializer twice, or ensure that all initializers are idempotent,
 * because this is not dealt with automatically as with constructors.
 */
contract Initializable {
    /**
     * @dev Indicates that the contract has been initialized.
     */
    bool private initialized;

    /**
     * @dev Indicates that the contract is in the process of being initialized.
     */
    bool private initializing;

    /**
     * @dev Modifier to use in the initializer function of a contract.
     */
    modifier initializer() {
        require(initializing || isConstructor() || !initialized, "Contract instance has already been initialized");

        bool isTopLevelCall = !initializing;
        if (isTopLevelCall) {
            initializing = true;
            initialized = true;
        }

        _;

        if (isTopLevelCall) {
            initializing = false;
        }
    }

    /// @dev Returns true if and only if the function is running in the constructor
    function isConstructor() private view returns (bool) {
        // extcodesize checks the size of the code stored in an address, and
        // address returns the current address. Since the code is still not
        // deployed when running a constructor, any checks on its code size will
        // yield zero, making it an effective way to detect if a contract is
        // under construction or not.
        address self = address(this);
        uint256 cs;
        assembly {
            cs := extcodesize(self)
        }
        return cs == 0;
    }

    // Reserved storage space to allow for layout changes in the future.
    uint256[50] private ______gap;
}


// Dependency file: contracts/truefi/common/UpgradeableERC20.sol

// pragma solidity 0.6.10;

// import {Address} from "@openzeppelin/contracts/utils/Address.sol";
// import {Context} from "@openzeppelin/contracts/GSN/Context.sol";
// import {IERC20} from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
// import {SafeMath} from "@openzeppelin/contracts/math/SafeMath.sol";

// import {Initializable} from "contracts/truefi/common/Initializable.sol";

/**
 * @dev Implementation of the {IERC20} interface.
 *
 * This implementation is agnostic to the way tokens are created. This means
 * that a supply mechanism has to be added in a derived contract using {_mint}.
 * For a generic mechanism see {ERC20PresetMinterPauser}.
 *
 * TIP: For a detailed writeup see our guide
 * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How
 * to implement supply mechanisms].
 *
 * We have followed general OpenZeppelin guidelines: functions revert instead
 * of returning `false` on failure. This behavior is nonetheless conventional
 * and does not conflict with the expectations of ERC20 applications.
 *
 * Additionally, an {Approval} event is emitted on calls to {transferFrom}.
 * This allows applications to reconstruct the allowance for all accounts just
 * by listening to said events. Other implementations of the EIP may not emit
 * these events, as it isn't required by the specification.
 *
 * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}
 * functions have been added to mitigate the well-known issues around setting
 * allowances. See {IERC20-approve}.
 */
contract ERC20 is Initializable, Context, IERC20 {
    using SafeMath for uint256;
    using Address for address;

    mapping(address =&gt; uint256) private _balances;

    mapping(address =&gt; mapping(address =&gt; uint256)) private _allowances;

    uint256 private _totalSupply;

    string private _name;
    string private _symbol;
    uint8 private _decimals;

    /**
     * @dev Sets the values for {name} and {symbol}, initializes {decimals} with
     * a default value of 18.
     *
     * To select a different value for {decimals}, use {_setupDecimals}.
     *
     * All three of these values are immutable: they can only be set once during
     * construction.
     */
    function __ERC20_initialize(string memory name, string memory symbol) internal initializer {
        _name = name;
        _symbol = symbol;
        _decimals = 18;
    }

    /**
     * @dev Returns the name of the token.
     */
    function name() public view returns (string memory) {
        return _name;
    }

    /**
     * @dev Returns the symbol of the token, usually a shorter version of the
     * name.
     */
    function symbol() public view returns (string memory) {
        return _symbol;
    }

    /**
     * @dev Returns the number of decimals used to get its user representation.
     * For example, if `decimals` equals `2`, a balance of `505` tokens should
     * be displayed to a user as `5,05` (`505 / 10 ** 2`).
     *
     * Tokens usually opt for a value of 18, imitating the relationship between
     * Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is
     * called.
     *
     * NOTE: This information is only used for _display_ purposes: it in
     * no way affects any of the arithmetic of the contract, including
     * {IERC20-balanceOf} and {IERC20-transfer}.
     */
    function decimals() public view returns (uint8) {
        return _decimals;
    }

    /**
     * @dev See {IERC20-totalSupply}.
     */
    function totalSupply() public override view returns (uint256) {
        return _totalSupply;
    }

    /**
     * @dev See {IERC20-balanceOf}.
     */
    function balanceOf(address account) public override view returns (uint256) {
        return _balances[account];
    }

    /**
     * @dev See {IERC20-transfer}.
     *
     * Requirements:
     *
     * - `recipient` cannot be the zero address.
     * - the caller must have a balance of at least `amount`.
     */
    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {
        _transfer(_msgSender(), recipient, amount);
        return true;
    }

    /**
     * @dev See {IERC20-allowance}.
     */
    function allowance(address owner, address spender) public virtual override view returns (uint256) {
        return _allowances[owner][spender];
    }

    /**
     * @dev See {IERC20-approve}.
     *
     * Requirements:
     *
     * - `spender` cannot be the zero address.
     */
    function approve(address spender, uint256 amount) public virtual override returns (bool) {
        _approve(_msgSender(), spender, amount);
        return true;
    }

    /**
     * @dev See {IERC20-transferFrom}.
     *
     * Emits an {Approval} event indicating the updated allowance. This is not
     * required by the EIP. See the note at the beginning of {ERC20};
     *
     * Requirements:
     * - `sender` and `recipient` cannot be the zero address.
     * - `sender` must have a balance of at least `amount`.
     * - the caller must have allowance for ``sender``'s tokens of at least
     * `amount`.
     */
    function transferFrom(
        address sender,
        address recipient,
        uint256 amount
    ) public virtual override returns (bool) {
        _transfer(sender, recipient, amount);
        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, "ERC20: transfer amount exceeds allowance"));
        return true;
    }

    /**
     * @dev Atomically increases the allowance granted to `spender` by the caller.
     *
     * This is an alternative to {approve} that can be used as a mitigation for
     * problems described in {IERC20-approve}.
     *
     * Emits an {Approval} event indicating the updated allowance.
     *
     * Requirements:
     *
     * - `spender` cannot be the zero address.
     */
    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {
        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));
        return true;
    }

    /**
     * @dev Atomically decreases the allowance granted to `spender` by the caller.
     *
     * This is an alternative to {approve} that can be used as a mitigation for
     * problems described in {IERC20-approve}.
     *
     * Emits an {Approval} event indicating the updated allowance.
     *
     * Requirements:
     *
     * - `spender` cannot be the zero address.
     * - `spender` must have allowance for the caller of at least
     * `subtractedValue`.
     */
    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {
        _approve(
            _msgSender(),
            spender,
            _allowances[_msgSender()][spender].sub(subtractedValue, "ERC20: decreased allowance below zero")
        );
        return true;
    }

    /**
     * @dev Moves tokens `amount` from `sender` to `recipient`.
     *
     * This is internal function is equivalent to {transfer}, and can be used to
     * e.g. implement automatic token fees, slashing mechanisms, etc.
     *
     * Emits a {Transfer} event.
     *
     * Requirements:
     *
     * - `sender` cannot be the zero address.
     * - `recipient` cannot be the zero address.
     * - `sender` must have a balance of at least `amount`.
     */
    function _transfer(
        address sender,
        address recipient,
        uint256 amount
    ) internal virtual {
        require(sender != address(0), "ERC20: transfer from the zero address");
        require(recipient != address(0), "ERC20: transfer to the zero address");

        _beforeTokenTransfer(sender, recipient, amount);

        _balances[sender] = _balances[sender].sub(amount, "ERC20: transfer amount exceeds balance");
        _balances[recipient] = _balances[recipient].add(amount);
        emit Transfer(sender, recipient, amount);
    }

    /** @dev Creates `amount` tokens and assigns them to `account`, increasing
     * the total supply.
     *
     * Emits a {Transfer} event with `from` set to the zero address.
     *
     * Requirements
     *
     * - `to` cannot be the zero address.
     */
    function _mint(address account, uint256 amount) internal virtual {
        require(account != address(0), "ERC20: mint to the zero address");

        _beforeTokenTransfer(address(0), account, amount);

        _totalSupply = _totalSupply.add(amount);
        _balances[account] = _balances[account].add(amount);
        emit Transfer(address(0), account, amount);
    }

    /**
     * @dev Destroys `amount` tokens from `account`, reducing the
     * total supply.
     *
     * Emits a {Transfer} event with `to` set to the zero address.
     *
     * Requirements
     *
     * - `account` cannot be the zero address.
     * - `account` must have at least `amount` tokens.
     */
    function _burn(address account, uint256 amount) internal virtual {
        require(account != address(0), "ERC20: burn from the zero address");

        _beforeTokenTransfer(account, address(0), amount);

        _balances[account] = _balances[account].sub(amount, "ERC20: burn amount exceeds balance");
        _totalSupply = _totalSupply.sub(amount);
        emit Transfer(account, address(0), amount);
    }

    /**
     * @dev Sets `amount` as the allowance of `spender` over the `owner`s tokens.
     *
     * This is internal function is equivalent to `approve`, and can be used to
     * e.g. set automatic allowances for certain subsystems, etc.
     *
     * Emits an {Approval} event.
     *
     * Requirements:
     *
     * - `owner` cannot be the zero address.
     * - `spender` cannot be the zero address.
     */
    function _approve(
        address owner,
        address spender,
        uint256 amount
    ) internal virtual {
        require(owner != address(0), "ERC20: approve from the zero address");
        require(spender != address(0), "ERC20: approve to the zero address");

        _allowances[owner][spender] = amount;
        emit Approval(owner, spender, amount);
    }

    /**
     * @dev Sets {decimals} to a value other than the default one of 18.
     *
     * WARNING: This function should only be called from the constructor. Most
     * applications that interact with token contracts will not expect
     * {decimals} to ever change, and may work incorrectly if it does.
     */
    function _setupDecimals(uint8 decimals_) internal {
        _decimals = decimals_;
    }

    /**
     * @dev Hook that is called before any transfer of tokens. This includes
     * minting and burning.
     *
     * Calling conditions:
     *
     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens
     * will be to transferred to `to`.
     * - when `from` is zero, `amount` tokens will be minted for `to`.
     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.
     * - `from` and `to` are never both zero.
     *
     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].
     */
    function _beforeTokenTransfer(
        address from,
        address to,
        uint256 amount
    ) internal virtual {}
}


// Dependency file: contracts/truefi/common/UpgradeableOwnable.sol

// pragma solidity 0.6.10;

// import {Context} from "@openzeppelin/contracts/GSN/Context.sol";

// import {Initializable} from "contracts/truefi/common/Initializable.sol";

/**
 * @dev Contract module which provides a basic access control mechanism, where
 * there is an account (an owner) that can be granted exclusive access to
 * specific functions.
 *
 * By default, the owner account will be the one that deploys the contract. This
 * can later be changed with {transferOwnership}.
 *
 * This module is used through inheritance. It will make available the modifier
 * `onlyOwner`, which can be applied to your functions to restrict their use to
 * the owner.
 */
contract Ownable is Initializable, Context {
    address private _owner;

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    /**
     * @dev Initializes the contract setting the deployer as the initial owner.
     */
    function initialize() internal initializer {
        address msgSender = _msgSender();
        _owner = msgSender;
        emit OwnershipTransferred(address(0), msgSender);
    }

    /**
     * @dev Returns the address of the current owner.
     */
    function owner() public view returns (address) {
        return _owner;
    }

    /**
     * @dev Throws if called by any account other than the owner.
     */
    modifier onlyOwner() {
        require(_owner == _msgSender(), "Ownable: caller is not the owner");
        _;
    }

    /**
     * @dev Leaves the contract without owner. It will not be possible to call
     * `onlyOwner` functions anymore. Can only be called by the current owner.
     *
     * NOTE: Renouncing ownership will leave the contract without an owner,
     * thereby removing any functionality that is only available to the owner.
     */
    function renounceOwnership() public virtual onlyOwner {
        emit OwnershipTransferred(_owner, address(0));
        _owner = address(0);
    }

    /**
     * @dev Transfers ownership of the contract to a new account (`newOwner`).
     * Can only be called by the current owner.
     */
    function transferOwnership(address newOwner) public virtual onlyOwner {
        require(newOwner != address(0), "Ownable: new owner is the zero address");
        emit OwnershipTransferred(_owner, newOwner);
        _owner = newOwner;
    }
}


// Dependency file: contracts/truefi/interface/IYToken.sol

// pragma solidity 0.6.10;

// import {IERC20} from "@openzeppelin/contracts/token/ERC20/IERC20.sol";

interface IYToken is IERC20 {
    function getPricePerFullShare() external view returns (uint256);
}


// Dependency file: contracts/truefi/interface/ICurve.sol

// pragma solidity 0.6.10;

// import {IERC20} from "@openzeppelin/contracts/token/ERC20/IERC20.sol";

// import {IYToken} from "contracts/truefi/interface/IYToken.sol";

interface ICurve {
    function calc_token_amount(uint256[4] memory amounts, bool deposit) external view returns (uint256);

    function get_virtual_price() external view returns (uint256);
}

interface ICurveGauge {
    function balanceOf(address depositor) external view returns (uint256);

    function minter() external returns (ICurveMinter);

    function deposit(uint256 amount) external;

    function withdraw(uint256 amount) external;
}

interface ICurveMinter {
    function mint(address gauge) external;

    function token() external view returns (IERC20);
}

interface ICurvePool {
    function add_liquidity(uint256[4] memory amounts, uint256 min_mint_amount) external;

    function remove_liquidity_one_coin(
        uint256 _token_amount,
        int128 i,
        uint256 min_amount,
        bool donate_dust
    ) external;

    function calc_withdraw_one_coin(uint256 _token_amount, int128 i) external view returns (uint256);

    function token() external view returns (IERC20);

    function curve() external view returns (ICurve);

    function coins(int128 id) external view returns (IYToken);
}


// Dependency file: contracts/truefi/interface/ITrueFiPool.sol

// pragma solidity 0.6.10;

// import {IERC20} from "@openzeppelin/contracts/token/ERC20/IERC20.sol";

/**
 * TruePool is an ERC20 which represents a share of a pool
 *
 * This contract can be used to wrap opportunities to be compatible
 * with TrueFi and allow users to directly opt-in through the TUSD contract
 *
 * Each TruePool is also a staking opportunity for TRU
 */
interface ITrueFiPool is IERC20 {
    /// @dev pool token (TUSD)
    function currencyToken() external view returns (IERC20);

    /**
     * @dev join pool
     * 1. Transfer TUSD from sender
     * 2. Mint pool tokens based on value to sender
     */
    function join(uint256 amount) external;

    /**
     * @dev exit pool
     * 1. Transfer pool tokens from sender
     * 2. Burn pool tokens
     * 3. Transfer value of pool tokens in TUSD to sender
     */
    function exit(uint256 amount) external;

    /**
     * @dev borrow from pool
     * 1. Transfer TUSD to sender
     * 2. Only lending pool should be allowed to call this
     */
    function borrow(uint256 amount, uint256 <span class="marker" id="mapping-1"></span><span class="token upd" id="move-src-1" data-title="parameter/identifier">amountWithoutF<span class="cupd">ee</span></span>) external;

    /**
     * @dev join pool
     * 1. Transfer TUSD from sender
     * 2. Only lending pool should be allowed to call this
     */
    function repay(uint256 amount) external;
}


// Dependency file: contracts/truefi/interface/ITrueLender.sol

// pragma solidity 0.6.10;

interface ITrueLender {
    function value() external view returns (uint256);

    function distribute(
        address recipient,
        uint256 numerator,
        uint256 denominator
    ) external;
}


// Dependency file: contracts/truefi/interface/IUniswapRouter.sol

// pragma solidity 0.6.10;

interface IUniswapRouter {
    function swapExactTokensForTokens(
        uint256 amountIn,
        uint256 amountOutMin,
        address[] calldata path,
        address to,
        uint256 deadline
    ) external returns (uint256[] memory amounts);
}


// Dependency file: contracts/truefi/Log.sol

/*
 * ABDK Math 64.64 Smart Contract Library.  Copyright © 2019 by ABDK Consulting.
 * Author: Mikhail Vladimirov &lt;mikhail.vladimirov@gmail.com&gt;
 */
// pragma solidity 0.6.10;

/**
 * Smart contract library of mathematical functions operating with signed
 * 64.64-bit fixed point numbers.  Signed 64.64-bit fixed point number is
 * basically a simple fraction whose numerator is signed 128-bit integer and
 * denominator is 2^64.  As long as denominator is always the same, there is no
 * need to store it, thus in Solidity signed 64.64-bit fixed point numbers are
 * represented by int128 type holding only the numerator.
 */
library ABDKMath64x64 {
    /**
     * Convert unsigned 256-bit integer number into signed 64.64-bit fixed point
     * number.  Revert on overflow.
     *
     * @param x unsigned 256-bit integer number
     * @return signed 64.64-bit fixed point number
     */
    function fromUInt(uint256 x) internal pure returns (int128) {
        require(x &lt;= 0x7FFFFFFFFFFFFFFF);
        return int128(x &lt;&lt; 64);
    }

    /**
     * Calculate binary logarithm of x.  Revert if x &lt;= 0.
     *
     * @param x signed 64.64-bit fixed point number
     * @return signed 64.64-bit fixed point number
     */
    function log_2(int128 x) internal pure returns (int128) {
        require(x &gt; 0);

        int256 msb = 0;
        int256 xc = x;
        if (xc &gt;= 0x10000000000000000) {
            xc &gt;&gt;= 64;
            msb += 64;
        }
        if (xc &gt;= 0x100000000) {
            xc &gt;&gt;= 32;
            msb += 32;
        }
        if (xc &gt;= 0x10000) {
            xc &gt;&gt;= 16;
            msb += 16;
        }
        if (xc &gt;= 0x100) {
            xc &gt;&gt;= 8;
            msb += 8;
        }
        if (xc &gt;= 0x10) {
            xc &gt;&gt;= 4;
            msb += 4;
        }
        if (xc &gt;= 0x4) {
            xc &gt;&gt;= 2;
            msb += 2;
        }
        if (xc &gt;= 0x2) msb += 1; // No need to shift xc anymore

        int256 result = (msb - 64) &lt;&lt; 64;
        uint256 ux = uint256(x) &lt;&lt; uint256(127 - msb);
        for (int256 bit = 0x8000000000000000; bit &gt; 0; bit &gt;&gt;= 1) {
            ux *= ux;
            uint256 b = ux &gt;&gt; 255;
            ux &gt;&gt;= 127 + b;
            result += bit * int256(b);
        }

        return int128(result);
    }

    /**
     * Calculate natural logarithm of x.  Revert if x &lt;= 0.
     *
     * @param x signed 64.64-bit fixed point number
     * @return signed 64.64-bit fixed point number
     */
    function ln(int128 x) internal pure returns (int128) {
        require(x &gt; 0);

        return int128((uint256(log_2(x)) * 0xB17217F7D1CF79ABC9E3B39803F2F6AF) &gt;&gt; 128);
    }
}


// Root file: contracts/truefi/TrueFiPool.sol

pragma solidity 0.6.10;

// import {IERC20} from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
// import {ReentrancyGuard} from "@openzeppelin/contracts/utils/ReentrancyGuard.sol";
// import {SafeMath} from "@openzeppelin/contracts/math/SafeMath.sol";

// import {ERC20} from "contracts/truefi/common/UpgradeableERC20.sol";
// import {Ownable} from "contracts/truefi/common/UpgradeableOwnable.sol";
// import {ICurveGauge, ICurveMinter, ICurvePool} from "contracts/truefi/interface/ICurve.sol";
// import {ITrueFiPool} from "contracts/truefi/interface/ITrueFiPool.sol";
// import {ITrueLender} from "contracts/truefi/interface/ITrueLender.sol";
// import {IUniswapRouter} from "contracts/truefi/interface/IUniswapRouter.sol";
// import {ABDKMath64x64} from "contracts/truefi/Log.sol";

<span class="marker" id="mapping-2"></span><span class="token mv" id="move-src-2" data-title="source_file/comment"><span class="marker" id="mapping-3"></span><span class="token upd" id="move-src-3" data-title="source_file/comment"><span class="cupd">/</span>**<span class="cupd"></span>
 * <span class="cupd">@</span>t<span class="cupd">i</span>tle TrueFi Pool
 * @dev Lendin<span class="cupd">g</span> pool which<span class="cupd"> </span>uses curve.fi to store idle funds
 * Earn<span class="cupd"> </span>hi<span class="cupd">g</span>h<span class="cupd"> </span>interest rates on currency deposit<span class="cupd">s</span> t<span class="cupd">h</span>rough<span class="cupd"> u</span>nco<span class="cupd">l</span>l<span class="cupd">a</span>teralized loans
 *<span class="cupd">
</span> *<span class="cupd"> </span>Funds d<span class="cupd">e</span>posite<span class="cupd">d</span> in t<span class="cupd">h</span>is pool are NOT LIQUID!
 * Exiting the pool will withdraw<span class="cupd"> a</span> basket <span class="cupd">o</span>f Loa<span class="cupd">n</span>To<span class="cupd">k</span>ens backing the pool
<span class="cupd"> </span>* Af<span class="cupd">t</span>er exitin<span class="cupd">g</span>,<span class="cupd"> </span>a<span class="cupd">n </span>account will need to <span class="cupd">w</span>ait<span class="cupd"> </span>for LoanTokens to expire and burn them
 * <span class="cupd">I</span>t is reco<span class="cupd">m</span>mended to perform a zap or swap tokens on Uniswap for liquidity
 *
 * Funds are managed through an external function to save gas on deposits
 */</span></span>
contract TrueFiPool is ITrueFiPool, ERC20, ReentrancyGuard, Ownable {
    using SafeMath for uint256;

    // ================ WARNING ==================
    // ===== THIS CONTRACT IS INITIALIZABLE ======
    // === STORAGE VARIABLES ARE DECLARED BELOW ==
    // REMOVAL OR REORDER OF VARIABLES WILL RESULT
    // ========= IN STORAGE CORRUPTION ===========

    ICurvePool public _curvePool;
    ICurveGauge public _curveGauge;
    IERC20 public _currencyToken;
    ITrueLender public _lender;
    ICurveMinter public _minter;
    IUniswapRouter public _uniRouter;

    // fee for deposits
    uint256 public joiningFee;
    // track claimable fees
    uint256 public claimableFees;

    mapping(address =&gt; uint256) latestJoinBlock;

    // ======= STORAGE DECLARATION END ============

    // curve.fi data
    uint8 constant N_TOKENS = 4;
    uint8 constant TUSD_INDEX = 3;

    /**
     * @dev Emitted when fee is changed
     * @param newFee New fee
     */
    event JoiningFeeChanged(uint256 newFee);

    /**
     * @dev Emitted when someone joins the pool
     * @param staker Account staking
     * @param deposited Amount deposited
     * @param minted Amount of pool tokens minted
     */
    event Joined(address indexed staker, uint256 deposited, uint256 minted);

    /**
     * @dev Emitted when someone exits the pool
     * @param staker Account exiting
     * @param amount Amount unstaking
     */
    event Exited(address indexed staker, uint256 amount);

    /**
     * @dev Emitted when funds are flushed into curve.fi
     * @param currencyAmount Amount of tokens deposited
     */
    event Flushed(uint256 currencyAmount);

    /**
     * @dev Emitted when funds are pulled from curve.fi
     * @param yAmount Amount of pool tokens
     */
    event Pulled(uint256 yAmount);

    /**
     * @dev Emitted when funds are borrowed from pool
     * @param borrower Borrower address
     * @param amount Amount of funds borrowed from pool
     * @param fee Fees collected from this transaction
     */
    event Borrow(address borrower, uint256 amount, uint256 fee);

    /**
     * @dev Emitted when borrower repays the pool
     * @param payer Address of borrower
     * @param amount Amount repaid
     */
    event Repaid(address indexed payer, uint256 amount);

    /**
     * @dev Emitted when fees are collected
     * @param beneficiary Account to receive fees
     * @param amount Amount of fees collected
     */
    event Collected(address indexed beneficiary, uint256 amount);

    /**
     * @dev Initialize pool
     * @param __curvePool curve pool address
     * @param __curveGauge curve gauge address
     * @param __currencyToken curve pool underlying token
     * @param __lender TrueLender address
     * @param __uniRouter Uniswap router
     */
    function initialize(
        ICurvePool __curvePool,
        ICurveGauge __curveGauge,
        IERC20 __currencyToken,
        ITrueLender __lender,
        IUniswapRouter __uniRouter
    ) public initializer {
        ERC20.__ERC20_initialize("TrueFi LP", "TFI-LP");
        Ownable.initialize();

        _curvePool = __curvePool;
        _curveGauge = __curveGauge;
        _currencyToken = __currencyToken;
        _lender = __lender;
        _minter = _curveGauge.minter();
        _uniRouter = __uniRouter;

        joiningFee = 25;

        <span class="marker" id="mapping-4"></span><span class="token mv" id="move-src-4" data-title="function_body/expression_statement"><span class="marker" id="mapping-5"></span><span class="token upd" id="move-src-5" data-title="member_expression/identifier"><span class="cupd">_</span>curr<span class="cupd">e</span>ncy<span class="cupd">Token</span></span>.approve(address(<span class="marker" id="mapping-6"></span><span class="token upd" id="move-src-6" data-title="call_argument/identifier"><span class="cupd">_</span>c<span class="cupd">u</span>rvePool</span>), <span class="marker" id="mapping-7"></span><span class="token del" data-title="call_argument/type_cast_expression">uint256(-1)</span>);</span>
        <span class="marker" id="mapping-8"></span><span class="token mv" id="move-src-7" data-title="function_body/expression_statement"><span class="marker" id="mapping-9"></span><span class="token del" data-title="member_expression/call_expression">_curvePool.token()</span><span class="marker" id="mapping-10"></span><span class="token mv" id="move-src-8" data-title="member_expression/.">.</span><span class="marker" id="mapping-11"></span><span class="token upd" id="move-src-9" data-title="member_expression/identifier">appr<span class="cupd">o</span>ve</span>(<span class="marker" id="mapping-12"></span><span class="token mv" id="move-src-10" data-title="call_expression/call_argument">address(<span class="marker" id="mapping-13"></span><span class="token upd" id="move-src-11" data-title="call_argument/identifier">_curvePool</span>)</span>, <span class="marker" id="mapping-14"></span><span class="token del" data-title="call_expression/call_argument">uint256(-1)</span>);</span>
    }

    /**
     * @dev only lender can perform borrowing or repaying
     */
    modifier onlyLender() {
        require(msg.sender == address(_lender), "TrueFiPool: Only lender can borrow or repay");
        _;
    }

    /**
     * @dev get currency token address
     * @return currency token address
     */
    function currencyToken() public override view returns (IERC20) {
        return _currencyToken;
    }

    <span class="marker" id="mapping-15"></span><span class="token mv" id="move-src-12" data-title="contract_body/comment"><span class="marker" id="mapping-16"></span><span class="token upd" id="move-src-13" data-title="contract_body/comment"><span class="cupd">/</span>**<span class="cupd"></span><span class="cupd">
</span>     * @d<span class="cupd">e</span>v Get to<span class="cupd">ta</span><span class="cupd">l</span> bal<span class="cupd">a</span><span class="cupd">n</span>c<span class="cupd">e</span><span class="cupd"> </span>of c<span class="cupd">u</span>rve.f<span class="cupd">i</span><span class="cupd"> </span>pool<span class="cupd"> </span><span class="cupd">t</span>okens
     */</span></span>
    function yTokenBalance() public view returns (uint256) {
        return _curvePool.token().balanceOf(address(this)).add(_curveGauge.balanceOf(address(this)));
    }

    <span class="marker" id="mapping-17"></span><span class="token mv" id="move-src-14" data-title="contract_body/comment"><span class="marker" id="mapping-18"></span><span class="token upd" id="move-src-15" data-title="contract_body/comment"><span class="cupd">/</span>**<span class="cupd"></span><span class="cupd">
</span>     * @<span class="cupd">d</span>e<span class="cupd">v</span> V<span class="cupd">i</span>rt<span class="cupd">u</span><span class="cupd">a</span>l value of yCRV tokens in the pool
     */</span></span>
    function yTokenValue() public view returns (uint256) {
        return yTokenBalance().mul(_curvePool.curve().get_virtual_price()).div(1 ether);
    }

    <span class="marker" id="mapping-19"></span><span class="token mv" id="move-src-16" data-title="contract_body/comment"><span class="marker" id="mapping-20"></span><span class="token upd" id="move-src-17" data-title="contract_body/comment"><span class="cupd">/</span>**<span class="cupd"></span><span class="cupd">
</span>     * @<span class="cupd">d</span>e<span class="cupd">v</span> Virt<span class="cupd">u</span>a<span class="cupd">l</span> <span class="cupd">va</span>lu<span class="cupd">e</span> <span class="cupd">o</span>f li<span class="cupd">q</span>uid ass<span class="cupd">e</span>ts<span class="cupd"> </span><span class="cupd">i</span><span class="cupd">n </span><span class="cupd">th</span><span class="cupd">e</span><span class="cupd"> pool</span>
     */</span></span>
    function liquidValue() public view returns (uint256) {
        return currencyBalance().add(yTokenValue());
    }

    <span class="marker" id="mapping-21"></span><span class="token mv" id="move-src-18" data-title="contract_body/comment"><span class="marker" id="mapping-22"></span><span class="token upd" id="move-src-19" data-title="contract_body/comment"><span class="cupd">/</span>**<span class="cupd"></span>
     * <span class="cupd">@</span>de<span class="cupd">v</span> <span class="cupd">C</span>alcu<span class="cupd">l</span>a<span class="cupd">t</span><span class="cupd">e</span> pool <span class="cupd">v</span>alue <span class="cupd">in</span> TUSD
     * "virtual pr<span class="cupd">i</span>c<span class="cupd">e</span>" o<span class="cupd">f</span> <span class="cupd">e</span>nti<span class="cupd">r</span>e<span class="cupd"> </span>po<span class="cupd">o</span>l<span class="cupd"> </span>-<span class="cupd"> </span>LoanTokens, TUSD, <span class="cupd">c</span>ur<span class="cupd">v</span>e y<span class="cupd"> </span>pool t<span class="cupd">o</span>kens
     <span class="cupd">*</span> @re<span class="cupd">t</span>urn poo<span class="cupd">l</span> value in TUSD
     */</span></span>
    function poolValue() public view returns (uint256) {
        return liquidValue().add(<span class="marker" id="mapping-23"></span><span class="token mv" id="move-src-20" data-title="call_argument/call_expression">_lender.value()</span>);
    }

    /**
     * @dev ensure enough curve.fi pool tokens are available
     * Check if current available amount of TUSD is enough and
     * withdraw remainder from gauge
     * @param neededAmount amount required
     */
    function ensureEnoughTokensAreAvailable(uint256 neededAmount) internal {
        uint256 currentlyAvailableAmount = _curvePool.token().balanceOf(address(this));
        if (currentlyAvailableAmount &lt; neededAmount) {
            _curveGauge.withdraw(neededAmount.sub(currentlyAvailableAmount));
        }
    }

    /**
     * @dev set pool join fee
     * @param fee new fee
     */
    function setJoiningFee(uint256 fee) external onlyOwner {
        require(fee &lt;= 10000, "TrueFiPool: Fee cannot exceed transaction value");
        joiningFee = fee;
        emit JoiningFeeChanged(fee);
    }

    /**
     * @dev sets all token allowances used to 0
     */
    function resetApprovals() external onlyOwner {
        _currencyToken.approve(address(_curvePool), 0);
        _curvePool.token().approve(address(_curvePool), 0);
        _curvePool.token().approve(address(_curveGauge), 0);
    }

    /**
     * @dev Join the pool by depositing currency tokens
     * @param amount amount of currency token to deposit
     */
    function join(uint256 amount) external override {
        uint256 fee = amount.mul(joiningFee).div(10000);
        uint256 <span class="marker" id="mapping-24"></span><span class="token upd" id="move-src-21" data-title="variable_declaration/identifier">a<span class="cupd">m</span>ou<span class="cupd">nt</span>ToD<span class="cupd">e</span>p<span class="cupd">o</span>sit</span> = <span class="marker" id="mapping-25"></span><span class="token mv" id="move-src-22" data-title="variable_declaration_statement/call_expression">amount.sub(fee)</span>;
        <span class="marker" id="mapping-26"></span><span class="token del" data-title="function_body/variable_declaration_statement"><span class="marker" id="mapping-27"></span><span class="token mv" id="move-src-23" data-title="variable_declaration_statement/variable_declaration">uint256 <span class="marker" id="mapping-28"></span><span class="token upd" id="move-src-24" data-title="variable_declaration/identifier"><span class="cupd">a</span><span class="cupd">mountTo</span>Mint</span></span> = amountToDeposit;</span>

        <span class="marker" id="mapping-29"></span><span class="token del" data-title="function_body/comment">// first staker mints same amount deposited</span>
        <span class="marker" id="mapping-30"></span><span class="token mv" id="move-src-25" data-title="function_body/if_statement">if (totalSupply() &gt; 0) {
            <span class="marker" id="mapping-31"></span><span class="token upd" id="move-src-26" data-title="assignment_expression/identifier">a<span class="cupd">m</span>ou<span class="cupd">nt</span>T<span class="cupd">o</span>Mi<span class="cupd">nt</span></span> = totalSupply().mul(<span class="marker" id="mapping-32"></span><span class="token upd" id="move-src-27" data-title="call_argument/identifier">amountToD<span class="cupd">eposit</span></span>).div(poolValue());
        }</span>
        <span class="marker" id="mapping-33"></span><span class="token del" data-title="function_body/comment">// mint pool tokens</span>
        <span class="marker" id="mapping-34"></span><span class="token mv" id="move-src-28" data-title="function_body/expression_statement">_mint(msg.sender, <span class="marker" id="mapping-35"></span><span class="token upd" id="move-src-29" data-title="call_argument/identifier">a<span class="cupd">m</span>ou<span class="cupd">nt</span>T<span class="cupd">o</span>Mi<span class="cupd">nt</span></span>);</span>
        claimableFees = claimableFees.add(fee);

        latestJoinBlock[tx.origin] = block.number;
        require(_currencyToken.transferFrom(msg.sender, address(this), amount));

        <span class="marker" id="mapping-36"></span><span class="token mv" id="move-src-30" data-title="function_body/emit_statement">emit <span class="marker" id="mapping-37"></span><span class="token upd" id="move-src-31" data-title="emit_statement/identifier">Joined</span>(msg.sender, amount, <span class="marker" id="mapping-38"></span><span class="token del" data-title="emit_statement/call_argument">amountToMint</span>);</span>
    }

    // prettier-ignore
    /**
     * @dev Exit pool
     * This function will withdraw a basket of currencies backing the pool value
     * @param amount amount of pool tokens to redeem for underlying tokens
     */
    function exit(uint256 amount) external override nonReentrant {
        require(block.number != latestJoinBlock[tx.origin], "TrueFiPool: Cannot join and exit in same block");
        require(amount &lt;= balanceOf(msg.sender), "TrueFiPool: insufficient funds");

        uint256 _totalSupply = totalSupply();

        // get share of currency tokens kept in the pool
        uint256 currencyAmountToTransfer = amount.mul(
            currencyBalance()).div(_totalSupply);

        // calculate amount of curve.fi pool tokens
        uint256 curveLiquidityAmountToTransfer = amount.mul(
            yTokenBalance()).div(_totalSupply);

        // burn tokens sent
        _burn(msg.sender, amount);

        // withdraw basket of loan tokens
        _lender.distribute(msg.sender, amount, _totalSupply);

        // if currency remaining, transfer
        if (currencyAmountToTransfer &gt; 0) {
            require(_currencyToken.transfer(msg.sender, currencyAmountToTransfer));
        }
        // if curve tokens remaining, transfer
        if (curveLiquidityAmountToTransfer &gt; 0) {
            ensureEnoughTokensAreAvailable(curveLiquidityAmountToTransfer);
            require(_curvePool.token().transfer(msg.sender, curveLiquidityAmountToTransfer));
        }

        emit Exited(msg.sender, amount);
    }

    <span class="marker" id="mapping-39"></span><span class="token mv" id="move-src-32" data-title="contract_body/comment"><span class="marker" id="mapping-40"></span><span class="token upd" id="move-src-33" data-title="contract_body/comment"><span class="cupd">/</span>**<span class="cupd"></span>
     * @dev Exit po<span class="cupd">o</span>l o<span class="cupd">n</span>ly with liquid <span class="cupd">t</span>okens
     * This functio<span class="cupd">n</span> wi<span class="cupd">l</span>l with<span class="cupd">d</span>raw TUSD<span class="cupd"> </span>but<span class="cupd"> </span>with a small <span class="cupd">p</span>enal<span class="cupd">t</span>y
     * @param<span class="cupd"> </span>amount amoun<span class="cupd">t </span><span class="cupd">of</span> pool to<span class="cupd">k</span>ens to redeem for unde<span class="cupd">r</span>lyi<span class="cupd">n</span>g tokens
     */</span></span>
    function liquidExit(uint256 amount) external nonReentrant {
        require(block.number != latestJoinBlock[tx.origin], "TrueFiPool: Cannot join and exit in same block");
        require(amount &lt;= balanceOf(msg.sender), "TrueFiPool: Insufficient funds");

        uint256 amountToWithdraw = poolValue().mul(amount).div(totalSupply());
        amountToWithdraw = amountToWithdraw.mul(liquidExitPenalty(amountToWithdraw)).div(10000);
        require(amountToWithdraw &lt;= liquidValue(), "TrueFiPool: Not enough liquidity in pool");

        // burn tokens sent
        _burn(msg.sender, amount);

        if (amountToWithdraw &gt; currencyBalance()) {
            removeLiquidityFromCurve(amountToWithdraw.sub(currencyBalance()));
            require(amountToWithdraw &lt;= currencyBalance(), "TrueFiPool: Not enough funds were withdrawn from Curve");
        }

        require(_currencyToken.transfer(msg.sender, amountToWithdraw));

        emit Exited(msg.sender, amountToWithdraw);
    }

    /**
     * @dev Penalty (in % * 100) applied if liquid exit is performed with this amount
     * returns 10000 if no penalty
     */
    function liquidExitPenalty(uint256 amount) public view returns (uint256) {
        uint256 lv = liquidValue();
        uint256 pv = poolValue();
        if (amount == pv) {
            return 10000;
        }
        uint256 liquidRatioBefore = lv.mul(10000).div(pv);
        uint256 liquidRatioAfter = lv.sub(amount).mul(10000).div(pv.sub(amount));
        return uint256(10000).sub(averageExitPenalty(liquidRatioAfter, liquidRatioBefore));
    }

    /**
     * @dev Calculates integral of 5/(x+50)dx times 10000
     */
    function integrateAtPoint(uint256 x) public pure returns (uint256) {
        return uint256(ABDKMath64x64.ln(ABDKMath64x64.fromUInt(x.add(50)))).mul(50000).div(2**64);
    }

    <span class="marker" id="mapping-41"></span><span class="token mv" id="move-src-34" data-title="contract_body/comment"><span class="marker" id="mapping-42"></span><span class="token upd" id="move-src-35" data-title="contract_body/comment"><span class="cupd">/**
     * @dev</span> Calcul<span class="cupd">a</span><span class="cupd">t</span>e<span class="cupd">s</span> a<span class="cupd">v</span>e<span class="cupd">r</span>a<span class="cupd">ge</span> <span class="cupd">pe</span><span class="cupd">n</span>alt<span class="cupd">y</span> o<span class="cupd">n</span> int<span class="cupd">e</span>r<span class="cupd">v</span>a<span class="cupd">l</span> [f<span class="cupd">r</span>om<span class="cupd">;</span><span class="cupd"> </span><span class="cupd">t</span>o<span class="cupd">]</span><span class="cupd">
   </span><span class="cupd">  </span>*/</span></span>
    function averageExitPenalty(uint256 from, uint256 to) public pure returns (uint256) {
        require(from &lt;= to, "TrueFiPool: To precedes from");
        if (from == 10000) {
            // When all liquid, dont penalize
            return 0;
        }
        if (from == to) {
            return uint256(50000).div(from.add(50));
        }
        return integrateAtPoint(to).sub(integrateAtPoint(from)).div(to.sub(from));
    }

    /**
     * @dev Deposit idle funds into curve.fi pool and stake in gauge
     * Called by owner to help manage funds in pool and save on gas for deposits
     * @param currencyAmount Amount of funds to deposit into curve
     * @param minMintAmount Minimum amount to mint
     */
    function flush(uint256 currencyAmount, uint256 minMintAmount) external <span class="marker" id="mapping-43"></span><span class="token mv" id="move-src-36" data-title="function_definition/modifier_invocation">onlyOwner</span> {
        require(currencyAmount &lt;= currencyBalance(), "TrueFiPool: Insufficient currency balance");

        uint256[N_TOKENS] memory amounts = [0, 0, 0, currencyAmount];

        // add TUSD to curve
        _currencyToken.approve(address(_curvePool), currencyAmount);
        _curvePool.add_liquidity(amounts, minMintAmount);

        // stake yCurve tokens in gauge
        uint256 yBalance = _curvePool.token().balanceOf(address(this));
        _curvePool.token().approve(address(_curveGauge), yBalance);
        _curveGauge.deposit(yBalance);

        emit Flushed(currencyAmount);
    }

    /**
     * @dev Remove liquidity from curve
     * @param yAmount amount of curve pool tokens
     * @param minCurrencyAmount minimum amount of tokens to withdraw
     */
    function pull(uint256 yAmount, uint256 minCurrencyAmount) external <span class="marker" id="mapping-44"></span><span class="token mv" id="move-src-37" data-title="function_definition/modifier_invocation">onlyOwner</span> {
        require(yAmount &lt;= yTokenBalance(), "TrueFiPool: Insufficient Curve liquidity balance");

        // unstake in gauge
        ensureEnoughTokensAreAvailable(yAmount);

        // remove TUSD from curve
        _curvePool.token().approve(address(_curvePool), yAmount);
        _curvePool.remove_liquidity_one_coin(yAmount, TUSD_INDEX, minCurrencyAmount, false);

        emit Pulled(yAmount);
    }

    // prettier-ignore
    <span class="marker" id="mapping-45"></span><span class="token mv" id="move-src-38" data-title="contract_body/comment"><span class="marker" id="mapping-46"></span><span class="token upd" id="move-src-39" data-title="contract_body/comment"><span class="cupd">/**
     * @dev</span> R<span class="cupd">e</span>mo<span class="cupd">v</span>e liqu<span class="cupd">i</span>dit<span class="cupd">y</span> <span class="cupd">f</span>rom<span class="cupd"> </span>cur<span class="cupd">ve</span><span class="cupd"> </span>an<span class="cupd">d</span> t<span class="cupd">ra</span>ns<span class="cupd">f</span>e<span class="cupd">r</span> t<span class="cupd">o</span> borrowe<span class="cupd">r
 </span>  <span class="cupd">  * @para</span><span class="cupd">m</span> ex<span class="cupd">p</span>e<span class="cupd">c</span>tedAmou<span class="cupd">n</span><span class="cupd">t</span> ex<span class="cupd">p</span>e<span class="cupd">c</span>t<span class="cupd">ed</span> amount to <span class="cupd">b</span>orr<span class="cupd">ow
    </span> */</span></span>
    function borrow(<span class="marker" id="mapping-47"></span><span class="token mv" id="move-src-40" data-title="function_definition/parameter">uint256 <span class="marker" id="mapping-48"></span><span class="token upd" id="move-src-41" data-title="parameter/identifier"><span class="cupd">e</span>x<span class="cupd">p</span>ec<span class="cupd">tedAmount</span></span></span>, uint256 <span class="marker" id="mapping-49"></span><span class="token upd" id="move-src-42" data-title="parameter/identifier">amountWithoutF<span class="cupd">ee</span></span>) external override nonReentrant onlyLender {
        <span class="marker" id="mapping-50"></span><span class="token mv" id="move-src-43" data-title="function_body/expression_statement"><span class="marker" id="mapping-51"></span><span class="token del" data-title="call_expression/identifier">require</span>(<span class="marker" id="mapping-52"></span><span class="token del" data-title="call_argument/binary_expression">expectedAmount &gt;= amountWithoutFee</span>, "TrueFiPool: Fee cannot be negative");</span>

        // if there is not enough TUSD, withdraw from curve
        if (<span class="marker" id="mapping-53"></span><span class="token upd" id="move-src-44" data-title="binary_expression/identifier">expectedA<span class="cupd">mount</span></span> &gt; currencyBalance()) {
            removeLiquidityFromCurve(<span class="marker" id="mapping-54"></span><span class="token upd" id="move-src-45" data-title="member_expression/identifier">expectedA<span class="cupd">mount</span></span>.sub(currencyBalance()));
            require(<span class="marker" id="mapping-55"></span><span class="token upd" id="move-src-46" data-title="binary_expression/identifier">expectedA<span class="cupd">mount</span></span> &lt;= currencyBalance(), "TrueFiPool: Not enough funds in pool to cover borrow");
        }

        <span class="marker" id="mapping-56"></span><span class="token del" data-title="function_body/comment">// calculate fees and transfer remainder</span>
        <span class="marker" id="mapping-57"></span><span class="token mv" id="move-src-47" data-title="function_body/variable_declaration_statement">uint256 <span class="marker" id="mapping-58"></span><span class="token upd" id="move-src-48" data-title="variable_declaration/identifier">fee</span> = <span class="marker" id="mapping-59"></span><span class="token del" data-title="call_expression/member_expression">expectedAmount.sub</span>(<span class="marker" id="mapping-60"></span><span class="token del" data-title="call_expression/call_argument">amountWithoutFee</span>);</span>
        <span class="marker" id="mapping-61"></span><span class="token del" data-title="expression_statement/assignment_expression">claimableFees = claimableFees.add(fee)</span>;
        require(_currencyToken.transfer(msg.sender, <span class="marker" id="mapping-62"></span><span class="token del" data-title="call_argument/identifier">amountWithoutFee</span>));

        <span class="marker" id="mapping-63"></span><span class="token mv" id="move-src-49" data-title="function_body/emit_statement">emit <span class="marker" id="mapping-64"></span><span class="token upd" id="move-src-50" data-title="emit_statement/identifier">Borrow</span>(msg.sender, <span class="marker" id="mapping-65"></span><span class="token upd" id="move-src-51" data-title="call_argument/identifier">expectedA<span class="cupd">mount</span></span>, <span class="marker" id="mapping-66"></span><span class="token mv" id="move-src-52" data-title="emit_statement/call_argument">fee</span>);</span>
    }

    function removeLiquidityFromCurve(uint256 amountToWithdraw) internal {
        // get rough estimate of how much yCRV we should sell
        uint256 roughCurveTokenAmount = calcTokenAmount(amountToWithdraw).mul(1005).div(1000);
        require(roughCurveTokenAmount &lt;= yTokenBalance(), "TrueFiPool: Not enough Curve liquidity tokens in pool to cover borrow");
        // pull tokens from gauge
        ensureEnoughTokensAreAvailable(roughCurveTokenAmount);
        // remove TUSD from curve
        _curvePool.token().approve(address(_curvePool), roughCurveTokenAmount);
        uint256 minAmount = roughCurveTokenAmount.mul(_curvePool.curve().get_virtual_price()).mul(999).div(1000).div(1 ether);
        _curvePool.remove_liquidity_one_coin(roughCurveTokenAmount, TUSD_INDEX, minAmount, false);
    }

    /**
     * @dev repay debt by transferring tokens to the contract
     * @param currencyAmount amount to repay
     */
    function repay(uint256 currencyAmount) external override onlyLender {
        require(_currencyToken.transferFrom(msg.sender, address(this), currencyAmount));
        emit Repaid(msg.sender, currencyAmount);
    }

    /**
     * @dev Collect CRV tokens minted by staking at gauge
     */
    function collectCrv() external <span class="marker" id="mapping-67"></span><span class="token mv" id="move-src-53" data-title="function_definition/modifier_invocation">onlyOwner</span> {
        _minter.mint(address(_curveGauge));
    }

    /**
     * @dev Sell collected CRV on Uniswap
     * - Selling CRV is managed by the contract owner
     * - Calculations can be made off-chain and called based on market conditions
     * - Need to pass path of exact pairs to go through while executing exchange
     * For example, CRV -&gt; WETH -&gt; TUSD
     *
     * @param amountIn see https://uniswap.org/docs/v2/smart-contracts/router02/#swapexacttokensfortokens
     * @param amountOutMin see https://uniswap.org/docs/v2/smart-contracts/router02/#swapexacttokensfortokens
     * @param path see https://uniswap.org/docs/v2/smart-contracts/router02/#swapexacttokensfortokens
     */
    function sellCrv(
        uint256 amountIn,
        uint256 amountOutMin,
        address[] calldata path
    ) public <span class="marker" id="mapping-68"></span><span class="token upd" id="move-src-54" data-title="modifier_invocation/identifier"><span class="cupd">onlyOwner</span></span> {
        _minter.token().approve(address(_uniRouter), amountIn);
        _uniRouter.swapExactTokensForTokens(amountIn, amountOutMin, path, address(this), block.timestamp + 1 hours);
    }

    /**
     * @dev Claim fees from the pool
     * @param beneficiary account to send funds to
     */
    function collectFees(address beneficiary) external <span class="marker" id="mapping-69"></span><span class="token upd" id="move-src-55" data-title="modifier_invocation/identifier"><span class="cupd">onlyOwner</span></span> {
        uint256 amount = claimableFees;
        claimableFees = 0;

        if (amount &gt; 0) {
            require(_currencyToken.transfer(beneficiary, amount));
        }

        emit Collected(beneficiary, amount);
    }

    <span class="marker" id="mapping-70"></span><span class="token mv" id="move-src-56" data-title="contract_body/comment"><span class="marker" id="mapping-71"></span><span class="token upd" id="move-src-57" data-title="contract_body/comment"><span class="cupd">/**
     * </span>@noti<span class="cupd">c</span><span class="cupd">e </span>Expe<span class="cupd">c</span><span class="cupd">ted</span> amo<span class="cupd">u</span>n<span class="cupd">t</span> <span class="cupd">o</span>f m<span class="cupd">i</span>nt<span class="cupd">e</span>d Curve.fi yDAI/yUSDC/yUSDT/yTUSD toke<span class="cupd">n</span>s<span class="cupd">.</span>
     *<span class="cupd"> C</span>an<span class="cupd"> </span><span class="cupd">b</span>e<span class="cupd"> </span>us<span class="cupd">e</span>d t<span class="cupd">o</span> <span class="cupd">c</span>ontrol slip<span class="cupd">pa</span>ge
     * Ca<span class="cupd">ll</span>ed<span class="cupd"> </span>in flus<span class="cupd">h</span>() funct<span class="cupd">ion</span>
 <span class="cupd">    * @pa</span>ram <span class="cupd">c</span><span class="cupd">u</span>rrencyAmo<span class="cupd">u</span>nt am<span class="cupd">o</span>un<span class="cupd">t</span> <span class="cupd">t</span>o ca<span class="cupd">l</span>c<span class="cupd">u</span><span class="cupd">l</span>at<span class="cupd">e</span><span class="cupd"> for
  </span>   */</span></span>
    function calcTokenAmount(uint256 currencyAmount) public view returns (uint256) {
        // prettier-ignore
        uint256 yTokenAmount = currencyAmount.mul(1e18).div(
            _curvePool.coins(TUSD_INDEX).getPricePerFullShare());
        uint256[N_TOKENS] memory yAmounts = [0, 0, 0, yTokenAmount];
        return _curvePool.curve().calc_token_amount(yAmounts, true);
    }

    /**
     * @dev Converts the value of a single yCRV into an underlying asset
     * @param yAmount amount of curve pool tokens to calculate for
     * @return Value of one y pool token
     */
    function calcWithdrawOneCoin(uint256 yAmount) public view returns (uint256) {
        return _curvePool.calc_withdraw_one_coin(yAmount, TUSD_INDEX);
    }

    /**
     * @dev Currency token balance
     * @return Currency token balance
     */
    function currencyBalance() internal view returns (uint256) {
        return _currencyToken.balanceOf(address(this)).sub(claimableFees);
    }
}</pre></div><div class="col-6"><h5>0xb3c6fd9a58329172d043c987abfce211e9985613.etherscan.io-TrueFiPool.sol</h5><pre class="pre-scrollable">/*
    .'''''''''''..     ..''''''''''''''''..       ..'''''''''''''''..
    .;;;;;;;;;;;'.   .';;;;;;;;;;;;;;;;;;,.     .,;;;;;;;;;;;;;;;;;,.
    .;;;;;;;;;;,.   .,;;;;;;;;;;;;;;;;;;;,.    .,;;;;;;;;;;;;;;;;;;,.
    .;;;;;;;;;,.   .,;;;;;;;;;;;;;;;;;;;;,.   .;;;;;;;;;;;;;;;;;;;;,.
    ';;;;;;;;'.  .';;;;;;;;;;;;;;;;;;;;;;,. .';;;;;;;;;;;;;;;;;;;;;,.
    ';;;;;,..   .';;;;;;;;;;;;;;;;;;;;;;;,..';;;;;;;;;;;;;;;;;;;;;;,.
    ......     .';;;;;;;;;;;;;,'''''''''''.,;;;;;;;;;;;;;,'''''''''..
              .,;;;;;;;;;;;;;.           .,;;;;;;;;;;;;;.
             .,;;;;;;;;;;;;,.           .,;;;;;;;;;;;;,.
            .,;;;;;;;;;;;;,.           .,;;;;;;;;;;;;,.
           .,;;;;;;;;;;;;,.           .;;;;;;;;;;;;;,.     .....
          .;;;;;;;;;;;;;'.         ..';;;;;;;;;;;;;'.    .',;;;;,'.
        .';;;;;;;;;;;;;'.         .';;;;;;;;;;;;;;'.   .';;;;;;;;;;.
       .';;;;;;;;;;;;;'.         .';;;;;;;;;;;;;;'.    .;;;;;;;;;;;,.
      .,;;;;;;;;;;;;;'...........,;;;;;;;;;;;;;;.      .;;;;;;;;;;;,.
     .,;;;;;;;;;;;;,..,;;;;;;;;;;;;;;;;;;;;;;;,.       ..;;;;;;;;;,.
    .,;;;;;;;;;;;;,. .,;;;;;;;;;;;;;;;;;;;;;;,.          .',;;;,,..
   .,;;;;;;;;;;;;,.  .,;;;;;;;;;;;;;;;;;;;;;,.              ....
    ..',;;;;;;;;,.   .,;;;;;;;;;;;;;;;;;;;;,.
       ..',;;;;'.    .,;;;;;;;;;;;;;;;;;;;'.
          ...'..     .';;;;;;;;;;;;;;,,,'.
                       ...............
*/

<span class="marker" id="mapping-72"></span><span class="token mv" id="move-dst-3" data-title="source_file/comment"><span class="marker" id="mapping-73"></span><span class="token upd" id="move-dst-3" data-title="source_file/comment"><span class="cupd">/</span>/<span class="cupd"> </span>h<span class="cupd">t</span><span class="cupd">t</span><span class="cupd">p</span><span class="cupd">s</span>://<span class="cupd">g</span><span class="cupd">i</span><span class="cupd">t</span><span class="cupd">h</span><span class="cupd">u</span>b.<span class="cupd">co</span>m/<span class="cupd">t</span><span class="cupd">r</span><span class="cupd">u</span><span class="cupd">s</span><span class="cupd">t</span><span class="cupd">t</span><span class="cupd">o</span><span class="cupd">ke</span><span class="cupd">n</span>/<span class="cupd">s</span>m<span class="cupd">a</span><span class="cupd">r</span><span class="cupd">t</span>-<span class="cupd">c</span><span class="cupd">o</span><span class="cupd">nt</span><span class="cupd">r</span><span class="cupd">a</span><span class="cupd">c</span><span class="cupd">t</span>s</span></span>
// Dependency file: @openzeppelin/contracts/token/ERC20/IERC20.sol

// SPDX-License-Identifier: MIT

// pragma solidity ^0.6.0;

/**
 * @dev Interface of the ERC20 standard as defined in the EIP.
 */
interface IERC20 {
    /**
     * @dev Returns the amount of tokens in existence.
     */
    function totalSupply() external view returns (uint256);

    /**
     * @dev Returns the amount of tokens owned by `account`.
     */
    function balanceOf(address account) external view returns (uint256);

    /**
     * @dev Moves `amount` tokens from the caller's account to `recipient`.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * Emits a {Transfer} event.
     */
    function transfer(address recipient, uint256 amount) external returns (bool);

    /**
     * @dev Returns the remaining number of tokens that `spender` will be
     * allowed to spend on behalf of `owner` through {transferFrom}. This is
     * zero by default.
     *
     * This value changes when {approve} or {transferFrom} are called.
     */
    function allowance(address owner, address spender) external view returns (uint256);

    /**
     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * // importANT: Beware that changing an allowance with this method brings the risk
     * that someone may use both the old and the new allowance by unfortunate
     * transaction ordering. One possible solution to mitigate this race
     * condition is to first reduce the spender's allowance to 0 and set the
     * desired value afterwards:
     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
     *
     * Emits an {Approval} event.
     */
    function approve(address spender, uint256 amount) external returns (bool);

    /**
     * @dev Moves `amount` tokens from `sender` to `recipient` using the
     * allowance mechanism. `amount` is then deducted from the caller's
     * allowance.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * Emits a {Transfer} event.
     */
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);

    /**
     * @dev Emitted when `value` tokens are moved from one account (`from`) to
     * another (`to`).
     *
     * Note that `value` may be zero.
     */
    event Transfer(address indexed from, address indexed to, uint256 value);

    /**
     * @dev Emitted when the allowance of a `spender` for an `owner` is set by
     * a call to {approve}. `value` is the new allowance.
     */
    event Approval(address indexed owner, address indexed spender, uint256 value);
}


// Dependency file: @openzeppelin/contracts/utils/ReentrancyGuard.sol


// pragma solidity ^0.6.0;

/**
 * @dev Contract module that helps prevent reentrant calls to a function.
 *
 * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier
 * available, which can be applied to functions to make sure there are no nested
 * (reentrant) calls to them.
 *
 * Note that because there is a single `nonReentrant` guard, functions marked as
 * `nonReentrant` may not call one another. This can be worked around by making
 * those functions `private`, and then adding `external` `nonReentrant` entry
 * points to them.
 *
 * TIP: If you would like to learn more about reentrancy and alternative ways
 * to protect against it, check out our blog post
 * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].
 */
contract ReentrancyGuard {
    // Booleans are more expensive than uint256 or any type that takes up a full
    // word because each write operation emits an extra SLOAD to first read the
    // slot's contents, replace the bits taken up by the boolean, and then write
    // back. This is the compiler's defense against contract upgrades and
    // pointer aliasing, and it cannot be disabled.

    // The values being non-zero value makes deployment a bit more expensive,
    // but in exchange the refund on every call to nonReentrant will be lower in
    // amount. Since refunds are capped to a percentage of the total
    // transaction's gas, it is best to keep them low in cases like this one, to
    // increase the likelihood of the full refund coming into effect.
    uint256 private constant _NOT_ENTERED = 1;
    uint256 private constant _ENTERED = 2;

    uint256 private _status;

    constructor () internal {
        _status = _NOT_ENTERED;
    }

    /**
     * @dev Prevents a contract from calling itself, directly or indirectly.
     * Calling a `nonReentrant` function from another `nonReentrant`
     * function is not supported. It is possible to prevent this from happening
     * by making the `nonReentrant` function external, and make it call a
     * `private` function that does the actual work.
     */
    modifier nonReentrant() {
        // On the first call to nonReentrant, _notEntered will be true
        require(_status != _ENTERED, "ReentrancyGuard: reentrant call");

        // Any calls to nonReentrant after this point will fail
        _status = _ENTERED;

        _;

        // By storing the original value once again, a refund is triggered (see
        // https://eips.ethereum.org/EIPS/eip-2200)
        _status = _NOT_ENTERED;
    }
}


// Dependency file: @openzeppelin/contracts/math/SafeMath.sol


// pragma solidity ^0.6.0;

/**
 * @dev Wrappers over Solidity's arithmetic operations with added overflow
 * checks.
 *
 * Arithmetic operations in Solidity wrap on overflow. This can easily result
 * in bugs, because programmers usually assume that an overflow raises an
 * error, which is the standard behavior in high level programming languages.
 * `SafeMath` restores this intuition by reverting the transaction when an
 * operation overflows.
 *
 * Using this library instead of the unchecked operations eliminates an entire
 * class of bugs, so it's recommended to use it always.
 */
library SafeMath {
    /**
     * @dev Returns the addition of two unsigned integers, reverting on
     * overflow.
     *
     * Counterpart to Solidity's `+` operator.
     *
     * Requirements:
     *
     * - Addition cannot overflow.
     */
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c &gt;= a, "SafeMath: addition overflow");

        return c;
    }

    /**
     * @dev Returns the subtraction of two unsigned integers, reverting on
     * overflow (when the result is negative).
     *
     * Counterpart to Solidity's `-` operator.
     *
     * Requirements:
     *
     * - Subtraction cannot overflow.
     */
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        return sub(a, b, "SafeMath: subtraction overflow");
    }

    /**
     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on
     * overflow (when the result is negative).
     *
     * Counterpart to Solidity's `-` operator.
     *
     * Requirements:
     *
     * - Subtraction cannot overflow.
     */
    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
        require(b &lt;= a, errorMessage);
        uint256 c = a - b;

        return c;
    }

    /**
     * @dev Returns the multiplication of two unsigned integers, reverting on
     * overflow.
     *
     * Counterpart to Solidity's `*` operator.
     *
     * Requirements:
     *
     * - Multiplication cannot overflow.
     */
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the
        // benefit is lost if 'b' is also tested.
        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522
        if (a == 0) {
            return 0;
        }

        uint256 c = a * b;
        require(c / a == b, "SafeMath: multiplication overflow");

        return c;
    }

    /**
     * @dev Returns the integer division of two unsigned integers. Reverts on
     * division by zero. The result is rounded towards zero.
     *
     * Counterpart to Solidity's `/` operator. Note: this function uses a
     * `revert` opcode (which leaves remaining gas untouched) while Solidity
     * uses an invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     *
     * - The divisor cannot be zero.
     */
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        return div(a, b, "SafeMath: division by zero");
    }

    /**
     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on
     * division by zero. The result is rounded towards zero.
     *
     * Counterpart to Solidity's `/` operator. Note: this function uses a
     * `revert` opcode (which leaves remaining gas untouched) while Solidity
     * uses an invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     *
     * - The divisor cannot be zero.
     */
    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
        require(b &gt; 0, errorMessage);
        uint256 c = a / b;
        // assert(a == b * c + a % b); // There is no case in which this doesn't hold

        return c;
    }

    /**
     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),
     * Reverts when dividing by zero.
     *
     * Counterpart to Solidity's `%` operator. This function uses a `revert`
     * opcode (which leaves remaining gas untouched) while Solidity uses an
     * invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     *
     * - The divisor cannot be zero.
     */
    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
        return mod(a, b, "SafeMath: modulo by zero");
    }

    /**
     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),
     * Reverts with custom message when dividing by zero.
     *
     * Counterpart to Solidity's `%` operator. This function uses a `revert`
     * opcode (which leaves remaining gas untouched) while Solidity uses an
     * invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     *
     * - The divisor cannot be zero.
     */
    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
        require(b != 0, errorMessage);
        return a % b;
    }
}


// Dependency file: @openzeppelin/contracts/utils/Address.sol


// pragma solidity ^0.6.2;

/**
 * @dev Collection of functions related to the address type
 */
library Address {
    /**
     * @dev Returns true if `account` is a contract.
     *
     * [// importANT]
     * ====
     * It is unsafe to assume that an address for which this function returns
     * false is an externally-owned account (EOA) and not a contract.
     *
     * Among others, `isContract` will return false for the following
     * types of addresses:
     *
     *  - an externally-owned account
     *  - a contract in construction
     *  - an address where a contract will be created
     *  - an address where a contract lived, but was destroyed
     * ====
     */
    function isContract(address account) internal view returns (bool) {
        // This method relies in extcodesize, which returns 0 for contracts in
        // construction, since the code is only stored at the end of the
        // constructor execution.

        uint256 size;
        // solhint-disable-next-line no-inline-assembly
        assembly { size := extcodesize(account) }
        return size &gt; 0;
    }

    /**
     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to
     * `recipient`, forwarding all available gas and reverting on errors.
     *
     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost
     * of certain opcodes, possibly making contracts go over the 2300 gas limit
     * imposed by `transfer`, making them unable to receive funds via
     * `transfer`. {sendValue} removes this limitation.
     *
     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].
     *
     * // importANT: because control is transferred to `recipient`, care must be
     * taken to not create reentrancy vulnerabilities. Consider using
     * {ReentrancyGuard} or the
     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].
     */
    function sendValue(address payable recipient, uint256 amount) internal {
        require(address(this).balance &gt;= amount, "Address: insufficient balance");

        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value
        (bool success, ) = recipient.call{ value: amount }("");
        require(success, "Address: unable to send value, recipient may have reverted");
    }

    /**
     * @dev Performs a Solidity function call using a low level `call`. A
     * plain`call` is an unsafe replacement for a function call: use this
     * function instead.
     *
     * If `target` reverts with a revert reason, it is bubbled up by this
     * function (like regular Solidity function calls).
     *
     * Returns the raw returned data. To convert to the expected return value,
     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].
     *
     * Requirements:
     *
     * - `target` must be a contract.
     * - calling `target` with `data` must not revert.
     *
     * _Available since v3.1._
     */
    function functionCall(address target, bytes memory data) internal returns (bytes memory) {
      return functionCall(target, data, "Address: low-level call failed");
    }

    /**
     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with
     * `errorMessage` as a fallback revert reason when `target` reverts.
     *
     * _Available since v3.1._
     */
    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {
        return _functionCallWithValue(target, data, 0, errorMessage);
    }

    /**
     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],
     * but also transferring `value` wei to `target`.
     *
     * Requirements:
     *
     * - the calling contract must have an ETH balance of at least `value`.
     * - the called Solidity function must be `payable`.
     *
     * _Available since v3.1._
     */
    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {
        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");
    }

    /**
     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but
     * with `errorMessage` as a fallback revert reason when `target` reverts.
     *
     * _Available since v3.1._
     */
    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {
        require(address(this).balance &gt;= value, "Address: insufficient balance for call");
        return _functionCallWithValue(target, data, value, errorMessage);
    }

    function _functionCallWithValue(address target, bytes memory data, uint256 weiValue, string memory errorMessage) private returns (bytes memory) {
        require(isContract(target), "Address: call to non-contract");

        // solhint-disable-next-line avoid-low-level-calls
        (bool success, bytes memory returndata) = target.call{ value: weiValue }(data);
        if (success) {
            return returndata;
        } else {
            // Look for revert reason and bubble it up if present
            if (returndata.length &gt; 0) {
                // The easiest way to bubble the revert reason is using memory via assembly

                // solhint-disable-next-line no-inline-assembly
                assembly {
                    let returndata_size := mload(returndata)
                    revert(add(32, returndata), returndata_size)
                }
            } else {
                revert(errorMessage);
            }
        }
    }
}


// Dependency file: @openzeppelin/contracts/GSN/Context.sol


// pragma solidity ^0.6.0;

/*
 * @dev Provides information about the current execution context, including the
 * sender of the transaction and its data. While these are generally available
 * via msg.sender and msg.data, they should not be accessed in such a direct
 * manner, since when dealing with GSN meta-transactions the account sending and
 * paying for execution may not be the actual sender (as far as an application
 * is concerned).
 *
 * This contract is only required for intermediate, library-like contracts.
 */
abstract contract Context {
    function _msgSender() internal view virtual returns (address payable) {
        return msg.sender;
    }

    function _msgData() internal view virtual returns (bytes memory) {
        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691
        return msg.data;
    }
}


// Dependency file: contracts/truefi/common/Initializable.sol

// Copied from https://github.com/OpenZeppelin/openzeppelin-contracts-ethereum-package/blob/v3.0.0/contracts/Initializable.sol

// pragma solidity 0.6.10;

/**
 * @title Initializable
 *
 * @dev Helper contract to support initializer functions. To use it, replace
 * the constructor with a function that has the `initializer` modifier.
 * WARNING: Unlike constructors, initializer functions must be manually
 * invoked. This applies both to deploying an Initializable contract, as well
 * as extending an Initializable contract via inheritance.
 * WARNING: When used with inheritance, manual care must be taken to not invoke
 * a parent initializer twice, or ensure that all initializers are idempotent,
 * because this is not dealt with automatically as with constructors.
 */
contract Initializable {
    /**
     * @dev Indicates that the contract has been initialized.
     */
    bool private initialized;

    /**
     * @dev Indicates that the contract is in the process of being initialized.
     */
    bool private initializing;

    /**
     * @dev Modifier to use in the initializer function of a contract.
     */
    modifier initializer() {
        require(initializing || isConstructor() || !initialized, "Contract instance has already been initialized");

        bool isTopLevelCall = !initializing;
        if (isTopLevelCall) {
            initializing = true;
            initialized = true;
        }

        _;

        if (isTopLevelCall) {
            initializing = false;
        }
    }

    /// @dev Returns true if and only if the function is running in the constructor
    function isConstructor() private view returns (bool) {
        // extcodesize checks the size of the code stored in an address, and
        // address returns the current address. Since the code is still not
        // deployed when running a constructor, any checks on its code size will
        // yield zero, making it an effective way to detect if a contract is
        // under construction or not.
        address self = address(this);
        uint256 cs;
        assembly {
            cs := extcodesize(self)
        }
        return cs == 0;
    }

    // Reserved storage space to allow for layout changes in the future.
    uint256[50] private ______gap;
}


// Dependency file: contracts/truefi/common/UpgradeableERC20.sol

// pragma solidity 0.6.10;

// import {Address} from "@openzeppelin/contracts/utils/Address.sol";
// import {Context} from "@openzeppelin/contracts/GSN/Context.sol";
// import {IERC20} from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
// import {SafeMath} from "@openzeppelin/contracts/math/SafeMath.sol";

// import {Initializable} from "contracts/truefi/common/Initializable.sol";

/**
 * @dev Implementation of the {IERC20} interface.
 *
 * This implementation is agnostic to the way tokens are created. This means
 * that a supply mechanism has to be added in a derived contract using {_mint}.
 * For a generic mechanism see {ERC20PresetMinterPauser}.
 *
 * TIP: For a detailed writeup see our guide
 * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How
 * to implement supply mechanisms].
 *
 * We have followed general OpenZeppelin guidelines: functions revert instead
 * of returning `false` on failure. This behavior is nonetheless conventional
 * and does not conflict with the expectations of ERC20 applications.
 *
 * Additionally, an {Approval} event is emitted on calls to {transferFrom}.
 * This allows applications to reconstruct the allowance for all accounts just
 * by listening to said events. Other implementations of the EIP may not emit
 * these events, as it isn't required by the specification.
 *
 * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}
 * functions have been added to mitigate the well-known issues around setting
 * allowances. See {IERC20-approve}.
 */
contract ERC20 is Initializable, Context, IERC20 {
    using SafeMath for uint256;
    using Address for address;

    mapping(address =&gt; uint256) private _balances;

    mapping(address =&gt; mapping(address =&gt; uint256)) private _allowances;

    uint256 private _totalSupply;

    string private _name;
    string private _symbol;
    uint8 private _decimals;

    /**
     * @dev Sets the values for {name} and {symbol}, initializes {decimals} with
     * a default value of 18.
     *
     * To select a different value for {decimals}, use {_setupDecimals}.
     *
     * All three of these values are immutable: they can only be set once during
     * construction.
     */
    function __ERC20_initialize(string memory name, string memory symbol) internal initializer {
        _name = name;
        _symbol = symbol;
        _decimals = 18;
    }

    /**
     * @dev Returns the name of the token.
     */
    function name() public view returns (string memory) {
        return _name;
    }

    /**
     * @dev Returns the symbol of the token, usually a shorter version of the
     * name.
     */
    function symbol() public view returns (string memory) {
        return _symbol;
    }

    /**
     * @dev Returns the number of decimals used to get its user representation.
     * For example, if `decimals` equals `2`, a balance of `505` tokens should
     * be displayed to a user as `5,05` (`505 / 10 ** 2`).
     *
     * Tokens usually opt for a value of 18, imitating the relationship between
     * Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is
     * called.
     *
     * NOTE: This information is only used for _display_ purposes: it in
     * no way affects any of the arithmetic of the contract, including
     * {IERC20-balanceOf} and {IERC20-transfer}.
     */
    function decimals() public view returns (uint8) {
        return _decimals;
    }

    /**
     * @dev See {IERC20-totalSupply}.
     */
    function totalSupply() public override view returns (uint256) {
        return _totalSupply;
    }

    /**
     * @dev See {IERC20-balanceOf}.
     */
    function balanceOf(address account) public override view returns (uint256) {
        return _balances[account];
    }

    /**
     * @dev See {IERC20-transfer}.
     *
     * Requirements:
     *
     * - `recipient` cannot be the zero address.
     * - the caller must have a balance of at least `amount`.
     */
    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {
        _transfer(_msgSender(), recipient, amount);
        return true;
    }

    /**
     * @dev See {IERC20-allowance}.
     */
    function allowance(address owner, address spender) public virtual override view returns (uint256) {
        return _allowances[owner][spender];
    }

    /**
     * @dev See {IERC20-approve}.
     *
     * Requirements:
     *
     * - `spender` cannot be the zero address.
     */
    function approve(address spender, uint256 amount) public virtual override returns (bool) {
        _approve(_msgSender(), spender, amount);
        return true;
    }

    /**
     * @dev See {IERC20-transferFrom}.
     *
     * Emits an {Approval} event indicating the updated allowance. This is not
     * required by the EIP. See the note at the beginning of {ERC20};
     *
     * Requirements:
     * - `sender` and `recipient` cannot be the zero address.
     * - `sender` must have a balance of at least `amount`.
     * - the caller must have allowance for ``sender``'s tokens of at least
     * `amount`.
     */
    function transferFrom(
        address sender,
        address recipient,
        uint256 amount
    ) public virtual override returns (bool) {
        _transfer(sender, recipient, amount);
        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, "ERC20: transfer amount exceeds allowance"));
        return true;
    }

    /**
     * @dev Atomically increases the allowance granted to `spender` by the caller.
     *
     * This is an alternative to {approve} that can be used as a mitigation for
     * problems described in {IERC20-approve}.
     *
     * Emits an {Approval} event indicating the updated allowance.
     *
     * Requirements:
     *
     * - `spender` cannot be the zero address.
     */
    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {
        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));
        return true;
    }

    /**
     * @dev Atomically decreases the allowance granted to `spender` by the caller.
     *
     * This is an alternative to {approve} that can be used as a mitigation for
     * problems described in {IERC20-approve}.
     *
     * Emits an {Approval} event indicating the updated allowance.
     *
     * Requirements:
     *
     * - `spender` cannot be the zero address.
     * - `spender` must have allowance for the caller of at least
     * `subtractedValue`.
     */
    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {
        _approve(
            _msgSender(),
            spender,
            _allowances[_msgSender()][spender].sub(subtractedValue, "ERC20: decreased allowance below zero")
        );
        return true;
    }

    /**
     * @dev Moves tokens `amount` from `sender` to `recipient`.
     *
     * This is internal function is equivalent to {transfer}, and can be used to
     * e.g. implement automatic token fees, slashing mechanisms, etc.
     *
     * Emits a {Transfer} event.
     *
     * Requirements:
     *
     * - `sender` cannot be the zero address.
     * - `recipient` cannot be the zero address.
     * - `sender` must have a balance of at least `amount`.
     */
    function _transfer(
        address sender,
        address recipient,
        uint256 amount
    ) internal virtual {
        require(sender != address(0), "ERC20: transfer from the zero address");
        require(recipient != address(0), "ERC20: transfer to the zero address");

        _beforeTokenTransfer(sender, recipient, amount);

        _balances[sender] = _balances[sender].sub(amount, "ERC20: transfer amount exceeds balance");
        _balances[recipient] = _balances[recipient].add(amount);
        emit Transfer(sender, recipient, amount);
    }

    /** @dev Creates `amount` tokens and assigns them to `account`, increasing
     * the total supply.
     *
     * Emits a {Transfer} event with `from` set to the zero address.
     *
     * Requirements
     *
     * - `to` cannot be the zero address.
     */
    function _mint(address account, uint256 amount) internal virtual {
        require(account != address(0), "ERC20: mint to the zero address");

        _beforeTokenTransfer(address(0), account, amount);

        _totalSupply = _totalSupply.add(amount);
        _balances[account] = _balances[account].add(amount);
        emit Transfer(address(0), account, amount);
    }

    /**
     * @dev Destroys `amount` tokens from `account`, reducing the
     * total supply.
     *
     * Emits a {Transfer} event with `to` set to the zero address.
     *
     * Requirements
     *
     * - `account` cannot be the zero address.
     * - `account` must have at least `amount` tokens.
     */
    function _burn(address account, uint256 amount) internal virtual {
        require(account != address(0), "ERC20: burn from the zero address");

        _beforeTokenTransfer(account, address(0), amount);

        _balances[account] = _balances[account].sub(amount, "ERC20: burn amount exceeds balance");
        _totalSupply = _totalSupply.sub(amount);
        emit Transfer(account, address(0), amount);
    }

    /**
     * @dev Sets `amount` as the allowance of `spender` over the `owner`s tokens.
     *
     * This is internal function is equivalent to `approve`, and can be used to
     * e.g. set automatic allowances for certain subsystems, etc.
     *
     * Emits an {Approval} event.
     *
     * Requirements:
     *
     * - `owner` cannot be the zero address.
     * - `spender` cannot be the zero address.
     */
    function _approve(
        address owner,
        address spender,
        uint256 amount
    ) internal virtual {
        require(owner != address(0), "ERC20: approve from the zero address");
        require(spender != address(0), "ERC20: approve to the zero address");

        _allowances[owner][spender] = amount;
        emit Approval(owner, spender, amount);
    }

    /**
     * @dev Sets {decimals} to a value other than the default one of 18.
     *
     * WARNING: This function should only be called from the constructor. Most
     * applications that interact with token contracts will not expect
     * {decimals} to ever change, and may work incorrectly if it does.
     */
    function _setupDecimals(uint8 decimals_) internal {
        _decimals = decimals_;
    }

    /**
     * @dev Hook that is called before any transfer of tokens. This includes
     * minting and burning.
     *
     * Calling conditions:
     *
     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens
     * will be to transferred to `to`.
     * - when `from` is zero, `amount` tokens will be minted for `to`.
     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.
     * - `from` and `to` are never both zero.
     *
     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].
     */
    function _beforeTokenTransfer(
        address from,
        address to,
        uint256 amount
    ) internal virtual {}

    <span class="marker" id="mapping-74"></span><span class="token add" data-title="contract_body/function_definition">function updateNameAndSymbol(string memory __name, string memory __symbol) internal {
        _name = __name;
        _symbol = __symbol;
    }</span>
}


// Dependency file: contracts/truefi/common/UpgradeableOwnable.sol

// pragma solidity 0.6.10;

// import {Context} from "@openzeppelin/contracts/GSN/Context.sol";

// import {Initializable} from "contracts/truefi/common/Initializable.sol";

/**
 * @dev Contract module which provides a basic access control mechanism, where
 * there is an account (an owner) that can be granted exclusive access to
 * specific functions.
 *
 * By default, the owner account will be the one that deploys the contract. This
 * can later be changed with {transferOwnership}.
 *
 * This module is used through inheritance. It will make available the modifier
 * `onlyOwner`, which can be applied to your functions to restrict their use to
 * the owner.
 */
contract Ownable is Initializable, Context {
    address private _owner;

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    /**
     * @dev Initializes the contract setting the deployer as the initial owner.
     */
    function initialize() internal initializer {
        address msgSender = _msgSender();
        _owner = msgSender;
        emit OwnershipTransferred(address(0), msgSender);
    }

    /**
     * @dev Returns the address of the current owner.
     */
    function owner() public view returns (address) {
        return _owner;
    }

    /**
     * @dev Throws if called by any account other than the owner.
     */
    modifier onlyOwner() {
        require(_owner == _msgSender(), "Ownable: caller is not the owner");
        _;
    }

    /**
     * @dev Leaves the contract without owner. It will not be possible to call
     * `onlyOwner` functions anymore. Can only be called by the current owner.
     *
     * NOTE: Renouncing ownership will leave the contract without an owner,
     * thereby removing any functionality that is only available to the owner.
     */
    function renounceOwnership() public virtual onlyOwner {
        emit OwnershipTransferred(_owner, address(0));
        _owner = address(0);
    }

    /**
     * @dev Transfers ownership of the contract to a new account (`newOwner`).
     * Can only be called by the current owner.
     */
    function transferOwnership(address newOwner) public virtual onlyOwner {
        require(newOwner != address(0), "Ownable: new owner is the zero address");
        emit OwnershipTransferred(_owner, newOwner);
        _owner = newOwner;
    }
}


// Dependency file: contracts/truefi/interface/IYToken.sol

// pragma solidity 0.6.10;

// import {IERC20} from "@openzeppelin/contracts/token/ERC20/IERC20.sol";

interface IYToken is IERC20 {
    function getPricePerFullShare() external view returns (uint256);
}


// Dependency file: contracts/truefi/interface/ICurve.sol

// pragma solidity 0.6.10;

// import {IERC20} from "@openzeppelin/contracts/token/ERC20/IERC20.sol";

// import {IYToken} from "contracts/truefi/interface/IYToken.sol";

interface ICurve {
    function calc_token_amount(uint256[4] memory amounts, bool deposit) external view returns (uint256);

    function get_virtual_price() external view returns (uint256);
}

interface ICurveGauge {
    function balanceOf(address depositor) external view returns (uint256);

    function minter() external returns (ICurveMinter);

    function deposit(uint256 amount) external;

    function withdraw(uint256 amount) external;
}

interface ICurveMinter {
    function mint(address gauge) external;

    function token() external view returns (IERC20);
}

interface ICurvePool {
    function add_liquidity(uint256[4] memory amounts, uint256 min_mint_amount) external;

    function remove_liquidity_one_coin(
        uint256 _token_amount,
        int128 i,
        uint256 min_amount,
        bool donate_dust
    ) external;

    function calc_withdraw_one_coin(uint256 _token_amount, int128 i) external view returns (uint256);

    function token() external view returns (IERC20);

    function curve() external view returns (ICurve);

    function coins(int128 id) external view returns (IYToken);
}


// Dependency file: contracts/truefi/interface/ITrueFiPool.sol

// pragma solidity 0.6.10;

// import {IERC20} from "@openzeppelin/contracts/token/ERC20/IERC20.sol";

/**
 * TruePool is an ERC20 which represents a share of a pool
 *
 * This contract can be used to wrap opportunities to be compatible
 * with TrueFi and allow users to directly opt-in through the TUSD contract
 *
 * Each TruePool is also a staking opportunity for TRU
 */
interface ITrueFiPool is IERC20 {
    /// @dev pool token (TUSD)
    function currencyToken() external view returns (IERC20);

    <span class="marker" id="mapping-75"></span><span class="token add" data-title="contract_body/comment">/// @dev stake token (TRU)</span>
    <span class="marker" id="mapping-76"></span><span class="token add" data-title="contract_body/function_definition">function stakeToken() external view returns (IERC20);</span>

    /**
     * @dev join pool
     * 1. Transfer TUSD from sender
     * 2. Mint pool tokens based on value to sender
     */
    function join(uint256 amount) external;

    /**
     * @dev exit pool
     * 1. Transfer pool tokens from sender
     * 2. Burn pool tokens
     * 3. Transfer value of pool tokens in TUSD to sender
     */
    function exit(uint256 amount) external;

    /**
     * @dev borrow from pool
     * 1. Transfer TUSD to sender
     * 2. Only lending pool should be allowed to call this
     */
    function borrow(uint256 amount, uint256 <span class="marker" id="mapping-77"></span><span class="token upd" id="move-dst-1" data-title="parameter/identifier">f<span class="cupd">ee</span></span>) external;

    /**
     * @dev join pool
     * 1. Transfer TUSD from sender
     * 2. Only lending pool should be allowed to call this
     */
    function repay(uint256 amount) external;
}


// Dependency file: contracts/truefi/interface/ITrueLender.sol

// pragma solidity 0.6.10;

interface ITrueLender {
    function value() external view returns (uint256);

    function distribute(
        address recipient,
        uint256 numerator,
        uint256 denominator
    ) external;
}


// Dependency file: contracts/truefi/interface/IUniswapRouter.sol

// pragma solidity 0.6.10;

interface IUniswapRouter {
    function swapExactTokensForTokens(
        uint256 amountIn,
        uint256 amountOutMin,
        address[] calldata path,
        address to,
        uint256 deadline
    ) external returns (uint256[] memory amounts);
}


// Dependency file: contracts/truefi/Log.sol

/*
 * ABDK Math 64.64 Smart Contract Library.  Copyright © 2019 by ABDK Consulting.
 * Author: Mikhail Vladimirov &lt;mikhail.vladimirov@gmail.com&gt;
 */
// pragma solidity 0.6.10;

/**
 * Smart contract library of mathematical functions operating with signed
 * 64.64-bit fixed point numbers.  Signed 64.64-bit fixed point number is
 * basically a simple fraction whose numerator is signed 128-bit integer and
 * denominator is 2^64.  As long as denominator is always the same, there is no
 * need to store it, thus in Solidity signed 64.64-bit fixed point numbers are
 * represented by int128 type holding only the numerator.
 */
library ABDKMath64x64 {
    /**
     * Convert unsigned 256-bit integer number into signed 64.64-bit fixed point
     * number.  Revert on overflow.
     *
     * @param x unsigned 256-bit integer number
     * @return signed 64.64-bit fixed point number
     */
    function fromUInt(uint256 x) internal pure returns (int128) {
        require(x &lt;= 0x7FFFFFFFFFFFFFFF);
        return int128(x &lt;&lt; 64);
    }

    /**
     * Calculate binary logarithm of x.  Revert if x &lt;= 0.
     *
     * @param x signed 64.64-bit fixed point number
     * @return signed 64.64-bit fixed point number
     */
    function log_2(int128 x) internal pure returns (int128) {
        require(x &gt; 0);

        int256 msb = 0;
        int256 xc = x;
        if (xc &gt;= 0x10000000000000000) {
            xc &gt;&gt;= 64;
            msb += 64;
        }
        if (xc &gt;= 0x100000000) {
            xc &gt;&gt;= 32;
            msb += 32;
        }
        if (xc &gt;= 0x10000) {
            xc &gt;&gt;= 16;
            msb += 16;
        }
        if (xc &gt;= 0x100) {
            xc &gt;&gt;= 8;
            msb += 8;
        }
        if (xc &gt;= 0x10) {
            xc &gt;&gt;= 4;
            msb += 4;
        }
        if (xc &gt;= 0x4) {
            xc &gt;&gt;= 2;
            msb += 2;
        }
        if (xc &gt;= 0x2) msb += 1; // No need to shift xc anymore

        int256 result = (msb - 64) &lt;&lt; 64;
        uint256 ux = uint256(x) &lt;&lt; uint256(127 - msb);
        for (int256 bit = 0x8000000000000000; bit &gt; 0; bit &gt;&gt;= 1) {
            ux *= ux;
            uint256 b = ux &gt;&gt; 255;
            ux &gt;&gt;= 127 + b;
            result += bit * int256(b);
        }

        return int128(result);
    }

    /**
     * Calculate natural logarithm of x.  Revert if x &lt;= 0.
     *
     * @param x signed 64.64-bit fixed point number
     * @return signed 64.64-bit fixed point number
     */
    function ln(int128 x) internal pure returns (int128) {
        require(x &gt; 0);

        return int128((uint256(log_2(x)) * 0xB17217F7D1CF79ABC9E3B39803F2F6AF) &gt;&gt; 128);
    }
}


<span class="marker" id="mapping-78"></span><span class="token add" data-title="source_file/comment">// Dependency file: contracts/truefi/interface/ITruPriceOracle.sol</span>

<span class="marker" id="mapping-79"></span><span class="token add" data-title="source_file/comment">// pragma solidity 0.6.10;</span>

<span class="marker" id="mapping-80"></span><span class="token add" data-title="source_file/interface_declaration">interface ITruPriceOracle {
    function usdToTru(uint256 amount) external view returns (uint256);

    function truToUsd(uint256 amount) external view returns (uint256);
}</span>


// Root file: contracts/truefi/TrueFiPool.sol

pragma solidity 0.6.10;

// import {IERC20} from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
// import {ReentrancyGuard} from "@openzeppelin/contracts/utils/ReentrancyGuard.sol";
// import {SafeMath} from "@openzeppelin/contracts/math/SafeMath.sol";

// import {ERC20} from "contracts/truefi/common/UpgradeableERC20.sol";
// import {Ownable} from "contracts/truefi/common/UpgradeableOwnable.sol";
// import {ICurveGauge, ICurveMinter, ICurvePool} from "contracts/truefi/interface/ICurve.sol";
// import {ITrueFiPool} from "contracts/truefi/interface/ITrueFiPool.sol";
// import {ITrueLender} from "contracts/truefi/interface/ITrueLender.sol";
// import {IUniswapRouter} from "contracts/truefi/interface/IUniswapRouter.sol";
// import {ABDKMath64x64} from "contracts/truefi/Log.sol";
<span class="marker" id="mapping-81"></span><span class="token add" data-title="source_file/comment">// import {ITruPriceOracle} from "contracts/truefi/interface/ITruPriceOracle.sol";</span>

<span class="marker" id="mapping-82"></span><span class="token add" data-title="source_file/comment">/**
 * @title TrueFi Pool
 * @dev Lending pool which uses curve.fi to store idle funds
 * Earn high interest rates on currency deposits through uncollateralized loans
 *
 * Funds deposited in this pool are not fully liquid. Luqidity
 * Exiting the pool has 2 options:
 * - withdraw a basket of LoanTokens backing the pool
 * - take an exit penallty depending on pool liquidity
 * After exiting, an account will need to wait for LoanTokens to expire and burn them
 * It is recommended to perform a zap or swap tokens on Uniswap for increased liquidity
 *
 * Funds are managed through an external function to save gas on deposits
 */</span>
contract TrueFiPool is ITrueFiPool, ERC20, ReentrancyGuard, Ownable {
    using SafeMath for uint256;

    // ================ WARNING ==================
    // ===== THIS CONTRACT IS INITIALIZABLE ======
    // === STORAGE VARIABLES ARE DECLARED BELOW ==
    // REMOVAL OR REORDER OF VARIABLES WILL RESULT
    // ========= IN STORAGE CORRUPTION ===========

    ICurvePool public _curvePool;
    ICurveGauge public _curveGauge;
    IERC20 public _currencyToken;
    ITrueLender public _lender;
    ICurveMinter public _minter;
    IUniswapRouter public _uniRouter;

    // fee for deposits
    uint256 public joiningFee;
    // track claimable fees
    uint256 public claimableFees;

    mapping(address =&gt; uint256) latestJoinBlock;

    <span class="marker" id="mapping-83"></span><span class="token add" data-title="contract_body/state_variable_declaration">IERC20 public _stakeToken;</span>

    <span class="marker" id="mapping-84"></span><span class="token mv" id="move-dst-13" data-title="contract_body/comment"><span class="marker" id="mapping-85"></span><span class="token upd" id="move-dst-13" data-title="contract_body/comment"><span class="cupd">/</span>/<span class="cupd"> </span>cache<span class="cupd"> </span><span class="cupd">v</span><span class="cupd">al</span>ues<span class="cupd"> </span>duri<span class="cupd">n</span>g syn<span class="cupd">c</span><span class="cupd"> </span>f<span class="cupd">o</span><span class="cupd">r</span><span class="cupd"> </span>gas o<span class="cupd">p</span><span class="cupd">t</span>imizati<span class="cupd">o</span>n</span></span>
    <span class="marker" id="mapping-86"></span><span class="token add" data-title="contract_body/state_variable_declaration">bool private inSync;</span>
    <span class="marker" id="mapping-87"></span><span class="token add" data-title="contract_body/state_variable_declaration">uint256 private yTokenValueCache;</span>
    <span class="marker" id="mapping-88"></span><span class="token add" data-title="contract_body/state_variable_declaration">uint256 private loansValueCache;</span>

    <span class="marker" id="mapping-89"></span><span class="token mv" id="move-dst-15" data-title="contract_body/comment"><span class="marker" id="mapping-90"></span><span class="token upd" id="move-dst-15" data-title="contract_body/comment"><span class="cupd">/</span>/<span class="cupd"> </span>TRU<span class="cupd"> </span>pric<span class="cupd">e</span><span class="cupd"> </span>o<span class="cupd">r</span><span class="cupd">a</span>c<span class="cupd">l</span>e</span></span>
    <span class="marker" id="mapping-91"></span><span class="token add" data-title="contract_body/state_variable_declaration">ITruPriceOracle public _oracle;</span>

    <span class="marker" id="mapping-92"></span><span class="token mv" id="move-dst-17" data-title="contract_body/comment"><span class="marker" id="mapping-93"></span><span class="token upd" id="move-dst-17" data-title="contract_body/comment"><span class="cupd">/</span>/<span class="cupd"> </span>fund<span class="cupd"> </span>manag<span class="cupd">e</span>r<span class="cupd"> </span>c<span class="cupd">a</span>n<span class="cupd"> </span>c<span class="cupd">al</span>l<span class="cupd"> </span><span class="cupd">f</span><span class="cupd">u</span>nc<span class="cupd">t</span><span class="cupd">i</span>o<span class="cupd">n</span>s<span class="cupd"> t</span>o <span class="cupd">he</span>lp<span class="cupd"> </span>manage <span class="cupd">pool </span>funds</span></span>
    <span class="marker" id="mapping-94"></span><span class="token mv" id="move-dst-19" data-title="contract_body/comment"><span class="marker" id="mapping-95"></span><span class="token upd" id="move-dst-19" data-title="contract_body/comment"><span class="cupd">/</span>/<span class="cupd"> </span>fun<span class="cupd">d</span><span class="cupd"> </span>m<span class="cupd">a</span>n<span class="cupd">a</span>g<span class="cupd">e</span>r<span class="cupd"> </span>c<span class="cupd">a</span><span class="cupd">n </span>b<span class="cupd">e</span><span class="cupd"> </span>s<span class="cupd">e</span><span class="cupd">t</span><span class="cupd"> </span>t<span class="cupd">o</span><span class="cupd"> </span>0<span class="cupd"> </span><span class="cupd">o</span><span class="cupd">r</span><span class="cupd"> </span>g<span class="cupd">o</span>v<span class="cupd">e</span><span class="cupd">r</span><span class="cupd">n</span><span class="cupd">a</span>nce</span></span>
    <span class="marker" id="mapping-96"></span><span class="token add" data-title="contract_body/state_variable_declaration">address public fundsManager;</span>

    <span class="marker" id="mapping-97"></span><span class="token mv" id="move-dst-33" data-title="contract_body/comment"><span class="marker" id="mapping-98"></span><span class="token upd" id="move-dst-33" data-title="contract_body/comment"><span class="cupd">/</span>/<span class="cupd"> </span>a<span class="cupd">l</span><span class="cupd">l</span><span class="cupd">o</span><span class="cupd">w</span><span class="cupd"> </span>p<span class="cupd">a</span><span class="cupd">u</span>s<span class="cupd">i</span><span class="cupd">n</span>g<span class="cupd"> </span><span class="cupd">o</span><span class="cupd">f </span>de<span class="cupd">po</span><span class="cupd">s</span><span class="cupd">i</span><span class="cupd">t</span>s</span></span>
    <span class="marker" id="mapping-99"></span><span class="token add" data-title="contract_body/state_variable_declaration">bool public isJoiningPaused;</span>

    // ======= STORAGE DECLARATION END ============

    // curve.fi data
    uint8 constant N_TOKENS = 4;
    uint8 constant TUSD_INDEX = 3;

    <span class="marker" id="mapping-100"></span><span class="token mv" id="move-dst-35" data-title="contract_body/comment"><span class="marker" id="mapping-101"></span><span class="token upd" id="move-dst-35" data-title="contract_body/comment"><span class="cupd">/**
     * @dev</span> Em<span class="cupd">i</span>t<span class="cupd">t</span>e<span class="cupd">d</span> w<span class="cupd">h</span>en s<span class="cupd">t</span>a<span class="cupd">ke</span> to<span class="cupd">ke</span>n<span class="cupd"> </span>addres<span class="cupd">s</span><span class="cupd"></span>
     * @<span class="cupd">p</span><span class="cupd">a</span>r<span class="cupd">a</span>m<span class="cupd"> </span>tok<span class="cupd">e</span>n New<span class="cupd"> </span>stake<span class="cupd"> </span>tok<span class="cupd">e</span>n addre<span class="cupd">ss
 </span> <span class="cupd">  </span> */</span></span>
    <span class="marker" id="mapping-102"></span><span class="token add" data-title="contract_body/event_definition">event StakeTokenChanged(IERC20 token);</span>

    <span class="marker" id="mapping-103"></span><span class="token mv" id="move-dst-39" data-title="contract_body/comment"><span class="marker" id="mapping-104"></span><span class="token upd" id="move-dst-39" data-title="contract_body/comment"><span class="cupd">/**
     * @dev</span> <span class="cupd">E</span>mit<span class="cupd">t</span><span class="cupd">e</span><span class="cupd">d</span> <span class="cupd">o</span>r<span class="cupd">a</span>c<span class="cupd">le</span> <span class="cupd">w</span>a<span class="cupd">s</span> c<span class="cupd">ha</span>n<span class="cupd">g</span>e<span class="cupd">d</span><span class="cupd"></span><span class="cupd">
   </span><span class="cupd">  * @para</span>m<span class="cupd"> </span>newO<span class="cupd">r</span>a<span class="cupd">c</span><span class="cupd">l</span>e<span class="cupd"> </span>New o<span class="cupd">r</span>a<span class="cupd">c</span><span class="cupd">le</span> a<span class="cupd">d</span>dre<span class="cupd">ss
    </span> */</span></span>
    <span class="marker" id="mapping-105"></span><span class="token add" data-title="contract_body/event_definition">event OracleChanged(ITruPriceOracle newOracle);</span>

    <span class="marker" id="mapping-106"></span><span class="token mv" id="move-dst-57" data-title="contract_body/comment"><span class="marker" id="mapping-107"></span><span class="token upd" id="move-dst-57" data-title="contract_body/comment"><span class="cupd">/**
     * </span>@<span class="cupd">d</span>e<span class="cupd">v </span>Em<span class="cupd">i</span>t<span class="cupd">ted</span> wh<span class="cupd">e</span><span class="cupd">n</span><span class="cupd"> </span>f<span class="cupd">u</span><span class="cupd">n</span><span class="cupd">d</span><span class="cupd">s</span> <span class="cupd">ma</span>na<span class="cupd">g</span>e<span class="cupd">r</span> <span class="cupd">i</span><span class="cupd">s</span><span class="cupd"> </span>ch<span class="cupd">a</span><span class="cupd">ng</span><span class="cupd">ed</span><span class="cupd"></span><span class="cupd">
</span><span class="cupd">   </span><span class="cupd">  * @para</span>m<span class="cupd"> </span>new<span class="cupd">M</span><span class="cupd">a</span>nag<span class="cupd">e</span>r N<span class="cupd">e</span>w<span class="cupd"> </span>m<span class="cupd">a</span>n<span class="cupd">a</span>g<span class="cupd">e</span>r a<span class="cupd">d</span>dre<span class="cupd">ss
    </span> */</span></span>
    <span class="marker" id="mapping-108"></span><span class="token add" data-title="contract_body/event_definition">event FundsManagerChanged(address newManager);</span>

    /**
     * @dev Emitted when fee is changed
     * @param newFee New fee
     */
    event JoiningFeeChanged(uint256 newFee);

    /**
     * @dev Emitted when someone joins the pool
     * @param staker Account staking
     * @param deposited Amount deposited
     * @param minted Amount of pool tokens minted
     */
    event Joined(address indexed staker, uint256 deposited, uint256 minted);

    /**
     * @dev Emitted when someone exits the pool
     * @param staker Account exiting
     * @param amount Amount unstaking
     */
    event Exited(address indexed staker, uint256 amount);

    /**
     * @dev Emitted when funds are flushed into curve.fi
     * @param currencyAmount Amount of tokens deposited
     */
    event Flushed(uint256 currencyAmount);

    /**
     * @dev Emitted when funds are pulled from curve.fi
     * @param yAmount Amount of pool tokens
     */
    event Pulled(uint256 yAmount);

    /**
     * @dev Emitted when funds are borrowed from pool
     * @param borrower Borrower address
     * @param amount Amount of funds borrowed from pool
     * @param fee Fees collected from this transaction
     */
    event Borrow(address borrower, uint256 amount, uint256 fee);

    /**
     * @dev Emitted when borrower repays the pool
     * @param payer Address of borrower
     * @param amount Amount repaid
     */
    event Repaid(address indexed payer, uint256 amount);

    /**
     * @dev Emitted when fees are collected
     * @param beneficiary Account to receive fees
     * @param amount Amount of fees collected
     */
    event Collected(address indexed beneficiary, uint256 amount);

    <span class="marker" id="mapping-109"></span><span class="token add" data-title="contract_body/comment">/**
     * @dev Emitted when joining is paused or unpaused
     * @param isJoiningPaused New pausing status
     */</span>
    <span class="marker" id="mapping-110"></span><span class="token add" data-title="contract_body/event_definition">event JoiningPauseStatusChanged(bool isJoiningPaused);</span>

    /**
     * @dev Initialize pool
     * @param __curvePool curve pool address
     * @param __curveGauge curve gauge address
     * @param __currencyToken curve pool underlying token
     * @param __lender TrueLender address
     * @param __uniRouter Uniswap router
     */
    function initialize(
        ICurvePool __curvePool,
        ICurveGauge __curveGauge,
        IERC20 __currencyToken,
        ITrueLender __lender,
        IUniswapRouter __uniRouter<span class="marker" id="mapping-111"></span><span class="token add" data-title="function_definition/,">,</span>
        <span class="marker" id="mapping-112"></span><span class="token add" data-title="function_definition/parameter">IERC20 __stakeToken</span><span class="marker" id="mapping-113"></span><span class="token add" data-title="function_definition/,">,</span>
        <span class="marker" id="mapping-114"></span><span class="token add" data-title="function_definition/parameter">ITruPriceOracle __oracle</span>
    ) public initializer {
        ERC20.__ERC20_initialize("TrueFi LP", "TFI-LP");
        Ownable.initialize();

        _curvePool = __curvePool;
        _curveGauge = __curveGauge;
        _currencyToken = __currencyToken;
        _lender = __lender;
        _minter = _curveGauge.minter();
        _uniRouter = __uniRouter;
        <span class="marker" id="mapping-115"></span><span class="token add" data-title="function_body/expression_statement">_stakeToken = __stakeToken;</span>
        <span class="marker" id="mapping-116"></span><span class="token add" data-title="function_body/expression_statement">_oracle = __oracle;</span>

        joiningFee = 25;
    }

    /**
     * @dev only lender can perform borrowing or repaying
     */
    modifier onlyLender() {
        require(msg.sender == address(_lender), "TrueFiPool: Caller is not the lender");
        _;
    }

    <span class="marker" id="mapping-117"></span><span class="token add" data-title="contract_body/comment">/**
     * @dev pool can only be joined when it's unpaused
     */</span>
    <span class="marker" id="mapping-118"></span><span class="token add" data-title="contract_body/modifier_definition">modifier joiningNotPaused() {
        require(!isJoiningPaused, "TrueFiPool: Joining the pool is paused");
        _;
    }</span>

    <span class="marker" id="mapping-119"></span><span class="token add" data-title="contract_body/comment">/**
     * @dev only lender can perform borrowing or repaying
     */</span>
    <span class="marker" id="mapping-120"></span><span class="token add" data-title="contract_body/modifier_definition">modifier onlyOwnerOrManager() {
        require(msg.sender == owner() || msg.sender == fundsManager, "TrueFiPool: Caller is neither owner nor funds manager");
        _;
    }</span>

    <span class="marker" id="mapping-121"></span><span class="token add" data-title="contract_body/comment">/**
     * Sync values to avoid making expensive calls multiple times
     * Will set inSync to true, allowing getter functions to return cached values
     * Wipes cached values to save gas
     */</span>
    <span class="marker" id="mapping-122"></span><span class="token add" data-title="contract_body/modifier_definition">modifier sync() {
        // sync
        yTokenValueCache = yTokenValue();
        loansValueCache = loansValue();
        inSync = true;
        _;
        // wipe
        inSync = false;
        yTokenValueCache = 0;
        loansValueCache = 0;
    }</span>

    /**
     * @dev get currency token address
     * @return currency token address
     */
    function currencyToken() public override view returns (IERC20) {
        return _currencyToken;
    }

    <span class="marker" id="mapping-123"></span><span class="token add" data-title="contract_body/comment">/**
     * @dev get stake token address
     * @return stake token address
     */</span>
    <span class="marker" id="mapping-124"></span><span class="token add" data-title="contract_body/function_definition">function stakeToken() public override view returns (IERC20) {
        return _stakeToken;
    }</span>

    <span class="marker" id="mapping-125"></span><span class="token add" data-title="contract_body/comment">/**
     * @dev set stake token address
     * @param token stake token address
     */</span>
    <span class="marker" id="mapping-126"></span><span class="token add" data-title="contract_body/function_definition">function setStakeToken(<span class="marker" id="mapping-127"></span><span class="token add" data-title="function_definition/parameter">IERC20 token</span>) <span class="marker" id="mapping-128"></span><span class="token add" data-title="function_definition/visibility">public</span> <span class="marker" id="mapping-129"></span><span class="token mv" id="move-dst-36" data-title="function_definition/modifier_invocation">onlyOwner</span> <span class="marker" id="mapping-130"></span><span class="token add" data-title="function_definition/function_body">{
        _stakeToken = token;
        emit StakeTokenChanged(token);
    }</span></span>

    <span class="marker" id="mapping-131"></span><span class="token add" data-title="contract_body/comment">/**
     * @dev set funds manager address
     */</span>
    <span class="marker" id="mapping-132"></span><span class="token add" data-title="contract_body/function_definition">function setFundsManager(<span class="marker" id="mapping-133"></span><span class="token add" data-title="function_definition/parameter">address newFundsManager</span>) <span class="marker" id="mapping-134"></span><span class="token add" data-title="function_definition/visibility">public</span> <span class="marker" id="mapping-135"></span><span class="token mv" id="move-dst-37" data-title="function_definition/modifier_invocation">onlyOwner</span> <span class="marker" id="mapping-136"></span><span class="token add" data-title="function_definition/function_body">{
        fundsManager = newFundsManager;
        emit FundsManagerChanged(newFundsManager);
    }</span></span>

    <span class="marker" id="mapping-137"></span><span class="token add" data-title="contract_body/comment">/**
     * @dev set oracle token address
     * @param newOracle new oracle address
     */</span>
    <span class="marker" id="mapping-138"></span><span class="token add" data-title="contract_body/function_definition">function setOracle(<span class="marker" id="mapping-139"></span><span class="token add" data-title="function_definition/parameter">ITruPriceOracle newOracle</span>) <span class="marker" id="mapping-140"></span><span class="token add" data-title="function_definition/visibility">public</span> <span class="marker" id="mapping-141"></span><span class="token mv" id="move-dst-53" data-title="function_definition/modifier_invocation">onlyOwner</span> <span class="marker" id="mapping-142"></span><span class="token add" data-title="function_definition/function_body">{
        _oracle = newOracle;
        emit OracleChanged(newOracle);
    }</span></span>

    <span class="marker" id="mapping-143"></span><span class="token add" data-title="contract_body/comment">/**
     * @dev Allow pausing of deposits in case of emergency
     * @param status New deposit status
     */</span>
    <span class="marker" id="mapping-144"></span><span class="token add" data-title="contract_body/function_definition">function changeJoiningPauseStatus(bool status) external onlyOwnerOrManager {
        isJoiningPaused = status;
        emit JoiningPauseStatusChanged(status);
    }</span>

    <span class="marker" id="mapping-145"></span><span class="token add" data-title="contract_body/comment">/**
     * @dev Get total balance of stake tokens
     * @return Balance of stake tokens in this contract
     */</span>
    <span class="marker" id="mapping-146"></span><span class="token add" data-title="contract_body/function_definition">function stakeTokenBalance() public view returns (uint256) {
        return _stakeToken.balanceOf(address(this));
    }</span>

    <span class="marker" id="mapping-147"></span><span class="token add" data-title="contract_body/comment">/**
     * @dev Get total balance of curve.fi pool tokens
     * @return Balance of y pool tokens in this contract
     */</span>
    function yTokenBalance() public view returns (uint256) {
        return _curvePool.token().balanceOf(address(this)).add(_curveGauge.balanceOf(address(this)));
    }

    <span class="marker" id="mapping-148"></span><span class="token add" data-title="contract_body/comment">/**
     * @dev Virtual value of yCRV tokens in the pool
     * Will return sync value if inSync
     * @return yTokenValue in USD.
     */</span>
    function yTokenValue() public view returns (uint256) {
        <span class="marker" id="mapping-149"></span><span class="token add" data-title="function_body/if_statement">if (inSync) {
            return yTokenValueCache;
        }</span>
        return yTokenBalance().mul(_curvePool.curve().get_virtual_price()).div(1 ether);
    }

    <span class="marker" id="mapping-150"></span><span class="token add" data-title="contract_body/comment">/**
     * @dev Price of TRU in USD
     * @return Oracle price of TRU in USD
     */</span>
    <span class="marker" id="mapping-151"></span><span class="token add" data-title="contract_body/function_definition">function truValue() <span class="marker" id="mapping-152"></span><span class="token add" data-title="function_definition/visibility">public</span> <span class="marker" id="mapping-153"></span><span class="token add" data-title="function_definition/state_mutability">view</span> <span class="marker" id="mapping-154"></span><span class="token add" data-title="function_definition/return_type_definition">returns (uint256)</span> <span class="marker" id="mapping-155"></span><span class="token add" data-title="function_definition/function_body">{
        <span class="marker" id="mapping-156"></span><span class="token mv" id="move-dst-47" data-title="function_body/variable_declaration_statement">uint256 <span class="marker" id="mapping-157"></span><span class="token upd" id="move-dst-48" data-title="variable_declaration/identifier">balance</span> = <span class="marker" id="mapping-158"></span><span class="token add" data-title="call_expression/identifier">stakeTokenBalance</span>();</span>
        <span class="marker" id="mapping-159"></span><span class="token add" data-title="function_body/if_statement">if (balance == 0) {
            return 0;
        }</span>
        <span class="marker" id="mapping-160"></span><span class="token add" data-title="function_body/return_statement">return _oracle.truToUsd(balance);</span>
    }</span></span>

    <span class="marker" id="mapping-161"></span><span class="token add" data-title="contract_body/comment">/**
     * @dev Virtual value of liquid assets in the pool
     * @return Virtual liquid value of pool assets
     */</span>
    function liquidValue() public view returns (uint256) {
        return currencyBalance().add(yTokenValue());
    }

    <span class="marker" id="mapping-162"></span><span class="token add" data-title="contract_body/comment">/**
     * @dev Calculate pool value in TUSD
     * "virtual price" of entire pool - LoanTokens, TUSD, curve y pool tokens
     * @return pool value in USD
     */</span>
    function poolValue() public view returns (uint256) {
        <span class="marker" id="mapping-163"></span><span class="token add" data-title="function_body/comment">// this assumes defaulted loans are worth their full value</span>
        return liquidValue().add(<span class="marker" id="mapping-164"></span><span class="token add" data-title="call_argument/call_expression">loansValue()</span>);
    }

    <span class="marker" id="mapping-165"></span><span class="token add" data-title="contract_body/comment">/**
     * @dev Virtual value of loan assets in the pool
     * Will return cached value if inSync
     * @return Value of loans in pool
     */</span>
    <span class="marker" id="mapping-166"></span><span class="token add" data-title="contract_body/function_definition">function loansValue() <span class="marker" id="mapping-167"></span><span class="token add" data-title="function_definition/visibility">public</span> <span class="marker" id="mapping-168"></span><span class="token add" data-title="function_definition/state_mutability">view</span> <span class="marker" id="mapping-169"></span><span class="token add" data-title="function_definition/return_type_definition">returns (uint256)</span> <span class="marker" id="mapping-170"></span><span class="token add" data-title="function_definition/function_body">{
        <span class="marker" id="mapping-171"></span><span class="token add" data-title="function_body/if_statement">if (inSync) {
            return loansValueCache;
        }</span>
        <span class="marker" id="mapping-172"></span><span class="token add" data-title="function_body/return_statement">return <span class="marker" id="mapping-173"></span><span class="token mv" id="move-dst-20" data-title="return_statement/call_expression">_lender.value()</span>;</span>
    }</span></span>

    /**
     * @dev ensure enough curve.fi pool tokens are available
     * Check if current available amount of TUSD is enough and
     * withdraw remainder from gauge
     * @param neededAmount amount required
     */
    function ensureEnoughTokensAreAvailable(uint256 neededAmount) internal {
        uint256 currentlyAvailableAmount = _curvePool.token().balanceOf(address(this));
        if (currentlyAvailableAmount &lt; neededAmount) {
            _curveGauge.withdraw(neededAmount.sub(currentlyAvailableAmount));
        }
    }

    /**
     * @dev set pool join fee
     * @param fee new fee
     */
    function setJoiningFee(uint256 fee) external onlyOwner {
        require(fee &lt;= 10000, "TrueFiPool: Fee cannot exceed transaction value");
        joiningFee = fee;
        emit JoiningFeeChanged(fee);
    }

    /**
     * @dev sets all token allowances used to 0
     */
    function resetApprovals() external onlyOwner {
        _currencyToken.approve(address(_curvePool), 0);
        _curvePool.token().approve(address(_curvePool), 0);
        _curvePool.token().approve(address(_curveGauge), 0);
    }

    /**
     * @dev Join the pool by depositing currency tokens
     * @param amount amount of currency token to deposit
     */
    function join(uint256 amount) external override <span class="marker" id="mapping-174"></span><span class="token add" data-title="function_definition/modifier_invocation">joiningNotPaused</span> {
        uint256 fee = amount.mul(joiningFee).div(10000);
        uint256 <span class="marker" id="mapping-175"></span><span class="token upd" id="move-dst-21" data-title="variable_declaration/identifier"><span class="cupd">m</span>i<span class="cupd">nt</span><span class="cupd">e</span>dAm<span class="cupd">o</span>unt</span> = <span class="marker" id="mapping-176"></span><span class="token add" data-title="variable_declaration_statement/call_expression">mint(<span class="marker" id="mapping-177"></span><span class="token add" data-title="call_expression/call_argument"><span class="marker" id="mapping-178"></span><span class="token mv" id="move-dst-22" data-title="call_argument/call_expression">amount.sub(fee)</span></span>)</span>;
        claimableFees = claimableFees.add(fee);

        latestJoinBlock[tx.origin] = block.number;
        require(_currencyToken.transferFrom(msg.sender, address(this), amount));

        <span class="marker" id="mapping-179"></span><span class="token mv" id="move-dst-49" data-title="function_body/emit_statement">emit <span class="marker" id="mapping-180"></span><span class="token upd" id="move-dst-50" data-title="emit_statement/identifier">Joined</span>(msg.sender, <span class="marker" id="mapping-181"></span><span class="token upd" id="move-dst-51" data-title="call_argument/identifier">a<span class="cupd">mount</span></span>, <span class="marker" id="mapping-182"></span><span class="token add" data-title="emit_statement/call_argument">mintedAmount</span>);</span>
    }

    // prettier-ignore
    /**
     * @dev Exit pool
     * This function will withdraw a basket of currencies backing the pool value
     * @param amount amount of pool tokens to redeem for underlying tokens
     */
    function exit(uint256 amount) external override nonReentrant {
        require(block.number != latestJoinBlock[tx.origin], "TrueFiPool: Cannot join and exit in same block");
        require(amount &lt;= balanceOf(msg.sender), "TrueFiPool: insufficient funds");

        uint256 _totalSupply = totalSupply();

        // get share of currency tokens kept in the pool
        uint256 currencyAmountToTransfer = amount.mul(
            currencyBalance()).div(_totalSupply);

        // calculate amount of curve.fi pool tokens
        uint256 curveLiquidityAmountToTransfer = amount.mul(
            yTokenBalance()).div(_totalSupply);

        <span class="marker" id="mapping-183"></span><span class="token add" data-title="function_body/comment">// calculate amount of stake tokens</span>
        <span class="marker" id="mapping-184"></span><span class="token add" data-title="function_body/variable_declaration_statement"><span class="marker" id="mapping-185"></span><span class="token mv" id="move-dst-23" data-title="variable_declaration_statement/variable_declaration">uint256 <span class="marker" id="mapping-186"></span><span class="token upd" id="move-dst-24" data-title="variable_declaration/identifier">st<span class="cupd">a</span>keTokenA<span class="cupd">mountTo</span>Transfer</span></span> = <span class="marker" id="mapping-187"></span><span class="token add" data-title="variable_declaration_statement/call_expression">amount.mul(
            stakeTokenBalance()).div(_totalSupply)</span>;</span>

        // burn tokens sent
        _burn(msg.sender, amount);

        // withdraw basket of loan tokens
        _lender.distribute(msg.sender, amount, _totalSupply);

        // if currency remaining, transfer
        if (currencyAmountToTransfer &gt; 0) {
            require(_currencyToken.transfer(msg.sender, currencyAmountToTransfer));
        }
        // if curve tokens remaining, transfer
        if (curveLiquidityAmountToTransfer &gt; 0) {
            ensureEnoughTokensAreAvailable(curveLiquidityAmountToTransfer);
            require(_curvePool.token().transfer(msg.sender, curveLiquidityAmountToTransfer));
        }

        <span class="marker" id="mapping-188"></span><span class="token add" data-title="function_body/comment">// if stake token remaining, transfer</span>
        <span class="marker" id="mapping-189"></span><span class="token add" data-title="function_body/if_statement">if (stakeTokenAmountToTransfer &gt; 0) {
            require(_stakeToken.transfer(msg.sender, stakeTokenAmountToTransfer));
        }</span>

        emit Exited(msg.sender, amount);
    }

    <span class="marker" id="mapping-190"></span><span class="token add" data-title="contract_body/comment">/**
     * @dev Exit pool only with liquid tokens
     * This function will withdraw TUSD but with a small penalty
     * Uses the sync() modifier to reduce gas costs of using curve
     * @param amount amount of pool tokens to redeem for underlying tokens
     */</span>
    function liquidExit(uint256 amount) external nonReentrant <span class="marker" id="mapping-191"></span><span class="token add" data-title="function_definition/modifier_invocation">sync</span> {
        require(block.number != latestJoinBlock[tx.origin], "TrueFiPool: Cannot join and exit in same block");
        require(amount &lt;= balanceOf(msg.sender), "TrueFiPool: Insufficient funds");

        uint256 amountToWithdraw = poolValue().mul(amount).div(totalSupply());
        amountToWithdraw = amountToWithdraw.mul(liquidExitPenalty(amountToWithdraw)).div(10000);
        require(amountToWithdraw &lt;= liquidValue(), "TrueFiPool: Not enough liquidity in pool");

        // burn tokens sent
        _burn(msg.sender, amount);

        if (amountToWithdraw &gt; currencyBalance()) {
            removeLiquidityFromCurve(amountToWithdraw.sub(currencyBalance()));
            require(amountToWithdraw &lt;= currencyBalance(), "TrueFiPool: Not enough funds were withdrawn from Curve");
        }

        require(_currencyToken.transfer(msg.sender, amountToWithdraw));

        emit Exited(msg.sender, amountToWithdraw);
    }

    /**
     * @dev Penalty (in % * 100) applied if liquid exit is performed with this amount
     * returns 10000 if no penalty
     */
    function liquidExitPenalty(uint256 amount) public view returns (uint256) {
        uint256 lv = liquidValue();
        uint256 pv = poolValue();
        if (amount == pv) {
            return 10000;
        }
        uint256 liquidRatioBefore = lv.mul(10000).div(pv);
        uint256 liquidRatioAfter = lv.sub(amount).mul(10000).div(pv.sub(amount));
        return uint256(10000).sub(averageExitPenalty(liquidRatioAfter, liquidRatioBefore));
    }

    /**
     * @dev Calculates integral of 5/(x+50)dx times 10000
     */
    function integrateAtPoint(uint256 x) public pure returns (uint256) {
        return uint256(ABDKMath64x64.ln(ABDKMath64x64.fromUInt(x.add(50)))).mul(50000).div(2**64);
    }

    <span class="marker" id="mapping-192"></span><span class="token add" data-title="contract_body/comment">/**
     * @dev Calculates average penalty on interval [from; to]
     * @return average exit penalty
     */</span>
    function averageExitPenalty(uint256 from, uint256 to) public pure returns (uint256) {
        require(from &lt;= to, "TrueFiPool: To precedes from");
        if (from == 10000) {
            // When all liquid, dont penalize
            return 0;
        }
        if (from == to) {
            return uint256(50000).div(from.add(50));
        }
        return integrateAtPoint(to).sub(integrateAtPoint(from)).div(to.sub(from));
    }

    /**
     * @dev Deposit idle funds into curve.fi pool and stake in gauge
     * Called by owner to help manage funds in pool and save on gas for deposits
     * @param currencyAmount Amount of funds to deposit into curve
     * @param minMintAmount Minimum amount to mint
     */
    function flush(uint256 currencyAmount, uint256 minMintAmount) external <span class="marker" id="mapping-193"></span><span class="token add" data-title="function_definition/modifier_invocation">onlyOwnerOrManager</span> {
        require(currencyAmount &lt;= currencyBalance(), "TrueFiPool: Insufficient currency balance");

        uint256[N_TOKENS] memory amounts = [0, 0, 0, currencyAmount];

        // add TUSD to curve
        _currencyToken.approve(address(_curvePool), currencyAmount);
        _curvePool.add_liquidity(amounts, minMintAmount);

        // stake yCurve tokens in gauge
        uint256 yBalance = _curvePool.token().balanceOf(address(this));
        _curvePool.token().approve(address(_curveGauge), yBalance);
        _curveGauge.deposit(yBalance);

        emit Flushed(currencyAmount);
    }

    /**
     * @dev Remove liquidity from curve
     * @param yAmount amount of curve pool tokens
     * @param minCurrencyAmount minimum amount of tokens to withdraw
     */
    function pull(uint256 yAmount, uint256 minCurrencyAmount) external <span class="marker" id="mapping-194"></span><span class="token add" data-title="function_definition/modifier_invocation">onlyOwnerOrManager</span> {
        require(yAmount &lt;= yTokenBalance(), "TrueFiPool: Insufficient Curve liquidity balance");

        // unstake in gauge
        ensureEnoughTokensAreAvailable(yAmount);

        // remove TUSD from curve
        _curvePool.token().approve(address(_curvePool), yAmount);
        _curvePool.remove_liquidity_one_coin(yAmount, TUSD_INDEX, minCurrencyAmount, false);

        emit Pulled(yAmount);
    }

    // prettier-ignore
    <span class="marker" id="mapping-195"></span><span class="token add" data-title="contract_body/comment">/**
     * @dev Remove liquidity from curve if necessary and transfer to lender
     * @param amount amount for lender to withdraw
     */</span>
    function borrow(<span class="marker" id="mapping-196"></span><span class="token add" data-title="function_definition/parameter">uint256 amount</span>, uint256 <span class="marker" id="mapping-197"></span><span class="token upd" id="move-dst-42" data-title="parameter/identifier">f<span class="cupd">ee</span></span>) external override nonReentrant onlyLender {
        // if there is not enough TUSD, withdraw from curve
        if (<span class="marker" id="mapping-198"></span><span class="token upd" id="move-dst-44" data-title="binary_expression/identifier">a<span class="cupd">mount</span></span> &gt; currencyBalance()) {
            removeLiquidityFromCurve(<span class="marker" id="mapping-199"></span><span class="token upd" id="move-dst-45" data-title="member_expression/identifier">a<span class="cupd">mount</span></span>.sub(currencyBalance()));
            require(<span class="marker" id="mapping-200"></span><span class="token upd" id="move-dst-46" data-title="binary_expression/identifier">a<span class="cupd">mount</span></span> &lt;= currencyBalance(), "TrueFiPool: Not enough funds in pool to cover borrow");
        }

        <span class="marker" id="mapping-201"></span><span class="token add" data-title="expression_statement/call_expression">mint(fee)</span>;
        require(_currencyToken.transfer(msg.sender, <span class="marker" id="mapping-202"></span><span class="token add" data-title="call_argument/call_expression">amount.sub(fee)</span>));

        <span class="marker" id="mapping-203"></span><span class="token mv" id="move-dst-30" data-title="function_body/emit_statement">emit <span class="marker" id="mapping-204"></span><span class="token upd" id="move-dst-31" data-title="emit_statement/identifier">Borrow</span>(msg.sender, amount, <span class="marker" id="mapping-205"></span><span class="token mv" id="move-dst-52" data-title="emit_statement/call_argument">fee</span>);</span>
    }

    function removeLiquidityFromCurve(uint256 amountToWithdraw) internal {
        // get rough estimate of how much yCRV we should sell
        uint256 roughCurveTokenAmount = calcTokenAmount(amountToWithdraw).mul(1005).div(1000);
        require(roughCurveTokenAmount &lt;= yTokenBalance(), "TrueFiPool: Not enough Curve liquidity tokens in pool to cover borrow");
        // pull tokens from gauge
        ensureEnoughTokensAreAvailable(roughCurveTokenAmount);
        // remove TUSD from curve
        _curvePool.token().approve(address(_curvePool), roughCurveTokenAmount);
        uint256 minAmount = roughCurveTokenAmount.mul(_curvePool.curve().get_virtual_price()).mul(999).div(1000).div(1 ether);
        _curvePool.remove_liquidity_one_coin(roughCurveTokenAmount, TUSD_INDEX, minAmount, false);
    }

    /**
     * @dev repay debt by transferring tokens to the contract
     * @param currencyAmount amount to repay
     */
    function repay(uint256 currencyAmount) external override onlyLender {
        require(_currencyToken.transferFrom(msg.sender, address(this), currencyAmount));
        emit Repaid(msg.sender, currencyAmount);
    }

    /**
     * @dev Collect CRV tokens minted by staking at gauge
     */
    function collectCrv() external <span class="marker" id="mapping-206"></span><span class="token add" data-title="function_definition/modifier_invocation">onlyOwnerOrManager</span> {
        _minter.mint(address(_curveGauge));
    }

    /**
     * @dev Sell collected CRV on Uniswap
     * - Selling CRV is managed by the contract owner
     * - Calculations can be made off-chain and called based on market conditions
     * - Need to pass path of exact pairs to go through while executing exchange
     * For example, CRV -&gt; WETH -&gt; TUSD
     *
     * @param amountIn see https://uniswap.org/docs/v2/smart-contracts/router02/#swapexacttokensfortokens
     * @param amountOutMin see https://uniswap.org/docs/v2/smart-contracts/router02/#swapexacttokensfortokens
     * @param path see https://uniswap.org/docs/v2/smart-contracts/router02/#swapexacttokensfortokens
     */
    function sellCrv(
        uint256 amountIn,
        uint256 amountOutMin,
        address[] calldata path
    ) public <span class="marker" id="mapping-207"></span><span class="token upd" id="move-dst-54" data-title="modifier_invocation/identifier"><span class="cupd">onlyOwner</span>OrManager</span> {
        _minter.token().approve(address(_uniRouter), amountIn);
        _uniRouter.swapExactTokensForTokens(amountIn, amountOutMin, path, address(this), block.timestamp + 1 hours);
    }

    <span class="marker" id="mapping-208"></span><span class="token add" data-title="contract_body/comment">/**
     * @dev Sell collected TRU on Uniswap
     * - Selling TRU is managed by the contract owner
     * - Calculations can be made off-chain and called based on market conditions
     * - Need to pass path of exact pairs to go through while executing exchange
     * For example, CRV -&gt; WETH -&gt; TUSD
     *
     * @param amountIn see https://uniswap.org/docs/v2/smart-contracts/router02/#swapexacttokensfortokens
     * @param amountOutMin see https://uniswap.org/docs/v2/smart-contracts/router02/#swapexacttokensfortokens
     * @param path see https://uniswap.org/docs/v2/smart-contracts/router02/#swapexacttokensfortokens
     */</span>
    <span class="marker" id="mapping-209"></span><span class="token add" data-title="contract_body/function_definition">function sellStakeToken(
        <span class="marker" id="mapping-210"></span><span class="token add" data-title="function_definition/parameter">uint256 amountIn</span>,
        <span class="marker" id="mapping-211"></span><span class="token add" data-title="function_definition/parameter">uint256 amountOutMin</span>,
        <span class="marker" id="mapping-212"></span><span class="token add" data-title="function_definition/parameter">address[] calldata path</span>
    ) <span class="marker" id="mapping-213"></span><span class="token add" data-title="function_definition/visibility">public</span> <span class="marker" id="mapping-214"></span><span class="token add" data-title="function_definition/modifier_invocation">onlyOwnerOrManager</span> <span class="marker" id="mapping-215"></span><span class="token add" data-title="function_definition/function_body">{
        <span class="marker" id="mapping-216"></span><span class="token mv" id="move-dst-4" data-title="function_body/expression_statement"><span class="marker" id="mapping-217"></span><span class="token upd" id="move-dst-5" data-title="member_expression/identifier"><span class="cupd">_</span>stak<span class="cupd">e</span><span class="cupd">Token</span></span>.approve(address(<span class="marker" id="mapping-218"></span><span class="token upd" id="move-dst-6" data-title="call_argument/identifier"><span class="cupd">_</span><span class="cupd">u</span>niRouter</span>), <span class="marker" id="mapping-219"></span><span class="token add" data-title="call_argument/identifier">amountIn</span>);</span>
        <span class="marker" id="mapping-220"></span><span class="token mv" id="move-dst-7" data-title="function_body/expression_statement"><span class="marker" id="mapping-221"></span><span class="token upd" id="move-dst-9" data-title="member_expression/identifier">_uniR<span class="cupd">o</span>uter</span><span class="marker" id="mapping-222"></span><span class="token mv" id="move-dst-8" data-title="member_expression/.">.</span><span class="marker" id="mapping-223"></span><span class="token add" data-title="member_expression/identifier">swapExactTokensForTokens</span>(<span class="marker" id="mapping-224"></span><span class="token add" data-title="call_expression/call_argument">amountIn</span>, <span class="marker" id="mapping-225"></span><span class="token add" data-title="call_expression/call_argument">amountOutMin</span><span class="marker" id="mapping-226"></span><span class="token add" data-title="call_expression/,">,</span> <span class="marker" id="mapping-227"></span><span class="token add" data-title="call_expression/call_argument">path</span><span class="marker" id="mapping-228"></span><span class="token add" data-title="call_expression/,">,</span> <span class="marker" id="mapping-229"></span><span class="token mv" id="move-dst-10" data-title="call_expression/call_argument">address(<span class="marker" id="mapping-230"></span><span class="token upd" id="move-dst-11" data-title="call_argument/identifier">this</span>)</span><span class="marker" id="mapping-231"></span><span class="token add" data-title="call_expression/,">,</span> <span class="marker" id="mapping-232"></span><span class="token add" data-title="call_expression/call_argument">block.timestamp + 1 hours</span>);</span>
    }</span></span>

    /**
     * @dev Claim fees from the pool
     * @param beneficiary account to send funds to
     */
    function collectFees(address beneficiary) external <span class="marker" id="mapping-233"></span><span class="token upd" id="move-dst-55" data-title="modifier_invocation/identifier"><span class="cupd">onlyOwner</span>OrManager</span> {
        uint256 amount = claimableFees;
        claimableFees = 0;

        if (amount &gt; 0) {
            require(_currencyToken.transfer(beneficiary, amount));
        }

        emit Collected(beneficiary, amount);
    }

    <span class="marker" id="mapping-234"></span><span class="token add" data-title="contract_body/comment">/**
     * @notice Expected amount of minted Curve.fi yDAI/yUSDC/yUSDT/yTUSD tokens.
     * Can be used to control slippage
     * Called in flush() function
     * @param currencyAmount amount to calculate for
     * @return expected amount minted given currency amount
     */</span>
    function calcTokenAmount(uint256 currencyAmount) public view returns (uint256) {
        // prettier-ignore
        uint256 yTokenAmount = currencyAmount.mul(1e18).div(
            _curvePool.coins(TUSD_INDEX).getPricePerFullShare());
        uint256[N_TOKENS] memory yAmounts = [0, 0, 0, yTokenAmount];
        return _curvePool.curve().calc_token_amount(yAmounts, true);
    }

    /**
     * @dev Converts the value of a single yCRV into an underlying asset
     * @param yAmount amount of curve pool tokens to calculate for
     * @return Value of one y pool token
     */
    function calcWithdrawOneCoin(uint256 yAmount) public view returns (uint256) {
        return _curvePool.calc_withdraw_one_coin(yAmount, TUSD_INDEX);
    }

    /**
     * @dev Currency token balance
     * @return Currency token balance
     */
    function currencyBalance() internal view returns (uint256) {
        return _currencyToken.balanceOf(address(this)).sub(claimableFees);
    }

    <span class="marker" id="mapping-235"></span><span class="token add" data-title="contract_body/comment">/**
     * @param depositedAmount Amount of currency deposited
     * @return amount minted from this transaction
     */</span>
    <span class="marker" id="mapping-236"></span><span class="token add" data-title="contract_body/function_definition">function mint(<span class="marker" id="mapping-237"></span><span class="token mv" id="move-dst-40" data-title="function_definition/parameter">uint256 <span class="marker" id="mapping-238"></span><span class="token upd" id="move-dst-41" data-title="parameter/identifier">d<span class="cupd">e</span><span class="cupd">p</span>osi<span class="cupd">tedAmount</span></span></span>) <span class="marker" id="mapping-239"></span><span class="token add" data-title="function_definition/visibility">internal</span> <span class="marker" id="mapping-240"></span><span class="token add" data-title="function_definition/return_type_definition">returns (uint256)</span> <span class="marker" id="mapping-241"></span><span class="token add" data-title="function_definition/function_body">{
        <span class="marker" id="mapping-242"></span><span class="token add" data-title="function_body/variable_declaration_statement">uint256 mintedAmount = depositedAmount;</span>
        <span class="marker" id="mapping-243"></span><span class="token add" data-title="function_body/if_statement">if (mintedAmount == 0) {
            return mintedAmount;
        }</span>

        // first staker mints same amount deposited
        <span class="marker" id="mapping-244"></span><span class="token mv" id="move-dst-25" data-title="function_body/if_statement">if (totalSupply() &gt; 0) {
            <span class="marker" id="mapping-245"></span><span class="token upd" id="move-dst-26" data-title="assignment_expression/identifier"><span class="cupd">m</span>i<span class="cupd">nt</span>edAm<span class="cupd">o</span>u<span class="cupd">nt</span></span> = totalSupply().mul(<span class="marker" id="mapping-246"></span><span class="token upd" id="move-dst-27" data-title="call_argument/identifier">d<span class="cupd">eposit</span>edAmount</span>).div(poolValue());
        }</span>
        // mint pool tokens
        <span class="marker" id="mapping-247"></span><span class="token mv" id="move-dst-28" data-title="function_body/expression_statement">_mint(msg.sender, <span class="marker" id="mapping-248"></span><span class="token upd" id="move-dst-29" data-title="call_argument/identifier"><span class="cupd">m</span>i<span class="cupd">nt</span>edAm<span class="cupd">o</span>u<span class="cupd">nt</span></span>);</span>

        <span class="marker" id="mapping-249"></span><span class="token add" data-title="function_body/return_statement">return mintedAmount;</span>
    }</span></span>

    <span class="marker" id="mapping-250"></span><span class="token add" data-title="contract_body/comment">/**
     * @dev Update name and symbol of this contract
     */</span>
    <span class="marker" id="mapping-251"></span><span class="token add" data-title="contract_body/function_definition">function updateNameAndSymbol() <span class="marker" id="mapping-252"></span><span class="token add" data-title="function_definition/visibility">public</span> <span class="marker" id="mapping-253"></span><span class="token add" data-title="function_definition/function_body">{
        <span class="marker" id="mapping-254"></span><span class="token mv" id="move-dst-43" data-title="function_body/expression_statement"><span class="marker" id="mapping-255"></span><span class="token add" data-title="call_expression/member_expression">super.updateNameAndSymbol</span>(<span class="marker" id="mapping-256"></span><span class="token add" data-title="call_argument/string_literal">"TrueFi TrueUSD"</span>, "tfTUSD");</span>
    }</span></span>
}</pre></div></div></div></body></html>