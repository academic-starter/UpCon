<html lang="en"><head><meta charset="utf8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>GumTree</title><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css"><style type="text/css">/*
 * This file is part of GumTree.
 *
 * GumTree is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * GumTree is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with GumTree.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Copyright 2011-2015 Jean-Rémy Falleri <jr.falleri@gmail.com>
 * Copyright 2011-2015 Floréal Morandat <florealm@gmail.com>
 */

.add {
	border: 1px solid black;
	background-color: MediumSeaGreen;
}

.del {
	border: 1px solid black;
	background-color: IndianRed;
}

.mv {
	border: 1px solid black;
	background-color: Plum;
}

.upd {
	border: 1px solid black;
	background-color: DarkOrange;
	font-weight: bold;
}

.cupd {
	font-weight: normal;
	color: DimGray;
}

.selected {
	background-color: Gold;
}

.marker {
	margin: 0;
	padding: 0;
}

div {
	margin: 0px;
	padding: 0px;
}

.pre-scrollable {
	margin: 0px;
	padding: 0px;
	font-size: 10pt;
	color: black;
	max-height: 90vh;
	background-color: white;
	border: 1px solid black;
	font-family: "Hack, Inconsolata", "Consolas", "Liberation Sans Regular", "DejaVu Sans Mono", monospace;
}

.tooltip-inner {
    max-width: none;
}
</style><script type="text/javascript" src="https://code.jquery.com/jquery-3.4.1.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/js/bootstrap.bundle.min.js"></script><script type="text/javascript">/*
 * This file is part of GumTree.
 *
 * GumTree is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * GumTree is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with GumTree.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Copyright 2011-2015 Jean-Rémy Falleri <jr.falleri@gmail.com>
 * Copyright 2011-2015 Floréal Morandat <florealm@gmail.com>
 */

$(function(){
    let popoverTriggerList = [].slice.call(document.querySelectorAll('[data-bs-toggle="popover"]'))
    let popoverList = popoverTriggerList.map(function (popoverTriggerEl) {
      return new bootstrap.Popover(popoverTriggerEl)
    })

    $("body").keypress(function (event) {
        switch (event.which) {
            case 116:
                $('html, body').animate({scrollTop: 0}, 100);
                break;
            case 98:
                $("html, body").animate({ scrollTop: $(document).height() }, 100);
                break;
            case 113:
                window.location = "/quit";
                break;
            case 108:
                window.location = "/list";
                break;
        }
    });
});
</script><script type="text/javascript">/*
 * This file is part of GumTree.
 *
 * GumTree is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * GumTree is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with GumTree.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Copyright 2011-2015 Jean-Rémy Falleri <jr.falleri@gmail.com>
 * Copyright 2011-2015 Floréal Morandat <florealm@gmail.com>
 */

currentMapping = 0;

if (typeof String.prototype.startsWith != 'function') {
  String.prototype.startsWith = function (str){
    return this.slice(0, str.length) == str;
  };
}

function getMappedElement(eltId) {
	if (eltId.startsWith("move-src")) {
		return eltId.replace("src","dst");  	 	
  	}
  	else {
  		return eltId.replace("dst","src");
  	}
}

function nextMapping() {
	if (currentMapping == 0) {
		currentMapping = 1;
		return "#mapping-" + currentMapping.toString();
	} else {
		currentMapping++;
		
		if ($("#mapping-" + currentMapping.toString()).length > 0) {
			return "#mapping-" + currentMapping.toString();
		} else {
			currentMapping = 1;
			return "#mapping-" + currentMapping.toString();		
		}		
	}
}

function isSrc(eltId) {
	return eltId.startsWith("move-src");
}

$(function() {
    $("body").keypress(function (event) {
        switch(event.which) {
            case 110:
                const mapping = $(nextMapping());
                const pre = mapping.closest("pre");
                pre.animate({scrollTop: pre.scrollTop() + mapping.position().top - 200}, 100);
                break;
        }
    });

    // highlight
    $("span.mv.token, span.token.upd").click(function(event) {
        if ($(this).hasClass("selected")) {
            $("span.mv.token, span.token.upd").removeClass("selected");
        } else {
            $("span.mv.token, span.token.upd").removeClass("selected");
            const refElt = $("#" + getMappedElement($(this).attr("id")));
            $(this).addClass("selected");
            refElt.addClass("selected");
            const pre = refElt.closest("pre");
            console.log(pre);
            pre.animate({scrollTop: pre.scrollTop() + refElt.position().top - 200}, 100);
        }
        event.stopPropagation();
    });
    
    $("span.add.token, span.token.del").click(function(event) {
        $("span.mv.token, span.token.upd").removeClass("selected");
        event.stopPropagation();
    });

    // tooltip
    $("span.token").hover(
    	function (event) {
    		$(this).tooltip('show');
    		event.stopPropagation();
    	},
    	function (event) {
    		$(this).tooltip('hide');
    		event.stopPropagation();
    	}
    );
});
</script></head><body><div class="container-fluid"><div class="row"><div class="col"><div class="btn-toolbar justify-content-end"><div class="btn-group mr-2"><button class="btn btn-primary btn-sm" id="legend" data-bs-toggle="popover" data-bs-placement="bottom" data-bs-html="true" data-bs-content="<span class='del'>&nbsp;&nbsp;</span> deleted<br><span class='add'>&nbsp;&nbsp;</span> added<br><span class='mv'>&nbsp;&nbsp;</span> moved<br><span class='upd';>&nbsp;&nbsp;</span> updated<br>">Legend</button><button class="btn btn-primary btn-sm" id="shortcuts" data-bs-toggle="popover" data-bs-placement="bottom" data-bs-html="true" data-bs-content="<b>q</b> quit<br><b>l</b> list<br><b>n</b> next<br><b>t</b> top<br><b>b</b> bottom">Shortcuts</button></div><div class="btn-group"><a href="/list" class="btn btn-default btn-sm btn-primary">Back</a><a href="/quit" class="btn btn-default btn-sm btn-danger">Quit</a></div></div></div></div><div class="row"><div class="col-6"><h5>ACOPoolLib.sol</h5><pre class="pre-scrollable">pragma solidity ^0.6.6;
pragma experimental ABIEncoderV2;

import "./SafeMath.sol";
import "./IACOPoolStrategy.sol";
import "./IACOFactory.sol";
import "./IACOToken.sol";
import "./ILendingPool.sol";
import "./IACOPool2.sol";

library ACOPoolLib {
	using SafeMath for uint256;
	
	struct OpenPositionData {
	    bool isDeposit;
	    bool isCall;
	    uint256 underlyingPrice;
	    uint256 baseVolatility;
	    uint256 underlyingPriceAdjustPercentage;
	    uint256 withdrawOpenPositionPenalty;
	    uint256 fee;
	    uint256 underlyingPrecision;
	    address underlying;
	    address strikeAsset;
	    address strategy;
	    address acoFactory;
	    address lendingToken;
	}
	
	struct QuoteData {
		address lendingToken;
		address strategy;
		uint256 baseVolatility;
		uint256 fee;
		uint256 underlyingPrice;
		uint256 underlyingPrecision;
		AcoData acoData;
		IACOPool2.<span class="marker" id="mapping-1"></span><span class="token upd" id="move-src-1" data-title="user_defined_type/identifier"><span class="cupd">PoolAcoPermissionConfig</span></span> acoPermissionConfig;
	}
	
	struct AcoData {
        bool isCall;
        uint256 strikePrice; 
        uint256 expiryTime;
        uint256 tokenAmount;
	    address underlying;
        address strikeAsset; 
	}
	
	uint256 public constant PERCENTAGE_PRECISION = 100000;
	
	function name(address underlying, address strikeAsset, bool isCall) public view returns(string memory) {
        return string(abi.encodePacked(
            "ACO POOL WRITE ",
            _getAssetSymbol(underlying),
            "-",
            _getAssetSymbol(strikeAsset),
            "-",
            (isCall ? "CALL" : "PUT")
        ));
    }
    
    function acoStrikeAndExpirationIsValid(
		uint256 strikePrice, 
        uint256 acoExpiryTime, 
		uint256 underlyingPrice,
        IACOPool2.<span class="marker" id="mapping-2"></span><span class="token upd" id="move-src-2" data-title="user_defined_type/identifier"><span class="cupd">PoolAcoPermissionConfig</span></span> memory acoPermissionConfig
    ) public view returns(bool) {
        return _acoExpirationIsValid(acoExpiryTime, acoPermissionConfig) &amp;&amp; _acoStrikePriceIsValid(strikePrice, underlyingPrice, acoPermissionConfig);
    }

    function getBaseAssetsWithdrawWithLocked(
        uint256 shares,
        address underlying,
        address strikeAsset,
        bool isCall,
        uint256 totalSupply,
        address lendingToken
    ) public view returns(
        uint256 underlyingWithdrawn,
		uint256 strikeAssetWithdrawn
    ) {
		uint256 underlyingBalance = _getPoolBalanceOf(underlying);
		uint256 strikeAssetBalance;
		if (isCall) {
		    strikeAssetBalance = _getPoolBalanceOf(strikeAsset);
		} else {
		    strikeAssetBalance = _getPoolBalanceOf(lendingToken);
		}
		
		underlyingWithdrawn = underlyingBalance.mul(shares).div(totalSupply);
		strikeAssetWithdrawn = strikeAssetBalance.mul(shares).div(totalSupply);
    }
    
    function getBaseWithdrawNoLockedData(
        uint256 shares,
        uint256 totalSupply,
        bool isCall,
        uint256 underlyingBalance, 
        uint256 strikeAssetBalance, 
        uint256 collateralBalance, 
        uint256 collateralLockedRedeemable
    ) public pure returns(
        uint256 underlyingWithdrawn,
		uint256 strikeAssetWithdrawn,
		bool isPossible
    ) {
		uint256 collateralAmount = shares.mul(collateralBalance).div(totalSupply);
		
		if (isCall) {
			underlyingWithdrawn = collateralAmount;
			strikeAssetWithdrawn = strikeAssetBalance.mul(shares).div(totalSupply);
			isPossible = (collateralAmount &lt;= underlyingBalance.add(collateralLockedRedeemable));
		} else {
			strikeAssetWithdrawn = collateralAmount;
			underlyingWithdrawn = underlyingBalance.mul(shares).div(totalSupply);
			isPossible = (collateralAmount &lt;= strikeAssetBalance.add(collateralLockedRedeemable));
		}
    }
    
    function getAmountToLockedWithdraw(
        uint256 shares, 
        uint256 totalSupply, 
        address lendingToken,
        address underlying, 
        address strikeAsset, 
        bool isCall
    ) public view returns(
        uint256 underlyingWithdrawn, 
        uint256 strikeAssetWithdrawn
    ) {
		uint256 underlyingBalance = _getPoolBalanceOf(underlying);
		uint256 strikeAssetBalance;
		if (isCall) {
		    strikeAssetBalance = _getPoolBalanceOf(strikeAsset);
		} else {
		    strikeAssetBalance = _getPoolBalanceOf(lendingToken);
		}
		
		underlyingWithdrawn = underlyingBalance.mul(shares).div(totalSupply);
		strikeAssetWithdrawn = strikeAssetBalance.mul(shares).div(totalSupply);
    }
    
    function getAmountToNoLockedWithdraw(
        uint256 shares, 
        uint256 totalSupply,
        uint256 underlyingBalance, 
        uint256 strikeAssetBalance,
        uint256 collateralBalance,
        uint256 minCollateral,
        bool isCall
    ) public pure returns(
        uint256 underlyingWithdrawn, 
        uint256 strikeAssetWithdrawn
    ) {
		uint256 collateralAmount = shares.mul(collateralBalance).div(totalSupply);
		require(collateralAmount &gt;= minCollateral, "ACOPoolLib: The minimum collateral was not satisfied");

        if (isCall) {
			require(collateralAmount &lt;= underlyingBalance, "ACOPoolLib: Collateral balance is not sufficient");
			underlyingWithdrawn = collateralAmount;
			strikeAssetWithdrawn = strikeAssetBalance.mul(shares).div(totalSupply);
        } else {
			require(collateralAmount &lt;= strikeAssetBalance, "ACOPoolLib: Collateral balance is not sufficient");
			strikeAssetWithdrawn = collateralAmount;
			underlyingWithdrawn = underlyingBalance.mul(shares).div(totalSupply);
		}
    }
    
    function quote(QuoteData memory data) public view returns(
        uint256 swapPrice, 
        uint256 protocolFee, 
        uint256 volatility, 
        uint256 collateralAmount
    ) {
        AcoData memory acoData = data.acoData;
        require(_acoExpirationIsValid(acoData.expiryTime, data.acoPermissionConfig), "ACOPoolLib: Invalid ACO token expiration");
		require(_acoStrikePriceIsValid(acoData.strikePrice, data.underlyingPrice, data.acoPermissionConfig), "ACOPoolLib: Invalid ACO token strike price");

        uint256 collateralAvailable;
        (collateralAmount, collateralAvailable) = _getOrderSizeData(data.lendingToken, data.underlyingPrecision, acoData);
        uint256 calcPrice;
        (calcPrice, volatility) = _strategyQuote(data.strategy, data.underlyingPrice, data.baseVolatility, collateralAmount, collateralAvailable, acoData);
        (swapPrice, protocolFee) = _setSwapPriceAndFee(calcPrice, acoData.tokenAmount, data.fee, data.underlyingPrecision);
    }

	function getCollateralData(OpenPositionData memory data, address[] memory openAcos) public view returns(
        uint256 underlyingBalance, 
        uint256 strikeAssetBalance, 
        uint256 collateralBalance,
        uint256 collateralLocked,
        uint256 collateralOnOpenPosition,
        uint256 collateralLockedRedeemable
    ) {
		(underlyingBalance, strikeAssetBalance, collateralBalance) = _getBaseCollateralData(
            data.isDeposit, 
            data.underlying,
            data.strikeAsset,
            data.isCall,
            data.underlyingPrice,
            data.lendingToken,
            data.underlyingPriceAdjustPercentage,
            data.underlyingPrecision);
            
		(collateralLocked, collateralOnOpenPosition, collateralLockedRedeemable) = _poolOpenPositionCollateralBalance(data, openAcos);
	}
	
	function _getBaseCollateralData(
	    bool isDeposit,
	    address underlying,
	    address strikeAsset,
	    bool isCall,
	    uint256 underlyingPrice,
	    address lendingToken,
	    uint256 underlyingPriceAdjustPercentage,
	    uint256 underlyingPrecision
	) internal view returns(
        uint256 underlyingBalance, 
        uint256 strikeAssetBalance, 
        uint256 collateralBalance
    ) {
		underlyingBalance = _getPoolBalanceOf(underlying);
		
		if (isCall) {
		    strikeAssetBalance = _getPoolBalanceOf(strikeAsset);
			collateralBalance = underlyingBalance;
			if (isDeposit &amp;&amp; strikeAssetBalance &gt; 0) {
				uint256 priceAdjusted = _getUnderlyingPriceAdjusted(underlyingPrice, underlyingPriceAdjustPercentage, false); 
				collateralBalance = collateralBalance.add(strikeAssetBalance.mul(underlyingPrecision).div(priceAdjusted));
			}
		} else {
		    strikeAssetBalance = _getPoolBalanceOf(lendingToken);
			collateralBalance = strikeAssetBalance;
			if (isDeposit &amp;&amp; underlyingBalance &gt; 0) {
				uint256 priceAdjusted = _getUnderlyingPriceAdjusted(underlyingPrice, underlyingPriceAdjustPercentage, true); 
				collateralBalance = collateralBalance.add(underlyingBalance.mul(priceAdjusted).div(underlyingPrecision));
			}
		}
	}

	function _poolOpenPositionCollateralBalance(OpenPositionData memory data, address[] memory openAcos) internal view returns(
        uint256 collateralLocked, 
        uint256 collateralOnOpenPosition,
        uint256 collateralLockedRedeemable
    ) {
		for (uint256 i = 0; i &lt; openAcos.length; ++i) {
			address acoToken = openAcos[i];
            
            (uint256 locked, uint256 openPosition, uint256 lockedRedeemable) = _getOpenPositionCollateralBalance(acoToken, data);
            
            collateralLocked = collateralLocked.add(locked);
            collateralOnOpenPosition = collateralOnOpenPosition.add(openPosition);
            collateralLockedRedeemable = collateralLockedRedeemable.add(lockedRedeemable);
		}
		if (!data.isDeposit) {
			collateralOnOpenPosition = collateralOnOpenPosition.mul(PERCENTAGE_PRECISION.add(data.withdrawOpenPositionPenalty)).div(PERCENTAGE_PRECISION);
		}
	}
	
	function _getOpenPositionCollateralBalance(address acoToken, OpenPositionData memory data) internal view returns(
        uint256 collateralLocked, 
        uint256 collateralOnOpenPosition,
        uint256 collateralLockedRedeemable
    ) {
        AcoData memory acoData = _getOpenPositionCollateralExtraData(acoToken, data.acoFactory);
        collateralLocked = _getCollateralAmount(acoData.tokenAmount, acoData.strikePrice, acoData.isCall, data.underlyingPrecision);
        
        if (acoData.expiryTime &gt; block.timestamp) {
    		(uint256 price,) = _strategyQuote(data.strategy, data.underlyingPrice, data.baseVolatility, 0, 1, acoData);
    		if (data.fee &gt; 0) {
    		    price = price.mul(PERCENTAGE_PRECISION.add(data.fee)).div(PERCENTAGE_PRECISION);
    		}
    		if (acoData.isCall) {
    			uint256 priceAdjusted = _getUnderlyingPriceAdjusted(data.underlyingPrice, data.underlyingPriceAdjustPercentage, false); 
    			collateralOnOpenPosition = price.mul(acoData.tokenAmount).div(priceAdjusted);
    		} else {
    			collateralOnOpenPosition = price.mul(acoData.tokenAmount).div(data.underlyingPrecision);
    		}
        } else {
            collateralLockedRedeemable = collateralLocked;
        }
    }
    
	function <span class="marker" id="mapping-3"></span><span class="token upd" id="move-src-3" data-title="function_definition/identifier"><span class="cupd">_</span><span class="cupd">a</span>coS<span class="cupd">t</span><span class="cupd">ri</span>k<span class="cupd">eP</span><span class="cupd">r</span>i<span class="cupd">ce</span>IsV<span class="cupd">a</span>lid</span>(
		<span class="marker" id="mapping-4"></span><span class="token mv" id="move-src-4" data-title="function_definition/parameter">uint256 strikePrice</span>, 
		<span class="marker" id="mapping-5"></span><span class="token mv" id="move-src-5" data-title="function_definition/parameter">uint256 underlyingPrice</span>,
		<span class="marker" id="mapping-6"></span><span class="token del" data-title="function_definition/parameter">IACOPool2.PoolAcoPermissionConfig memory acoPermissionConfig</span>
	) <span class="marker" id="mapping-7"></span><span class="token mv" id="move-src-6" data-title="function_definition/visibility">internal</span> <span class="marker" id="mapping-8"></span><span class="token mv" id="move-src-7" data-title="function_definition/state_mutability">pure</span> <span class="marker" id="mapping-9"></span><span class="token mv" id="move-src-8" data-title="function_definition/return_type_definition">returns(bool)</span> {
	    <span class="marker" id="mapping-10"></span><span class="token del" data-title="function_body/return_statement">return <span class="marker" id="mapping-11"></span><span class="token del" data-title="return_statement/parenthesized_expression">(
	        <span class="marker" id="mapping-12"></span><span class="token del" data-title="parenthesized_expression/binary_expression"><span class="marker" id="mapping-13"></span><span class="token del" data-title="binary_expression/binary_expression"><span class="marker" id="mapping-14"></span><span class="token del" data-title="binary_expression/binary_expression"><span class="marker" id="mapping-15"></span><span class="token del" data-title="binary_expression/parenthesized_expression">(<span class="marker" id="mapping-16"></span><span class="token del" data-title="parenthesized_expression/call_expression"><span class="marker" id="mapping-17"></span><span class="token del" data-title="call_expression/member_expression"><span class="marker" id="mapping-18"></span><span class="token del" data-title="member_expression/binary_expression"><span class="marker" id="mapping-19"></span><span class="token del" data-title="binary_expression/binary_expression">acoPermissionConfig.tolerancePriceBelowMin == 0</span> || <span class="marker" id="mapping-20"></span><span class="token del" data-title="binary_expression/binary_expression">strikePrice &lt;= <span class="marker" id="mapping-21"></span><span class="token del" data-title="binary_expression/call_expression"><span class="marker" id="mapping-22"></span><span class="token del" data-title="call_expression/member_expression">underlyingPrice.mul</span>(<span class="marker" id="mapping-23"></span><span class="token del" data-title="call_expression/call_argument"><span class="marker" id="mapping-24"></span><span class="token del" data-title="call_argument/call_expression"><span class="marker" id="mapping-25"></span><span class="token del" data-title="call_expression/member_expression">PERCENTAGE_PRECISION.sub</span>(<span class="marker" id="mapping-26"></span><span class="token mv" id="move-src-9" data-title="call_expression/call_argument">acoPermissionConfig.tolerancePriceBelowMin</span>)</span></span>)</span></span></span>.div</span>(<span class="marker" id="mapping-27"></span><span class="token del" data-title="call_expression/call_argument">PERCENTAGE_PRECISION</span>)</span>)</span>
	        &amp;&amp; <span class="marker" id="mapping-28"></span><span class="token del" data-title="binary_expression/parenthesized_expression">(<span class="marker" id="mapping-29"></span><span class="token mv" id="move-src-10" data-title="parenthesized_expression/call_expression"><span class="marker" id="mapping-30"></span><span class="token del" data-title="member_expression/binary_expression"><span class="marker" id="mapping-31"></span><span class="token del" data-title="binary_expression/binary_expression">acoPermissionConfig.tolerancePriceBelowMax == 0</span> || <span class="marker" id="mapping-32"></span><span class="token del" data-title="binary_expression/binary_expression">strikePrice &gt;= <span class="marker" id="mapping-33"></span><span class="token mv" id="move-src-11" data-title="binary_expression/call_expression">underlyingPrice.mul(PERCENTAGE_PRECISION.sub(<span class="marker" id="mapping-34"></span><span class="token mv" id="move-src-12" data-title="call_expression/call_argument">acoPermissionConfig.tolerancePriceBelowMax</span>))</span></span></span>.div(<span class="marker" id="mapping-35"></span><span class="token del" data-title="call_expression/call_argument">PERCENTAGE_PRECISION</span>)</span>)</span></span>
	        &amp;&amp; <span class="marker" id="mapping-36"></span><span class="token del" data-title="binary_expression/parenthesized_expression">(<span class="marker" id="mapping-37"></span><span class="token del" data-title="parenthesized_expression/call_expression"><span class="marker" id="mapping-38"></span><span class="token del" data-title="call_expression/member_expression"><span class="marker" id="mapping-39"></span><span class="token del" data-title="member_expression/binary_expression"><span class="marker" id="mapping-40"></span><span class="token del" data-title="binary_expression/binary_expression">acoPermissionConfig.tolerancePriceAboveMin == 0</span> || <span class="marker" id="mapping-41"></span><span class="token del" data-title="binary_expression/binary_expression">strikePrice &gt;= <span class="marker" id="mapping-42"></span><span class="token del" data-title="binary_expression/call_expression"><span class="marker" id="mapping-43"></span><span class="token del" data-title="call_expression/member_expression">underlyingPrice.mul</span>(<span class="marker" id="mapping-44"></span><span class="token del" data-title="call_expression/call_argument"><span class="marker" id="mapping-45"></span><span class="token del" data-title="call_argument/call_expression"><span class="marker" id="mapping-46"></span><span class="token del" data-title="call_expression/member_expression">PERCENTAGE_PRECISION.add</span>(<span class="marker" id="mapping-47"></span><span class="token mv" id="move-src-13" data-title="call_expression/call_argument">acoPermissionConfig.tolerancePriceAboveMin</span>)</span></span>)</span></span></span>.div</span>(<span class="marker" id="mapping-48"></span><span class="token mv" id="move-src-14" data-title="call_expression/call_argument">PERCENTAGE_PRECISION</span>)</span>)</span></span>
	        &amp;&amp; <span class="marker" id="mapping-49"></span><span class="token del" data-title="binary_expression/parenthesized_expression">(<span class="marker" id="mapping-50"></span><span class="token mv" id="move-src-15" data-title="parenthesized_expression/call_expression"><span class="marker" id="mapping-51"></span><span class="token del" data-title="member_expression/binary_expression"><span class="marker" id="mapping-52"></span><span class="token del" data-title="binary_expression/binary_expression">acoPermissionConfig.tolerancePriceAboveMax == 0</span> || <span class="marker" id="mapping-53"></span><span class="token del" data-title="binary_expression/binary_expression">strikePrice &lt;= <span class="marker" id="mapping-54"></span><span class="token mv" id="move-src-16" data-title="binary_expression/call_expression">underlyingPrice.mul(PERCENTAGE_PRECISION.add(<span class="marker" id="mapping-55"></span><span class="token mv" id="move-src-17" data-title="call_expression/call_argument">acoPermissionConfig.tolerancePriceAboveMax</span>))</span></span></span>.div(PERCENTAGE_PRECISION)</span>)</span></span>
        )</span>;</span>
	}

	function _acoExpirationIsValid(uint256 acoExpiryTime, IACOPool2.<span class="marker" id="mapping-56"></span><span class="token upd" id="move-src-18" data-title="user_defined_type/identifier"><span class="cupd">PoolAcoPermissionConfig</span></span> memory acoPermissionConfig) internal view returns(bool) {
		return acoExpiryTime &gt;= block.timestamp.add(acoPermissionConfig.minExpiration) &amp;&amp; acoExpiryTime &lt;= block.timestamp.add(acoPermissionConfig.maxExpiration);
	}
    
    function _getCollateralAmount(
		uint256 tokenAmount,
		uint256 strikePrice,
		bool isCall,
		uint256 underlyingPrecision
	) private pure returns(uint256) {
        if (isCall) {
            return tokenAmount;
        } else if (tokenAmount &gt; 0) {
            return tokenAmount.mul(strikePrice).div(underlyingPrecision);
        } else {
            return 0;
        }
    }
    
    function _getOrderSizeData(
        address lendingToken,
        uint256 underlyingPrecision,
        AcoData memory acoData
    ) private view returns(
        uint256 collateralAmount, 
        uint256 collateralAvailable
    ) {
        if (acoData.isCall) {
            collateralAvailable = _getPoolBalanceOf(acoData.underlying);
            collateralAmount = acoData.tokenAmount; 
        } else {
            collateralAvailable = _getPoolBalanceOf(lendingToken);
            collateralAmount = _getCollateralAmount(acoData.tokenAmount, acoData.strikePrice, acoData.isCall, underlyingPrecision);
            require(collateralAmount &gt; 0, "ACOPoolLib: The token amount is too small");
        }
        require(collateralAmount &lt;= collateralAvailable, "ACOPoolLib: Insufficient liquidity");
    }
    
	function _strategyQuote(
        address strategy,
        uint256 underlyingPrice,
		uint256 baseVolatility,
        uint256 collateralAmount,
        uint256 collateralAvailable,
        AcoData memory acoData
    ) private view returns(uint256 swapPrice, uint256 volatility) {
        (swapPrice, volatility) = IACOPoolStrategy(strategy).quote(IACOPoolStrategy.OptionQuote(
			underlyingPrice,
            acoData.underlying, 
            acoData.strikeAsset, 
            acoData.isCall, 
            acoData.strikePrice, 
            acoData.expiryTime, 
            baseVolatility, 
            collateralAmount, 
            collateralAvailable
        ));
    }
    
    function _setSwapPriceAndFee(
        uint256 calcPrice, 
        uint256 tokenAmount, 
        uint256 fee,
        uint256 underlyingPrecision
    ) private pure returns(uint256 swapPrice, uint256 protocolFee) {
        
        swapPrice = calcPrice.mul(tokenAmount).div(underlyingPrecision);
        
        if (fee &gt; 0) {
            protocolFee = swapPrice.mul(fee).div(PERCENTAGE_PRECISION);
			swapPrice = swapPrice.add(protocolFee);
        }
        require(swapPrice &gt; 0, "ACOPoolLib: Invalid quoted price");
    }
    
    function _getOpenPositionCollateralExtraData(address acoToken, address acoFactory) private view returns(AcoData memory acoData) {
        (address underlying, address strikeAsset, bool isCall, uint256 strikePrice, uint256 expiryTime) = IACOFactory(acoFactory).acoTokenData(acoToken);
        uint256 tokenAmount = IACOToken(acoToken).currentCollateralizedTokens(address(this));
        acoData = AcoData(isCall, strikePrice, expiryTime, tokenAmount, underlying, strikeAsset);
    }
    
	function _getUnderlyingPriceAdjusted(uint256 underlyingPrice, uint256 underlyingPriceAdjustPercentage, bool isMaximum) private pure returns(uint256) {
		if (isMaximum) {
			return underlyingPrice.mul(PERCENTAGE_PRECISION.add(underlyingPriceAdjustPercentage)).div(PERCENTAGE_PRECISION);
		} else {
			return underlyingPrice.mul(PERCENTAGE_PRECISION.sub(underlyingPriceAdjustPercentage)).div(PERCENTAGE_PRECISION);
		}
    }
    
    function _getPoolBalanceOf(address asset) private view returns(uint256) {
        if (asset == address(0)) {
            return address(this).balance;
        } else {
            (bool success, bytes memory returndata) = asset.staticcall(abi.encodeWithSelector(0x70a08231, address(this)));
            require(success, "ACOPoolLib::_getAssetBalanceOf");
            return abi.decode(returndata, (uint256));
        }
    }
    
    function _getAssetSymbol(address asset) private view returns(string memory) {
        if (asset == address(0)) {
            return "ETH";
        } else {
            (bool success, bytes memory returndata) = asset.staticcall(abi.encodeWithSelector(0x95d89b41));
            require(success, "ACOPoolLib::_getAssetSymbol");
            return abi.decode(returndata, (string));
        }
    }
}</pre></div><div class="col-6"><h5>ACOPoolLib.sol</h5><pre class="pre-scrollable">pragma solidity ^0.6.6;
pragma experimental ABIEncoderV2;

import "./SafeMath.sol";
import "./IACOPoolStrategy.sol";
import "./IACOFactory.sol";
import "./IACOToken.sol";
import "./ILendingPool.sol";
import "./IACOPool2.sol";

library ACOPoolLib {
	using SafeMath for uint256;
	
	struct OpenPositionData {
	    bool isDeposit;
	    bool isCall;
	    uint256 underlyingPrice;
	    uint256 baseVolatility;
	    uint256 underlyingPriceAdjustPercentage;
	    uint256 withdrawOpenPositionPenalty;
	    uint256 fee;
	    uint256 underlyingPrecision;
	    address underlying;
	    address strikeAsset;
	    address strategy;
	    address acoFactory;
	    address lendingToken;
	}
	
	struct QuoteData {
		address lendingToken;
		address strategy;
		uint256 baseVolatility;
		uint256 fee;
		uint256 underlyingPrice;
		uint256 underlyingPrecision;
		AcoData acoData;
		IACOPool2.<span class="marker" id="mapping-57"></span><span class="token upd" id="move-dst-1" data-title="user_defined_type/identifier"><span class="cupd">PoolAcoPermissionConfig</span>V2</span> acoPermissionConfig;
	}
	
	struct AcoData {
        bool isCall;
        uint256 strikePrice; 
        uint256 expiryTime;
        uint256 tokenAmount;
	    address underlying;
        address strikeAsset; 
	}
	
	uint256 public constant PERCENTAGE_PRECISION = 100000;
	
	function name(
        address underlying, 
        address strikeAsset, 
        bool isCall<span class="marker" id="mapping-58"></span><span class="token add" data-title="function_definition/,">,</span> 
        <span class="marker" id="mapping-59"></span><span class="token add" data-title="function_definition/parameter">uint256 poolId</span>
    ) public view returns(string memory) {
        return string(abi.encodePacked(
            "ACO POOL WRITE ",
            _getAssetSymbol(underlying),
            "-",
            _getAssetSymbol(strikeAsset),
            "-",
            (isCall ? "CALL #" : "PUT #")<span class="marker" id="mapping-60"></span><span class="token add" data-title="call_expression/,">,</span>
            <span class="marker" id="mapping-61"></span><span class="token add" data-title="call_expression/call_argument">_formatNumber(poolId)</span>
        ));
    }
    
    function acoStrikeAndExpirationIsValid(
		uint256 strikePrice, 
        uint256 acoExpiryTime, 
		uint256 underlyingPrice,
        IACOPool2.<span class="marker" id="mapping-62"></span><span class="token upd" id="move-dst-2" data-title="user_defined_type/identifier"><span class="cupd">PoolAcoPermissionConfig</span>V2</span> memory acoPermissionConfig
    ) public view returns(bool) {
        return _acoExpirationIsValid(acoExpiryTime, acoPermissionConfig) &amp;&amp; _acoStrikePriceIsValid(strikePrice, underlyingPrice, acoPermissionConfig);
    }

    function getBaseAssetsWithdrawWithLocked(
        uint256 shares,
        address underlying,
        address strikeAsset,
        bool isCall,
        uint256 totalSupply,
        address lendingToken
    ) public view returns(
        uint256 underlyingWithdrawn,
		uint256 strikeAssetWithdrawn
    ) {
		uint256 underlyingBalance = _getPoolBalanceOf(underlying);
		uint256 strikeAssetBalance;
		if (isCall) {
		    strikeAssetBalance = _getPoolBalanceOf(strikeAsset);
		} else {
		    strikeAssetBalance = _getPoolBalanceOf(lendingToken);
		}
		
		underlyingWithdrawn = underlyingBalance.mul(shares).div(totalSupply);
		strikeAssetWithdrawn = strikeAssetBalance.mul(shares).div(totalSupply);
    }
    
    function getBaseWithdrawNoLockedData(
        uint256 shares,
        uint256 totalSupply,
        bool isCall,
        uint256 underlyingBalance, 
        uint256 strikeAssetBalance, 
        uint256 collateralBalance, 
        uint256 collateralLockedRedeemable
    ) public pure returns(
        uint256 underlyingWithdrawn,
		uint256 strikeAssetWithdrawn,
		bool isPossible
    ) {
		uint256 collateralAmount = shares.mul(collateralBalance).div(totalSupply);
		
		if (isCall) {
			underlyingWithdrawn = collateralAmount;
			strikeAssetWithdrawn = strikeAssetBalance.mul(shares).div(totalSupply);
			isPossible = (collateralAmount &lt;= underlyingBalance.add(collateralLockedRedeemable));
		} else {
			strikeAssetWithdrawn = collateralAmount;
			underlyingWithdrawn = underlyingBalance.mul(shares).div(totalSupply);
			isPossible = (collateralAmount &lt;= strikeAssetBalance.add(collateralLockedRedeemable));
		}
    }
    
    function getAmountToLockedWithdraw(
        uint256 shares, 
        uint256 totalSupply, 
        address lendingToken,
        address underlying, 
        address strikeAsset, 
        bool isCall
    ) public view returns(
        uint256 underlyingWithdrawn, 
        uint256 strikeAssetWithdrawn
    ) {
		uint256 underlyingBalance = _getPoolBalanceOf(underlying);
		uint256 strikeAssetBalance;
		if (isCall) {
		    strikeAssetBalance = _getPoolBalanceOf(strikeAsset);
		} else {
		    strikeAssetBalance = _getPoolBalanceOf(lendingToken);
		}
		
		underlyingWithdrawn = underlyingBalance.mul(shares).div(totalSupply);
		strikeAssetWithdrawn = strikeAssetBalance.mul(shares).div(totalSupply);
    }
    
    function getAmountToNoLockedWithdraw(
        uint256 shares, 
        uint256 totalSupply,
        uint256 underlyingBalance, 
        uint256 strikeAssetBalance,
        uint256 collateralBalance,
        uint256 minCollateral,
        bool isCall
    ) public pure returns(
        uint256 underlyingWithdrawn, 
        uint256 strikeAssetWithdrawn
    ) {
		uint256 collateralAmount = shares.mul(collateralBalance).div(totalSupply);
		require(collateralAmount &gt;= minCollateral, "ACOPoolLib: The minimum collateral was not satisfied");

        if (isCall) {
			require(collateralAmount &lt;= underlyingBalance, "ACOPoolLib: Collateral balance is not sufficient");
			underlyingWithdrawn = collateralAmount;
			strikeAssetWithdrawn = strikeAssetBalance.mul(shares).div(totalSupply);
        } else {
			require(collateralAmount &lt;= strikeAssetBalance, "ACOPoolLib: Collateral balance is not sufficient");
			strikeAssetWithdrawn = collateralAmount;
			underlyingWithdrawn = underlyingBalance.mul(shares).div(totalSupply);
		}
    }
    
    function quote(QuoteData memory data) public view returns(
        uint256 swapPrice, 
        uint256 protocolFee, 
        uint256 volatility, 
        uint256 collateralAmount
    ) {
        AcoData memory acoData = data.acoData;
        require(_acoExpirationIsValid(acoData.expiryTime, data.acoPermissionConfig), "ACOPoolLib: Invalid ACO token expiration");
		require(_acoStrikePriceIsValid(acoData.strikePrice, data.underlyingPrice, data.acoPermissionConfig), "ACOPoolLib: Invalid ACO token strike price");

        uint256 collateralAvailable;
        (collateralAmount, collateralAvailable) = _getOrderSizeData(data.lendingToken, data.underlyingPrecision, acoData);
        uint256 calcPrice;
        (calcPrice, volatility) = _strategyQuote(data.strategy, data.underlyingPrice, data.baseVolatility, collateralAmount, collateralAvailable, acoData);
        (swapPrice, protocolFee) = _setSwapPriceAndFee(calcPrice, acoData.tokenAmount, data.fee, data.underlyingPrecision);
    }

	function getCollateralData(OpenPositionData memory data, address[] memory openAcos) public view returns(
        uint256 underlyingBalance, 
        uint256 strikeAssetBalance, 
        uint256 collateralBalance,
        uint256 collateralLocked,
        uint256 collateralOnOpenPosition,
        uint256 collateralLockedRedeemable
    ) {
		(underlyingBalance, strikeAssetBalance, collateralBalance) = _getBaseCollateralData(
            data.isDeposit, 
            data.underlying,
            data.strikeAsset,
            data.isCall,
            data.underlyingPrice,
            data.lendingToken,
            data.underlyingPriceAdjustPercentage,
            data.underlyingPrecision);
            
		(collateralLocked, collateralOnOpenPosition, collateralLockedRedeemable) = _poolOpenPositionCollateralBalance(data, openAcos);
	}

    <span class="marker" id="mapping-63"></span><span class="token add" data-title="contract_body/function_definition">function _formatNumber(uint256 value) internal pure returns(string memory) {
        if (value == 0) {
            return "0";
        }
        uint256 digits;
        uint256 temp = value;
        while (temp != 0) {
            temp /= 10;
            digits++;
        }
        bytes memory buffer = new bytes(digits);
        uint256 index = digits - 1;
        temp = value;
        for (uint256 i = 0; i &lt; digits; ++i) {
            buffer[index--] = byte(uint8(48 + temp % 10));
            temp /= 10;
        }
        return string(buffer);
    }</span>
	
	function _getBaseCollateralData(
	    bool isDeposit,
	    address underlying,
	    address strikeAsset,
	    bool isCall,
	    uint256 underlyingPrice,
	    address lendingToken,
	    uint256 underlyingPriceAdjustPercentage,
	    uint256 underlyingPrecision
	) internal view returns(
        uint256 underlyingBalance, 
        uint256 strikeAssetBalance, 
        uint256 collateralBalance
    ) {
		underlyingBalance = _getPoolBalanceOf(underlying);
		
		if (isCall) {
		    strikeAssetBalance = _getPoolBalanceOf(strikeAsset);
			collateralBalance = underlyingBalance;
			if (isDeposit &amp;&amp; strikeAssetBalance &gt; 0) {
				uint256 priceAdjusted = _getUnderlyingPriceAdjusted(underlyingPrice, underlyingPriceAdjustPercentage, false); 
				collateralBalance = collateralBalance.add(strikeAssetBalance.mul(underlyingPrecision).div(priceAdjusted));
			}
		} else {
		    strikeAssetBalance = _getPoolBalanceOf(lendingToken);
			collateralBalance = strikeAssetBalance;
			if (isDeposit &amp;&amp; underlyingBalance &gt; 0) {
				uint256 priceAdjusted = _getUnderlyingPriceAdjusted(underlyingPrice, underlyingPriceAdjustPercentage, true); 
				collateralBalance = collateralBalance.add(underlyingBalance.mul(priceAdjusted).div(underlyingPrecision));
			}
		}
	}

	function _poolOpenPositionCollateralBalance(OpenPositionData memory data, address[] memory openAcos) internal view returns(
        uint256 collateralLocked, 
        uint256 collateralOnOpenPosition,
        uint256 collateralLockedRedeemable
    ) {
		for (uint256 i = 0; i &lt; openAcos.length; ++i) {
			address acoToken = openAcos[i];
            
            (uint256 locked, uint256 openPosition, uint256 lockedRedeemable) = _getOpenPositionCollateralBalance(acoToken, data);
            
            collateralLocked = collateralLocked.add(locked);
            collateralOnOpenPosition = collateralOnOpenPosition.add(openPosition);
            collateralLockedRedeemable = collateralLockedRedeemable.add(lockedRedeemable);
		}
		if (!data.isDeposit) {
			collateralOnOpenPosition = collateralOnOpenPosition.mul(PERCENTAGE_PRECISION.add(data.withdrawOpenPositionPenalty)).div(PERCENTAGE_PRECISION);
		}
	}
	
	function _getOpenPositionCollateralBalance(address acoToken, OpenPositionData memory data) internal view returns(
        uint256 collateralLocked, 
        uint256 collateralOnOpenPosition,
        uint256 collateralLockedRedeemable
    ) {
        AcoData memory acoData = _getOpenPositionCollateralExtraData(acoToken, data.acoFactory);
        collateralLocked = _getCollateralAmount(acoData.tokenAmount, acoData.strikePrice, acoData.isCall, data.underlyingPrecision);
        
        if (acoData.expiryTime &gt; block.timestamp) {
    		(uint256 price,) = _strategyQuote(data.strategy, data.underlyingPrice, data.baseVolatility, 0, 1, acoData);
    		if (data.fee &gt; 0) {
    		    price = price.mul(PERCENTAGE_PRECISION.add(data.fee)).div(PERCENTAGE_PRECISION);
    		}
    		if (acoData.isCall) {
    			uint256 priceAdjusted = _getUnderlyingPriceAdjusted(data.underlyingPrice, data.underlyingPriceAdjustPercentage, false); 
    			collateralOnOpenPosition = price.mul(acoData.tokenAmount).div(priceAdjusted);
    		} else {
    			collateralOnOpenPosition = price.mul(acoData.tokenAmount).div(data.underlyingPrecision);
    		}
        } else {
            collateralLockedRedeemable = collateralLocked;
        }
    }
    
	<span class="marker" id="mapping-64"></span><span class="token add" data-title="contract_body/function_definition">function _acoStrikePriceIsValid(
		<span class="marker" id="mapping-65"></span><span class="token mv" id="move-dst-4" data-title="function_definition/parameter">uint256 strikePrice</span>, 
		<span class="marker" id="mapping-66"></span><span class="token mv" id="move-dst-5" data-title="function_definition/parameter">uint256 underlyingPrice</span>,
		<span class="marker" id="mapping-67"></span><span class="token add" data-title="function_definition/parameter">IACOPool2.PoolAcoPermissionConfigV2 memory acoPermissionConfig</span>
	) <span class="marker" id="mapping-68"></span><span class="token mv" id="move-dst-6" data-title="function_definition/visibility">internal</span> <span class="marker" id="mapping-69"></span><span class="token mv" id="move-dst-7" data-title="function_definition/state_mutability">pure</span> <span class="marker" id="mapping-70"></span><span class="token mv" id="move-dst-8" data-title="function_definition/return_type_definition">returns(bool)</span> <span class="marker" id="mapping-71"></span><span class="token add" data-title="function_definition/function_body">{
	    <span class="marker" id="mapping-72"></span><span class="token add" data-title="function_body/return_statement">return <span class="marker" id="mapping-73"></span><span class="token add" data-title="return_statement/parenthesized_expression">(
	        <span class="marker" id="mapping-74"></span><span class="token add" data-title="parenthesized_expression/binary_expression"><span class="marker" id="mapping-75"></span><span class="token add" data-title="binary_expression/binary_expression"><span class="marker" id="mapping-76"></span><span class="token add" data-title="binary_expression/binary_expression"><span class="marker" id="mapping-77"></span><span class="token add" data-title="binary_expression/binary_expression"><span class="marker" id="mapping-78"></span><span class="token add" data-title="binary_expression/binary_expression"><span class="marker" id="mapping-79"></span><span class="token add" data-title="binary_expression/call_expression">_validatePricePercentageTolerance(<span class="marker" id="mapping-80"></span><span class="token add" data-title="call_expression/call_argument">strikePrice</span>, <span class="marker" id="mapping-81"></span><span class="token add" data-title="call_expression/call_argument">underlyingPrice</span>, <span class="marker" id="mapping-82"></span><span class="token mv" id="move-dst-9" data-title="call_expression/call_argument">acoPermissionConfig.tolerancePriceBelowMin</span>, <span class="marker" id="mapping-83"></span><span class="token add" data-title="call_expression/call_argument">false</span>, <span class="marker" id="mapping-84"></span><span class="token add" data-title="call_expression/call_argument">true</span>)</span> &amp;&amp;
	        <span class="marker" id="mapping-85"></span><span class="token add" data-title="binary_expression/call_expression">_validatePricePercentageTolerance(<span class="marker" id="mapping-86"></span><span class="token add" data-title="call_expression/call_argument">strikePrice</span>, <span class="marker" id="mapping-87"></span><span class="token add" data-title="call_expression/call_argument">underlyingPrice</span>, <span class="marker" id="mapping-88"></span><span class="token mv" id="move-dst-12" data-title="call_expression/call_argument">acoPermissionConfig.tolerancePriceBelowMax</span>, <span class="marker" id="mapping-89"></span><span class="token add" data-title="call_expression/call_argument">false</span>, <span class="marker" id="mapping-90"></span><span class="token add" data-title="call_expression/call_argument">false</span>)</span></span> &amp;&amp;
	        <span class="marker" id="mapping-91"></span><span class="token add" data-title="binary_expression/call_expression">_validatePricePercentageTolerance(<span class="marker" id="mapping-92"></span><span class="token add" data-title="call_expression/call_argument">strikePrice</span>, <span class="marker" id="mapping-93"></span><span class="token add" data-title="call_expression/call_argument">underlyingPrice</span>, <span class="marker" id="mapping-94"></span><span class="token mv" id="move-dst-13" data-title="call_expression/call_argument">acoPermissionConfig.tolerancePriceAboveMin</span>, <span class="marker" id="mapping-95"></span><span class="token add" data-title="call_expression/call_argument">true</span>, <span class="marker" id="mapping-96"></span><span class="token add" data-title="call_expression/call_argument">false</span>)</span></span> &amp;&amp;
	        <span class="marker" id="mapping-97"></span><span class="token add" data-title="binary_expression/call_expression">_validatePricePercentageTolerance(<span class="marker" id="mapping-98"></span><span class="token add" data-title="call_expression/call_argument">strikePrice</span>, <span class="marker" id="mapping-99"></span><span class="token add" data-title="call_expression/call_argument">underlyingPrice</span>, <span class="marker" id="mapping-100"></span><span class="token mv" id="move-dst-17" data-title="call_expression/call_argument">acoPermissionConfig.tolerancePriceAboveMax</span>, <span class="marker" id="mapping-101"></span><span class="token add" data-title="call_expression/call_argument">true</span>, <span class="marker" id="mapping-102"></span><span class="token add" data-title="call_expression/call_argument">true</span>)</span></span> &amp;&amp;
	        <span class="marker" id="mapping-103"></span><span class="token add" data-title="binary_expression/parenthesized_expression">(acoPermissionConfig.minStrikePrice &lt;= strikePrice)</span></span> &amp;&amp;
	        <span class="marker" id="mapping-104"></span><span class="token add" data-title="binary_expression/parenthesized_expression">(acoPermissionConfig.maxStrikePrice == 0 || acoPermissionConfig.maxStrikePrice &gt;= strikePrice)</span></span>
        )</span>;</span>
	}</span></span>
	
	function <span class="marker" id="mapping-105"></span><span class="token upd" id="move-dst-3" data-title="function_definition/identifier"><span class="cupd">_</span>v<span class="cupd">a</span>lida<span class="cupd">t</span>eP<span class="cupd">ri</span>c<span class="cupd">eP</span>e<span class="cupd">r</span><span class="cupd">ce</span>nt<span class="cupd">a</span>geTolerance</span>(
	    <span class="marker" id="mapping-106"></span><span class="token add" data-title="function_definition/parameter">uint256 strikePrice</span>, 
	    <span class="marker" id="mapping-107"></span><span class="token add" data-title="function_definition/parameter">uint256 underlyingPrice</span>, 
	    <span class="marker" id="mapping-108"></span><span class="token add" data-title="function_definition/parameter">int256 tolerance</span><span class="marker" id="mapping-109"></span><span class="token add" data-title="function_definition/,">,</span> 
	    <span class="marker" id="mapping-110"></span><span class="token add" data-title="function_definition/parameter">bool isAbove</span><span class="marker" id="mapping-111"></span><span class="token add" data-title="function_definition/,">,</span>
	    <span class="marker" id="mapping-112"></span><span class="token add" data-title="function_definition/parameter">bool shouldBeLesser</span>
    ) <span class="marker" id="mapping-113"></span><span class="token add" data-title="function_definition/visibility">internal</span> <span class="marker" id="mapping-114"></span><span class="token add" data-title="function_definition/state_mutability">pure</span> <span class="marker" id="mapping-115"></span><span class="token add" data-title="function_definition/return_type_definition">returns(bool)</span> {
        <span class="marker" id="mapping-116"></span><span class="token add" data-title="function_body/if_statement">if (<span class="marker" id="mapping-117"></span><span class="token add" data-title="if_statement/binary_expression">tolerance &lt; int256(0)</span>) <span class="marker" id="mapping-118"></span><span class="token add" data-title="if_statement/block_statement">{
            return true;
        }</span> else <span class="marker" id="mapping-119"></span><span class="token add" data-title="if_statement/block_statement">{
            <span class="marker" id="mapping-120"></span><span class="token add" data-title="block_statement/variable_declaration_statement">uint256 value;</span>
            <span class="marker" id="mapping-121"></span><span class="token add" data-title="block_statement/if_statement">if (isAbove) <span class="marker" id="mapping-122"></span><span class="token add" data-title="if_statement/block_statement">{
                <span class="marker" id="mapping-123"></span><span class="token add" data-title="block_statement/expression_statement"><span class="marker" id="mapping-124"></span><span class="token add" data-title="expression_statement/assignment_expression">value = <span class="marker" id="mapping-125"></span><span class="token mv" id="move-dst-15" data-title="assignment_expression/call_expression"><span class="marker" id="mapping-126"></span><span class="token mv" id="move-dst-16" data-title="member_expression/call_expression">underlyingPrice.mul(PERCENTAGE_PRECISION.add(<span class="marker" id="mapping-127"></span><span class="token add" data-title="call_expression/call_argument">uint256(tolerance)</span>))</span>.div(PERCENTAGE_PRECISION)</span></span>;</span>
            }</span> else <span class="marker" id="mapping-128"></span><span class="token add" data-title="if_statement/block_statement">{
                <span class="marker" id="mapping-129"></span><span class="token add" data-title="block_statement/expression_statement"><span class="marker" id="mapping-130"></span><span class="token add" data-title="expression_statement/assignment_expression">value = <span class="marker" id="mapping-131"></span><span class="token mv" id="move-dst-10" data-title="assignment_expression/call_expression"><span class="marker" id="mapping-132"></span><span class="token mv" id="move-dst-11" data-title="member_expression/call_expression">underlyingPrice.mul(PERCENTAGE_PRECISION.sub(<span class="marker" id="mapping-133"></span><span class="token add" data-title="call_expression/call_argument">uint256(tolerance)</span>))</span>.div(<span class="marker" id="mapping-134"></span><span class="token mv" id="move-dst-14" data-title="call_expression/call_argument">PERCENTAGE_PRECISION</span>)</span></span>;</span>
            }</span></span>
            <span class="marker" id="mapping-135"></span><span class="token add" data-title="block_statement/if_statement">if (shouldBeLesser) {
                return strikePrice &lt;= value;
            } else {
                return strikePrice &gt;= value;
            }</span>
        }</span></span>
    }

	function _acoExpirationIsValid(uint256 acoExpiryTime, IACOPool2.<span class="marker" id="mapping-136"></span><span class="token upd" id="move-dst-18" data-title="user_defined_type/identifier"><span class="cupd">PoolAcoPermissionConfig</span>V2</span> memory acoPermissionConfig) internal view returns(bool) {
		return acoExpiryTime &gt;= block.timestamp.add(acoPermissionConfig.minExpiration) &amp;&amp; acoExpiryTime &lt;= block.timestamp.add(acoPermissionConfig.maxExpiration);
	}
    
    function _getCollateralAmount(
		uint256 tokenAmount,
		uint256 strikePrice,
		bool isCall,
		uint256 underlyingPrecision
	) private pure returns(uint256) {
        if (isCall) {
            return tokenAmount;
        } else if (tokenAmount &gt; 0) {
            return tokenAmount.mul(strikePrice).div(underlyingPrecision);
        } else {
            return 0;
        }
    }
    
    function _getOrderSizeData(
        address lendingToken,
        uint256 underlyingPrecision,
        AcoData memory acoData
    ) private view returns(
        uint256 collateralAmount, 
        uint256 collateralAvailable
    ) {
        if (acoData.isCall) {
            collateralAvailable = _getPoolBalanceOf(acoData.underlying);
            collateralAmount = acoData.tokenAmount; 
        } else {
            collateralAvailable = _getPoolBalanceOf(lendingToken);
            collateralAmount = _getCollateralAmount(acoData.tokenAmount, acoData.strikePrice, acoData.isCall, underlyingPrecision);
            require(collateralAmount &gt; 0, "ACOPoolLib: The token amount is too small");
        }
        require(collateralAmount &lt;= collateralAvailable, "ACOPoolLib: Insufficient liquidity");
    }
    
	function _strategyQuote(
        address strategy,
        uint256 underlyingPrice,
		uint256 baseVolatility,
        uint256 collateralAmount,
        uint256 collateralAvailable,
        AcoData memory acoData
    ) private view returns(uint256 swapPrice, uint256 volatility) {
        (swapPrice, volatility) = IACOPoolStrategy(strategy).quote(IACOPoolStrategy.OptionQuote(
			underlyingPrice,
            acoData.underlying, 
            acoData.strikeAsset, 
            acoData.isCall, 
            acoData.strikePrice, 
            acoData.expiryTime, 
            baseVolatility, 
            collateralAmount, 
            collateralAvailable
        ));
    }
    
    function _setSwapPriceAndFee(
        uint256 calcPrice, 
        uint256 tokenAmount, 
        uint256 fee,
        uint256 underlyingPrecision
    ) private pure returns(uint256 swapPrice, uint256 protocolFee) {
        
        swapPrice = calcPrice.mul(tokenAmount).div(underlyingPrecision);
        
        if (fee &gt; 0) {
            protocolFee = swapPrice.mul(fee).div(PERCENTAGE_PRECISION);
			swapPrice = swapPrice.add(protocolFee);
        }
        require(swapPrice &gt; 0, "ACOPoolLib: Invalid quoted price");
    }
    
    function _getOpenPositionCollateralExtraData(address acoToken, address acoFactory) private view returns(AcoData memory acoData) {
        (address underlying, address strikeAsset, bool isCall, uint256 strikePrice, uint256 expiryTime) = IACOFactory(acoFactory).acoTokenData(acoToken);
        uint256 tokenAmount = IACOToken(acoToken).currentCollateralizedTokens(address(this));
        acoData = AcoData(isCall, strikePrice, expiryTime, tokenAmount, underlying, strikeAsset);
    }
    
	function _getUnderlyingPriceAdjusted(uint256 underlyingPrice, uint256 underlyingPriceAdjustPercentage, bool isMaximum) private pure returns(uint256) {
		if (isMaximum) {
			return underlyingPrice.mul(PERCENTAGE_PRECISION.add(underlyingPriceAdjustPercentage)).div(PERCENTAGE_PRECISION);
		} else {
			return underlyingPrice.mul(PERCENTAGE_PRECISION.sub(underlyingPriceAdjustPercentage)).div(PERCENTAGE_PRECISION);
		}
    }
    
    function _getPoolBalanceOf(address asset) private view returns(uint256) {
        if (asset == address(0)) {
            return address(this).balance;
        } else {
            (bool success, bytes memory returndata) = asset.staticcall(abi.encodeWithSelector(0x70a08231, address(this)));
            require(success, "ACOPoolLib::_getAssetBalanceOf");
            return abi.decode(returndata, (uint256));
        }
    }
    
    function _getAssetSymbol(address asset) private view returns(string memory) {
        if (asset == address(0)) {
            return "ETH";
        } else {
            (bool success, bytes memory returndata) = asset.staticcall(abi.encodeWithSelector(0x95d89b41));
            require(success, "ACOPoolLib::_getAssetSymbol");
            return abi.decode(returndata, (string));
        }
    }
}</pre></div></div></div></body></html>