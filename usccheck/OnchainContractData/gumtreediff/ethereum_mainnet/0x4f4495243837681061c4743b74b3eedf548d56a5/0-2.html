<html lang="en"><head><meta charset="utf8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>GumTree</title><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css"><style type="text/css">/*
 * This file is part of GumTree.
 *
 * GumTree is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * GumTree is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with GumTree.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Copyright 2011-2015 Jean-Rémy Falleri <jr.falleri@gmail.com>
 * Copyright 2011-2015 Floréal Morandat <florealm@gmail.com>
 */

.add {
	border: 1px solid black;
	background-color: MediumSeaGreen;
}

.del {
	border: 1px solid black;
	background-color: IndianRed;
}

.mv {
	border: 1px solid black;
	background-color: Plum;
}

.upd {
	border: 1px solid black;
	background-color: DarkOrange;
	font-weight: bold;
}

.cupd {
	font-weight: normal;
	color: DimGray;
}

.selected {
	background-color: Gold;
}

.marker {
	margin: 0;
	padding: 0;
}

div {
	margin: 0px;
	padding: 0px;
}

.pre-scrollable {
	margin: 0px;
	padding: 0px;
	font-size: 10pt;
	color: black;
	max-height: 90vh;
	background-color: white;
	border: 1px solid black;
	font-family: "Hack, Inconsolata", "Consolas", "Liberation Sans Regular", "DejaVu Sans Mono", monospace;
}

.tooltip-inner {
    max-width: none;
}
</style><script type="text/javascript" src="https://code.jquery.com/jquery-3.4.1.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/js/bootstrap.bundle.min.js"></script><script type="text/javascript">/*
 * This file is part of GumTree.
 *
 * GumTree is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * GumTree is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with GumTree.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Copyright 2011-2015 Jean-Rémy Falleri <jr.falleri@gmail.com>
 * Copyright 2011-2015 Floréal Morandat <florealm@gmail.com>
 */

$(function(){
    let popoverTriggerList = [].slice.call(document.querySelectorAll('[data-bs-toggle="popover"]'))
    let popoverList = popoverTriggerList.map(function (popoverTriggerEl) {
      return new bootstrap.Popover(popoverTriggerEl)
    })

    $("body").keypress(function (event) {
        switch (event.which) {
            case 116:
                $('html, body').animate({scrollTop: 0}, 100);
                break;
            case 98:
                $("html, body").animate({ scrollTop: $(document).height() }, 100);
                break;
            case 113:
                window.location = "/quit";
                break;
            case 108:
                window.location = "/list";
                break;
        }
    });
});
</script><script type="text/javascript">/*
 * This file is part of GumTree.
 *
 * GumTree is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * GumTree is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with GumTree.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Copyright 2011-2015 Jean-Rémy Falleri <jr.falleri@gmail.com>
 * Copyright 2011-2015 Floréal Morandat <florealm@gmail.com>
 */

currentMapping = 0;

if (typeof String.prototype.startsWith != 'function') {
  String.prototype.startsWith = function (str){
    return this.slice(0, str.length) == str;
  };
}

function getMappedElement(eltId) {
	if (eltId.startsWith("move-src")) {
		return eltId.replace("src","dst");  	 	
  	}
  	else {
  		return eltId.replace("dst","src");
  	}
}

function nextMapping() {
	if (currentMapping == 0) {
		currentMapping = 1;
		return "#mapping-" + currentMapping.toString();
	} else {
		currentMapping++;
		
		if ($("#mapping-" + currentMapping.toString()).length > 0) {
			return "#mapping-" + currentMapping.toString();
		} else {
			currentMapping = 1;
			return "#mapping-" + currentMapping.toString();		
		}		
	}
}

function isSrc(eltId) {
	return eltId.startsWith("move-src");
}

$(function() {
    $("body").keypress(function (event) {
        switch(event.which) {
            case 110:
                const mapping = $(nextMapping());
                const pre = mapping.closest("pre");
                pre.animate({scrollTop: pre.scrollTop() + mapping.position().top - 200}, 100);
                break;
        }
    });

    // highlight
    $("span.mv.token, span.token.upd").click(function(event) {
        if ($(this).hasClass("selected")) {
            $("span.mv.token, span.token.upd").removeClass("selected");
        } else {
            $("span.mv.token, span.token.upd").removeClass("selected");
            const refElt = $("#" + getMappedElement($(this).attr("id")));
            $(this).addClass("selected");
            refElt.addClass("selected");
            const pre = refElt.closest("pre");
            console.log(pre);
            pre.animate({scrollTop: pre.scrollTop() + refElt.position().top - 200}, 100);
        }
        event.stopPropagation();
    });
    
    $("span.add.token, span.token.del").click(function(event) {
        $("span.mv.token, span.token.upd").removeClass("selected");
        event.stopPropagation();
    });

    // tooltip
    $("span.token").hover(
    	function (event) {
    		$(this).tooltip('show');
    		event.stopPropagation();
    	},
    	function (event) {
    		$(this).tooltip('hide');
    		event.stopPropagation();
    	}
    );
});
</script></head><body><div class="container-fluid"><div class="row"><div class="col"><div class="btn-toolbar justify-content-end"><div class="btn-group mr-2"><button class="btn btn-primary btn-sm" id="legend" data-bs-toggle="popover" data-bs-placement="bottom" data-bs-html="true" data-bs-content="<span class='del'>&nbsp;&nbsp;</span> deleted<br><span class='add'>&nbsp;&nbsp;</span> added<br><span class='mv'>&nbsp;&nbsp;</span> moved<br><span class='upd';>&nbsp;&nbsp;</span> updated<br>">Legend</button><button class="btn btn-primary btn-sm" id="shortcuts" data-bs-toggle="popover" data-bs-placement="bottom" data-bs-html="true" data-bs-content="<b>q</b> quit<br><b>l</b> list<br><b>n</b> next<br><b>t</b> top<br><b>b</b> bottom">Shortcuts</button></div><div class="btn-group"><a href="/list" class="btn btn-default btn-sm btn-primary">Back</a><a href="/quit" class="btn btn-default btn-sm btn-danger">Quit</a></div></div></div></div><div class="row"><div class="col-6"><h5>0xd71f7151bf894e452a9dfecde202026970090607.etherscan.io-AxelarGatewayMultisig.sol</h5><pre class="pre-scrollable">// SPDX-License-Identifier: MIT

pragma solidity<span class="marker" id="mapping-1"></span><span class="token del" data-title="solidity_pragma_token/solidity_version_comparison_operator"> =</span><span class="marker" id="mapping-2"></span><span class="token upd" id="move-src-1" data-title="solidity_pragma_token/solidity_version"><span class="cupd">0.8.9</span></span>;

interface IAxelarGateway {
    /**********\
    |* Events *|
    \**********/

    event Executed(bytes32 indexed commandId);

    event TokenDeployed(string symbol, address tokenAddresses);

    <span class="marker" id="mapping-3"></span><span class="token del" data-title="contract_body/event_definition">event TokenFrozen(<span class="marker" id="mapping-4"></span><span class="token mv" id="move-src-2" data-title="event_definition/event_paramater">string <span class="marker" id="mapping-5"></span><span class="token del" data-title="event_paramater/indexed">indexed</span> <span class="marker" id="mapping-6"></span><span class="token upd" id="move-src-3" data-title="event_paramater/identifier"><span class="cupd">s</span>ymbol</span></span>);</span>

    <span class="marker" id="mapping-7"></span><span class="token del" data-title="contract_body/event_definition">event TokenUnfrozen(<span class="marker" id="mapping-8"></span><span class="token mv" id="move-src-4" data-title="event_definition/event_paramater">string <span class="marker" id="mapping-9"></span><span class="token del" data-title="event_paramater/indexed">indexed</span> <span class="marker" id="mapping-10"></span><span class="token upd" id="move-src-5" data-title="event_paramater/identifier"><span class="cupd">s</span>ymbol</span></span>);</span>

    event AllTokensFrozen();

    event AllTokensUnfrozen();

    event AccountBlacklisted(address indexed account);

    event AccountWhitelisted(address indexed account);

    event Upgraded(address indexed implementation);

    /***********\
    |* Getters *|
    \***********/

    function allTokensFrozen() external view returns (bool);

    function implementation() external view returns (address);

    function tokenAddresses(string memory symbol) external view returns (address);

    function tokenFrozen(string memory symbol) external view returns (bool);

    function isCommandExecuted(bytes32 commandId) external view returns (bool);

    /*******************\
    |* Admin Functions *|
    \*******************/

    function freezeToken(string memory symbol) external;

    function unfreezeToken(string memory symbol) external;

    function freezeAllTokens() external;

    function unfreezeAllTokens() external;

    function upgrade(address newImplementation, bytes calldata setupParams) external;

    /**********************\
    |* External Functions *|
    \**********************/

    function setup(bytes calldata params) external;

    function execute(bytes calldata input) external;
}

interface IAxelarGatewayMultisig is IAxelarGateway {

    event OwnershipTransferred(address[] preOwners, uint256 prevThreshold, address[] newOwners, uint256 newThreshold);

    event OperatorshipTransferred(address[] preOperators, uint256 prevThreshold, address[] newOperators, uint256 newThreshold);

    <span class="marker" id="mapping-11"></span><span class="token mv" id="move-src-6" data-title="contract_body/function_definition">function <span class="marker" id="mapping-12"></span><span class="token upd" id="move-src-7" data-title="function_definition/identifier"><span class="cupd">o</span>wn<span class="cupd">er</span>s</span>() external view returns (address[] memory);</span>

    function <span class="marker" id="mapping-13"></span><span class="token upd" id="move-src-8" data-title="function_definition/identifier"><span class="cupd">o</span>p<span class="cupd">er</span>ators</span>() external view returns (address[] memory);

}

/**
 * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.
 *
 * These functions can be used to verify that a message was signed by the holder
 * of the private keys of a given address.
 */
library ECDSA {
    /**
     * @dev Returns the address that signed a hashed message (`hash`) with
     * `signature`. This address can then be used for verification purposes.
     *
     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:
     * this function rejects them by requiring the `s` value to be in the lower
     * half order, and the `v` value to be either 27 or 28.
     *
     * IMPORTANT: `hash` _must_ be the result of a hash operation for the
     * verification to be secure: it is possible to craft signatures that
     * recover to arbitrary addresses for non-hashed data. A safe way to ensure
     * this is by receiving a hash of the original message (which may otherwise
     * be too long), and then calling {toEthSignedMessageHash} on it.
     */
    function recover(bytes32 hash, bytes memory signature) internal pure returns (address signer) {
        // Check the signature length
        <span class="marker" id="mapping-14"></span><span class="token del" data-title="function_body/expression_statement"><span class="marker" id="mapping-15"></span><span class="token del" data-title="expression_statement/call_expression">require(<span class="marker" id="mapping-16"></span><span class="token del" data-title="call_expression/call_argument"><span class="marker" id="mapping-17"></span><span class="token mv" id="move-src-9" data-title="call_argument/binary_expression">signature.length <span class="marker" id="mapping-18"></span><span class="token del" data-title="binary_expression/==">==</span> 65</span></span>, <span class="marker" id="mapping-19"></span><span class="token del" data-title="call_expression/call_argument">'INV_LEN'</span>)</span>;</span>

        // Divide the signature in r, s and v variables
        bytes32 r;
        bytes32 s;
        uint8 v;

        // ecrecover takes the signature parameters, and the only way to get them
        // currently is to use assembly.
        // solhint-disable-next-line no-inline-assembly
        assembly {
            r := mload(add(signature, 0x20))
            s := mload(add(signature, 0x40))
            v := byte(0, mload(add(signature, 0x60)))
        }

        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature
        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines
        // the valid range for s in (281): 0 &lt; s &lt; secp256k1n ÷ 2 + 1, and for v in (282): v ∈ {27, 28}. Most
        // signatures from current libraries generate a unique signature with an s-value in the lower half order.
        //
        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value
        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or
        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept
        // these malleable signatures as well.
        <span class="marker" id="mapping-20"></span><span class="token mv" id="move-src-10" data-title="function_body/expression_statement">require(uint256(s) &lt;= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0, 'INV_S');</span>

        <span class="marker" id="mapping-21"></span><span class="token mv" id="move-src-11" data-title="function_body/expression_statement">require(v == 27 || v == 28, 'INV_V');</span>

        // If the signature is valid (and not malleable), return the signer address
        <span class="marker" id="mapping-22"></span><span class="token del" data-title="function_body/expression_statement"><span class="marker" id="mapping-23"></span><span class="token del" data-title="expression_statement/call_expression">require(<span class="marker" id="mapping-24"></span><span class="token del" data-title="call_expression/call_argument"><span class="marker" id="mapping-25"></span><span class="token mv" id="move-src-12" data-title="call_argument/binary_expression">(signer = ecrecover(hash, v, r, s)) <span class="marker" id="mapping-26"></span><span class="token del" data-title="binary_expression/!=">!=</span> address(0)</span></span>, <span class="marker" id="mapping-27"></span><span class="token del" data-title="call_expression/call_argument">'INV_SIG'</span>)</span>;</span>
    }

    /**
     * @dev Returns an Ethereum Signed Message, created from a `hash`. This
     * replicates the behavior of the
     * https://github.com/ethereum/wiki/wiki/JSON-RPC#eth_sign[`eth_sign`]
     * JSON-RPC method.
     *
     * See {recover}.
     */
    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {
        // 32 is the length in bytes of hash,
        // enforced by the type signature above
        return keccak256(abi.encodePacked('\x19Ethereum Signed Message:\n32', hash));
    }
}

<span class="marker" id="mapping-28"></span><span class="token mv" id="move-src-13" data-title="source_file/comment">/**
 * @dev Interface of the ERC20 standard as defined in the EIP.
 */</span>
<span class="marker" id="mapping-29"></span><span class="token mv" id="move-src-14" data-title="source_file/interface_declaration">interface IERC20 {
    /**
     * @dev Returns the amount of tokens in existence.
     */
    function totalSupply() external view returns (uint256);

    /**
     * @dev Returns the amount of tokens owned by `account`.
     */
    function balanceOf(address account) external view returns (uint256);

    /**
     * @dev Moves `amount` tokens from the caller's account to `recipient`.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * Emits a {Transfer} event.
     */
    function transfer(address recipient, uint256 amount) external returns (bool);

    /**
     * @dev Returns the remaining number of tokens that `spender` will be
     * allowed to spend on behalf of `owner` through {transferFrom}. This is
     * zero by default.
     *
     * This value changes when {approve} or {transferFrom} are called.
     */
    function allowance(address owner, address spender) external view returns (uint256);

    /**
     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * IMPORTANT: Beware that changing an allowance with this method brings the risk
     * that someone may use both the old and the new allowance by unfortunate
     * transaction ordering. One possible solution to mitigate this race
     * condition is to first reduce the spender's allowance to 0 and set the
     * desired value afterwards:
     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
     *
     * Emits an {Approval} event.
     */
    function approve(address spender, uint256 amount) external returns (bool);

    /**
     * @dev Moves `amount` tokens from `sender` to `recipient` using the
     * allowance mechanism. `amount` is then deducted from the caller's
     * allowance.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * Emits a {Transfer} event.
     */
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);

    /**
     * @dev Emitted when `value` tokens are moved from one account (`from`) to
     * another (`to`).
     *
     * Note that `value` may be zero.
     */
    event Transfer(address indexed from, address indexed to, uint256 value);

    /**
     * @dev Emitted when the allowance of a `spender` for an `owner` is set by
     * a call to {approve}. `value` is the new allowance.
     */
    event Approval(address indexed owner, address indexed spender, uint256 value);
}</span>

/*
 * @dev Provides information about the current execution context, including the
 * sender of the transaction and its data. While these are generally available
 * via msg.sender and msg.data, they should not be accessed in such a direct
 * manner, since when dealing with GSN meta-transactions the account sending and
 * paying for execution may not be the actual sender (as far as an application
 * is concerned).
 *
 * This contract is only required for intermediate, library-like contracts.
 */
abstract contract Context {
    function _msgSender() internal view virtual returns (address payable) {
        return payable(msg.sender);
    }

    function _msgData() internal view virtual returns (bytes memory) {
        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691
        return msg.data;
    }
}

/**
 * @dev Implementation of the {IERC20} interface.
 *
 * This implementation is agnostic to the way tokens are created. This means
 * that a supply mechanism has to be added in a derived contract using {_mint}.
 * For a generic mechanism see {ERC20PresetMinterPauser}.
 *
 * TIP: For a detailed writeup see our guide
 * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How
 * to implement supply mechanisms].
 *
 * We have followed general OpenZeppelin guidelines: functions revert instead
 * of returning `false` on failure. This behavior is nonetheless conventional
 * and does not conflict with the expectations of ERC20 applications.
 *
 * Additionally, an {Approval} event is emitted on calls to {transferFrom}.
 * This allows applications to reconstruct the allowance for all accounts just
 * by listening to said events. Other implementations of the EIP may not emit
 * these events, as it isn't required by the specification.
 *
 * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}
 * functions have been added to mitigate the well-known issues around setting
 * allowances. See {IERC20-approve}.
 */
contract ERC20 is Context, IERC20 {
    mapping(address =&gt; uint256) public override balanceOf;

    mapping(address =&gt; mapping(address =&gt; uint256)) public override allowance;

    uint256 public override totalSupply;

    string public name;
    string public symbol;

    uint8 public immutable decimals;

    /**
     * @dev Sets the values for {name}, {symbol}, and {decimals}.
     *
     * All three of these values are immutable: they can only be set once during
     * construction.
     */
    constructor(
        string memory name_,
        string memory symbol_,
        uint8 decimals_
    ) {
        name = name_;
        symbol = symbol_;
        decimals = decimals_;
    }

    /**
     * @dev See {IERC20-transfer}.
     *
     * Requirements:
     *
     * - `recipient` cannot be the zero address.
     * - the caller must have a balance of at least `amount`.
     */
    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {
        _transfer(_msgSender(), recipient, amount);
        return true;
    }

    /**
     * @dev See {IERC20-approve}.
     *
     * Requirements:
     *
     * - `spender` cannot be the zero address.
     */
    function approve(address spender, uint256 amount) public virtual override returns (bool) {
        _approve(_msgSender(), spender, amount);
        return true;
    }

    /**
     * @dev See {IERC20-transferFrom}.
     *
     * Emits an {Approval} event indicating the updated allowance. This is not
     * required by the EIP. See the note at the beginning of {ERC20}.
     *
     * Requirements:
     *
     * - `sender` and `recipient` cannot be the zero address.
     * - `sender` must have a balance of at least `amount`.
     * - the caller must have allowance for ``sender``'s tokens of at least
     * `amount`.
     */
    function transferFrom(
        address sender,
        address recipient,
        uint256 amount
    ) public virtual override returns (bool) {
        _transfer(sender, recipient, amount);
        _approve(sender, _msgSender(), allowance[sender][_msgSender()] - amount);
        return true;
    }

    /**
     * @dev Atomically increases the allowance granted to `spender` by the caller.
     *
     * This is an alternative to {approve} that can be used as a mitigation for
     * problems described in {IERC20-approve}.
     *
     * Emits an {Approval} event indicating the updated allowance.
     *
     * Requirements:
     *
     * - `spender` cannot be the zero address.
     */
    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {
        _approve(_msgSender(), spender, allowance[_msgSender()][spender] + addedValue);
        return true;
    }

    /**
     * @dev Atomically decreases the allowance granted to `spender` by the caller.
     *
     * This is an alternative to {approve} that can be used as a mitigation for
     * problems described in {IERC20-approve}.
     *
     * Emits an {Approval} event indicating the updated allowance.
     *
     * Requirements:
     *
     * - `spender` cannot be the zero address.
     * - `spender` must have allowance for the caller of at least
     * `subtractedValue`.
     */
    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {
        _approve(_msgSender(), spender, allowance[_msgSender()][spender] - subtractedValue);
        return true;
    }

    /**
     * @dev Moves tokens `amount` from `sender` to `recipient`.
     *
     * This is internal function is equivalent to {transfer}, and can be used to
     * e.g. implement automatic token fees, slashing mechanisms, etc.
     *
     * Emits a {Transfer} event.
     *
     * Requirements:
     *
     * - `sender` cannot be the zero address.
     * - `recipient` cannot be the zero address.
     * - `sender` must have a balance of at least `amount`.
     */
    function _transfer(
        address sender,
        address recipient,
        uint256 amount
    ) internal virtual {
        require(sender != address(0), 'ZERO_ADDR');
        require(recipient != address(0), 'ZERO_ADDR');

        _beforeTokenTransfer(sender, recipient, amount);

        balanceOf[sender] -= amount;
        balanceOf[recipient] += amount;
        emit Transfer(sender, recipient, amount);
    }

    /** @dev Creates `amount` tokens and assigns them to `account`, increasing
     * the total supply.
     *
     * Emits a {Transfer} event with `from` set to the zero address.
     *
     * Requirements:
     *
     * - `to` cannot be the zero address.
     */
    function _mint(address account, uint256 amount) internal virtual {
        require(account != address(0), 'ZERO_ADDR');

        _beforeTokenTransfer(address(0), account, amount);

        totalSupply += amount;
        balanceOf[account] += amount;
        emit Transfer(address(0), account, amount);
    }

    /**
     * @dev Destroys `amount` tokens from `account`, reducing the
     * total supply.
     *
     * Emits a {Transfer} event with `to` set to the zero address.
     *
     * Requirements:
     *
     * - `account` cannot be the zero address.
     * - `account` must have at least `amount` tokens.
     */
    function _burn(address account, uint256 amount) internal virtual {
        require(account != address(0), 'ZERO_ADDR');

        _beforeTokenTransfer(account, address(0), amount);

        balanceOf[account] -= amount;
        totalSupply -= amount;
        emit Transfer(account, address(0), amount);
    }

    /**
     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.
     *
     * This internal function is equivalent to `approve`, and can be used to
     * e.g. set automatic allowances for certain subsystems, etc.
     *
     * Emits an {Approval} event.
     *
     * Requirements:
     *
     * - `owner` cannot be the zero address.
     * - `spender` cannot be the zero address.
     */
    function _approve(
        address owner,
        address spender,
        uint256 amount
    ) internal virtual {
        require(owner != address(0), 'ZERO_ADDR');
        require(spender != address(0), 'ZERO_ADDR');

        allowance[owner][spender] = amount;
        emit Approval(owner, spender, amount);
    }

    /**
     * @dev Hook that is called before any transfer of tokens. This includes
     * minting and burning.
     *
     * Calling conditions:
     *
     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens
     * will be to transferred to `to`.
     * - when `from` is zero, `amount` tokens will be minted for `to`.
     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.
     * - `from` and `to` are never both zero.
     *
     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].
     */
    function _beforeTokenTransfer(
        address from,
        address to,
        uint256 amount
    ) internal virtual {}
}

<span class="marker" id="mapping-30"></span><span class="token mv" id="move-src-15" data-title="source_file/contract_declaration">abstract contract Ownable {
    address public owner;

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    constructor() {
        owner = msg.sender;
        emit OwnershipTransferred(address(0), msg.sender);
    }

    modifier onlyOwner() {
        require(owner == msg.sender, 'NOT_OWNER');
        _;
    }

    function transferOwnership(address newOwner) public virtual onlyOwner {
        require(newOwner != address(0), 'ZERO_ADDR');

        emit OwnershipTransferred(owner, newOwner);
        owner = newOwner;
    }
}</span>

<span class="marker" id="mapping-31"></span><span class="token del" data-title="source_file/contract_declaration">contract Burner <span class="marker" id="mapping-32"></span><span class="token del" data-title="contract_declaration/contract_body">{
    <span class="marker" id="mapping-33"></span><span class="token del" data-title="contract_body/constructor_definition">constructor(<span class="marker" id="mapping-34"></span><span class="token mv" id="move-src-16" data-title="constructor_definition/parameter">address tokenAddress</span>, <span class="marker" id="mapping-35"></span><span class="token mv" id="move-src-17" data-title="constructor_definition/parameter">bytes32 salt</span>) <span class="marker" id="mapping-36"></span><span class="token del" data-title="constructor_definition/function_body">{
        <span class="marker" id="mapping-37"></span><span class="token del" data-title="function_body/expression_statement">BurnableMintableCappedERC20(tokenAddress).burn(salt);</span>

        <span class="marker" id="mapping-38"></span><span class="token del" data-title="function_body/expression_statement"><span class="marker" id="mapping-39"></span><span class="token del" data-title="expression_statement/call_expression">selfdestruct(<span class="marker" id="mapping-40"></span><span class="token del" data-title="call_expression/call_argument"><span class="marker" id="mapping-41"></span><span class="token del" data-title="call_argument/payable_conversion_expression">payable(<span class="marker" id="mapping-42"></span><span class="token del" data-title="payable_conversion_expression/call_argument"><span class="marker" id="mapping-43"></span><span class="token mv" id="move-src-18" data-title="call_argument/type_cast_expression">address(0)</span></span>)</span></span>)</span>;</span>
    }</span></span>
}</span></span>

<span class="marker" id="mapping-44"></span><span class="token mv" id="move-src-19" data-title="source_file/comment">/**
 * @title EternalStorage
 * @dev This contract holds all the necessary state variables to carry out the storage of any contract.
 */</span>
<span class="marker" id="mapping-45"></span><span class="token mv" id="move-src-20" data-title="source_file/contract_declaration">contract EternalStorage {
    mapping(bytes32 =&gt; uint256) private _uintStorage;
    mapping(bytes32 =&gt; string) private _stringStorage;
    mapping(bytes32 =&gt; address) private _addressStorage;
    mapping(bytes32 =&gt; bytes) private _bytesStorage;
    mapping(bytes32 =&gt; bool) private _boolStorage;
    mapping(bytes32 =&gt; int256) private _intStorage;

    // *** Getter Methods ***
    function getUint(bytes32 key) public view returns (uint256) {
        return _uintStorage[key];
    }

    function getString(bytes32 key) public view returns (string memory) {
        return _stringStorage[key];
    }

    function getAddress(bytes32 key) public view returns (address) {
        return _addressStorage[key];
    }

    function getBytes(bytes32 key) public view returns (bytes memory) {
        return _bytesStorage[key];
    }

    function getBool(bytes32 key) public view returns (bool) {
        return _boolStorage[key];
    }

    function getInt(bytes32 key) public view returns (int256) {
        return _intStorage[key];
    }

    // *** Setter Methods ***
    function _setUint(bytes32 key, uint256 value) internal {
        _uintStorage[key] = value;
    }

    function _setString(bytes32 key, string memory value) internal {
        _stringStorage[key] = value;
    }

    function _setAddress(bytes32 key, address value) internal {
        _addressStorage[key] = value;
    }

    function _setBytes(bytes32 key, bytes memory value) internal {
        _bytesStorage[key] = value;
    }

    function _setBool(bytes32 key, bool value) internal {
        _boolStorage[key] = value;
    }

    function _setInt(bytes32 key, int256 value) internal {
        _intStorage[key] = value;
    }

    // *** Delete Methods ***
    function _deleteUint(bytes32 key) internal {
        delete _uintStorage[key];
    }

    function _deleteString(bytes32 key) internal {
        delete _stringStorage[key];
    }

    function _deleteAddress(bytes32 key) internal {
        delete _addressStorage[key];
    }

    function _deleteBytes(bytes32 key) internal {
        delete _bytesStorage[key];
    }

    function _deleteBool(bytes32 key) internal {
        delete _boolStorage[key];
    }

    function _deleteInt(bytes32 key) internal {
        delete _intStorage[key];
    }
}</span>

contract BurnableMintableCappedERC20 is <span class="marker" id="mapping-46"></span><span class="token mv" id="move-src-21" data-title="contract_declaration/inheritance_specifier">ERC20</span><span class="marker" id="mapping-47"></span><span class="token del" data-title="contract_declaration/,">,</span> <span class="marker" id="mapping-48"></span><span class="token mv" id="move-src-22" data-title="contract_declaration/inheritance_specifier">Ownable</span> {
    <span class="marker" id="mapping-49"></span><span class="token mv" id="move-src-23" data-title="contract_body/state_variable_declaration">uint256 public cap;</span>

    <span class="marker" id="mapping-50"></span><span class="token mv" id="move-src-24" data-title="contract_body/state_variable_declaration">bytes32 <span class="marker" id="mapping-51"></span><span class="token mv" id="move-src-25" data-title="state_variable_declaration/visibility">private</span> constant <span class="marker" id="mapping-52"></span><span class="token upd" id="move-src-26" data-title="state_variable_declaration/identifier"><span class="cupd">PREFIX_</span>T<span class="cupd">O</span>KE<span class="cupd">N</span><span class="cupd">_</span>F<span class="cupd">RO</span>ZEN</span> = keccak256('token-frozen');</span>
    <span class="marker" id="mapping-53"></span><span class="token mv" id="move-src-27" data-title="contract_body/state_variable_declaration">bytes32 <span class="marker" id="mapping-54"></span><span class="token mv" id="move-src-28" data-title="state_variable_declaration/visibility">private</span> constant <span class="marker" id="mapping-55"></span><span class="token upd" id="move-src-29" data-title="state_variable_declaration/identifier">K<span class="cupd">E</span>Y<span class="cupd">_</span>ALL_<span class="cupd">TOKEN</span>S<span class="cupd">_</span>FROZEN</span> = keccak256('all-tokens-frozen');</span>

    event Frozen(address indexed owner);
    event Unfrozen(address indexed owner);

    <span class="marker" id="mapping-56"></span><span class="token mv" id="move-src-30" data-title="contract_body/constructor_definition">constructor(
        string memory name,
        string memory symbol,
        uint8 decimals,
        uint256 capacity
    ) ERC20(name, symbol, decimals) Ownable() {
        cap = capacity;
    }</span>

    function depositAddress(bytes32 salt) public view returns (address) {
        <span class="marker" id="mapping-57"></span><span class="token del" data-title="function_body/comment">// This would be easier, cheaper, simpler, and result in  globally consistent deposit addresses for any salt (all chains, all tokens).</span>
        <span class="marker" id="mapping-58"></span><span class="token del" data-title="function_body/comment">// return address(uint160(uint256(keccak256(abi.encodePacked(bytes32(0x000000000000000000000000000000000000000000000000000000000000dead), salt)))));</span>

        /* Convert a hash which is bytes32 to an address which is 20-byte long
        according to https://docs.soliditylang.org/en/v0.8.1/control-structures.html?highlight=create2#salted-contract-creations-create2 */
        return
            address(
                uint160(
                    uint256(
                        keccak256(
                            abi.encodePacked(
                                bytes1(0xff),
                                owner,
                                salt,
                                keccak256(<span class="marker" id="mapping-59"></span><span class="token mv" id="move-src-31" data-title="call_expression/member_expression">abi.encodePacked</span>(type(<span class="marker" id="mapping-60"></span><span class="token upd" id="move-src-32" data-title="user_defined_type/identifier">Bur<span class="cupd">n</span><span class="cupd">er</span></span>).creationCode<span class="marker" id="mapping-61"></span><span class="token del" data-title="call_expression/,">,</span> <span class="marker" id="mapping-62"></span><span class="token del" data-title="call_expression/call_argument"><span class="marker" id="mapping-63"></span><span class="token del" data-title="call_argument/call_expression"><span class="marker" id="mapping-64"></span><span class="token mv" id="move-src-33" data-title="call_expression/member_expression">abi.encode</span>(<span class="marker" id="mapping-65"></span><span class="token mv" id="move-src-34" data-title="call_expression/call_argument">address(this)</span>)</span></span><span class="marker" id="mapping-66"></span><span class="token del" data-title="call_expression/,">,</span> <span class="marker" id="mapping-67"></span><span class="token mv" id="move-src-35" data-title="call_expression/call_argument">salt</span>))
                            )
                        )
                    )
                )
            );
    }

    <span class="marker" id="mapping-68"></span><span class="token mv" id="move-src-36" data-title="contract_body/function_definition">function mint(address account, uint256 amount) public onlyOwner {
        uint256 capacity = cap;
        require(capacity == 0 || totalSupply + amount &lt;= capacity, 'CAP_EXCEEDED');

        _mint(account, amount);
    }</span>

    function burn(bytes32 salt) public onlyOwner {
        address account = depositAddress(salt);
        _burn(account, balanceOf[account]);
    }

    function _beforeTokenTransfer(
        address,
        address,
        uint256
    ) internal view override {
        require(!EternalStorage(owner).getBool(KEY_ALL_TOKENS_FROZEN), 'IS_FROZEN');
        require(!EternalStorage(owner).getBool(keccak256(abi.encodePacked(PREFIX_TOKEN_FROZEN, symbol))), 'IS_FROZEN');
    }
}

contract AdminMultisigBase is EternalStorage {
    bytes32 internal constant KEY_ADMIN_EPOCH = keccak256('admin-epoch');

    bytes32 internal constant PREFIX_ADMIN = keccak256('admin');
    bytes32 internal constant PREFIX_ADMIN_COUNT = keccak256('admin-count');
    bytes32 internal constant PREFIX_ADMIN_THRESHOLD = keccak256('admin-threshold');
    bytes32 internal constant PREFIX_ADMIN_VOTE_COUNTS = keccak256('admin-vote-counts');
    bytes32 internal constant PREFIX_ADMIN_VOTED = keccak256('admin-voted');
    bytes32 internal constant PREFIX_IS_ADMIN = keccak256('is-admin');

    modifier onlyAdmin() {
        uint256 adminEpoch = _adminEpoch();

        <span class="marker" id="mapping-69"></span><span class="token del" data-title="function_body/expression_statement"><span class="marker" id="mapping-70"></span><span class="token mv" id="move-src-37" data-title="expression_statement/call_expression"><span class="marker" id="mapping-71"></span><span class="token upd" id="move-src-38" data-title="call_expression/identifier">require</span>(<span class="marker" id="mapping-72"></span><span class="token mv" id="move-src-39" data-title="call_argument/call_expression">_isAdmin(adminEpoch, msg.sender)</span><span class="marker" id="mapping-73"></span><span class="token del" data-title="call_expression/,">,</span> <span class="marker" id="mapping-74"></span><span class="token mv" id="move-src-40" data-title="call_expression/call_argument">'NOT_ADMIN'</span>)</span>;</span>

        bytes32 topic = keccak256(msg.data);

        // Check that admin has not voted, then record that they have voted.
        <span class="marker" id="mapping-75"></span><span class="token del" data-title="function_body/expression_statement"><span class="marker" id="mapping-76"></span><span class="token del" data-title="expression_statement/call_expression">require(<span class="marker" id="mapping-77"></span><span class="token del" data-title="call_expression/call_argument"><span class="marker" id="mapping-78"></span><span class="token del" data-title="call_argument/unary_expression">!<span class="marker" id="mapping-79"></span><span class="token mv" id="move-src-41" data-title="unary_expression/call_expression">_hasVoted(adminEpoch, topic, msg.sender)</span></span></span>, <span class="marker" id="mapping-80"></span><span class="token del" data-title="call_expression/call_argument">'VOTED'</span>)</span>;</span>
        _setHasVoted(adminEpoch, topic, msg.sender, true);

        // Determine the new vote count and update it.
        uint256 adminVoteCount = _getVoteCount(adminEpoch, topic) + uint256(1);
        _setVoteCount(adminEpoch, topic, adminVoteCount);

        // Do not proceed with operation execution if insufficient votes.
        if (adminVoteCount &lt; _getAdminThreshold(adminEpoch)) return;

        _;

        // Clear vote count and voted booleans.
        _setVoteCount(adminEpoch, topic, uint256(0));

        uint256 adminCount = _getAdminCount(adminEpoch);

        for (uint256 i; i &lt; adminCount; i++) {
            _setHasVoted(adminEpoch, topic, _getAdmin(adminEpoch, i), false);
        }
    }

    /********************\
    |* Pure Key Getters *|
    \********************/

    function _getAdminKey(uint256 adminEpoch, uint256 index) internal pure returns (bytes32) {
        return keccak256(abi.encodePacked(PREFIX_ADMIN, adminEpoch, index));
    }

    function _getAdminCountKey(uint256 adminEpoch) internal pure returns (bytes32) {
        return keccak256(abi.encodePacked(PREFIX_ADMIN_COUNT, adminEpoch));
    }

    function _getAdminThresholdKey(uint256 adminEpoch) internal pure returns (bytes32) {
        return keccak256(abi.encodePacked(PREFIX_ADMIN_THRESHOLD, adminEpoch));
    }

    function _getAdminVoteCountsKey(uint256 adminEpoch, bytes32 topic) internal pure returns (bytes32) {
        return keccak256(abi.encodePacked(PREFIX_ADMIN_VOTE_COUNTS, adminEpoch, topic));
    }

    function _getAdminVotedKey(
        uint256 adminEpoch,
        bytes32 topic,
        address account
    ) internal pure returns (bytes32) {
        return keccak256(abi.encodePacked(PREFIX_ADMIN_VOTED, adminEpoch, topic, account));
    }

    function _getIsAdminKey(uint256 adminEpoch, address account) internal pure returns (bytes32) {
        return keccak256(abi.encodePacked(PREFIX_IS_ADMIN, adminEpoch, account));
    }

    /***********\
    |* Getters *|
    \***********/

    function _adminEpoch() internal view returns (uint256) {
        return getUint(KEY_ADMIN_EPOCH);
    }

    function _getAdmin(uint256 adminEpoch, uint256 index) internal view returns (address) {
        return getAddress(_getAdminKey(adminEpoch, index));
    }

    function _getAdminCount(uint256 adminEpoch) internal view returns (uint256) {
        return getUint(_getAdminCountKey(adminEpoch));
    }

    function _getAdminThreshold(uint256 adminEpoch) internal view returns (uint256) {
        return getUint(_getAdminThresholdKey(adminEpoch));
    }

    function _getVoteCount(uint256 adminEpoch, bytes32 topic) internal view returns (uint256) {
        return getUint(_getAdminVoteCountsKey(adminEpoch, topic));
    }

    function _hasVoted(
        uint256 adminEpoch,
        bytes32 topic,
        address account
    ) internal view returns (bool) {
        return getBool(_getAdminVotedKey(adminEpoch, topic, account));
    }

    function _isAdmin(uint256 adminEpoch, address account) internal view returns (bool) {
        return getBool(_getIsAdminKey(adminEpoch, account));
    }

    /***********\
    |* Setters *|
    \***********/

    function _setAdminEpoch(uint256 adminEpoch) internal {
        _setUint(KEY_ADMIN_EPOCH, adminEpoch);
    }

    function _setAdmin(
        uint256 adminEpoch,
        uint256 index,
        address account
    ) internal {
        _setAddress(_getAdminKey(adminEpoch, index), account);
    }

    function _setAdminCount(uint256 adminEpoch, uint256 adminCount) internal {
        _setUint(_getAdminCountKey(adminEpoch), adminCount);
    }

    function _setAdmins(
        uint256 adminEpoch,
        address[] memory accounts,
        uint256 threshold
    ) internal {
        uint256 adminLength = accounts.length;

        <span class="marker" id="mapping-81"></span><span class="token del" data-title="function_body/expression_statement">require(adminLength &gt;= threshold, 'INV_ADMINS');</span>
        <span class="marker" id="mapping-82"></span><span class="token del" data-title="function_body/expression_statement"><span class="marker" id="mapping-83"></span><span class="token del" data-title="expression_statement/call_expression">require(<span class="marker" id="mapping-84"></span><span class="token del" data-title="call_expression/call_argument"><span class="marker" id="mapping-85"></span><span class="token mv" id="move-src-42" data-title="call_argument/binary_expression">threshold <span class="marker" id="mapping-86"></span><span class="token del" data-title="binary_expression/>">&gt;</span> uint256(0)</span></span>, <span class="marker" id="mapping-87"></span><span class="token del" data-title="call_expression/call_argument">'INV_ADMIN_THLD'</span>)</span>;</span>

        _setAdminThreshold(adminEpoch, threshold);
        _setAdminCount(adminEpoch, adminLength);

        for (uint256 i; i &lt; adminLength; i++) {
            address account = accounts[i];

            // Check that the account wasn't already set as an admin for this epoch.
            <span class="marker" id="mapping-88"></span><span class="token del" data-title="block_statement/expression_statement"><span class="marker" id="mapping-89"></span><span class="token del" data-title="expression_statement/call_expression">require(<span class="marker" id="mapping-90"></span><span class="token del" data-title="call_expression/call_argument"><span class="marker" id="mapping-91"></span><span class="token del" data-title="call_argument/unary_expression">!<span class="marker" id="mapping-92"></span><span class="token mv" id="move-src-43" data-title="unary_expression/call_expression">_isAdmin(adminEpoch, account)</span></span></span>, <span class="marker" id="mapping-93"></span><span class="token del" data-title="call_expression/call_argument">'DUP_ADMIN'</span>)</span>;</span>

            // Set this account as the i-th admin in this epoch (needed to we can clear topic votes in `onlyAdmin`).
            _setAdmin(adminEpoch, i, account);
            _setIsAdmin(adminEpoch, account, true);
        }
    }

    function _setAdminThreshold(uint256 adminEpoch, uint256 adminThreshold) internal {
        _setUint(_getAdminThresholdKey(adminEpoch), adminThreshold);
    }

    function _setVoteCount(
        uint256 adminEpoch,
        bytes32 topic,
        uint256 voteCount
    ) internal {
        _setUint(_getAdminVoteCountsKey(adminEpoch, topic), voteCount);
    }

    function _setHasVoted(
        uint256 adminEpoch,
        bytes32 topic,
        address account,
        bool voted
    ) internal {
        _setBool(_getAdminVotedKey(adminEpoch, topic, account), voted);
    }

    function _setIsAdmin(
        uint256 adminEpoch,
        address account,
        bool isAdmin
    ) internal {
        _setBool(_getIsAdminKey(adminEpoch, account), isAdmin);
    }
}

abstract contract AxelarGateway is IAxelarGateway, AdminMultisigBase {
    /// @dev Storage slot with the address of the current factory. `keccak256('eip1967.proxy.implementation') - 1`.
    bytes32 internal constant KEY_IMPLEMENTATION =
        bytes32(0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc);

    bytes32 internal constant KEY_ALL_TOKENS_FROZEN = keccak256('all-tokens-frozen');

    bytes32 internal constant PREFIX_COMMAND_EXECUTED = keccak256('command-executed');
    bytes32 internal constant PREFIX_TOKEN_ADDRESS = keccak256('token-address');
    bytes32 internal constant PREFIX_TOKEN_FROZEN = keccak256('token-frozen');

    bytes32 internal constant SELECTOR_BURN_TOKEN = keccak256('burnToken');
    bytes32 internal constant SELECTOR_DEPLOY_TOKEN = keccak256('deployToken');
    bytes32 internal constant SELECTOR_MINT_TOKEN = keccak256('mintToken');
    bytes32 internal constant SELECTOR_TRANSFER_OPERATORSHIP = keccak256('transferOperatorship');
    bytes32 internal constant SELECTOR_TRANSFER_OWNERSHIP = keccak256('transferOwnership');

    uint8 internal constant OLD_KEY_RETENTION = 16;

    modifier onlySelf() {
        <span class="marker" id="mapping-94"></span><span class="token del" data-title="function_body/expression_statement"><span class="marker" id="mapping-95"></span><span class="token del" data-title="expression_statement/call_expression">require(<span class="marker" id="mapping-96"></span><span class="token del" data-title="call_expression/call_argument"><span class="marker" id="mapping-97"></span><span class="token mv" id="move-src-44" data-title="call_argument/binary_expression">msg.sender <span class="marker" id="mapping-98"></span><span class="token del" data-title="binary_expression/==">==</span> address(this)</span></span>, <span class="marker" id="mapping-99"></span><span class="token del" data-title="call_expression/call_argument">'NOT_SELF'</span>)</span>;</span>

        _;
    }

    /***********\
    |* Getters *|
    \***********/

    function allTokensFrozen() public view override returns (bool) {
        return getBool(KEY_ALL_TOKENS_FROZEN);
    }

    function implementation() public view override returns (address) {
        return getAddress(KEY_IMPLEMENTATION);
    }

    function tokenAddresses(string memory symbol) public view override returns (address) {
        return getAddress(_getTokenAddressKey(symbol));
    }

    function tokenFrozen(string memory symbol) public view override returns (bool) {
        return getBool(_getFreezeTokenKey(symbol));
    }

    function isCommandExecuted(bytes32 commandId) public view override returns (bool) {
        return getBool(_getIsCommandExecutedKey(commandId));
    }

    /*******************\
    |* Admin Functions *|
    \*******************/

    function freezeToken(string memory symbol) external override onlyAdmin {
        _setBool(_getFreezeTokenKey(symbol), true);

        emit TokenFrozen(symbol);
    }

    function unfreezeToken(string memory symbol) external override onlyAdmin {
        _setBool(_getFreezeTokenKey(symbol), false);

        emit TokenUnfrozen(symbol);
    }

    function freezeAllTokens() external override onlyAdmin {
        _setBool(KEY_ALL_TOKENS_FROZEN, true);

        emit AllTokensFrozen();
    }

    function unfreezeAllTokens() external override onlyAdmin {
        _setBool(KEY_ALL_TOKENS_FROZEN, false);

        emit AllTokensUnfrozen();
    }

    function upgrade(address newImplementation, bytes calldata setupParams) external override onlyAdmin {
        emit Upgraded(newImplementation);

        <span class="marker" id="mapping-100"></span><span class="token mv" id="move-src-45" data-title="function_body/variable_declaration_statement">(bool success, ) = newImplementation.delegatecall(
            abi.encodeWithSelector(IAxelarGateway.setup.selector, setupParams)
        );</span>
        <span class="marker" id="mapping-101"></span><span class="token mv" id="move-src-46" data-title="function_body/expression_statement">require(<span class="marker" id="mapping-102"></span><span class="token del" data-title="call_argument/identifier">success</span>, 'SETUP_FAILED');</span>

        _setImplementation(newImplementation);
    }

    /**********************\
    |* Internal Functions *|
    \**********************/

    <span class="marker" id="mapping-103"></span><span class="token mv" id="move-src-47" data-title="contract_body/function_definition">function <span class="marker" id="mapping-104"></span><span class="token upd" id="move-src-48" data-title="function_definition/identifier">_<span class="cupd">deployToken</span></span>(
        string memory name,
        string memory symbol,
        uint8 decimals,
        uint256 cap
    ) <span class="marker" id="mapping-105"></span><span class="token mv" id="move-src-49" data-title="function_definition/visibility">internal</span> {
        <span class="marker" id="mapping-106"></span><span class="token del" data-title="function_body/expression_statement"><span class="marker" id="mapping-107"></span><span class="token del" data-title="expression_statement/call_expression">require(<span class="marker" id="mapping-108"></span><span class="token del" data-title="call_expression/call_argument"><span class="marker" id="mapping-109"></span><span class="token mv" id="move-src-50" data-title="call_argument/binary_expression">tokenAddresses(symbol) <span class="marker" id="mapping-110"></span><span class="token del" data-title="binary_expression/==">==</span> address(0)</span></span>, <span class="marker" id="mapping-111"></span><span class="token mv" id="move-src-51" data-title="call_expression/call_argument">'TOKEN_EXIST'</span>)</span>;</span>

        <span class="marker" id="mapping-112"></span><span class="token mv" id="move-src-52" data-title="function_body/variable_declaration_statement">bytes32 salt = keccak256(abi.encodePacked(symbol));</span>
        <span class="marker" id="mapping-113"></span><span class="token del" data-title="function_body/variable_declaration_statement"><span class="marker" id="mapping-114"></span><span class="token mv" id="move-src-53" data-title="variable_declaration_statement/variable_declaration">address <span class="marker" id="mapping-115"></span><span class="token upd" id="move-src-54" data-title="variable_declaration/identifier">t<span class="cupd">o</span>ken</span></span> = <span class="marker" id="mapping-116"></span><span class="token mv" id="move-src-55" data-title="variable_declaration_statement/type_cast_expression">address(new BurnableMintableCappedERC20{ salt: salt }(name, symbol, decimals, cap))</span>;</span>

        <span class="marker" id="mapping-117"></span><span class="token del" data-title="function_body/expression_statement"><span class="marker" id="mapping-118"></span><span class="token del" data-title="expression_statement/call_expression">_setTokenAddress(<span class="marker" id="mapping-119"></span><span class="token mv" id="move-src-56" data-title="call_expression/call_argument">symbol</span>, <span class="marker" id="mapping-120"></span><span class="token del" data-title="call_expression/call_argument">token</span>)</span>;</span>

        <span class="marker" id="mapping-121"></span><span class="token del" data-title="function_body/emit_statement">emit TokenDeployed(<span class="marker" id="mapping-122"></span><span class="token mv" id="move-src-57" data-title="emit_statement/call_argument">symbol</span>, <span class="marker" id="mapping-123"></span><span class="token del" data-title="emit_statement/call_argument">token</span>);</span>
    }</span>

    function _mintToken(
        string memory symbol,
        address account,
        uint256 amount
    ) internal {
        address tokenAddress = tokenAddresses(symbol);
        <span class="marker" id="mapping-124"></span><span class="token del" data-title="function_body/expression_statement"><span class="marker" id="mapping-125"></span><span class="token del" data-title="expression_statement/call_expression">require(<span class="marker" id="mapping-126"></span><span class="token del" data-title="call_expression/call_argument"><span class="marker" id="mapping-127"></span><span class="token mv" id="move-src-58" data-title="call_argument/binary_expression">tokenAddress <span class="marker" id="mapping-128"></span><span class="token del" data-title="binary_expression/!=">!=</span> address(0)</span></span>, <span class="marker" id="mapping-129"></span><span class="token del" data-title="call_expression/call_argument">'TOKEN_NOT_EXIST'</span>)</span>;</span>

        <span class="marker" id="mapping-130"></span><span class="token mv" id="move-src-59" data-title="function_body/expression_statement">BurnableMintableCappedERC20(tokenAddress).mint(account, amount);</span>
    }

    function _burnToken(string memory symbol, bytes32 salt) internal {
        address tokenAddress = tokenAddresses(symbol);
        <span class="marker" id="mapping-131"></span><span class="token del" data-title="function_body/expression_statement"><span class="marker" id="mapping-132"></span><span class="token del" data-title="expression_statement/call_expression">require(<span class="marker" id="mapping-133"></span><span class="token del" data-title="call_expression/call_argument"><span class="marker" id="mapping-134"></span><span class="token mv" id="move-src-60" data-title="call_argument/binary_expression"><span class="marker" id="mapping-135"></span><span class="token upd" id="move-src-61" data-title="binary_expression/identifier">t<span class="cupd">o</span>kenAddress</span> <span class="marker" id="mapping-136"></span><span class="token del" data-title="binary_expression/!=">!=</span> address(0)</span></span>, <span class="marker" id="mapping-137"></span><span class="token del" data-title="call_expression/call_argument">'TOKEN_NOT_EXIST'</span>)</span>;</span>

        <span class="marker" id="mapping-138"></span><span class="token mv" id="move-src-62" data-title="function_body/expression_statement">BurnableMintableCappedERC20(tokenAddress).burn(salt);</span>
    }

    /********************\
    |* Pure Key Getters *|
    \********************/

    function _getFreezeTokenKey(string memory symbol) internal pure returns (bytes32) {
        return keccak256(abi.encodePacked(PREFIX_TOKEN_FROZEN, symbol));
    }

    function _getTokenAddressKey(string memory symbol) internal pure returns (bytes32) {
        return keccak256(abi.encodePacked(PREFIX_TOKEN_ADDRESS, symbol));
    }

    function _getIsCommandExecutedKey(bytes32 commandId) internal pure returns (bytes32) {
        return keccak256(abi.encodePacked(PREFIX_COMMAND_EXECUTED, commandId));
    }

    /********************\
    |* Internal Getters *|
    \********************/

    <span class="marker" id="mapping-139"></span><span class="token mv" id="move-src-63" data-title="contract_body/function_definition">function <span class="marker" id="mapping-140"></span><span class="token upd" id="move-src-64" data-title="function_definition/identifier">_g<span class="cupd">e</span><span class="cupd">t</span>ChainID</span>() <span class="marker" id="mapping-141"></span><span class="token mv" id="move-src-65" data-title="function_definition/visibility">internal</span> view returns (<span class="marker" id="mapping-142"></span><span class="token mv" id="move-src-66" data-title="return_type_definition/parameter">uint256 <span class="marker" id="mapping-143"></span><span class="token upd" id="move-src-67" data-title="parameter/identifier">id</span></span>) {
        <span class="marker" id="mapping-144"></span><span class="token del" data-title="function_body/assembly_statement">assembly {
            id := chainid()
        }</span>
    }</span>

    /********************\
    |* Internal Setters *|
    \********************/

    function _setTokenAddress(string memory symbol, <span class="marker" id="mapping-145"></span><span class="token mv" id="move-src-68" data-title="function_definition/parameter">address <span class="marker" id="mapping-146"></span><span class="token upd" id="move-src-69" data-title="parameter/identifier">t<span class="cupd">o</span>ke<span class="cupd">n</span><span class="cupd">Addr</span></span></span>) internal {
        _setAddress(_getTokenAddressKey(symbol), <span class="marker" id="mapping-147"></span><span class="token mv" id="move-src-70" data-title="call_expression/call_argument">tokenAddr</span>);
    }

    function _setCommandExecuted(bytes32 commandId, bool executed) internal {
        _setBool(_getIsCommandExecutedKey(commandId), executed);
    }

    function _setImplementation(address newImplementation) internal {
        _setAddress(KEY_IMPLEMENTATION, newImplementation);
    }
}

contract AxelarGatewayMultisig is IAxelarGatewayMultisig, AxelarGateway {
    bytes32 internal constant KEY_OWNER_EPOCH = keccak256('owner-epoch');

    bytes32 internal constant PREFIX_OWNER = keccak256('owner');
    bytes32 internal constant PREFIX_OWNER_COUNT = keccak256('owner-count');
    bytes32 internal constant PREFIX_OWNER_THRESHOLD = keccak256('owner-threshold');
    bytes32 internal constant PREFIX_IS_OWNER = keccak256('is-owner');

    bytes32 internal constant KEY_OPERATOR_EPOCH = keccak256('operator-epoch');

    bytes32 internal constant PREFIX_OPERATOR = keccak256('operator');
    bytes32 internal constant PREFIX_OPERATOR_COUNT = keccak256('operator-count');
    bytes32 internal constant PREFIX_OPERATOR_THRESHOLD = keccak256('operator-threshold');
    bytes32 internal constant PREFIX_IS_OPERATOR = keccak256('is-operator');

    function <span class="marker" id="mapping-148"></span><span class="token upd" id="move-src-71" data-title="function_definition/identifier"><span class="cupd">_</span><span class="cupd">c</span><span class="cupd">ontains</span><span class="cupd">Duplicate</span>s</span>(address[] memory accounts) internal pure returns (bool) {
        <span class="marker" id="mapping-149"></span><span class="token del" data-title="function_body/variable_declaration_statement"><span class="marker" id="mapping-150"></span><span class="token mv" id="move-src-72" data-title="variable_declaration_statement/variable_declaration">uint256 <span class="marker" id="mapping-151"></span><span class="token upd" id="move-src-73" data-title="variable_declaration/identifier">count</span></span> = <span class="marker" id="mapping-152"></span><span class="token del" data-title="variable_declaration_statement/member_expression">accounts.length</span>;</span>

        <span class="marker" id="mapping-153"></span><span class="token del" data-title="function_body/for_statement">for (<span class="marker" id="mapping-154"></span><span class="token mv" id="move-src-74" data-title="for_statement/variable_declaration_statement">uint256 i;</span> <span class="marker" id="mapping-155"></span><span class="token del" data-title="for_statement/expression_statement">i &lt; count;</span> <span class="marker" id="mapping-156"></span><span class="token mv" id="move-src-75" data-title="for_statement/update_expression">++i</span>) <span class="marker" id="mapping-157"></span><span class="token del" data-title="for_statement/block_statement">{
            <span class="marker" id="mapping-158"></span><span class="token mv" id="move-src-76" data-title="block_statement/for_statement">for (<span class="marker" id="mapping-159"></span><span class="token del" data-title="for_statement/variable_declaration_statement"><span class="marker" id="mapping-160"></span><span class="token del" data-title="variable_declaration_statement/variable_declaration"><span class="marker" id="mapping-161"></span><span class="token mv" id="move-src-77" data-title="variable_declaration/type_name">uint256</span> j</span> = <span class="marker" id="mapping-162"></span><span class="token mv" id="move-src-78" data-title="variable_declaration_statement/binary_expression">i + 1</span>;</span> <span class="marker" id="mapping-163"></span><span class="token del" data-title="binary_expression/identifier">j</span> <span class="marker" id="mapping-164"></span><span class="token del" data-title="binary_expression/<">&lt;</span> <span class="marker" id="mapping-165"></span><span class="token del" data-title="binary_expression/identifier">count</span>; <span class="marker" id="mapping-166"></span><span class="token del" data-title="for_statement/update_expression">++j</span>) {
                if (accounts[i] <span class="marker" id="mapping-167"></span><span class="token del" data-title="binary_expression/==">==</span> accounts[<span class="marker" id="mapping-168"></span><span class="token del" data-title="array_access/identifier">j</span>]) <span class="marker" id="mapping-169"></span><span class="token mv" id="move-src-79" data-title="if_statement/return_statement">return true;</span>
            }</span>
        }</span></span>

        <span class="marker" id="mapping-170"></span><span class="token del" data-title="function_body/return_statement">return false;</span>
    }

    /************************\
    |* Owners Functionality *|
    \************************/

    /********************\
    |* Pure Key Getters *|
    \********************/

    function _getOwnerKey(<span class="marker" id="mapping-171"></span><span class="token mv" id="move-src-80" data-title="function_definition/parameter">uint256 <span class="marker" id="mapping-172"></span><span class="token upd" id="move-src-81" data-title="parameter/identifier">ownerEpoch</span></span>, uint256 index) internal pure returns (bytes32) {
        return keccak256(abi.encodePacked(PREFIX_OWNER, <span class="marker" id="mapping-173"></span><span class="token upd" id="move-src-82" data-title="call_argument/identifier">own<span class="cupd">e</span>rE<span class="cupd">poch</span></span>, index));
    }

    function _getOwnerCountKey(<span class="marker" id="mapping-174"></span><span class="token mv" id="move-src-83" data-title="function_definition/parameter">uint256 <span class="marker" id="mapping-175"></span><span class="token upd" id="move-src-84" data-title="parameter/identifier">ow<span class="cupd">ne</span>rEpoch</span></span>) internal pure returns (bytes32) {
        return keccak256(abi.encodePacked(PREFIX_OWNER_COUNT, <span class="marker" id="mapping-176"></span><span class="token upd" id="move-src-85" data-title="call_argument/identifier">own<span class="cupd">e</span>rE<span class="cupd">poch</span></span>));
    }

    function _getOwnerThresholdKey(<span class="marker" id="mapping-177"></span><span class="token mv" id="move-src-86" data-title="function_definition/parameter">uint256 <span class="marker" id="mapping-178"></span><span class="token upd" id="move-src-87" data-title="parameter/identifier"><span class="cupd">o</span>w<span class="cupd">n</span>erEpoch</span></span>) internal pure returns (bytes32) {
        return keccak256(abi.encodePacked(PREFIX_OWNER_THRESHOLD, <span class="marker" id="mapping-179"></span><span class="token upd" id="move-src-88" data-title="call_argument/identifier">own<span class="cupd">e</span>rE<span class="cupd">poch</span></span>));
    }

    function _getIsOwnerKey(<span class="marker" id="mapping-180"></span><span class="token mv" id="move-src-89" data-title="function_definition/parameter">uint256 <span class="marker" id="mapping-181"></span><span class="token upd" id="move-src-90" data-title="parameter/identifier">own<span class="cupd">e</span>rE<span class="cupd">poch</span></span></span>, address account) internal pure returns (bytes32) {
        return keccak256(abi.encodePacked(PREFIX_IS_OWNER, <span class="marker" id="mapping-182"></span><span class="token upd" id="move-src-91" data-title="call_argument/identifier">own<span class="cupd">e</span>rE<span class="cupd">poch</span></span>, account));
    }

    /***********\
    |* Getters *|
    \***********/

    function _ownerEpoch() internal view returns (uint256) {
        return getUint(KEY_OWNER_EPOCH);
    }

    <span class="marker" id="mapping-183"></span><span class="token mv" id="move-src-92" data-title="contract_body/function_definition">function <span class="marker" id="mapping-184"></span><span class="token upd" id="move-src-93" data-title="function_definition/identifier"><span class="cupd">_getO</span>wn<span class="cupd">er</span></span>(<span class="marker" id="mapping-185"></span><span class="token mv" id="move-src-94" data-title="function_definition/parameter">uint256 <span class="marker" id="mapping-186"></span><span class="token upd" id="move-src-95" data-title="parameter/identifier"><span class="cupd">o</span>w<span class="cupd">n</span>erEpoch</span></span>, uint256 index) internal view returns (address) {
        return getAddress(<span class="marker" id="mapping-187"></span><span class="token upd" id="move-src-96" data-title="call_expression/identifier"><span class="cupd">_getO</span>wn<span class="cupd">er</span><span class="cupd">Key</span></span>(<span class="marker" id="mapping-188"></span><span class="token upd" id="move-src-97" data-title="call_argument/identifier">own<span class="cupd">e</span>rE<span class="cupd">poch</span></span>, index));
    }</span>

    <span class="marker" id="mapping-189"></span><span class="token mv" id="move-src-98" data-title="contract_body/function_definition">function <span class="marker" id="mapping-190"></span><span class="token upd" id="move-src-99" data-title="function_definition/identifier"><span class="cupd">_getOwner</span>Count</span>(<span class="marker" id="mapping-191"></span><span class="token mv" id="move-src-100" data-title="function_definition/parameter">uint256 <span class="marker" id="mapping-192"></span><span class="token upd" id="move-src-101" data-title="parameter/identifier">own<span class="cupd">e</span>rE<span class="cupd">poch</span></span></span>) internal view returns (uint256) {
        return getUint(<span class="marker" id="mapping-193"></span><span class="token upd" id="move-src-102" data-title="call_expression/identifier"><span class="cupd">_getOwner</span>C<span class="cupd">o</span>unt<span class="cupd">Key</span></span>(<span class="marker" id="mapping-194"></span><span class="token upd" id="move-src-103" data-title="call_argument/identifier">own<span class="cupd">e</span>rE<span class="cupd">poch</span></span>));
    }</span>

    function <span class="marker" id="mapping-195"></span><span class="token upd" id="move-src-104" data-title="function_definition/identifier"><span class="cupd">_getOwner</span>Threshold</span>(<span class="marker" id="mapping-196"></span><span class="token mv" id="move-src-105" data-title="function_definition/parameter">uint256 <span class="marker" id="mapping-197"></span><span class="token upd" id="move-src-106" data-title="parameter/identifier">own<span class="cupd">e</span>rE<span class="cupd">poch</span></span></span>) internal view returns (uint256) {
        return getUint(<span class="marker" id="mapping-198"></span><span class="token upd" id="move-src-107" data-title="call_expression/identifier"><span class="cupd">_getOwner</span>Thresh<span class="cupd">o</span>ld<span class="cupd">Key</span></span>(<span class="marker" id="mapping-199"></span><span class="token upd" id="move-src-108" data-title="call_argument/identifier">own<span class="cupd">e</span>rE<span class="cupd">poch</span></span>));
    }

    function _isOwner(<span class="marker" id="mapping-200"></span><span class="token mv" id="move-src-109" data-title="function_definition/parameter">uint256 <span class="marker" id="mapping-201"></span><span class="token upd" id="move-src-110" data-title="parameter/identifier">own<span class="cupd">e</span>rE<span class="cupd">poch</span></span></span>, address account) internal view returns (bool) {
        return getBool(_getIsOwnerKey(<span class="marker" id="mapping-202"></span><span class="token upd" id="move-src-111" data-title="call_argument/identifier">own<span class="cupd">e</span>rE<span class="cupd">poch</span></span>, <span class="marker" id="mapping-203"></span><span class="token mv" id="move-src-112" data-title="call_expression/call_argument">account</span>));
    }

    <span class="marker" id="mapping-204"></span><span class="token mv" id="move-src-113" data-title="contract_body/comment"><span class="marker" id="mapping-205"></span><span class="token upd" id="move-src-114" data-title="contract_body/comment"><span class="cupd">//</span>/<span class="cupd"> </span>@dev<span class="cupd"> </span>Return<span class="cupd">s</span> <span class="cupd">t</span>rue<span class="cupd"> </span>if <span class="cupd">a</span><span class="cupd"> s</span>ufficient quantity <span class="cupd">o</span>f `acco<span class="cupd">u</span>nts`<span class="cupd"> </span>ar<span class="cupd">e </span>own<span class="cupd">e</span>rs <span class="cupd">i</span>n th<span class="cupd">e</span><span class="cupd"> </span>same `o<span class="cupd">w</span>nerEpoch`, w<span class="cupd">ith</span>in<span class="cupd"> </span>th<span class="cupd">e </span>la<span class="cupd">st</span> `OLD_KEY_RETENTION + 1` ow<span class="cupd">n</span>e<span class="cupd">r</span><span class="cupd"> </span>epochs.</span></span>
    <span class="marker" id="mapping-206"></span><span class="token mv" id="move-src-115" data-title="contract_body/function_definition">function <span class="marker" id="mapping-207"></span><span class="token upd" id="move-src-116" data-title="function_definition/identifier"><span class="cupd">_areValidRecentO</span>wn<span class="cupd">er</span>s</span>(<span class="marker" id="mapping-208"></span><span class="token mv" id="move-src-117" data-title="function_definition/parameter">address[] memory accounts</span>) <span class="marker" id="mapping-209"></span><span class="token mv" id="move-src-118" data-title="function_definition/visibility">internal</span> <span class="marker" id="mapping-210"></span><span class="token mv" id="move-src-119" data-title="function_definition/state_mutability">view</span> <span class="marker" id="mapping-211"></span><span class="token mv" id="move-src-120" data-title="function_definition/return_type_definition">returns (bool)</span> {
        <span class="marker" id="mapping-212"></span><span class="token mv" id="move-src-121" data-title="variable_declaration_statement/variable_declaration">uint256 <span class="marker" id="mapping-213"></span><span class="token upd" id="move-src-122" data-title="variable_declaration/identifier">o<span class="cupd">w</span><span class="cupd">ner</span>Epoch</span></span> = <span class="marker" id="mapping-214"></span><span class="token mv" id="move-src-123" data-title="variable_declaration_statement/call_expression">_ownerEpoch()</span>;
        <span class="marker" id="mapping-215"></span><span class="token mv" id="move-src-124" data-title="function_body/variable_declaration_statement">uint256 recentEpochs = OLD_KEY_RETENTION + uint256(1);</span>
        <span class="marker" id="mapping-216"></span><span class="token mv" id="move-src-125" data-title="variable_declaration_statement/variable_declaration">uint256 lowerBoundOwnerEpoch</span> = <span class="marker" id="mapping-217"></span><span class="token upd" id="move-src-126" data-title="binary_expression/identifier">own<span class="cupd">e</span>rE<span class="cupd">poch</span></span> &gt; recentEpochs ? <span class="marker" id="mapping-218"></span><span class="token upd" id="move-src-127" data-title="binary_expression/identifier">own<span class="cupd">e</span>rE<span class="cupd">poch</span></span> - recentEpochs : uint256(0);

        while (<span class="marker" id="mapping-219"></span><span class="token upd" id="move-src-128" data-title="binary_expression/identifier">own<span class="cupd">e</span>rE<span class="cupd">poch</span></span> &gt; <span class="marker" id="mapping-220"></span><span class="token upd" id="move-src-129" data-title="binary_expression/identifier"><span class="cupd">lowerBoundO</span>wn<span class="cupd">er</span><span class="cupd">Epoch</span></span>) {
            if (<span class="marker" id="mapping-221"></span><span class="token upd" id="move-src-130" data-title="call_expression/identifier"><span class="cupd">_areValidO</span>wn<span class="cupd">er</span><span class="cupd">sInEpoch</span></span>(<span class="marker" id="mapping-222"></span><span class="token upd" id="move-src-131" data-title="update_expression/identifier">own<span class="cupd">e</span>rE<span class="cupd">poch</span></span>--, accounts)) return true;
        }

        <span class="marker" id="mapping-223"></span><span class="token mv" id="move-src-132" data-title="function_body/return_statement">return false;</span>
    }</span>

    /// @dev Returns true if a sufficient quantity of `accounts` are owners in the `ownerEpoch`.
    <span class="marker" id="mapping-224"></span><span class="token mv" id="move-src-133" data-title="contract_body/function_definition">function <span class="marker" id="mapping-225"></span><span class="token upd" id="move-src-134" data-title="function_definition/identifier"><span class="cupd">_areValidO</span>wn<span class="cupd">er</span><span class="cupd">sInEpoch</span></span>(<span class="marker" id="mapping-226"></span><span class="token mv" id="move-src-135" data-title="function_definition/parameter">uint256 <span class="marker" id="mapping-227"></span><span class="token upd" id="move-src-136" data-title="parameter/identifier">own<span class="cupd">e</span>rE<span class="cupd">poch</span></span></span>, address[] memory accounts) internal view returns (bool) {
        <span class="marker" id="mapping-228"></span><span class="token del" data-title="function_body/if_statement">if (<span class="marker" id="mapping-229"></span><span class="token del" data-title="if_statement/call_expression">_containsDuplicates(accounts)</span>) <span class="marker" id="mapping-230"></span><span class="token mv" id="move-src-137" data-title="if_statement/return_statement">return false;</span></span>

        uint256 threshold = <span class="marker" id="mapping-231"></span><span class="token upd" id="move-src-138" data-title="call_expression/identifier"><span class="cupd">_getO</span>wn<span class="cupd">er</span><span class="cupd">Threshold</span></span>(<span class="marker" id="mapping-232"></span><span class="token upd" id="move-src-139" data-title="call_argument/identifier">own<span class="cupd">e</span>rE<span class="cupd">poch</span></span>);
        uint256 validSignerCount;

        for (uint256 i; i &lt; accounts.length; i++) {
            if (<span class="marker" id="mapping-233"></span><span class="token upd" id="move-src-140" data-title="call_expression/identifier"><span class="cupd">_isO</span>wn<span class="cupd">er</span></span>(<span class="marker" id="mapping-234"></span><span class="token upd" id="move-src-141" data-title="call_argument/identifier">own<span class="cupd">e</span>rE<span class="cupd">poch</span></span>, accounts[i]) &amp;&amp; ++validSignerCount &gt;= threshold) return true;
        }

        return false;
    }</span>

    <span class="marker" id="mapping-235"></span><span class="token mv" id="move-src-142" data-title="contract_body/comment"><span class="marker" id="mapping-236"></span><span class="token upd" id="move-src-143" data-title="contract_body/comment"><span class="cupd">//</span>/<span class="cupd"> </span>@dev<span class="cupd"> </span>Re<span class="cupd">t</span>ur<span class="cupd">n</span><span class="cupd">s </span>t<span class="cupd">h</span><span class="cupd">e </span>a<span class="cupd">r</span>r<span class="cupd">a</span>y<span class="cupd"> </span>of<span class="cupd"> </span>own<span class="cupd">e</span><span class="cupd">r</span>s<span class="cupd"> </span>w<span class="cupd">i</span><span class="cupd">t</span>h<span class="cupd">i</span><span class="cupd">n </span>t<span class="cupd">h</span><span class="cupd">e </span><span class="cupd">c</span>urr<span class="cupd">ent</span> `ownerEpoch`.</span></span>
    function owners() public view override returns (address[] memory results) {
        <span class="marker" id="mapping-237"></span><span class="token mv" id="move-src-144" data-title="function_body/variable_declaration_statement">uint256 <span class="marker" id="mapping-238"></span><span class="token upd" id="move-src-145" data-title="variable_declaration/identifier">own<span class="cupd">e</span>rE<span class="cupd">poch</span></span> = _ownerEpoch();</span>
        uint256 ownerCount = _getOwnerCount(<span class="marker" id="mapping-239"></span><span class="token upd" id="move-src-146" data-title="call_argument/identifier">own<span class="cupd">e</span>rE<span class="cupd">poch</span></span>);
        results = new address[](ownerCount);

        for (uint256 i; i &lt; ownerCount; i++) {
            results[i] = _getOwner(<span class="marker" id="mapping-240"></span><span class="token upd" id="move-src-147" data-title="call_argument/identifier">own<span class="cupd">e</span>rE<span class="cupd">poch</span></span>, i);
        }
    }

    /***********\
    |* Setters *|
    \***********/

    <span class="marker" id="mapping-241"></span><span class="token del" data-title="contract_body/function_definition">function _setOwnerEpoch(<span class="marker" id="mapping-242"></span><span class="token mv" id="move-src-148" data-title="function_definition/parameter">uint256 <span class="marker" id="mapping-243"></span><span class="token upd" id="move-src-149" data-title="parameter/identifier">own<span class="cupd">e</span>rE<span class="cupd">poch</span></span></span>) <span class="marker" id="mapping-244"></span><span class="token mv" id="move-src-150" data-title="function_definition/visibility">internal</span> <span class="marker" id="mapping-245"></span><span class="token del" data-title="function_definition/function_body">{
        <span class="marker" id="mapping-246"></span><span class="token del" data-title="function_body/expression_statement"><span class="marker" id="mapping-247"></span><span class="token del" data-title="expression_statement/call_expression">_setUint(<span class="marker" id="mapping-248"></span><span class="token mv" id="move-src-151" data-title="call_expression/call_argument">KEY_OWNER_EPOCH</span>, <span class="marker" id="mapping-249"></span><span class="token del" data-title="call_expression/call_argument">ownerEpoch</span>)</span>;</span>
    }</span></span>

    <span class="marker" id="mapping-250"></span><span class="token mv" id="move-src-152" data-title="contract_body/function_definition">function <span class="marker" id="mapping-251"></span><span class="token upd" id="move-src-153" data-title="function_definition/identifier"><span class="cupd">_setO</span>wn<span class="cupd">er</span></span>(
        <span class="marker" id="mapping-252"></span><span class="token mv" id="move-src-154" data-title="function_definition/parameter">uint256 <span class="marker" id="mapping-253"></span><span class="token upd" id="move-src-155" data-title="parameter/identifier">own<span class="cupd">e</span>rE<span class="cupd">poch</span></span></span>,
        uint256 index,
        <span class="marker" id="mapping-254"></span><span class="token mv" id="move-src-156" data-title="function_definition/parameter">address account</span>
    ) internal {
        <span class="marker" id="mapping-255"></span><span class="token del" data-title="function_body/expression_statement"><span class="marker" id="mapping-256"></span><span class="token del" data-title="expression_statement/call_expression">require(<span class="marker" id="mapping-257"></span><span class="token del" data-title="call_expression/call_argument"><span class="marker" id="mapping-258"></span><span class="token mv" id="move-src-157" data-title="call_argument/binary_expression"><span class="marker" id="mapping-259"></span><span class="token upd" id="move-src-158" data-title="binary_expression/identifier">acc<span class="cupd">o</span>unt</span> <span class="marker" id="mapping-260"></span><span class="token del" data-title="binary_expression/!=">!=</span> address(0)</span></span>, <span class="marker" id="mapping-261"></span><span class="token del" data-title="call_expression/call_argument">'ZERO_ADDR'</span>)</span>;</span>
        _setAddress(<span class="marker" id="mapping-262"></span><span class="token upd" id="move-src-159" data-title="call_expression/identifier"><span class="cupd">_getO</span>wn<span class="cupd">er</span><span class="cupd">Key</span></span>(<span class="marker" id="mapping-263"></span><span class="token upd" id="move-src-160" data-title="call_argument/identifier">own<span class="cupd">e</span>rE<span class="cupd">poch</span></span>, index), account);
    }</span>

    function _setOwnerCount(<span class="marker" id="mapping-264"></span><span class="token mv" id="move-src-161" data-title="function_definition/parameter">uint256 <span class="marker" id="mapping-265"></span><span class="token upd" id="move-src-162" data-title="parameter/identifier">own<span class="cupd">e</span>rE<span class="cupd">poch</span></span></span>, uint256 ownerCount) internal {
        _setUint(_getOwnerCountKey(<span class="marker" id="mapping-266"></span><span class="token upd" id="move-src-163" data-title="call_argument/identifier">own<span class="cupd">e</span>rE<span class="cupd">poch</span></span>), ownerCount);
    }

    <span class="marker" id="mapping-267"></span><span class="token mv" id="move-src-164" data-title="contract_body/function_definition">function <span class="marker" id="mapping-268"></span><span class="token upd" id="move-src-165" data-title="function_definition/identifier"><span class="cupd">_setO</span>wn<span class="cupd">er</span>s</span>(
        <span class="marker" id="mapping-269"></span><span class="token mv" id="move-src-166" data-title="function_definition/parameter">uint256 <span class="marker" id="mapping-270"></span><span class="token upd" id="move-src-167" data-title="parameter/identifier">own<span class="cupd">e</span>rE<span class="cupd">poch</span></span></span>,
        address[] memory accounts,
        uint256 threshold
    ) internal {
        uint256 accountLength = accounts.length;

        <span class="marker" id="mapping-271"></span><span class="token del" data-title="function_body/expression_statement">require(accountLength &gt;= threshold, 'INV_OWNERS');</span>
        <span class="marker" id="mapping-272"></span><span class="token del" data-title="function_body/expression_statement"><span class="marker" id="mapping-273"></span><span class="token del" data-title="expression_statement/call_expression">require(<span class="marker" id="mapping-274"></span><span class="token del" data-title="call_expression/call_argument"><span class="marker" id="mapping-275"></span><span class="token mv" id="move-src-168" data-title="call_argument/binary_expression">threshold <span class="marker" id="mapping-276"></span><span class="token del" data-title="binary_expression/>">&gt;</span> uint256(0)</span></span>, <span class="marker" id="mapping-277"></span><span class="token del" data-title="call_expression/call_argument">'INV_OWNER_THLD'</span>)</span>;</span>

        <span class="marker" id="mapping-278"></span><span class="token del" data-title="function_body/expression_statement"><span class="marker" id="mapping-279"></span><span class="token del" data-title="expression_statement/call_expression">_setOwnerThreshold(<span class="marker" id="mapping-280"></span><span class="token del" data-title="call_expression/call_argument">ownerEpoch</span>, <span class="marker" id="mapping-281"></span><span class="token mv" id="move-src-169" data-title="call_expression/call_argument">threshold</span>)</span>;</span>
        <span class="marker" id="mapping-282"></span><span class="token del" data-title="function_body/expression_statement"><span class="marker" id="mapping-283"></span><span class="token del" data-title="expression_statement/call_expression">_setOwnerCount(<span class="marker" id="mapping-284"></span><span class="token del" data-title="call_expression/call_argument">ownerEpoch</span>, <span class="marker" id="mapping-285"></span><span class="token mv" id="move-src-170" data-title="call_expression/call_argument">accountLength</span>)</span>;</span>

        for (<span class="marker" id="mapping-286"></span><span class="token mv" id="move-src-171" data-title="for_statement/variable_declaration_statement">uint256 i;</span> i &lt; accountLength; i++) {
            address account = accounts[i];

            <span class="marker" id="mapping-287"></span><span class="token upd" id="move-src-172" data-title="block_statement/comment"><span class="cupd">// Check that the account wasn't already set as an o</span>wn<span class="cupd">er</span><span class="cupd"> for this o</span>wn<span class="cupd">er</span><span class="cupd">Epoch.</span></span>
            <span class="marker" id="mapping-288"></span><span class="token del" data-title="block_statement/expression_statement"><span class="marker" id="mapping-289"></span><span class="token del" data-title="expression_statement/call_expression">require(<span class="marker" id="mapping-290"></span><span class="token del" data-title="call_expression/call_argument"><span class="marker" id="mapping-291"></span><span class="token del" data-title="call_argument/unary_expression">!<span class="marker" id="mapping-292"></span><span class="token del" data-title="unary_expression/call_expression">_isOwner(<span class="marker" id="mapping-293"></span><span class="token del" data-title="call_expression/call_argument">ownerEpoch</span>, <span class="marker" id="mapping-294"></span><span class="token mv" id="move-src-173" data-title="call_expression/call_argument">account</span>)</span></span></span>, <span class="marker" id="mapping-295"></span><span class="token del" data-title="call_expression/call_argument">'DUP_OWNER'</span>)</span>;</span>

            <span class="marker" id="mapping-296"></span><span class="token upd" id="move-src-174" data-title="block_statement/comment"><span class="cupd">// Set this account as the i-th o</span>wn<span class="cupd">er</span><span class="cupd"> in this o</span>wn<span class="cupd">er</span><span class="cupd">Epoch (needed to we can get all the o</span>wn<span class="cupd">er</span><span class="cupd">s for `o</span>wn<span class="cupd">er</span><span class="cupd">s`).</span></span>
            <span class="marker" id="mapping-297"></span><span class="token upd" id="move-src-175" data-title="call_expression/identifier"><span class="cupd">_setO</span>wn<span class="cupd">er</span></span>(<span class="marker" id="mapping-298"></span><span class="token upd" id="move-src-176" data-title="call_argument/identifier">own<span class="cupd">e</span>rE<span class="cupd">poch</span></span>, i, account);
            <span class="marker" id="mapping-299"></span><span class="token upd" id="move-src-177" data-title="call_expression/identifier"><span class="cupd">_setIsO</span>wn<span class="cupd">er</span></span>(<span class="marker" id="mapping-300"></span><span class="token upd" id="move-src-178" data-title="call_argument/identifier">own<span class="cupd">e</span>rE<span class="cupd">poch</span></span>, account, true);
        }
    }</span>

    function _setOwnerThreshold(<span class="marker" id="mapping-301"></span><span class="token mv" id="move-src-179" data-title="function_definition/parameter">uint256 <span class="marker" id="mapping-302"></span><span class="token upd" id="move-src-180" data-title="parameter/identifier">own<span class="cupd">e</span>rE<span class="cupd">poch</span></span></span><span class="marker" id="mapping-303"></span><span class="token mv" id="move-src-181" data-title="function_definition/,">,</span> uint256 <span class="marker" id="mapping-304"></span><span class="token upd" id="move-src-182" data-title="parameter/identifier"><span class="cupd">o</span>wnerThreshold</span>) internal {
        _setUint(_getOwnerThresholdKey(<span class="marker" id="mapping-305"></span><span class="token upd" id="move-src-183" data-title="call_argument/identifier">own<span class="cupd">e</span>rE<span class="cupd">poch</span></span>), <span class="marker" id="mapping-306"></span><span class="token del" data-title="call_expression/call_argument">ownerThreshold</span>);
    }

    function _setIsOwner(
        <span class="marker" id="mapping-307"></span><span class="token mv" id="move-src-184" data-title="function_definition/parameter">uint256 <span class="marker" id="mapping-308"></span><span class="token upd" id="move-src-185" data-title="parameter/identifier">own<span class="cupd">e</span>rE<span class="cupd">poch</span></span></span>,
        address account,
        bool isOwner
    ) internal {
        _setBool(_getIsOwnerKey(<span class="marker" id="mapping-309"></span><span class="token upd" id="move-src-186" data-title="call_argument/identifier">own<span class="cupd">e</span>rE<span class="cupd">poch</span></span>, <span class="marker" id="mapping-310"></span><span class="token mv" id="move-src-187" data-title="call_expression/call_argument">account</span>), isOwner);
    }

    /**************************\
    |* Operator Functionality *|
    \**************************/

    /********************\
    |* Pure Key Getters *|
    \********************/

    function _getOperatorKey(<span class="marker" id="mapping-311"></span><span class="token mv" id="move-src-188" data-title="function_definition/parameter">uint256 <span class="marker" id="mapping-312"></span><span class="token upd" id="move-src-189" data-title="parameter/identifier">op<span class="cupd">e</span>ratorE<span class="cupd">poch</span></span></span>, uint256 index) internal pure returns (bytes32) {
        return keccak256(abi.encodePacked(PREFIX_OPERATOR, <span class="marker" id="mapping-313"></span><span class="token upd" id="move-src-190" data-title="call_argument/identifier">op<span class="cupd">e</span>ratorE<span class="cupd">poch</span></span>, index));
    }

    function _getOperatorCountKey(<span class="marker" id="mapping-314"></span><span class="token mv" id="move-src-191" data-title="function_definition/parameter">uint256 <span class="marker" id="mapping-315"></span><span class="token upd" id="move-src-192" data-title="parameter/identifier">op<span class="cupd">e</span>ratorE<span class="cupd">poch</span></span></span>) internal pure returns (bytes32) {
        return keccak256(abi.encodePacked(PREFIX_OPERATOR_COUNT, <span class="marker" id="mapping-316"></span><span class="token upd" id="move-src-193" data-title="call_argument/identifier">op<span class="cupd">e</span>ratorE<span class="cupd">poch</span></span>));
    }

    function _getOperatorThresholdKey(<span class="marker" id="mapping-317"></span><span class="token mv" id="move-src-194" data-title="function_definition/parameter">uint256 <span class="marker" id="mapping-318"></span><span class="token upd" id="move-src-195" data-title="parameter/identifier">op<span class="cupd">e</span>ratorE<span class="cupd">poch</span></span></span>) internal pure returns (bytes32) {
        return keccak256(abi.encodePacked(PREFIX_OPERATOR_THRESHOLD, <span class="marker" id="mapping-319"></span><span class="token upd" id="move-src-196" data-title="call_argument/identifier">op<span class="cupd">e</span>ratorE<span class="cupd">poch</span></span>));
    }

    function _getIsOperatorKey(<span class="marker" id="mapping-320"></span><span class="token mv" id="move-src-197" data-title="function_definition/parameter">uint256 <span class="marker" id="mapping-321"></span><span class="token upd" id="move-src-198" data-title="parameter/identifier">op<span class="cupd">e</span>ratorE<span class="cupd">poch</span></span></span>, address account) internal pure returns (bytes32) {
        return keccak256(abi.encodePacked(PREFIX_IS_OPERATOR, <span class="marker" id="mapping-322"></span><span class="token upd" id="move-src-199" data-title="call_argument/identifier">op<span class="cupd">e</span>ratorE<span class="cupd">poch</span></span>, account));
    }

    /***********\
    |* Getters *|
    \***********/

    function _operatorEpoch() internal view returns (uint256) {
        return getUint(KEY_OPERATOR_EPOCH);
    }

    <span class="marker" id="mapping-323"></span><span class="token mv" id="move-src-200" data-title="contract_body/function_definition">function <span class="marker" id="mapping-324"></span><span class="token upd" id="move-src-201" data-title="function_definition/identifier"><span class="cupd">_getO</span>p<span class="cupd">er</span>ator</span>(<span class="marker" id="mapping-325"></span><span class="token mv" id="move-src-202" data-title="function_definition/parameter">uint256 <span class="marker" id="mapping-326"></span><span class="token upd" id="move-src-203" data-title="parameter/identifier">op<span class="cupd">e</span>ratorE<span class="cupd">poch</span></span></span>, uint256 index) internal view returns (address) {
        return getAddress(<span class="marker" id="mapping-327"></span><span class="token upd" id="move-src-204" data-title="call_expression/identifier"><span class="cupd">_getO</span>p<span class="cupd">er</span>ator<span class="cupd">Key</span></span>(<span class="marker" id="mapping-328"></span><span class="token upd" id="move-src-205" data-title="call_argument/identifier">op<span class="cupd">e</span>ratorE<span class="cupd">poch</span></span>, index));
    }</span>

    <span class="marker" id="mapping-329"></span><span class="token mv" id="move-src-206" data-title="contract_body/function_definition">function <span class="marker" id="mapping-330"></span><span class="token upd" id="move-src-207" data-title="function_definition/identifier">_g<span class="cupd">e</span>tOpe<span class="cupd">r</span>ato<span class="cupd">r</span>Count</span>(<span class="marker" id="mapping-331"></span><span class="token mv" id="move-src-208" data-title="function_definition/parameter">uint256 <span class="marker" id="mapping-332"></span><span class="token upd" id="move-src-209" data-title="parameter/identifier">op<span class="cupd">e</span>ratorE<span class="cupd">poch</span></span></span>) <span class="marker" id="mapping-333"></span><span class="token mv" id="move-src-210" data-title="function_definition/visibility">internal</span> view returns (uint256) {
        return <span class="marker" id="mapping-334"></span><span class="token upd" id="move-src-211" data-title="call_expression/identifier"><span class="cupd">get</span>Uint</span>(<span class="marker" id="mapping-335"></span><span class="token del" data-title="call_argument/call_expression">_getOperatorCountKey(operatorEpoch)</span>);
    }</span>

    <span class="marker" id="mapping-336"></span><span class="token mv" id="move-src-212" data-title="contract_body/function_definition">function <span class="marker" id="mapping-337"></span><span class="token upd" id="move-src-213" data-title="function_definition/identifier">_getO<span class="cupd">p</span>erat<span class="cupd">o</span>rThreshold</span>(<span class="marker" id="mapping-338"></span><span class="token mv" id="move-src-214" data-title="function_definition/parameter">uint256 <span class="marker" id="mapping-339"></span><span class="token upd" id="move-src-215" data-title="parameter/identifier">op<span class="cupd">e</span>ratorE<span class="cupd">poch</span></span></span>) <span class="marker" id="mapping-340"></span><span class="token mv" id="move-src-216" data-title="function_definition/visibility">internal</span> view returns (uint256) {
        return <span class="marker" id="mapping-341"></span><span class="token upd" id="move-src-217" data-title="call_expression/identifier">getU<span class="cupd">in</span>t</span>(<span class="marker" id="mapping-342"></span><span class="token del" data-title="call_expression/call_argument">_getOperatorThresholdKey(operatorEpoch)</span>);
    }</span>

    <span class="marker" id="mapping-343"></span><span class="token del" data-title="contract_body/function_definition">function _isOperator(<span class="marker" id="mapping-344"></span><span class="token mv" id="move-src-218" data-title="function_definition/parameter">uint256 <span class="marker" id="mapping-345"></span><span class="token upd" id="move-src-219" data-title="parameter/identifier">op<span class="cupd">e</span>ratorE<span class="cupd">poch</span></span></span>, <span class="marker" id="mapping-346"></span><span class="token mv" id="move-src-220" data-title="function_definition/parameter">address account</span>) <span class="marker" id="mapping-347"></span><span class="token mv" id="move-src-221" data-title="function_definition/visibility">internal</span> <span class="marker" id="mapping-348"></span><span class="token mv" id="move-src-222" data-title="function_definition/state_mutability">view</span> <span class="marker" id="mapping-349"></span><span class="token mv" id="move-src-223" data-title="function_definition/return_type_definition">returns (bool)</span> <span class="marker" id="mapping-350"></span><span class="token del" data-title="function_definition/function_body">{
        <span class="marker" id="mapping-351"></span><span class="token del" data-title="function_body/return_statement">return <span class="marker" id="mapping-352"></span><span class="token del" data-title="return_statement/call_expression">getBool(<span class="marker" id="mapping-353"></span><span class="token del" data-title="call_expression/call_argument"><span class="marker" id="mapping-354"></span><span class="token del" data-title="call_argument/call_expression">_getIsOperatorKey(<span class="marker" id="mapping-355"></span><span class="token del" data-title="call_expression/call_argument">operatorEpoch</span>, <span class="marker" id="mapping-356"></span><span class="token mv" id="move-src-224" data-title="call_expression/call_argument">account</span>)</span></span>)</span>;</span>
    }</span></span>

    /// @dev Returns true if a sufficient quantity of `accounts` are operator in the same `operatorEpoch`, within the last `OLD_KEY_RETENTION + 1` operator epochs.
    <span class="marker" id="mapping-357"></span><span class="token mv" id="move-src-225" data-title="contract_body/function_definition">function <span class="marker" id="mapping-358"></span><span class="token upd" id="move-src-226" data-title="function_definition/identifier"><span class="cupd">_areValid</span>R<span class="cupd">e</span>ce<span class="cupd">n</span>tOp<span class="cupd">er</span>ators</span>(<span class="marker" id="mapping-359"></span><span class="token mv" id="move-src-227" data-title="function_definition/parameter">address[] memory accounts</span>) <span class="marker" id="mapping-360"></span><span class="token mv" id="move-src-228" data-title="function_definition/visibility">internal</span> <span class="marker" id="mapping-361"></span><span class="token mv" id="move-src-229" data-title="function_definition/state_mutability">view</span> <span class="marker" id="mapping-362"></span><span class="token mv" id="move-src-230" data-title="function_definition/return_type_definition">returns (bool)</span> {
        <span class="marker" id="mapping-363"></span><span class="token del" data-title="function_body/variable_declaration_statement"><span class="marker" id="mapping-364"></span><span class="token mv" id="move-src-231" data-title="variable_declaration_statement/variable_declaration">uint256 <span class="marker" id="mapping-365"></span><span class="token upd" id="move-src-232" data-title="variable_declaration/identifier">o<span class="cupd">perator</span>Epoch</span></span> = <span class="marker" id="mapping-366"></span><span class="token mv" id="move-src-233" data-title="variable_declaration_statement/call_expression">_operatorEpoch()</span>;</span>
        <span class="marker" id="mapping-367"></span><span class="token mv" id="move-src-234" data-title="function_body/variable_declaration_statement">uint256 recentEpochs = OLD_KEY_RETENTION + uint256(1);</span>
        <span class="marker" id="mapping-368"></span><span class="token mv" id="move-src-235" data-title="variable_declaration_statement/variable_declaration">uint256 lowerBoundOperatorEpoch</span> = <span class="marker" id="mapping-369"></span><span class="token upd" id="move-src-236" data-title="binary_expression/identifier">op<span class="cupd">e</span>ratorE<span class="cupd">poch</span></span> &gt; recentEpochs ? <span class="marker" id="mapping-370"></span><span class="token upd" id="move-src-237" data-title="binary_expression/identifier">op<span class="cupd">e</span>ratorE<span class="cupd">poch</span></span> - recentEpochs : uint256(0);

        while (<span class="marker" id="mapping-371"></span><span class="token upd" id="move-src-238" data-title="binary_expression/identifier">op<span class="cupd">e</span>ratorE<span class="cupd">poch</span></span> &gt; <span class="marker" id="mapping-372"></span><span class="token upd" id="move-src-239" data-title="binary_expression/identifier"><span class="cupd">lowerBoundO</span>p<span class="cupd">er</span>ator<span class="cupd">Epoch</span></span>) {
            if (<span class="marker" id="mapping-373"></span><span class="token upd" id="move-src-240" data-title="call_expression/identifier"><span class="cupd">_areValidO</span>p<span class="cupd">er</span>ator<span class="cupd">sInEpoch</span></span>(<span class="marker" id="mapping-374"></span><span class="token upd" id="move-src-241" data-title="update_expression/identifier">op<span class="cupd">e</span>ratorE<span class="cupd">poch</span></span>--, accounts)) return true;
        }

        <span class="marker" id="mapping-375"></span><span class="token mv" id="move-src-242" data-title="function_body/return_statement">return false;</span>
    }</span>

    /// @dev Returns true if a sufficient quantity of `accounts` are operator in the `operatorEpoch`.
    <span class="marker" id="mapping-376"></span><span class="token mv" id="move-src-243" data-title="contract_body/function_definition">function <span class="marker" id="mapping-377"></span><span class="token upd" id="move-src-244" data-title="function_definition/identifier"><span class="cupd">_areValidO</span>p<span class="cupd">er</span>ator<span class="cupd">sInEpoch</span></span>(<span class="marker" id="mapping-378"></span><span class="token mv" id="move-src-245" data-title="function_definition/parameter">uint256 <span class="marker" id="mapping-379"></span><span class="token upd" id="move-src-246" data-title="parameter/identifier">op<span class="cupd">e</span>ratorE<span class="cupd">poch</span></span></span>, address[] memory accounts) internal view returns (bool) {
        <span class="marker" id="mapping-380"></span><span class="token del" data-title="function_body/if_statement">if (_containsDuplicates(accounts)) return false;</span>

        uint256 threshold = <span class="marker" id="mapping-381"></span><span class="token upd" id="move-src-247" data-title="call_expression/identifier"><span class="cupd">_getO</span>p<span class="cupd">er</span>ator<span class="cupd">Threshold</span></span>(<span class="marker" id="mapping-382"></span><span class="token upd" id="move-src-248" data-title="call_argument/identifier">op<span class="cupd">e</span>ratorE<span class="cupd">poch</span></span>);
        uint256 validSignerCount;

        for (<span class="marker" id="mapping-383"></span><span class="token mv" id="move-src-249" data-title="for_statement/variable_declaration_statement">uint256 i;</span> i &lt; accounts.length; i++) {
            if (<span class="marker" id="mapping-384"></span><span class="token upd" id="move-src-250" data-title="call_expression/identifier"><span class="cupd">_isO</span>p<span class="cupd">er</span>ator</span>(<span class="marker" id="mapping-385"></span><span class="token upd" id="move-src-251" data-title="call_argument/identifier">op<span class="cupd">e</span>ratorE<span class="cupd">poch</span></span>, accounts[i]) &amp;&amp; ++validSignerCount &gt;= threshold) return true;
        }

        return false;
    }</span>

    <span class="marker" id="mapping-386"></span><span class="token upd" id="move-src-252" data-title="contract_body/comment"><span class="cupd">/// @dev Returns the </span>array of operators within the <span class="cupd">current `operatorEpoch`.</span></span>
    function operators() public view override returns (address[] memory results) {
        <span class="marker" id="mapping-387"></span><span class="token mv" id="move-src-253" data-title="function_body/variable_declaration_statement">uint256 <span class="marker" id="mapping-388"></span><span class="token upd" id="move-src-254" data-title="variable_declaration/identifier"><span class="cupd">o</span>peratorEpoch</span> = <span class="marker" id="mapping-389"></span><span class="token mv" id="move-src-255" data-title="variable_declaration_statement/call_expression">_operatorEpoch()</span>;</span>
        uint256 operatorCount = _getOperatorCount(<span class="marker" id="mapping-390"></span><span class="token upd" id="move-src-256" data-title="call_argument/identifier">op<span class="cupd">e</span>ratorE<span class="cupd">poch</span></span>);
        results = new address[](operatorCount);

        <span class="marker" id="mapping-391"></span><span class="token mv" id="move-src-257" data-title="function_body/for_statement">for (<span class="marker" id="mapping-392"></span><span class="token mv" id="move-src-258" data-title="for_statement/variable_declaration_statement">uint256 i;</span> <span class="marker" id="mapping-393"></span><span class="token mv" id="move-src-259" data-title="for_statement/expression_statement">i &lt; operatorCount;</span> <span class="marker" id="mapping-394"></span><span class="token mv" id="move-src-260" data-title="for_statement/update_expression">i++</span>) {
            results[i] = <span class="marker" id="mapping-395"></span><span class="token upd" id="move-src-261" data-title="call_expression/identifier"><span class="cupd">_get</span>Operator</span>(<span class="marker" id="mapping-396"></span><span class="token upd" id="move-src-262" data-title="call_argument/identifier">op<span class="cupd">e</span>ratorE<span class="cupd">poch</span></span>, i);
        }</span>
    }

    /***********\
    |* Setters *|
    \***********/

    <span class="marker" id="mapping-397"></span><span class="token del" data-title="contract_body/function_definition">function _setOperatorEpoch(<span class="marker" id="mapping-398"></span><span class="token mv" id="move-src-263" data-title="function_definition/parameter">uint256 <span class="marker" id="mapping-399"></span><span class="token upd" id="move-src-264" data-title="parameter/identifier">op<span class="cupd">e</span>ratorE<span class="cupd">poch</span></span></span>) <span class="marker" id="mapping-400"></span><span class="token mv" id="move-src-265" data-title="function_definition/visibility">internal</span> <span class="marker" id="mapping-401"></span><span class="token del" data-title="function_definition/function_body">{
        <span class="marker" id="mapping-402"></span><span class="token del" data-title="function_body/expression_statement"><span class="marker" id="mapping-403"></span><span class="token del" data-title="expression_statement/call_expression">_setUint(<span class="marker" id="mapping-404"></span><span class="token mv" id="move-src-266" data-title="call_expression/call_argument">KEY_OPERATOR_EPOCH</span>, <span class="marker" id="mapping-405"></span><span class="token del" data-title="call_expression/call_argument">operatorEpoch</span>)</span>;</span>
    }</span></span>

    <span class="marker" id="mapping-406"></span><span class="token mv" id="move-src-267" data-title="contract_body/function_definition">function <span class="marker" id="mapping-407"></span><span class="token upd" id="move-src-268" data-title="function_definition/identifier"><span class="cupd">_setO</span>p<span class="cupd">er</span>ator</span>(
        <span class="marker" id="mapping-408"></span><span class="token mv" id="move-src-269" data-title="function_definition/parameter">uint256 <span class="marker" id="mapping-409"></span><span class="token upd" id="move-src-270" data-title="parameter/identifier">op<span class="cupd">e</span>ratorE<span class="cupd">poch</span></span></span>,
        uint256 index,
        <span class="marker" id="mapping-410"></span><span class="token mv" id="move-src-271" data-title="function_definition/parameter">address account</span>
    ) internal {
        _setAddress(<span class="marker" id="mapping-411"></span><span class="token upd" id="move-src-272" data-title="call_expression/identifier"><span class="cupd">_getO</span>p<span class="cupd">er</span>ator<span class="cupd">Key</span></span>(<span class="marker" id="mapping-412"></span><span class="token upd" id="move-src-273" data-title="call_argument/identifier">op<span class="cupd">e</span>ratorE<span class="cupd">poch</span></span>, index), account);
    }</span>

    function _setOperatorCount(<span class="marker" id="mapping-413"></span><span class="token mv" id="move-src-274" data-title="function_definition/parameter">uint256 <span class="marker" id="mapping-414"></span><span class="token upd" id="move-src-275" data-title="parameter/identifier">op<span class="cupd">e</span>ratorE<span class="cupd">poch</span></span></span>, uint256 operatorCount) internal {
        _setUint(_getOperatorCountKey(<span class="marker" id="mapping-415"></span><span class="token upd" id="move-src-276" data-title="call_argument/identifier">op<span class="cupd">e</span>ratorE<span class="cupd">poch</span></span>), operatorCount);
    }

    <span class="marker" id="mapping-416"></span><span class="token mv" id="move-src-277" data-title="contract_body/function_definition">function <span class="marker" id="mapping-417"></span><span class="token upd" id="move-src-278" data-title="function_definition/identifier"><span class="cupd">_setO</span>p<span class="cupd">er</span>ators</span>(
        <span class="marker" id="mapping-418"></span><span class="token mv" id="move-src-279" data-title="function_definition/parameter">uint256 <span class="marker" id="mapping-419"></span><span class="token upd" id="move-src-280" data-title="parameter/identifier">op<span class="cupd">e</span>ratorE<span class="cupd">poch</span></span></span>,
        address[] memory accounts,
        uint256 threshold
    ) internal {
        uint256 accountLength = accounts.length;

        <span class="marker" id="mapping-420"></span><span class="token del" data-title="function_body/expression_statement">require(accountLength &gt;= threshold, 'INV_OPERATORS');</span>
        <span class="marker" id="mapping-421"></span><span class="token del" data-title="function_body/expression_statement"><span class="marker" id="mapping-422"></span><span class="token del" data-title="expression_statement/call_expression">require(<span class="marker" id="mapping-423"></span><span class="token del" data-title="call_expression/call_argument"><span class="marker" id="mapping-424"></span><span class="token mv" id="move-src-281" data-title="call_argument/binary_expression">threshold <span class="marker" id="mapping-425"></span><span class="token del" data-title="binary_expression/>">&gt;</span> uint256(0)</span></span>, <span class="marker" id="mapping-426"></span><span class="token del" data-title="call_expression/call_argument">'INV_OPERATOR_THLD'</span>)</span>;</span>

        <span class="marker" id="mapping-427"></span><span class="token del" data-title="function_body/expression_statement"><span class="marker" id="mapping-428"></span><span class="token del" data-title="expression_statement/call_expression">_setOperatorThreshold(<span class="marker" id="mapping-429"></span><span class="token del" data-title="call_expression/call_argument">operatorEpoch</span>, <span class="marker" id="mapping-430"></span><span class="token mv" id="move-src-282" data-title="call_expression/call_argument">threshold</span>)</span>;</span>
        <span class="marker" id="mapping-431"></span><span class="token del" data-title="function_body/expression_statement"><span class="marker" id="mapping-432"></span><span class="token del" data-title="expression_statement/call_expression">_setOperatorCount(<span class="marker" id="mapping-433"></span><span class="token del" data-title="call_expression/call_argument">operatorEpoch</span>, <span class="marker" id="mapping-434"></span><span class="token mv" id="move-src-283" data-title="call_expression/call_argument">accountLength</span>)</span>;</span>

        for (<span class="marker" id="mapping-435"></span><span class="token mv" id="move-src-284" data-title="for_statement/variable_declaration_statement">uint256 i;</span> i &lt; accountLength; i++) {
            address account = accounts[i];

            <span class="marker" id="mapping-436"></span><span class="token upd" id="move-src-285" data-title="block_statement/comment"><span class="cupd">// Check that the account wasn't already set as an o</span>p<span class="cupd">er</span>ator<span class="cupd"> for this o</span>p<span class="cupd">er</span>ator<span class="cupd">Epoch.</span></span>
            <span class="marker" id="mapping-437"></span><span class="token del" data-title="block_statement/expression_statement"><span class="marker" id="mapping-438"></span><span class="token del" data-title="expression_statement/call_expression">require(<span class="marker" id="mapping-439"></span><span class="token del" data-title="call_expression/call_argument"><span class="marker" id="mapping-440"></span><span class="token del" data-title="call_argument/unary_expression">!<span class="marker" id="mapping-441"></span><span class="token del" data-title="unary_expression/call_expression">_isOperator(<span class="marker" id="mapping-442"></span><span class="token del" data-title="call_expression/call_argument">operatorEpoch</span>, <span class="marker" id="mapping-443"></span><span class="token mv" id="move-src-286" data-title="call_expression/call_argument">account</span>)</span></span></span>, <span class="marker" id="mapping-444"></span><span class="token del" data-title="call_expression/call_argument">'DUP_OPERATOR'</span>)</span>;</span>

            <span class="marker" id="mapping-445"></span><span class="token upd" id="move-src-287" data-title="block_statement/comment"><span class="cupd">// Set this account as the i-th o</span>p<span class="cupd">er</span>ator<span class="cupd"> in this o</span>p<span class="cupd">er</span>ator<span class="cupd">Epoch (needed to we can get all the o</span>p<span class="cupd">er</span>ator<span class="cupd">s for `o</span>p<span class="cupd">er</span>ator<span class="cupd">s`).</span></span>
            <span class="marker" id="mapping-446"></span><span class="token upd" id="move-src-288" data-title="call_expression/identifier"><span class="cupd">_setO</span>p<span class="cupd">er</span>ator</span>(<span class="marker" id="mapping-447"></span><span class="token upd" id="move-src-289" data-title="call_argument/identifier">op<span class="cupd">e</span>ratorE<span class="cupd">poch</span></span>, i, account);
            <span class="marker" id="mapping-448"></span><span class="token upd" id="move-src-290" data-title="call_expression/identifier"><span class="cupd">_setIsO</span>p<span class="cupd">er</span>ator</span>(<span class="marker" id="mapping-449"></span><span class="token upd" id="move-src-291" data-title="call_argument/identifier">op<span class="cupd">e</span>ratorE<span class="cupd">poch</span></span>, account, true);
        }
    }</span>

    <span class="marker" id="mapping-450"></span><span class="token del" data-title="contract_body/function_definition">function _setOperatorThreshold(<span class="marker" id="mapping-451"></span><span class="token mv" id="move-src-292" data-title="function_definition/parameter">uint256 <span class="marker" id="mapping-452"></span><span class="token upd" id="move-src-293" data-title="parameter/identifier">op<span class="cupd">e</span>ratorE<span class="cupd">poch</span></span></span>, <span class="marker" id="mapping-453"></span><span class="token mv" id="move-src-294" data-title="function_definition/parameter">uint256 <span class="marker" id="mapping-454"></span><span class="token upd" id="move-src-295" data-title="parameter/identifier">o<span class="cupd">p</span>erat<span class="cupd">o</span>rThreshold</span></span>) <span class="marker" id="mapping-455"></span><span class="token mv" id="move-src-296" data-title="function_definition/visibility">internal</span> <span class="marker" id="mapping-456"></span><span class="token del" data-title="function_definition/function_body">{
        _setUint(_getOperatorThresholdKey(operatorEpoch), operatorThreshold);
    }</span></span>

    function _setIsOperator(
        <span class="marker" id="mapping-457"></span><span class="token mv" id="move-src-297" data-title="function_definition/parameter">uint256 <span class="marker" id="mapping-458"></span><span class="token upd" id="move-src-298" data-title="parameter/identifier">op<span class="cupd">e</span>ratorE<span class="cupd">poch</span></span></span>,
        address account,
        bool isOperator
    ) internal {
        _setBool(_getIsOperatorKey(<span class="marker" id="mapping-459"></span><span class="token upd" id="move-src-299" data-title="call_argument/identifier">op<span class="cupd">e</span>ratorE<span class="cupd">poch</span></span>, <span class="marker" id="mapping-460"></span><span class="token mv" id="move-src-300" data-title="call_expression/call_argument">account</span>), isOperator);
    }

    /**********************\
    |* Self Functionality *|
    \**********************/

    function deployToken(bytes calldata params) external onlySelf {
        (string memory name, string memory symbol, uint8 decimals, uint256 cap) = abi.decode(
            params,
            (string, string, uint8, uint256)
        );

        _deployToken(name, <span class="marker" id="mapping-461"></span><span class="token mv" id="move-src-301" data-title="call_expression/call_argument">symbol</span>, decimals, cap);
    }

    function mintToken(bytes calldata params) external onlySelf {
        (string memory symbol, address account, uint256 amount) = abi.decode(params, (string, address, uint256));

        _mintToken(symbol, account, amount);
    }

    function burnToken(bytes calldata params) external onlySelf {
        (string memory symbol, bytes32 salt) = abi.decode(params, (string, bytes32));

        _burnToken(symbol, salt);
    }

    function transferOwnership(bytes calldata params) external onlySelf {
        (address[] memory newOwners, uint256 newThreshold) = abi.decode(params, (address[], uint256));

        <span class="marker" id="mapping-462"></span><span class="token mv" id="move-src-302" data-title="function_body/variable_declaration_statement">uint256 <span class="marker" id="mapping-463"></span><span class="token upd" id="move-src-303" data-title="variable_declaration/identifier">o<span class="cupd">w</span><span class="cupd">nerEpoch</span></span> = <span class="marker" id="mapping-464"></span><span class="token del" data-title="variable_declaration_statement/call_expression">_ownerEpoch()</span>;</span>

        emit OwnershipTransferred(<span class="marker" id="mapping-465"></span><span class="token mv" id="move-src-304" data-title="emit_statement/call_argument"><span class="marker" id="mapping-466"></span><span class="token upd" id="move-src-305" data-title="call_expression/identifier">o<span class="cupd">wner</span>s</span>()</span><span class="marker" id="mapping-467"></span><span class="token mv" id="move-src-306" data-title="emit_statement/,">,</span> <span class="marker" id="mapping-468"></span><span class="token upd" id="move-src-307" data-title="call_expression/identifier">_getO<span class="cupd">wner</span>Threshold</span>(<span class="marker" id="mapping-469"></span><span class="token upd" id="move-src-308" data-title="call_argument/identifier">own<span class="cupd">e</span>rE<span class="cupd">poch</span></span>), newOwners, newThreshold);

        _setOwnerEpoch(++<span class="marker" id="mapping-470"></span><span class="token upd" id="move-src-309" data-title="update_expression/identifier">own<span class="cupd">e</span>rE<span class="cupd">poch</span></span>);
        _setOwners(<span class="marker" id="mapping-471"></span><span class="token upd" id="move-src-310" data-title="call_argument/identifier">own<span class="cupd">e</span>rE<span class="cupd">poch</span></span>, newOwners, newThreshold);
    }

    function transferOperatorship(bytes calldata params) external onlySelf {
        (address[] memory newOperators, uint256 newThreshold) = abi.decode(params, (address[], uint256));

        <span class="marker" id="mapping-472"></span><span class="token mv" id="move-src-311" data-title="function_body/variable_declaration_statement"><span class="marker" id="mapping-473"></span><span class="token mv" id="move-src-312" data-title="variable_declaration_statement/variable_declaration">uint256 <span class="marker" id="mapping-474"></span><span class="token upd" id="move-src-313" data-title="variable_declaration/identifier">own<span class="cupd">e</span>rE<span class="cupd">poch</span></span></span> = _ownerEpoch();</span>

        emit OperatorshipTransferred(<span class="marker" id="mapping-475"></span><span class="token mv" id="move-src-314" data-title="emit_statement/call_argument"><span class="marker" id="mapping-476"></span><span class="token upd" id="move-src-315" data-title="call_expression/identifier">o<span class="cupd">perator</span>s</span>()</span><span class="marker" id="mapping-477"></span><span class="token mv" id="move-src-316" data-title="emit_statement/,">,</span> <span class="marker" id="mapping-478"></span><span class="token upd" id="move-src-317" data-title="call_expression/identifier">_getO<span class="cupd">perator</span>Threshold</span>(<span class="marker" id="mapping-479"></span><span class="token upd" id="move-src-318" data-title="call_argument/identifier">own<span class="cupd">e</span>rE<span class="cupd">poch</span></span>), newOperators, newThreshold);

        <span class="marker" id="mapping-480"></span><span class="token mv" id="move-src-319" data-title="function_body/variable_declaration_statement">uint256 <span class="marker" id="mapping-481"></span><span class="token upd" id="move-src-320" data-title="variable_declaration/identifier">op<span class="cupd">e</span>rator<span class="cupd">Epoch</span></span> = <span class="marker" id="mapping-482"></span><span class="token mv" id="move-src-321" data-title="variable_declaration_statement/call_expression">_operatorEpoch()</span>;</span>
        _setOperatorEpoch(++<span class="marker" id="mapping-483"></span><span class="token upd" id="move-src-322" data-title="update_expression/identifier">op<span class="cupd">e</span>ratorE<span class="cupd">poch</span></span>);
        _setOperators(<span class="marker" id="mapping-484"></span><span class="token upd" id="move-src-323" data-title="call_argument/identifier">op<span class="cupd">e</span>ratorE<span class="cupd">poch</span></span>, newOperators, newThreshold);
    }

    /**************************\
    |* External Functionality *|
    \**************************/

    function setup(bytes calldata params) external override {
        // Prevent setup from being called on a non-proxy (the implementation).
        <span class="marker" id="mapping-485"></span><span class="token del" data-title="function_body/expression_statement"><span class="marker" id="mapping-486"></span><span class="token del" data-title="expression_statement/call_expression">require(<span class="marker" id="mapping-487"></span><span class="token del" data-title="call_expression/call_argument"><span class="marker" id="mapping-488"></span><span class="token mv" id="move-src-324" data-title="call_argument/binary_expression">implementation() <span class="marker" id="mapping-489"></span><span class="token del" data-title="binary_expression/!=">!=</span> address(0)</span></span>, <span class="marker" id="mapping-490"></span><span class="token del" data-title="call_expression/call_argument">'NOT_PROXY'</span>)</span>;</span>

        (
            address[] memory adminAddresses,
            <span class="marker" id="mapping-491"></span><span class="token mv" id="move-src-325" data-title="variable_declaration_tuple/variable_declaration">uint256 <span class="marker" id="mapping-492"></span><span class="token upd" id="move-src-326" data-title="variable_declaration/identifier">adminTh<span class="cupd">r</span><span class="cupd">e</span>shold</span></span>,
            address[] memory ownerAddresses,
            <span class="marker" id="mapping-493"></span><span class="token mv" id="move-src-327" data-title="variable_declaration_tuple/variable_declaration">uint256 <span class="marker" id="mapping-494"></span><span class="token upd" id="move-src-328" data-title="variable_declaration/identifier"><span class="cupd">o</span>wnerThreshold</span></span>,
            address[] memory operatorAddresses,
            <span class="marker" id="mapping-495"></span><span class="token mv" id="move-src-329" data-title="variable_declaration_tuple/variable_declaration">uint256 <span class="marker" id="mapping-496"></span><span class="token upd" id="move-src-330" data-title="variable_declaration/identifier"><span class="cupd">o</span>p<span class="cupd">e</span>ra<span class="cupd">t</span>orThreshold</span></span>
        ) = abi.decode(params, (address[], uint256, address[], uint256, address[], uint256));

        <span class="marker" id="mapping-497"></span><span class="token del" data-title="function_body/variable_declaration_statement"><span class="marker" id="mapping-498"></span><span class="token mv" id="move-src-331" data-title="variable_declaration_statement/variable_declaration">uint256 <span class="marker" id="mapping-499"></span><span class="token upd" id="move-src-332" data-title="variable_declaration/identifier">adminE<span class="cupd">poch</span></span></span> = <span class="marker" id="mapping-500"></span><span class="token mv" id="move-src-333" data-title="variable_declaration_statement/binary_expression">_adminEpoch() + uint256(1)</span>;</span>
        _setAdminEpoch(<span class="marker" id="mapping-501"></span><span class="token upd" id="move-src-334" data-title="call_argument/identifier">a<span class="cupd">dminEpoch</span></span>);
        <span class="marker" id="mapping-502"></span><span class="token del" data-title="function_body/expression_statement"><span class="marker" id="mapping-503"></span><span class="token del" data-title="expression_statement/call_expression">_setAdmins(<span class="marker" id="mapping-504"></span><span class="token del" data-title="call_expression/call_argument">adminEpoch</span>, <span class="marker" id="mapping-505"></span><span class="token mv" id="move-src-335" data-title="call_expression/call_argument">adminAddresses</span>, <span class="marker" id="mapping-506"></span><span class="token del" data-title="call_expression/call_argument">adminThreshold</span>)</span>;</span>

        <span class="marker" id="mapping-507"></span><span class="token mv" id="move-src-336" data-title="function_body/variable_declaration_statement">uint256 <span class="marker" id="mapping-508"></span><span class="token upd" id="move-src-337" data-title="variable_declaration/identifier">own<span class="cupd">e</span>rE<span class="cupd">poch</span></span> = <span class="marker" id="mapping-509"></span><span class="token mv" id="move-src-338" data-title="variable_declaration_statement/binary_expression">_ownerEpoch() + uint256(1)</span>;</span>
        _setOwnerEpoch(<span class="marker" id="mapping-510"></span><span class="token upd" id="move-src-339" data-title="call_argument/identifier">o<span class="cupd">w</span><span class="cupd">nerEpoch</span></span>);
        <span class="marker" id="mapping-511"></span><span class="token del" data-title="function_body/expression_statement"><span class="marker" id="mapping-512"></span><span class="token del" data-title="expression_statement/call_expression">_setOwners(<span class="marker" id="mapping-513"></span><span class="token del" data-title="call_expression/call_argument">ownerEpoch</span>, <span class="marker" id="mapping-514"></span><span class="token mv" id="move-src-340" data-title="call_expression/call_argument">ownerAddresses</span>, <span class="marker" id="mapping-515"></span><span class="token del" data-title="call_expression/call_argument">ownerThreshold</span>)</span>;</span>

        uint256 <span class="marker" id="mapping-516"></span><span class="token upd" id="move-src-341" data-title="variable_declaration/identifier">o<span class="cupd">peratorEpoch</span></span> = _operatorEpoch() + uint256(1);
        _setOperatorEpoch(<span class="marker" id="mapping-517"></span><span class="token upd" id="move-src-342" data-title="call_argument/identifier">o<span class="cupd">peratorEpoch</span></span>);
        <span class="marker" id="mapping-518"></span><span class="token del" data-title="function_body/expression_statement"><span class="marker" id="mapping-519"></span><span class="token del" data-title="expression_statement/call_expression">_setOperators(<span class="marker" id="mapping-520"></span><span class="token del" data-title="call_expression/call_argument">operatorEpoch</span>, <span class="marker" id="mapping-521"></span><span class="token mv" id="move-src-343" data-title="call_expression/call_argument">operatorAddresses</span>, <span class="marker" id="mapping-522"></span><span class="token del" data-title="call_expression/call_argument">operatorThreshold</span>)</span>;</span>

        emit OwnershipTransferred(new address[](uint256(0)), uint256(0), ownerAddresses, <span class="marker" id="mapping-523"></span><span class="token upd" id="move-src-344" data-title="call_argument/identifier">o<span class="cupd">w</span><span class="cupd">nerThreshold</span></span>);
        emit OperatorshipTransferred(new address[](uint256(0)), uint256(0), operatorAddresses, <span class="marker" id="mapping-524"></span><span class="token upd" id="move-src-345" data-title="call_argument/identifier">o<span class="cupd">peratorThreshold</span></span>);
    }

    function execute(bytes calldata input) external override {
        (bytes memory data, bytes[] memory signatures) = abi.decode(input, (bytes, bytes[]));

        _execute(data, signatures);
    }

    function _execute(bytes memory data, bytes[] memory signatures) internal {
        uint256 signatureCount = signatures.length;

        address[] memory signers = new address[](signatureCount);

        for (uint256 i; i &lt; signatureCount; i++) {
            signers[i] = ECDSA.recover(ECDSA.toEthSignedMessageHash(keccak256(data)), signatures[i]);
        }

        (uint256 chainId, <span class="marker" id="mapping-525"></span><span class="token mv" id="move-src-346" data-title="variable_declaration_tuple/variable_declaration">bytes32[] memory commandIds</span>, <span class="marker" id="mapping-526"></span><span class="token mv" id="move-src-347" data-title="variable_declaration_tuple/variable_declaration">string[] memory commands</span>, bytes[] memory params) = abi.decode(
            data,
            (uint256, <span class="marker" id="mapping-527"></span><span class="token mv" id="move-src-348" data-title="tuple_expression/array_access">bytes32[]</span>, <span class="marker" id="mapping-528"></span><span class="token mv" id="move-src-349" data-title="tuple_expression/array_access">string[]</span>, bytes[])
        );

        <span class="marker" id="mapping-529"></span><span class="token del" data-title="function_body/expression_statement">require(chainId == _getChainID(), 'INV_CHAIN');</span>

        uint256 commandsLength = commandIds.length;

        <span class="marker" id="mapping-530"></span><span class="token del" data-title="function_body/expression_statement"><span class="marker" id="mapping-531"></span><span class="token del" data-title="expression_statement/call_expression">require(<span class="marker" id="mapping-532"></span><span class="token del" data-title="call_expression/call_argument"><span class="marker" id="mapping-533"></span><span class="token mv" id="move-src-350" data-title="call_argument/binary_expression">commandsLength <span class="marker" id="mapping-534"></span><span class="token del" data-title="binary_expression/==">==</span> commands.length <span class="marker" id="mapping-535"></span><span class="token del" data-title="binary_expression/&&">&amp;&amp;</span> commandsLength <span class="marker" id="mapping-536"></span><span class="token del" data-title="binary_expression/==">==</span> params.length</span></span>, <span class="marker" id="mapping-537"></span><span class="token del" data-title="call_expression/call_argument">'INV_CMDS'</span>)</span>;</span>

        bool areValidCurrentOwners <span class="marker" id="mapping-538"></span><span class="token del" data-title="variable_declaration_statement/=">=</span> <span class="marker" id="mapping-539"></span><span class="token mv" id="move-src-351" data-title="variable_declaration_statement/call_expression">_areValidOwnersInEpoch(_ownerEpoch(), signers)</span>;
        bool areValidRecentOwners <span class="marker" id="mapping-540"></span><span class="token del" data-title="variable_declaration_statement/=">=</span> <span class="marker" id="mapping-541"></span><span class="token del" data-title="variable_declaration_statement/binary_expression">areValidCurrentOwners || <span class="marker" id="mapping-542"></span><span class="token mv" id="move-src-352" data-title="binary_expression/call_expression"><span class="marker" id="mapping-543"></span><span class="token upd" id="move-src-353" data-title="call_expression/identifier"><span class="cupd">_</span>a<span class="cupd">r</span><span class="cupd">e</span>V<span class="cupd">a</span><span class="cupd">li</span>dRe<span class="cupd">c</span>en<span class="cupd">t</span>Owners</span>(signers)</span></span>;
        bool areValidRecentOperators <span class="marker" id="mapping-544"></span><span class="token del" data-title="variable_declaration_statement/=">=</span> <span class="marker" id="mapping-545"></span><span class="token mv" id="move-src-354" data-title="variable_declaration_statement/call_expression">_areValidRecentOperators(signers)</span>;

        for (uint256 i; i &lt; commandsLength; i++) {
            bytes32 commandId = commandIds[i];

            if (isCommandExecuted(commandId)) continue; /* Ignore if duplicate commandId received */

            bytes4 commandSelector;
            bytes32 commandHash = keccak256(abi.encodePacked(commands[i]));

            if (commandHash == SELECTOR_DEPLOY_TOKEN) {
                if (!areValidRecentOwners) continue;

                commandSelector = AxelarGatewayMultisig.deployToken.selector;
            } else <span class="marker" id="mapping-546"></span><span class="token mv" id="move-src-355" data-title="if_statement/if_statement">if (<span class="marker" id="mapping-547"></span><span class="token mv" id="move-src-356" data-title="if_statement/binary_expression">commandHash == SELECTOR_MINT_TOKEN</span>) <span class="marker" id="mapping-548"></span><span class="token mv" id="move-src-357" data-title="if_statement/block_statement">{
                if (!areValidRecentOperators &amp;&amp; !areValidRecentOwners) continue;

                commandSelector = AxelarGatewayMultisig.mintToken.selector;
            }</span> else if (commandHash == SELECTOR_BURN_TOKEN) {
                if (!areValidRecentOperators &amp;&amp; !areValidRecentOwners) continue;

                commandSelector = AxelarGatewayMultisig.burnToken.selector;
            } else if (commandHash == SELECTOR_TRANSFER_OWNERSHIP) {
                if (!areValidCurrentOwners) continue;

                commandSelector = AxelarGatewayMultisig.transferOwnership.selector;
            } else if (commandHash == SELECTOR_TRANSFER_OPERATORSHIP) {
                if (!areValidCurrentOwners) continue;

                commandSelector = AxelarGatewayMultisig.transferOperatorship.selector;
            } else {
                continue; /* Ignore if unknown command received */
            }</span>

            // Prevent a re-entrancy from executing this command before it can be marked as successful.
            _setCommandExecuted(commandId, true);
            (bool success, ) = address(this).call(abi.encodeWithSelector(commandSelector, params[i]));
            _setCommandExecuted(commandId, success);

            if (success) {
                emit Executed(commandId);
            }
        }
    }
}</pre></div><div class="col-6"><h5>0xbd3e8d41874bc123fb6913a2a6c6c8984c71876c.etherscan.io-AxelarGatewayMultisig.sol</h5><pre class="pre-scrollable">// SPDX-License-Identifier: MIT

pragma solidity<span class="marker" id="mapping-549"></span><span class="token upd" id="move-dst-1" data-title="solidity_pragma_token/solidity_version"> <span class="cupd">0.8.9</span></span>;

<span class="marker" id="mapping-550"></span><span class="token mv" id="move-dst-13" data-title="source_file/comment">/**
 * @dev Interface of the ERC20 standard as defined in the EIP.
 */</span>
<span class="marker" id="mapping-551"></span><span class="token mv" id="move-dst-14" data-title="source_file/interface_declaration">interface IERC20 {
    /**
     * @dev Returns the amount of tokens in existence.
     */
    function totalSupply() external view returns (uint256);

    /**
     * @dev Returns the amount of tokens owned by `account`.
     */
    function balanceOf(address account) external view returns (uint256);

    /**
     * @dev Moves `amount` tokens from the caller's account to `recipient`.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * Emits a {Transfer} event.
     */
    function transfer(address recipient, uint256 amount) external returns (bool);

    /**
     * @dev Returns the remaining number of tokens that `spender` will be
     * allowed to spend on behalf of `owner` through {transferFrom}. This is
     * zero by default.
     *
     * This value changes when {approve} or {transferFrom} are called.
     */
    function allowance(address owner, address spender) external view returns (uint256);

    /**
     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * IMPORTANT: Beware that changing an allowance with this method brings the risk
     * that someone may use both the old and the new allowance by unfortunate
     * transaction ordering. One possible solution to mitigate this race
     * condition is to first reduce the spender's allowance to 0 and set the
     * desired value afterwards:
     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
     *
     * Emits an {Approval} event.
     */
    function approve(address spender, uint256 amount) external returns (bool);

    /**
     * @dev Moves `amount` tokens from `sender` to `recipient` using the
     * allowance mechanism. `amount` is then deducted from the caller's
     * allowance.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * Emits a {Transfer} event.
     */
    function transferFrom(
        address sender,
        address recipient,
        uint256 amount
    ) external returns (bool);

    /**
     * @dev Emitted when `value` tokens are moved from one account (`from`) to
     * another (`to`).
     *
     * Note that `value` may be zero.
     */
    event Transfer(address indexed from, address indexed to, uint256 value);

    /**
     * @dev Emitted when the allowance of a `spender` for an `owner` is set by
     * a call to {approve}. `value` is the new allowance.
     */
    event Approval(address indexed owner, address indexed spender, uint256 value);
}</span>

<span class="marker" id="mapping-552"></span><span class="token mv" id="move-dst-15" data-title="source_file/contract_declaration">abstract contract Ownable {
    address public owner;

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    constructor() {
        owner = msg.sender;
        emit OwnershipTransferred(address(0), msg.sender);
    }

    modifier onlyOwner() {
        require(owner == msg.sender, 'NOT_OWNER');
        _;
    }

    function transferOwnership(address newOwner) public virtual onlyOwner {
        require(newOwner != address(0), 'ZERO_ADDR');

        emit OwnershipTransferred(owner, newOwner);
        owner = newOwner;
    }
}</span>

<span class="marker" id="mapping-553"></span><span class="token add" data-title="source_file/interface_declaration">interface IERC20BurnFrom {
    function burnFrom(address account, uint256 amount) external;
}</span>

<span class="marker" id="mapping-554"></span><span class="token mv" id="move-dst-19" data-title="source_file/comment">/**
 * @title EternalStorage
 * @dev This contract holds all the necessary state variables to carry out the storage of any contract.
 */</span>
<span class="marker" id="mapping-555"></span><span class="token mv" id="move-dst-20" data-title="source_file/contract_declaration">contract EternalStorage {
    mapping(bytes32 =&gt; uint256) private _uintStorage;
    mapping(bytes32 =&gt; string) private _stringStorage;
    mapping(bytes32 =&gt; address) private _addressStorage;
    mapping(bytes32 =&gt; bytes) private _bytesStorage;
    mapping(bytes32 =&gt; bool) private _boolStorage;
    mapping(bytes32 =&gt; int256) private _intStorage;

    // *** Getter Methods ***
    function getUint(bytes32 key) public view returns (uint256) {
        return _uintStorage[key];
    }

    function getString(bytes32 key) public view returns (string memory) {
        return _stringStorage[key];
    }

    function getAddress(bytes32 key) public view returns (address) {
        return _addressStorage[key];
    }

    function getBytes(bytes32 key) public view returns (bytes memory) {
        return _bytesStorage[key];
    }

    function getBool(bytes32 key) public view returns (bool) {
        return _boolStorage[key];
    }

    function getInt(bytes32 key) public view returns (int256) {
        return _intStorage[key];
    }

    // *** Setter Methods ***
    function _setUint(bytes32 key, uint256 value) internal {
        _uintStorage[key] = value;
    }

    function _setString(bytes32 key, string memory value) internal {
        _stringStorage[key] = value;
    }

    function _setAddress(bytes32 key, address value) internal {
        _addressStorage[key] = value;
    }

    function _setBytes(bytes32 key, bytes memory value) internal {
        _bytesStorage[key] = value;
    }

    function _setBool(bytes32 key, bool value) internal {
        _boolStorage[key] = value;
    }

    function _setInt(bytes32 key, int256 value) internal {
        _intStorage[key] = value;
    }

    // *** Delete Methods ***
    function _deleteUint(bytes32 key) internal {
        delete _uintStorage[key];
    }

    function _deleteString(bytes32 key) internal {
        delete _stringStorage[key];
    }

    function _deleteAddress(bytes32 key) internal {
        delete _addressStorage[key];
    }

    function _deleteBytes(bytes32 key) internal {
        delete _bytesStorage[key];
    }

    function _deleteBool(bytes32 key) internal {
        delete _boolStorage[key];
    }

    function _deleteInt(bytes32 key) internal {
        delete _intStorage[key];
    }
}</span>

<span class="marker" id="mapping-556"></span><span class="token add" data-title="source_file/contract_declaration">contract DepositHandler {
    uint256 internal constant IS_NOT_LOCKED = uint256(0);
    uint256 internal constant IS_LOCKED = uint256(1);

    uint256 internal _lockedStatus = IS_NOT_LOCKED;

    modifier noReenter() {
        require(_lockedStatus == IS_NOT_LOCKED);

        _lockedStatus = IS_LOCKED;
        _;
        _lockedStatus = IS_NOT_LOCKED;
    }

    function execute(address callee, bytes calldata data)
        external
        noReenter
        returns (bool success, bytes memory returnData)
    {
        (success, returnData) = callee.call(data);
    }

    function destroy(address etherDestination) external noReenter {
        selfdestruct(payable(etherDestination));
    }
}</span>

<span class="marker" id="mapping-557"></span><span class="token add" data-title="source_file/contract_declaration">contract TokenDeployer <span class="marker" id="mapping-558"></span><span class="token add" data-title="contract_declaration/contract_body">{
    <span class="marker" id="mapping-559"></span><span class="token mv" id="move-dst-47" data-title="contract_body/function_definition">function <span class="marker" id="mapping-560"></span><span class="token upd" id="move-dst-48" data-title="function_definition/identifier"><span class="cupd">deployToken</span></span>(
        string memory name,
        string memory symbol,
        uint8 decimals,
        uint256 cap<span class="marker" id="mapping-561"></span><span class="token add" data-title="function_definition/,">,</span>
        <span class="marker" id="mapping-562"></span><span class="token mv" id="move-dst-17" data-title="function_definition/parameter">bytes32 salt</span>
    ) <span class="marker" id="mapping-563"></span><span class="token add" data-title="function_definition/visibility">external</span> <span class="marker" id="mapping-564"></span><span class="token add" data-title="function_definition/return_type_definition">returns (address tokenAddress)</span> {
        <span class="marker" id="mapping-565"></span><span class="token add" data-title="function_body/expression_statement"><span class="marker" id="mapping-566"></span><span class="token add" data-title="expression_statement/assignment_expression">tokenAddress = <span class="marker" id="mapping-567"></span><span class="token mv" id="move-dst-55" data-title="assignment_expression/type_cast_expression">address(new BurnableMintableCappedERC20{ salt: salt }(name, symbol, decimals, cap))</span></span>;</span>
    }</span>
}</span></span>

interface IAxelarGateway {
    /**********\
    |* Events *|
    \**********/

    <span class="marker" id="mapping-568"></span><span class="token add" data-title="contract_body/event_definition">event TokenSent(
        address indexed sender,
        string destinationChain,
        string destinationAddress,
        string symbol,
        uint256 amount
    );</span>

    <span class="marker" id="mapping-569"></span><span class="token add" data-title="contract_body/event_definition">event ContractCall(
        <span class="marker" id="mapping-570"></span><span class="token add" data-title="event_definition/event_paramater">address indexed sender</span>,
        <span class="marker" id="mapping-571"></span><span class="token mv" id="move-dst-4" data-title="event_definition/event_paramater">string <span class="marker" id="mapping-572"></span><span class="token upd" id="move-dst-5" data-title="event_paramater/identifier">de<span class="cupd">s</span>tinationChain</span></span>,
        <span class="marker" id="mapping-573"></span><span class="token add" data-title="event_definition/event_paramater">string destinationContractAddress</span>,
        <span class="marker" id="mapping-574"></span><span class="token add" data-title="event_definition/event_paramater">bytes32 indexed payloadHash</span>,
        <span class="marker" id="mapping-575"></span><span class="token add" data-title="event_definition/event_paramater">bytes payload</span>
    );</span>

    <span class="marker" id="mapping-576"></span><span class="token add" data-title="contract_body/event_definition">event ContractCallWithToken(
        <span class="marker" id="mapping-577"></span><span class="token add" data-title="event_definition/event_paramater">address indexed sender</span>,
        <span class="marker" id="mapping-578"></span><span class="token mv" id="move-dst-2" data-title="event_definition/event_paramater">string <span class="marker" id="mapping-579"></span><span class="token upd" id="move-dst-3" data-title="event_paramater/identifier">de<span class="cupd">s</span>tinationChain</span></span>,
        <span class="marker" id="mapping-580"></span><span class="token add" data-title="event_definition/event_paramater">string destinationContractAddress</span>,
        <span class="marker" id="mapping-581"></span><span class="token add" data-title="event_definition/event_paramater">bytes32 indexed payloadHash</span>,
        <span class="marker" id="mapping-582"></span><span class="token add" data-title="event_definition/event_paramater">bytes payload</span>,
        <span class="marker" id="mapping-583"></span><span class="token add" data-title="event_definition/event_paramater">string symbol</span>,
        <span class="marker" id="mapping-584"></span><span class="token add" data-title="event_definition/event_paramater">uint256 amount</span>
    );</span>

    event Executed(bytes32 indexed commandId);

    event TokenDeployed(string symbol, address tokenAddresses);

    <span class="marker" id="mapping-585"></span><span class="token add" data-title="contract_body/event_definition">event ContractCallApproved(
        bytes32 indexed commandId,
        string sourceChain,
        string sourceAddress,
        address indexed contractAddress,
        bytes32 indexed payloadHash,
        bytes32 sourceTxHash,
        uint256 sourceEventIndex
    );</span>

    <span class="marker" id="mapping-586"></span><span class="token add" data-title="contract_body/event_definition">event ContractCallApprovedWithMint(
        bytes32 indexed commandId,
        string sourceChain,
        string sourceAddress,
        address indexed contractAddress,
        bytes32 indexed payloadHash,
        string symbol,
        uint256 amount,
        bytes32 sourceTxHash,
        uint256 sourceEventIndex
    );</span>

    <span class="marker" id="mapping-587"></span><span class="token add" data-title="contract_body/event_definition">event TokenFrozen(string symbol);</span>

    <span class="marker" id="mapping-588"></span><span class="token add" data-title="contract_body/event_definition">event TokenUnfrozen(string symbol);</span>

    event AllTokensFrozen();

    event AllTokensUnfrozen();

    event AccountBlacklisted(address indexed account);

    event AccountWhitelisted(address indexed account);

    event Upgraded(address indexed implementation);

    <span class="marker" id="mapping-589"></span><span class="token add" data-title="contract_body/comment">/******************\
    |* Public Methods *|
    \******************/</span>

    <span class="marker" id="mapping-590"></span><span class="token add" data-title="contract_body/function_definition">function sendToken(
        string memory destinationChain,
        string memory destinationAddress,
        string memory symbol,
        uint256 amount
    ) external;</span>

    <span class="marker" id="mapping-591"></span><span class="token add" data-title="contract_body/function_definition">function callContract(
        string memory destinationChain,
        string memory contractAddress,
        bytes memory payload
    ) external;</span>

    <span class="marker" id="mapping-592"></span><span class="token add" data-title="contract_body/function_definition">function callContractWithToken(
        string memory destinationChain,
        string memory contractAddress,
        bytes memory payload,
        string memory symbol,
        uint256 amount
    ) external;</span>

    <span class="marker" id="mapping-593"></span><span class="token add" data-title="contract_body/function_definition">function isContractCallApproved(
        bytes32 commandId,
        string memory sourceChain,
        string memory sourceAddress,
        address contractAddress,
        bytes32 payloadHash
    ) external view returns (bool);</span>

    <span class="marker" id="mapping-594"></span><span class="token add" data-title="contract_body/function_definition">function isContractCallAndMintApproved(
        bytes32 commandId,
        string memory sourceChain,
        string memory sourceAddress,
        address contractAddress,
        bytes32 payloadHash,
        string memory symbol,
        uint256 amount
    ) external view returns (bool);</span>

    <span class="marker" id="mapping-595"></span><span class="token add" data-title="contract_body/function_definition">function validateContractCall(
        bytes32 commandId,
        string memory sourceChain,
        string memory sourceAddress,
        bytes32 payloadHash
    ) external returns (bool);</span>

    <span class="marker" id="mapping-596"></span><span class="token add" data-title="contract_body/function_definition">function validateContractCallAndMint(
        bytes32 commandId,
        string memory sourceChain,
        string memory sourceAddress,
        bytes32 payloadHash,
        string memory symbol,
        uint256 amount
    ) external returns (bool);</span>

    /***********\
    |* Getters *|
    \***********/

    function allTokensFrozen() external view returns (bool);

    function implementation() external view returns (address);

    function tokenAddresses(string memory symbol) external view returns (address);

    function tokenFrozen(string memory symbol) external view returns (bool);

    function isCommandExecuted(bytes32 commandId) external view returns (bool);

    <span class="marker" id="mapping-597"></span><span class="token add" data-title="contract_body/function_definition">function adminEpoch() external view returns (uint256);</span>

    <span class="marker" id="mapping-598"></span><span class="token add" data-title="contract_body/function_definition">function adminThreshold(uint256 epoch) external view returns (uint256);</span>

    <span class="marker" id="mapping-599"></span><span class="token add" data-title="contract_body/function_definition">function admins(uint256 epoch) external view returns (address[] memory);</span>

    /*******************\
    |* Admin Functions *|
    \*******************/

    function freezeToken(string memory symbol) external;

    function unfreezeToken(string memory symbol) external;

    function freezeAllTokens() external;

    function unfreezeAllTokens() external;

    function upgrade(
        address newImplementation,
        <span class="marker" id="mapping-600"></span><span class="token add" data-title="function_definition/parameter">bytes32 newImplementationCodeHash</span><span class="marker" id="mapping-601"></span><span class="token add" data-title="function_definition/,">,</span>
        bytes calldata setupParams
    ) external;

    /**********************\
    |* External Functions *|
    \**********************/

    function setup(bytes calldata params) external;

    function execute(bytes calldata input) external;
}

interface IAxelarGatewayMultisig is IAxelarGateway {
    event OwnershipTransferred(address[] preOwners, uint256 prevThreshold, address[] newOwners, uint256 newThreshold);

    event OperatorshipTransferred(
        address[] preOperators,
        uint256 prevThreshold,
        address[] newOperators,
        uint256 newThreshold
    );

    <span class="marker" id="mapping-602"></span><span class="token add" data-title="contract_body/function_definition">function ownerEpoch() external view returns (uint256);</span>

    <span class="marker" id="mapping-603"></span><span class="token add" data-title="contract_body/function_definition">function ownerThreshold(uint256 epoch) external view returns (uint256);</span>

    function <span class="marker" id="mapping-604"></span><span class="token upd" id="move-dst-8" data-title="function_definition/identifier"><span class="cupd">o</span>wn<span class="cupd">er</span>s</span>(<span class="marker" id="mapping-605"></span><span class="token add" data-title="function_definition/parameter">uint256 epoch</span>) external view returns (address[] memory);

    <span class="marker" id="mapping-606"></span><span class="token add" data-title="contract_body/function_definition">function operatorEpoch() external view returns (uint256);</span>

    <span class="marker" id="mapping-607"></span><span class="token add" data-title="contract_body/function_definition">function operatorThreshold(uint256 epoch) external view returns (uint256);</span>

    <span class="marker" id="mapping-608"></span><span class="token mv" id="move-dst-6" data-title="contract_body/function_definition">function <span class="marker" id="mapping-609"></span><span class="token upd" id="move-dst-7" data-title="function_definition/identifier"><span class="cupd">o</span>p<span class="cupd">er</span>ators</span>(<span class="marker" id="mapping-610"></span><span class="token add" data-title="function_definition/parameter">uint256 epoch</span>) external view returns (address[] memory);</span>
}

/**
 * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.
 *
 * These functions can be used to verify that a message was signed by the holder
 * of the private keys of a given address.
 */
library ECDSA {
    <span class="marker" id="mapping-611"></span><span class="token add" data-title="contract_body/error_declaration">error InvalidSignatureLength();</span>
    <span class="marker" id="mapping-612"></span><span class="token add" data-title="contract_body/error_declaration">error InvalidS();</span>
    <span class="marker" id="mapping-613"></span><span class="token add" data-title="contract_body/error_declaration">error InvalidV();</span>
    <span class="marker" id="mapping-614"></span><span class="token add" data-title="contract_body/error_declaration">error InvalidSignature();</span>

    /**
     * @dev Returns the address that signed a hashed message (`hash`) with
     * `signature`. This address can then be used for verification purposes.
     *
     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:
     * this function rejects them by requiring the `s` value to be in the lower
     * half order, and the `v` value to be either 27 or 28.
     *
     * IMPORTANT: `hash` _must_ be the result of a hash operation for the
     * verification to be secure: it is possible to craft signatures that
     * recover to arbitrary addresses for non-hashed data. A safe way to ensure
     * this is by receiving a hash of the original message (which may otherwise
     * be too long), and then calling {toEthSignedMessageHash} on it.
     */
    function recover(bytes32 hash, bytes memory signature) internal pure returns (address signer) {
        // Check the signature length
        <span class="marker" id="mapping-615"></span><span class="token add" data-title="function_body/if_statement">if (<span class="marker" id="mapping-616"></span><span class="token mv" id="move-dst-9" data-title="if_statement/binary_expression">signature.length <span class="marker" id="mapping-617"></span><span class="token add" data-title="binary_expression/!=">!=</span> 65</span>) <span class="marker" id="mapping-618"></span><span class="token add" data-title="if_statement/revert_statement">revert InvalidSignatureLength();</span></span>

        // Divide the signature in r, s and v variables
        bytes32 r;
        bytes32 s;
        uint8 v;

        // ecrecover takes the signature parameters, and the only way to get them
        // currently is to use assembly.
        // solhint-disable-next-line no-inline-assembly
        assembly {
            r := mload(add(signature, 0x20))
            s := mload(add(signature, 0x40))
            v := byte(0, mload(add(signature, 0x60)))
        }

        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature
        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines
        // the valid range for s in (281): 0 &lt; s &lt; secp256k1n ÷ 2 + 1, and for v in (282): v ∈ {27, 28}. Most
        // signatures from current libraries generate a unique signature with an s-value in the lower half order.
        //
        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value
        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or
        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept
        // these malleable signatures as well.
        <span class="marker" id="mapping-619"></span><span class="token add" data-title="function_body/if_statement">if (uint256(s) &gt; 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) revert InvalidS();</span>

        <span class="marker" id="mapping-620"></span><span class="token add" data-title="function_body/if_statement">if (v != 27 &amp;&amp; v != 28) revert InvalidV();</span>

        // If the signature is valid (and not malleable), return the signer address
        <span class="marker" id="mapping-621"></span><span class="token add" data-title="function_body/if_statement">if (<span class="marker" id="mapping-622"></span><span class="token mv" id="move-dst-12" data-title="if_statement/binary_expression">(signer = ecrecover(hash, v, r, s)) <span class="marker" id="mapping-623"></span><span class="token add" data-title="binary_expression/==">==</span> address(0)</span>) <span class="marker" id="mapping-624"></span><span class="token add" data-title="if_statement/revert_statement">revert InvalidSignature();</span></span>
    }

    /**
     * @dev Returns an Ethereum Signed Message, created from a `hash`. This
     * replicates the behavior of the
     * https://github.com/ethereum/wiki/wiki/JSON-RPC#eth_sign[`eth_sign`]
     * JSON-RPC method.
     *
     * See {recover}.
     */
    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {
        // 32 is the length in bytes of hash,
        // enforced by the type signature above
        return keccak256(abi.encodePacked('\x19Ethereum Signed Message:\n32', hash));
    }
}

/*
 * @dev Provides information about the current execution context, including the
 * sender of the transaction and its data. While these are generally available
 * via msg.sender and msg.data, they should not be accessed in such a direct
 * manner, since when dealing with GSN meta-transactions the account sending and
 * paying for execution may not be the actual sender (as far as an application
 * is concerned).
 *
 * This contract is only required for intermediate, library-like contracts.
 */
abstract contract Context {
    function _msgSender() internal view virtual returns (address payable) {
        return payable(msg.sender);
    }

    function _msgData() internal view virtual returns (bytes memory) {
        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691
        return msg.data;
    }
}

/**
 * @dev Implementation of the {IERC20} interface.
 *
 * This implementation is agnostic to the way tokens are created. This means
 * that a supply mechanism has to be added in a derived contract using {_mint}.
 * For a generic mechanism see {ERC20PresetMinterPauser}.
 *
 * TIP: For a detailed writeup see our guide
 * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How
 * to implement supply mechanisms].
 *
 * We have followed general OpenZeppelin guidelines: functions revert instead
 * of returning `false` on failure. This behavior is nonetheless conventional
 * and does not conflict with the expectations of ERC20 applications.
 *
 * Additionally, an {Approval} event is emitted on calls to {transferFrom}.
 * This allows applications to reconstruct the allowance for all accounts just
 * by listening to said events. Other implementations of the EIP may not emit
 * these events, as it isn't required by the specification.
 *
 * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}
 * functions have been added to mitigate the well-known issues around setting
 * allowances. See {IERC20-approve}.
 */
contract ERC20 is Context, IERC20 {
    mapping(address =&gt; uint256) public override balanceOf;

    mapping(address =&gt; mapping(address =&gt; uint256)) public override allowance;

    uint256 public override totalSupply;

    string public name;
    string public symbol;

    uint8 public immutable decimals;

    /**
     * @dev Sets the values for {name}, {symbol}, and {decimals}.
     *
     * All three of these values are immutable: they can only be set once during
     * construction.
     */
    constructor(
        string memory name_,
        string memory symbol_,
        uint8 decimals_
    ) {
        name = name_;
        symbol = symbol_;
        decimals = decimals_;
    }

    /**
     * @dev See {IERC20-transfer}.
     *
     * Requirements:
     *
     * - `recipient` cannot be the zero address.
     * - the caller must have a balance of at least `amount`.
     */
    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {
        _transfer(_msgSender(), recipient, amount);
        return true;
    }

    /**
     * @dev See {IERC20-approve}.
     *
     * Requirements:
     *
     * - `spender` cannot be the zero address.
     */
    function approve(address spender, uint256 amount) public virtual override returns (bool) {
        _approve(_msgSender(), spender, amount);
        return true;
    }

    /**
     * @dev See {IERC20-transferFrom}.
     *
     * Emits an {Approval} event indicating the updated allowance. This is not
     * required by the EIP. See the note at the beginning of {ERC20}.
     *
     * Requirements:
     *
     * - `sender` and `recipient` cannot be the zero address.
     * - `sender` must have a balance of at least `amount`.
     * - the caller must have allowance for ``sender``'s tokens of at least
     * `amount`.
     */
    function transferFrom(
        address sender,
        address recipient,
        uint256 amount
    ) public virtual override returns (bool) {
        _transfer(sender, recipient, amount);
        _approve(sender, _msgSender(), allowance[sender][_msgSender()] - amount);
        return true;
    }

    /**
     * @dev Atomically increases the allowance granted to `spender` by the caller.
     *
     * This is an alternative to {approve} that can be used as a mitigation for
     * problems described in {IERC20-approve}.
     *
     * Emits an {Approval} event indicating the updated allowance.
     *
     * Requirements:
     *
     * - `spender` cannot be the zero address.
     */
    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {
        _approve(_msgSender(), spender, allowance[_msgSender()][spender] + addedValue);
        return true;
    }

    /**
     * @dev Atomically decreases the allowance granted to `spender` by the caller.
     *
     * This is an alternative to {approve} that can be used as a mitigation for
     * problems described in {IERC20-approve}.
     *
     * Emits an {Approval} event indicating the updated allowance.
     *
     * Requirements:
     *
     * - `spender` cannot be the zero address.
     * - `spender` must have allowance for the caller of at least
     * `subtractedValue`.
     */
    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {
        _approve(_msgSender(), spender, allowance[_msgSender()][spender] - subtractedValue);
        return true;
    }

    /**
     * @dev Moves tokens `amount` from `sender` to `recipient`.
     *
     * This is internal function is equivalent to {transfer}, and can be used to
     * e.g. implement automatic token fees, slashing mechanisms, etc.
     *
     * Emits a {Transfer} event.
     *
     * Requirements:
     *
     * - `sender` cannot be the zero address.
     * - `recipient` cannot be the zero address.
     * - `sender` must have a balance of at least `amount`.
     */
    function _transfer(
        address sender,
        address recipient,
        uint256 amount
    ) internal virtual {
        require(sender != address(0), 'ZERO_ADDR');
        require(recipient != address(0), 'ZERO_ADDR');

        _beforeTokenTransfer(sender, recipient, amount);

        balanceOf[sender] -= amount;
        balanceOf[recipient] += amount;
        emit Transfer(sender, recipient, amount);
    }

    /** @dev Creates `amount` tokens and assigns them to `account`, increasing
     * the total supply.
     *
     * Emits a {Transfer} event with `from` set to the zero address.
     *
     * Requirements:
     *
     * - `to` cannot be the zero address.
     */
    function _mint(address account, uint256 amount) internal virtual {
        require(account != address(0), 'ZERO_ADDR');

        _beforeTokenTransfer(address(0), account, amount);

        totalSupply += amount;
        balanceOf[account] += amount;
        emit Transfer(address(0), account, amount);
    }

    /**
     * @dev Destroys `amount` tokens from `account`, reducing the
     * total supply.
     *
     * Emits a {Transfer} event with `to` set to the zero address.
     *
     * Requirements:
     *
     * - `account` cannot be the zero address.
     * - `account` must have at least `amount` tokens.
     */
    function _burn(address account, uint256 amount) internal virtual {
        require(account != address(0), 'ZERO_ADDR');

        _beforeTokenTransfer(account, address(0), amount);

        balanceOf[account] -= amount;
        totalSupply -= amount;
        emit Transfer(account, address(0), amount);
    }

    /**
     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.
     *
     * This internal function is equivalent to `approve`, and can be used to
     * e.g. set automatic allowances for certain subsystems, etc.
     *
     * Emits an {Approval} event.
     *
     * Requirements:
     *
     * - `owner` cannot be the zero address.
     * - `spender` cannot be the zero address.
     */
    function _approve(
        address owner,
        address spender,
        uint256 amount
    ) internal virtual {
        require(owner != address(0), 'ZERO_ADDR');
        require(spender != address(0), 'ZERO_ADDR');

        allowance[owner][spender] = amount;
        emit Approval(owner, spender, amount);
    }

    /**
     * @dev Hook that is called before any transfer of tokens. This includes
     * minting and burning.
     *
     * Calling conditions:
     *
     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens
     * will be to transferred to `to`.
     * - when `from` is zero, `amount` tokens will be minted for `to`.
     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.
     * - `from` and `to` are never both zero.
     *
     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].
     */
    function _beforeTokenTransfer(
        address from,
        address to,
        uint256 amount
    ) internal virtual {}
}

<span class="marker" id="mapping-625"></span><span class="token add" data-title="source_file/contract_declaration">abstract contract ERC20Permit is <span class="marker" id="mapping-626"></span><span class="token add" data-title="contract_declaration/inheritance_specifier">ERC20</span> <span class="marker" id="mapping-627"></span><span class="token add" data-title="contract_declaration/contract_body">{
    <span class="marker" id="mapping-628"></span><span class="token add" data-title="contract_body/state_variable_declaration">bytes32 public DOMAIN_SEPARATOR;</span>

    <span class="marker" id="mapping-629"></span><span class="token add" data-title="contract_body/state_variable_declaration"><span class="marker" id="mapping-630"></span><span class="token add" data-title="state_variable_declaration/type_name">string</span> <span class="marker" id="mapping-631"></span><span class="token mv" id="move-dst-25" data-title="state_variable_declaration/visibility">private</span> constant EIP191_PREFIX_FOR_EIP712_STRUCTURED_DATA = <span class="marker" id="mapping-632"></span><span class="token add" data-title="state_variable_declaration/string_literal">'\x19\x01'</span>;</span>

    // keccak256('EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)')
    <span class="marker" id="mapping-633"></span><span class="token add" data-title="contract_body/state_variable_declaration"><span class="marker" id="mapping-634"></span><span class="token add" data-title="state_variable_declaration/type_name">bytes32</span> <span class="marker" id="mapping-635"></span><span class="token mv" id="move-dst-28" data-title="state_variable_declaration/visibility">private</span> constant DOMAIN_TYPE_SIGNATURE_HASH =
        <span class="marker" id="mapping-636"></span><span class="token add" data-title="state_variable_declaration/type_cast_expression">bytes32(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f)</span>;</span>

    // keccak256('Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)')
    <span class="marker" id="mapping-637"></span><span class="token add" data-title="contract_body/state_variable_declaration">bytes32 private constant PERMIT_SIGNATURE_HASH =
        bytes32(0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9);</span>

    <span class="marker" id="mapping-638"></span><span class="token add" data-title="contract_body/state_variable_declaration">mapping(address =&gt; uint256) public nonces;</span>

    <span class="marker" id="mapping-639"></span><span class="token add" data-title="contract_body/constructor_definition">constructor(<span class="marker" id="mapping-640"></span><span class="token add" data-title="constructor_definition/parameter">string memory name</span>) <span class="marker" id="mapping-641"></span><span class="token add" data-title="constructor_definition/function_body">{
        <span class="marker" id="mapping-642"></span><span class="token add" data-title="function_body/expression_statement"><span class="marker" id="mapping-643"></span><span class="token add" data-title="expression_statement/assignment_expression">DOMAIN_SEPARATOR = <span class="marker" id="mapping-644"></span><span class="token add" data-title="assignment_expression/call_expression">keccak256(
            <span class="marker" id="mapping-645"></span><span class="token add" data-title="call_expression/call_argument"><span class="marker" id="mapping-646"></span><span class="token add" data-title="call_argument/call_expression"><span class="marker" id="mapping-647"></span><span class="token add" data-title="call_expression/member_expression">abi.encode</span>(
                <span class="marker" id="mapping-648"></span><span class="token add" data-title="call_expression/call_argument">DOMAIN_TYPE_SIGNATURE_HASH</span>,
                <span class="marker" id="mapping-649"></span><span class="token add" data-title="call_expression/call_argument">keccak256(bytes(name))</span>,
                <span class="marker" id="mapping-650"></span><span class="token add" data-title="call_expression/call_argument"><span class="marker" id="mapping-651"></span><span class="token mv" id="move-dst-37" data-title="call_argument/call_expression"><span class="marker" id="mapping-652"></span><span class="token upd" id="move-dst-38" data-title="call_expression/identifier">keccak256</span>(<span class="marker" id="mapping-653"></span><span class="token add" data-title="call_argument/type_cast_expression"><span class="marker" id="mapping-654"></span><span class="token add" data-title="type_cast_expression/primitive_type">bytes</span>(<span class="marker" id="mapping-655"></span><span class="token mv" id="move-dst-40" data-title="type_cast_expression/call_argument">'1'</span>)</span>)</span></span>,
                <span class="marker" id="mapping-656"></span><span class="token add" data-title="call_expression/call_argument">block.chainid</span>,
                <span class="marker" id="mapping-657"></span><span class="token add" data-title="call_expression/call_argument">address(this)</span>
            )</span></span>
        )</span></span>;</span>
    }</span></span>

    <span class="marker" id="mapping-658"></span><span class="token add" data-title="contract_body/function_definition">function permit(
        <span class="marker" id="mapping-659"></span><span class="token add" data-title="function_definition/parameter">address issuer</span>,
        <span class="marker" id="mapping-660"></span><span class="token add" data-title="function_definition/parameter">address spender</span>,
        <span class="marker" id="mapping-661"></span><span class="token mv" id="move-dst-80" data-title="function_definition/parameter">uint256 <span class="marker" id="mapping-662"></span><span class="token upd" id="move-dst-81" data-title="parameter/identifier">value</span></span>,
        <span class="marker" id="mapping-663"></span><span class="token mv" id="move-dst-83" data-title="function_definition/parameter">uint256 <span class="marker" id="mapping-664"></span><span class="token upd" id="move-dst-84" data-title="parameter/identifier">deadli<span class="cupd">ne</span></span></span>,
        <span class="marker" id="mapping-665"></span><span class="token add" data-title="function_definition/parameter">uint8 v</span>,
        <span class="marker" id="mapping-666"></span><span class="token add" data-title="function_definition/parameter">bytes32 r</span>,
        <span class="marker" id="mapping-667"></span><span class="token add" data-title="function_definition/parameter">bytes32 s</span>
    ) <span class="marker" id="mapping-668"></span><span class="token add" data-title="function_definition/visibility">external</span> <span class="marker" id="mapping-669"></span><span class="token add" data-title="function_definition/function_body">{
        <span class="marker" id="mapping-670"></span><span class="token mv" id="move-dst-46" data-title="function_body/expression_statement">require(<span class="marker" id="mapping-671"></span><span class="token add" data-title="call_argument/binary_expression">block.timestamp &lt; deadline</span>, 'EXPIRED');</span>
        <span class="marker" id="mapping-672"></span><span class="token mv" id="move-dst-10" data-title="function_body/expression_statement">require(uint256(s) &lt;= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0, 'INV_S');</span>
        <span class="marker" id="mapping-673"></span><span class="token mv" id="move-dst-11" data-title="function_body/expression_statement">require(v == 27 || v == 28, 'INV_V');</span>

        <span class="marker" id="mapping-674"></span><span class="token add" data-title="function_body/variable_declaration_statement"><span class="marker" id="mapping-675"></span><span class="token add" data-title="variable_declaration_statement/variable_declaration">bytes32 digest</span> = <span class="marker" id="mapping-676"></span><span class="token add" data-title="variable_declaration_statement/call_expression">keccak256(
            <span class="marker" id="mapping-677"></span><span class="token add" data-title="call_expression/call_argument"><span class="marker" id="mapping-678"></span><span class="token add" data-title="call_argument/call_expression"><span class="marker" id="mapping-679"></span><span class="token mv" id="move-dst-31" data-title="call_expression/member_expression">abi.encodePacked</span>(
                <span class="marker" id="mapping-680"></span><span class="token add" data-title="call_expression/call_argument">EIP191_PREFIX_FOR_EIP712_STRUCTURED_DATA</span>,
                <span class="marker" id="mapping-681"></span><span class="token add" data-title="call_expression/call_argument">DOMAIN_SEPARATOR</span>,
                <span class="marker" id="mapping-682"></span><span class="token add" data-title="call_expression/call_argument"><span class="marker" id="mapping-683"></span><span class="token add" data-title="call_argument/call_expression">keccak256(<span class="marker" id="mapping-684"></span><span class="token add" data-title="call_expression/call_argument"><span class="marker" id="mapping-685"></span><span class="token add" data-title="call_argument/call_expression"><span class="marker" id="mapping-686"></span><span class="token mv" id="move-dst-33" data-title="call_expression/member_expression">abi.encode</span>(<span class="marker" id="mapping-687"></span><span class="token add" data-title="call_expression/call_argument">PERMIT_SIGNATURE_HASH</span>, <span class="marker" id="mapping-688"></span><span class="token add" data-title="call_expression/call_argument">issuer</span>, <span class="marker" id="mapping-689"></span><span class="token add" data-title="call_expression/call_argument">spender</span>, <span class="marker" id="mapping-690"></span><span class="token add" data-title="call_expression/call_argument">value</span>, <span class="marker" id="mapping-691"></span><span class="token add" data-title="call_expression/call_argument">nonces[issuer]++</span>, <span class="marker" id="mapping-692"></span><span class="token add" data-title="call_expression/call_argument">deadline</span>)</span></span>)</span></span>
            )</span></span>
        )</span>;</span>

        <span class="marker" id="mapping-693"></span><span class="token add" data-title="function_body/variable_declaration_statement"><span class="marker" id="mapping-694"></span><span class="token mv" id="move-dst-53" data-title="variable_declaration_statement/variable_declaration">address <span class="marker" id="mapping-695"></span><span class="token upd" id="move-dst-54" data-title="variable_declaration/identifier">rec<span class="cupd">o</span>veredAddress</span></span> = <span class="marker" id="mapping-696"></span><span class="token add" data-title="variable_declaration_statement/call_expression">ecrecover(digest, v, r, s)</span>;</span>
        <span class="marker" id="mapping-697"></span><span class="token add" data-title="function_body/expression_statement"><span class="marker" id="mapping-698"></span><span class="token add" data-title="expression_statement/call_expression">require(<span class="marker" id="mapping-699"></span><span class="token add" data-title="call_expression/call_argument">recoveredAddress == issuer</span>, <span class="marker" id="mapping-700"></span><span class="token mv" id="move-dst-51" data-title="call_expression/call_argument">'INV_SIG'</span>)</span>;</span>

        // _approve will revert if issuer is address(0x0)
        <span class="marker" id="mapping-701"></span><span class="token add" data-title="function_body/expression_statement">_approve(issuer, spender, value);</span>
    }</span></span>
}</span></span>

<span class="marker" id="mapping-702"></span><span class="token add" data-title="source_file/contract_declaration">contract MintableCappedERC20 is <span class="marker" id="mapping-703"></span><span class="token mv" id="move-dst-21" data-title="contract_declaration/inheritance_specifier">ERC20</span>, <span class="marker" id="mapping-704"></span><span class="token add" data-title="contract_declaration/inheritance_specifier">ERC20Permit</span>, <span class="marker" id="mapping-705"></span><span class="token mv" id="move-dst-22" data-title="contract_declaration/inheritance_specifier">Ownable</span>, <span class="marker" id="mapping-706"></span><span class="token add" data-title="contract_declaration/inheritance_specifier">IERC20BurnFrom</span> <span class="marker" id="mapping-707"></span><span class="token add" data-title="contract_declaration/contract_body">{
    <span class="marker" id="mapping-708"></span><span class="token mv" id="move-dst-23" data-title="contract_body/state_variable_declaration">uint256 public cap;</span>

    <span class="marker" id="mapping-709"></span><span class="token mv" id="move-dst-30" data-title="contract_body/constructor_definition">constructor(
        string memory name,
        string memory symbol,
        uint8 decimals,
        uint256 capacity
    ) ERC20(name, symbol, decimals) <span class="marker" id="mapping-710"></span><span class="token add" data-title="constructor_definition/modifier_invocation">ERC20Permit(name)</span> Ownable() {
        cap = capacity;
    }</span>

    <span class="marker" id="mapping-711"></span><span class="token mv" id="move-dst-36" data-title="contract_body/function_definition">function mint(address account, uint256 amount) public onlyOwner {
        uint256 capacity = cap;
        require(capacity == 0 || totalSupply + amount &lt;= capacity, 'CAP_EXCEEDED');

        _mint(account, amount);
    }</span>

    // TODO move burnFrom into a separate BurnableERC20 contract
    <span class="marker" id="mapping-712"></span><span class="token add" data-title="contract_body/function_definition">function burnFrom(<span class="marker" id="mapping-713"></span><span class="token mv" id="move-dst-156" data-title="function_definition/parameter">address account</span>, <span class="marker" id="mapping-714"></span><span class="token add" data-title="function_definition/parameter">uint256 amount</span>) <span class="marker" id="mapping-715"></span><span class="token add" data-title="function_definition/visibility">external</span> <span class="marker" id="mapping-716"></span><span class="token add" data-title="function_definition/modifier_invocation">onlyOwner</span> <span class="marker" id="mapping-717"></span><span class="token add" data-title="function_definition/function_body">{
        _approve(account, owner, allowance[account][owner] - amount);
        _burn(account, amount);
    }</span></span>
}</span></span>

contract BurnableMintableCappedERC20 is <span class="marker" id="mapping-718"></span><span class="token add" data-title="contract_declaration/inheritance_specifier">MintableCappedERC20</span> {
    <span class="marker" id="mapping-719"></span><span class="token add" data-title="contract_body/comment">// keccak256('token-frozen')</span>
    <span class="marker" id="mapping-720"></span><span class="token add" data-title="contract_body/state_variable_declaration">bytes32 private constant PREFIX_TOKEN_FROZEN =
        bytes32(0x1a7261d3a36c4ce4235d10859911c9444a6963a3591ec5725b96871d9810626b);</span>

    <span class="marker" id="mapping-721"></span><span class="token add" data-title="contract_body/comment">// keccak256('all-tokens-frozen')</span>
    <span class="marker" id="mapping-722"></span><span class="token add" data-title="contract_body/state_variable_declaration">bytes32 private constant KEY_ALL_TOKENS_FROZEN =
        bytes32(0x75a31d1ce8e5f9892188befc328d3b9bd3fa5037457e881abc21f388471b8d96);</span>

    event Frozen(address indexed owner);
    event Unfrozen(address indexed owner);

    <span class="marker" id="mapping-723"></span><span class="token add" data-title="contract_body/constructor_definition">constructor(
        string memory name,
        string memory symbol,
        uint8 decimals,
        uint256 capacity
    ) MintableCappedERC20(name, symbol, decimals, capacity) {}</span>

    function depositAddress(bytes32 salt) public view returns (address) {
        /* Convert a hash which is bytes32 to an address which is 20-byte long
        according to https://docs.soliditylang.org/en/v0.8.1/control-structures.html?highlight=create2#salted-contract-creations-create2 */
        return
            address(
                uint160(
                    uint256(
                        keccak256(
                            abi.encodePacked(
                                bytes1(0xff),
                                owner,
                                salt,
                                keccak256(<span class="marker" id="mapping-724"></span><span class="token add" data-title="call_expression/member_expression">abi.encodePacked</span>(type(<span class="marker" id="mapping-725"></span><span class="token upd" id="move-dst-32" data-title="user_defined_type/identifier">DepositHa<span class="cupd">n</span>dl<span class="cupd">er</span></span>).creationCode))
                            )
                        )
                    )
                )
            );
    }

    function burn(bytes32 salt) public onlyOwner {
        address account = depositAddress(salt);
        _burn(account, balanceOf[account]);
    }

    function _beforeTokenTransfer(
        address,
        address,
        uint256
    ) internal view override {
        require(!EternalStorage(owner).getBool(KEY_ALL_TOKENS_FROZEN), 'IS_FROZEN');
        require(!EternalStorage(owner).getBool(keccak256(abi.encodePacked(PREFIX_TOKEN_FROZEN, symbol))), 'IS_FROZEN');
    }
}

contract AdminMultisigBase is EternalStorage {
    <span class="marker" id="mapping-726"></span><span class="token add" data-title="contract_body/error_declaration">error NotAdmin();</span>
    <span class="marker" id="mapping-727"></span><span class="token add" data-title="contract_body/error_declaration">error AlreadyVoted();</span>
    <span class="marker" id="mapping-728"></span><span class="token add" data-title="contract_body/error_declaration">error InvalidAdmins();</span>
    <span class="marker" id="mapping-729"></span><span class="token add" data-title="contract_body/error_declaration">error InvalidAdminThreshold();</span>
    <span class="marker" id="mapping-730"></span><span class="token add" data-title="contract_body/error_declaration">error DuplicateAdmin(address admin);</span>

    <span class="marker" id="mapping-731"></span><span class="token add" data-title="contract_body/comment">// AUDIT: slot names should be prefixed with some standard string</span>
    <span class="marker" id="mapping-732"></span><span class="token add" data-title="contract_body/comment">// AUDIT: constants should be literal and their derivation should be in comments</span>
    bytes32 internal constant KEY_ADMIN_EPOCH = keccak256('admin-epoch');

    bytes32 internal constant PREFIX_ADMIN = keccak256('admin');
    bytes32 internal constant PREFIX_ADMIN_COUNT = keccak256('admin-count');
    bytes32 internal constant PREFIX_ADMIN_THRESHOLD = keccak256('admin-threshold');
    bytes32 internal constant PREFIX_ADMIN_VOTE_COUNTS = keccak256('admin-vote-counts');
    bytes32 internal constant PREFIX_ADMIN_VOTED = keccak256('admin-voted');
    bytes32 internal constant PREFIX_IS_ADMIN = keccak256('is-admin');

    modifier onlyAdmin() {
        uint256 adminEpoch = _adminEpoch();

        <span class="marker" id="mapping-733"></span><span class="token add" data-title="function_body/if_statement">if (<span class="marker" id="mapping-734"></span><span class="token add" data-title="if_statement/unary_expression">!<span class="marker" id="mapping-735"></span><span class="token mv" id="move-dst-39" data-title="unary_expression/call_expression">_isAdmin(adminEpoch, msg.sender)</span></span>) <span class="marker" id="mapping-736"></span><span class="token add" data-title="if_statement/revert_statement">revert NotAdmin();</span></span>

        bytes32 topic = keccak256(msg.data);

        // Check that admin has not voted, then record that they have voted.
        <span class="marker" id="mapping-737"></span><span class="token add" data-title="function_body/if_statement">if (<span class="marker" id="mapping-738"></span><span class="token mv" id="move-dst-41" data-title="if_statement/call_expression">_hasVoted(adminEpoch, topic, msg.sender)</span>) <span class="marker" id="mapping-739"></span><span class="token add" data-title="if_statement/revert_statement">revert AlreadyVoted();</span></span>

        _setHasVoted(adminEpoch, topic, msg.sender, true);

        // Determine the new vote count and update it.
        uint256 adminVoteCount = _getVoteCount(adminEpoch, topic) + uint256(1);
        _setVoteCount(adminEpoch, topic, adminVoteCount);

        // Do not proceed with operation execution if insufficient votes.
        if (adminVoteCount &lt; _getAdminThreshold(adminEpoch)) return;

        _;

        // Clear vote count and voted booleans.
        _setVoteCount(adminEpoch, topic, uint256(0));

        uint256 adminCount = _getAdminCount(adminEpoch);

        for (uint256 i; i &lt; adminCount; i++) {
            _setHasVoted(adminEpoch, topic, _getAdmin(adminEpoch, i), false);
        }
    }

    /********************\
    |* Pure Key Getters *|
    \********************/

    function _getAdminKey(uint256 adminEpoch, uint256 index) internal pure returns (bytes32) {
        return keccak256(abi.encodePacked(PREFIX_ADMIN, adminEpoch, index));
    }

    function _getAdminCountKey(uint256 adminEpoch) internal pure returns (bytes32) {
        return keccak256(abi.encodePacked(PREFIX_ADMIN_COUNT, adminEpoch));
    }

    function _getAdminThresholdKey(uint256 adminEpoch) internal pure returns (bytes32) {
        return keccak256(abi.encodePacked(PREFIX_ADMIN_THRESHOLD, adminEpoch));
    }

    function _getAdminVoteCountsKey(uint256 adminEpoch, bytes32 topic) internal pure returns (bytes32) {
        return keccak256(abi.encodePacked(PREFIX_ADMIN_VOTE_COUNTS, adminEpoch, topic));
    }

    function _getAdminVotedKey(
        uint256 adminEpoch,
        bytes32 topic,
        address account
    ) internal pure returns (bytes32) {
        return keccak256(abi.encodePacked(PREFIX_ADMIN_VOTED, adminEpoch, topic, account));
    }

    function _getIsAdminKey(uint256 adminEpoch, address account) internal pure returns (bytes32) {
        return keccak256(abi.encodePacked(PREFIX_IS_ADMIN, adminEpoch, account));
    }

    /***********\
    |* Getters *|
    \***********/

    function _adminEpoch() internal view returns (uint256) {
        return getUint(KEY_ADMIN_EPOCH);
    }

    function _getAdmin(uint256 adminEpoch, uint256 index) internal view returns (address) {
        return getAddress(_getAdminKey(adminEpoch, index));
    }

    function _getAdminCount(uint256 adminEpoch) internal view returns (uint256) {
        return getUint(_getAdminCountKey(adminEpoch));
    }

    function _getAdminThreshold(uint256 adminEpoch) internal view returns (uint256) {
        return getUint(_getAdminThresholdKey(adminEpoch));
    }

    function _getVoteCount(uint256 adminEpoch, bytes32 topic) internal view returns (uint256) {
        return getUint(_getAdminVoteCountsKey(adminEpoch, topic));
    }

    function _hasVoted(
        uint256 adminEpoch,
        bytes32 topic,
        address account
    ) internal view returns (bool) {
        return getBool(_getAdminVotedKey(adminEpoch, topic, account));
    }

    function _isAdmin(uint256 adminEpoch, address account) internal view returns (bool) {
        return getBool(_getIsAdminKey(adminEpoch, account));
    }

    /***********\
    |* Setters *|
    \***********/

    function _setAdminEpoch(uint256 adminEpoch) internal {
        _setUint(KEY_ADMIN_EPOCH, adminEpoch);
    }

    function _setAdmin(
        uint256 adminEpoch,
        uint256 index,
        address account
    ) internal {
        _setAddress(_getAdminKey(adminEpoch, index), account);
    }

    function _setAdminCount(uint256 adminEpoch, uint256 adminCount) internal {
        _setUint(_getAdminCountKey(adminEpoch), adminCount);
    }

    function _setAdmins(
        uint256 adminEpoch,
        address[] memory accounts,
        uint256 threshold
    ) internal {
        uint256 adminLength = accounts.length;

        <span class="marker" id="mapping-740"></span><span class="token add" data-title="function_body/if_statement">if (adminLength &lt; threshold) revert InvalidAdmins();</span>

        <span class="marker" id="mapping-741"></span><span class="token add" data-title="function_body/if_statement">if (<span class="marker" id="mapping-742"></span><span class="token mv" id="move-dst-42" data-title="if_statement/binary_expression">threshold <span class="marker" id="mapping-743"></span><span class="token add" data-title="binary_expression/==">==</span> uint256(0)</span>) <span class="marker" id="mapping-744"></span><span class="token add" data-title="if_statement/revert_statement">revert InvalidAdminThreshold();</span></span>

        _setAdminThreshold(adminEpoch, threshold);
        _setAdminCount(adminEpoch, adminLength);

        for (uint256 i; i &lt; adminLength; i++) {
            address account = accounts[i];

            // Check that the account wasn't already set as an admin for this epoch.
            <span class="marker" id="mapping-745"></span><span class="token add" data-title="block_statement/if_statement">if (<span class="marker" id="mapping-746"></span><span class="token mv" id="move-dst-43" data-title="if_statement/call_expression">_isAdmin(adminEpoch, account)</span>) <span class="marker" id="mapping-747"></span><span class="token add" data-title="if_statement/revert_statement">revert DuplicateAdmin(account);</span></span>

            <span class="marker" id="mapping-748"></span><span class="token add" data-title="block_statement/if_statement">if (account == address(0)) revert InvalidAdmins();</span>

            // Set this account as the i-th admin in this epoch (needed to we can clear topic votes in `onlyAdmin`).
            _setAdmin(adminEpoch, i, account);
            _setIsAdmin(adminEpoch, account, true);
        }
    }

    function _setAdminThreshold(uint256 adminEpoch, uint256 adminThreshold) internal {
        _setUint(_getAdminThresholdKey(adminEpoch), adminThreshold);
    }

    function _setVoteCount(
        uint256 adminEpoch,
        bytes32 topic,
        uint256 voteCount
    ) internal {
        _setUint(_getAdminVoteCountsKey(adminEpoch, topic), voteCount);
    }

    function _setHasVoted(
        uint256 adminEpoch,
        bytes32 topic,
        address account,
        bool voted
    ) internal {
        _setBool(_getAdminVotedKey(adminEpoch, topic, account), voted);
    }

    function _setIsAdmin(
        uint256 adminEpoch,
        address account,
        bool isAdmin
    ) internal {
        _setBool(_getIsAdminKey(adminEpoch, account), isAdmin);
    }
}

abstract contract AxelarGateway is IAxelarGateway, AdminMultisigBase {
    <span class="marker" id="mapping-749"></span><span class="token add" data-title="contract_body/error_declaration">error NotSelf();</span>
    <span class="marker" id="mapping-750"></span><span class="token add" data-title="contract_body/error_declaration">error InvalidCodeHash();</span>
    <span class="marker" id="mapping-751"></span><span class="token add" data-title="contract_body/error_declaration">error SetupFailed();</span>
    <span class="marker" id="mapping-752"></span><span class="token add" data-title="contract_body/error_declaration">error InvalidAmount();</span>
    <span class="marker" id="mapping-753"></span><span class="token add" data-title="contract_body/error_declaration">error TokenDoesNotExist(string symbol);</span>
    <span class="marker" id="mapping-754"></span><span class="token add" data-title="contract_body/error_declaration">error TokenAlreadyExists(string symbol);</span>
    <span class="marker" id="mapping-755"></span><span class="token add" data-title="contract_body/error_declaration">error TokenDeployFailed(string symbol);</span>
    <span class="marker" id="mapping-756"></span><span class="token add" data-title="contract_body/error_declaration">error TokenContractDoesNotExist(address token);</span>
    <span class="marker" id="mapping-757"></span><span class="token add" data-title="contract_body/error_declaration">error BurnFailed(string symbol);</span>
    <span class="marker" id="mapping-758"></span><span class="token add" data-title="contract_body/error_declaration">error MintFailed(string symbol);</span>
    <span class="marker" id="mapping-759"></span><span class="token add" data-title="contract_body/error_declaration">error TokenIsFrozen(string symbol);</span>

    <span class="marker" id="mapping-760"></span><span class="token add" data-title="contract_body/enum_declaration">enum Role {
        Admin,
        Owner,
        Operator
    }</span>

    <span class="marker" id="mapping-761"></span><span class="token add" data-title="contract_body/enum_declaration">enum TokenType {
        InternalBurnable,
        InternalBurnableFrom,
        External
    }</span>

    /// @dev Storage slot with the address of the current factory. `keccak256('eip1967.proxy.implementation') - 1`.
    bytes32 internal constant KEY_IMPLEMENTATION =
        bytes32(0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc);

    <span class="marker" id="mapping-762"></span><span class="token add" data-title="contract_body/comment">// AUDIT: slot names should be prefixed with some standard string</span>
    <span class="marker" id="mapping-763"></span><span class="token add" data-title="contract_body/comment">// AUDIT: constants should be literal and their derivation should be in comments</span>
    bytes32 internal constant KEY_ALL_TOKENS_FROZEN = keccak256('all-tokens-frozen');

    bytes32 internal constant PREFIX_COMMAND_EXECUTED = keccak256('command-executed');
    bytes32 internal constant PREFIX_TOKEN_ADDRESS = keccak256('token-address');
    <span class="marker" id="mapping-764"></span><span class="token mv" id="move-dst-27" data-title="contract_body/state_variable_declaration">bytes32 <span class="marker" id="mapping-765"></span><span class="token add" data-title="state_variable_declaration/visibility">internal</span> constant <span class="marker" id="mapping-766"></span><span class="token upd" id="move-dst-29" data-title="state_variable_declaration/identifier">PR<span class="cupd">E</span>FIX<span class="cupd">_</span><span class="cupd">TOKEN</span><span class="cupd">_</span>TYPE</span> = keccak256('token-type');</span>
    bytes32 internal constant PREFIX_TOKEN_FROZEN = keccak256('token-frozen');
    <span class="marker" id="mapping-767"></span><span class="token mv" id="move-dst-24" data-title="contract_body/state_variable_declaration">bytes32 <span class="marker" id="mapping-768"></span><span class="token add" data-title="state_variable_declaration/visibility">internal</span> constant <span class="marker" id="mapping-769"></span><span class="token upd" id="move-dst-26" data-title="state_variable_declaration/identifier"><span class="cupd">PREFIX_</span>C<span class="cupd">O</span><span class="cupd">N</span>TRACT<span class="cupd">_</span>CALL_APP<span class="cupd">RO</span>VED</span> = keccak256('contract-call-approved');</span>
    <span class="marker" id="mapping-770"></span><span class="token add" data-title="contract_body/state_variable_declaration">bytes32 internal constant PREFIX_CONTRACT_CALL_APPROVED_WITH_MINT = keccak256('contract-call-approved-with-mint');</span>

    bytes32 internal constant SELECTOR_BURN_TOKEN = keccak256('burnToken');
    bytes32 internal constant SELECTOR_DEPLOY_TOKEN = keccak256('deployToken');
    bytes32 internal constant SELECTOR_MINT_TOKEN = keccak256('mintToken');
    <span class="marker" id="mapping-771"></span><span class="token add" data-title="contract_body/state_variable_declaration">bytes32 internal constant SELECTOR_APPROVE_CONTRACT_CALL = keccak256('approveContractCall');</span>
    <span class="marker" id="mapping-772"></span><span class="token add" data-title="contract_body/state_variable_declaration">bytes32 internal constant SELECTOR_APPROVE_CONTRACT_CALL_WITH_MINT = keccak256('approveContractCallWithMint');</span>
    bytes32 internal constant SELECTOR_TRANSFER_OPERATORSHIP = keccak256('transferOperatorship');
    bytes32 internal constant SELECTOR_TRANSFER_OWNERSHIP = keccak256('transferOwnership');

    uint8 internal constant OLD_KEY_RETENTION = 16;

    <span class="marker" id="mapping-773"></span><span class="token add" data-title="contract_body/state_variable_declaration">address internal immutable TOKEN_DEPLOYER_IMPLEMENTATION;</span>

    <span class="marker" id="mapping-774"></span><span class="token add" data-title="contract_body/constructor_definition">constructor(address tokenDeployerImplementation) {
        TOKEN_DEPLOYER_IMPLEMENTATION = tokenDeployerImplementation;
    }</span>

    modifier onlySelf() {
        <span class="marker" id="mapping-775"></span><span class="token add" data-title="function_body/if_statement">if (<span class="marker" id="mapping-776"></span><span class="token mv" id="move-dst-44" data-title="if_statement/binary_expression">msg.sender <span class="marker" id="mapping-777"></span><span class="token add" data-title="binary_expression/!=">!=</span> address(this)</span>) <span class="marker" id="mapping-778"></span><span class="token add" data-title="if_statement/revert_statement">revert NotSelf();</span></span>

        _;
    }

    <span class="marker" id="mapping-779"></span><span class="token add" data-title="contract_body/comment">/******************\
    |* Public Methods *|
    \******************/</span>

    <span class="marker" id="mapping-780"></span><span class="token add" data-title="contract_body/function_definition">function sendToken(
        <span class="marker" id="mapping-781"></span><span class="token add" data-title="function_definition/parameter">string memory destinationChain</span>,
        <span class="marker" id="mapping-782"></span><span class="token add" data-title="function_definition/parameter">string memory destinationAddress</span>,
        <span class="marker" id="mapping-783"></span><span class="token add" data-title="function_definition/parameter">string memory symbol</span>,
        <span class="marker" id="mapping-784"></span><span class="token add" data-title="function_definition/parameter">uint256 amount</span>
    ) <span class="marker" id="mapping-785"></span><span class="token add" data-title="function_definition/visibility">external</span> <span class="marker" id="mapping-786"></span><span class="token add" data-title="function_definition/function_body">{
        <span class="marker" id="mapping-787"></span><span class="token add" data-title="function_body/expression_statement"><span class="marker" id="mapping-788"></span><span class="token add" data-title="expression_statement/call_expression">_burnTokenFrom(<span class="marker" id="mapping-789"></span><span class="token add" data-title="call_expression/call_argument">msg.sender</span>, <span class="marker" id="mapping-790"></span><span class="token mv" id="move-dst-56" data-title="call_expression/call_argument">symbol</span>, <span class="marker" id="mapping-791"></span><span class="token add" data-title="call_expression/call_argument">amount</span>)</span>;</span>
        <span class="marker" id="mapping-792"></span><span class="token add" data-title="function_body/emit_statement">emit TokenSent(<span class="marker" id="mapping-793"></span><span class="token add" data-title="emit_statement/call_argument">msg.sender</span>, <span class="marker" id="mapping-794"></span><span class="token add" data-title="emit_statement/call_argument">destinationChain</span>, <span class="marker" id="mapping-795"></span><span class="token add" data-title="emit_statement/call_argument">destinationAddress</span>, <span class="marker" id="mapping-796"></span><span class="token mv" id="move-dst-57" data-title="emit_statement/call_argument">symbol</span>, <span class="marker" id="mapping-797"></span><span class="token add" data-title="emit_statement/call_argument">amount</span>);</span>
    }</span></span>

    <span class="marker" id="mapping-798"></span><span class="token add" data-title="contract_body/function_definition">function callContract(
        string memory destinationChain,
        string memory destinationContractAddress,
        bytes memory payload
    ) external {
        emit ContractCall(msg.sender, destinationChain, destinationContractAddress, keccak256(payload), payload);
    }</span>

    <span class="marker" id="mapping-799"></span><span class="token add" data-title="contract_body/function_definition">function callContractWithToken(
        string memory destinationChain,
        string memory destinationContractAddress,
        bytes memory payload,
        string memory symbol,
        uint256 amount
    ) external {
        _burnTokenFrom(msg.sender, symbol, amount);
        emit ContractCallWithToken(
            msg.sender,
            destinationChain,
            destinationContractAddress,
            keccak256(payload),
            payload,
            symbol,
            amount
        );
    }</span>

    <span class="marker" id="mapping-800"></span><span class="token add" data-title="contract_body/function_definition">function isContractCallApproved(
        <span class="marker" id="mapping-801"></span><span class="token add" data-title="function_definition/parameter">bytes32 commandId</span>,
        <span class="marker" id="mapping-802"></span><span class="token add" data-title="function_definition/parameter">string memory sourceChain</span>,
        <span class="marker" id="mapping-803"></span><span class="token add" data-title="function_definition/parameter">string memory sourceAddress</span>,
        <span class="marker" id="mapping-804"></span><span class="token mv" id="move-dst-68" data-title="function_definition/parameter">address <span class="marker" id="mapping-805"></span><span class="token upd" id="move-dst-69" data-title="parameter/identifier">c<span class="cupd">o</span><span class="cupd">n</span>tract<span class="cupd">Addr</span>ess</span></span>,
        <span class="marker" id="mapping-806"></span><span class="token add" data-title="function_definition/parameter">bytes32 payloadHash</span>
    ) <span class="marker" id="mapping-807"></span><span class="token add" data-title="function_definition/visibility">external</span> <span class="marker" id="mapping-808"></span><span class="token mv" id="move-dst-222" data-title="function_definition/state_mutability">view</span> <span class="marker" id="mapping-809"></span><span class="token add" data-title="function_definition/override_specifier">override</span> <span class="marker" id="mapping-810"></span><span class="token mv" id="move-dst-223" data-title="function_definition/return_type_definition">returns (bool)</span> <span class="marker" id="mapping-811"></span><span class="token add" data-title="function_definition/function_body">{
        return
            getBool(_getIsContractCallApprovedKey(commandId, sourceChain, sourceAddress, contractAddress, payloadHash));
    }</span></span>

    <span class="marker" id="mapping-812"></span><span class="token add" data-title="contract_body/function_definition">function isContractCallAndMintApproved(
        bytes32 commandId,
        string memory sourceChain,
        string memory sourceAddress,
        address contractAddress,
        bytes32 payloadHash,
        string memory symbol,
        uint256 amount
    ) external view override returns (bool) {
        return
            getBool(
                _getIsContractCallApprovedWithMintKey(
                    commandId,
                    sourceChain,
                    sourceAddress,
                    contractAddress,
                    payloadHash,
                    symbol,
                    amount
                )
            );
    }</span>

    <span class="marker" id="mapping-813"></span><span class="token add" data-title="contract_body/function_definition">function validateContractCall(
        bytes32 commandId,
        string memory sourceChain,
        string memory sourceAddress,
        bytes32 payloadHash
    ) external override returns (bool valid) {
        bytes32 key = _getIsContractCallApprovedKey(commandId, sourceChain, sourceAddress, msg.sender, payloadHash);
        valid = getBool(key);
        if (valid) _setBool(key, false);
    }</span>

    <span class="marker" id="mapping-814"></span><span class="token add" data-title="contract_body/function_definition">function validateContractCallAndMint(
        bytes32 commandId,
        string memory sourceChain,
        string memory sourceAddress,
        bytes32 payloadHash,
        string memory symbol,
        uint256 amount
    ) external override returns (bool valid) {
        bytes32 key = _getIsContractCallApprovedWithMintKey(
            commandId,
            sourceChain,
            sourceAddress,
            msg.sender,
            payloadHash,
            symbol,
            amount
        );
        valid = getBool(key);
        if (valid) {
            _setBool(key, false);
            _mintToken(symbol, msg.sender, amount);
        }
    }</span>

    /***********\
    |* Getters *|
    \***********/

    function allTokensFrozen() public view override returns (bool) {
        return getBool(KEY_ALL_TOKENS_FROZEN);
    }

    function implementation() public view override returns (address) {
        return getAddress(KEY_IMPLEMENTATION);
    }

    function tokenAddresses(string memory symbol) public view override returns (address) {
        return getAddress(_getTokenAddressKey(symbol));
    }

    function tokenFrozen(string memory symbol) public view override returns (bool) {
        return getBool(_getFreezeTokenKey(symbol));
    }

    function isCommandExecuted(bytes32 commandId) public view override returns (bool) {
        return getBool(_getIsCommandExecutedKey(commandId));
    }

    <span class="marker" id="mapping-815"></span><span class="token add" data-title="contract_body/comment">/// @dev Returns the current `adminEpoch`.</span>
    <span class="marker" id="mapping-816"></span><span class="token mv" id="move-dst-212" data-title="contract_body/function_definition">function <span class="marker" id="mapping-817"></span><span class="token upd" id="move-dst-213" data-title="function_definition/identifier">adminE<span class="cupd">p</span><span class="cupd">o</span>ch</span>() <span class="marker" id="mapping-818"></span><span class="token add" data-title="function_definition/visibility">external</span> view <span class="marker" id="mapping-819"></span><span class="token add" data-title="function_definition/override_specifier">override</span> returns (uint256) {
        return <span class="marker" id="mapping-820"></span><span class="token upd" id="move-dst-217" data-title="call_expression/identifier">_adm<span class="cupd">in</span>Epoch</span>();
    }</span>

    <span class="marker" id="mapping-821"></span><span class="token add" data-title="contract_body/comment">/// @dev Returns the admin threshold for a given `adminEpoch`.</span>
    <span class="marker" id="mapping-822"></span><span class="token add" data-title="contract_body/function_definition">function adminThreshold(<span class="marker" id="mapping-823"></span><span class="token mv" id="move-dst-245" data-title="function_definition/parameter">uint256 <span class="marker" id="mapping-824"></span><span class="token upd" id="move-dst-246" data-title="parameter/identifier"><span class="cupd">e</span><span class="cupd">poch</span></span></span>) <span class="marker" id="mapping-825"></span><span class="token add" data-title="function_definition/visibility">external</span> <span class="marker" id="mapping-826"></span><span class="token add" data-title="function_definition/state_mutability">view</span> <span class="marker" id="mapping-827"></span><span class="token add" data-title="function_definition/override_specifier">override</span> <span class="marker" id="mapping-828"></span><span class="token add" data-title="function_definition/return_type_definition">returns (uint256)</span> <span class="marker" id="mapping-829"></span><span class="token add" data-title="function_definition/function_body">{
        return _getAdminThreshold(epoch);
    }</span></span>

    <span class="marker" id="mapping-830"></span><span class="token add" data-title="contract_body/comment">/// @dev Returns the array of admins within a given `adminEpoch`.</span>
    <span class="marker" id="mapping-831"></span><span class="token add" data-title="contract_body/function_definition">function admins(<span class="marker" id="mapping-832"></span><span class="token mv" id="move-dst-263" data-title="function_definition/parameter">uint256 <span class="marker" id="mapping-833"></span><span class="token upd" id="move-dst-264" data-title="parameter/identifier"><span class="cupd">e</span><span class="cupd">poch</span></span></span>) <span class="marker" id="mapping-834"></span><span class="token add" data-title="function_definition/visibility">external</span> <span class="marker" id="mapping-835"></span><span class="token add" data-title="function_definition/state_mutability">view</span> <span class="marker" id="mapping-836"></span><span class="token add" data-title="function_definition/override_specifier">override</span> <span class="marker" id="mapping-837"></span><span class="token add" data-title="function_definition/return_type_definition">returns (address[] memory results)</span> <span class="marker" id="mapping-838"></span><span class="token add" data-title="function_definition/function_body">{
        <span class="marker" id="mapping-839"></span><span class="token mv" id="move-dst-253" data-title="function_body/variable_declaration_statement">uint256 <span class="marker" id="mapping-840"></span><span class="token upd" id="move-dst-254" data-title="variable_declaration/identifier">adminC<span class="cupd">o</span>unt</span> = <span class="marker" id="mapping-841"></span><span class="token add" data-title="variable_declaration_statement/call_expression">_getAdminCount(epoch)</span>;</span>
        <span class="marker" id="mapping-842"></span><span class="token add" data-title="function_body/expression_statement">results = new address[](adminCount);</span>

        <span class="marker" id="mapping-843"></span><span class="token mv" id="move-dst-257" data-title="function_body/for_statement">for (<span class="marker" id="mapping-844"></span><span class="token mv" id="move-dst-284" data-title="for_statement/variable_declaration_statement">uint256 i;</span> <span class="marker" id="mapping-845"></span><span class="token add" data-title="for_statement/expression_statement">i &lt; adminCount;</span> <span class="marker" id="mapping-846"></span><span class="token add" data-title="for_statement/update_expression">i++</span>) {
            results[i] = <span class="marker" id="mapping-847"></span><span class="token upd" id="move-dst-261" data-title="call_expression/identifier"><span class="cupd">_get</span>Admin</span>(<span class="marker" id="mapping-848"></span><span class="token upd" id="move-dst-262" data-title="call_argument/identifier"><span class="cupd">e</span><span class="cupd">poch</span></span>, i);
        }</span>
    }</span></span>

    /*******************\
    |* Admin Functions *|
    \*******************/

    function freezeToken(string memory symbol) external override onlyAdmin {
        _setBool(_getFreezeTokenKey(symbol), true);

        emit TokenFrozen(symbol);
    }

    function unfreezeToken(string memory symbol) external override onlyAdmin {
        _setBool(_getFreezeTokenKey(symbol), false);

        emit TokenUnfrozen(symbol);
    }

    function freezeAllTokens() external override onlyAdmin {
        _setBool(KEY_ALL_TOKENS_FROZEN, true);

        emit AllTokensFrozen();
    }

    function unfreezeAllTokens() external override onlyAdmin {
        _setBool(KEY_ALL_TOKENS_FROZEN, false);

        emit AllTokensUnfrozen();
    }

    function upgrade(
        address newImplementation,
        <span class="marker" id="mapping-849"></span><span class="token add" data-title="function_definition/parameter">bytes32 newImplementationCodeHash</span><span class="marker" id="mapping-850"></span><span class="token add" data-title="function_definition/,">,</span>
        bytes calldata setupParams
    ) external override onlyAdmin {
        <span class="marker" id="mapping-851"></span><span class="token add" data-title="function_body/if_statement">if (newImplementationCodeHash != newImplementation.codehash) revert InvalidCodeHash();</span>

        emit Upgraded(newImplementation);

        <span class="marker" id="mapping-852"></span><span class="token add" data-title="function_body/comment">// AUDIT: If `newImplementation.setup` performs `selfdestruct`, it will result in the loss of _this_ implementation (thereby losing the gateway)</span>
        <span class="marker" id="mapping-853"></span><span class="token add" data-title="function_body/comment">//        if `upgrade` is entered within the context of _this_ implementation itself.</span>
        <span class="marker" id="mapping-854"></span><span class="token add" data-title="function_body/if_statement">if (<span class="marker" id="mapping-855"></span><span class="token add" data-title="if_statement/binary_expression">setupParams.length &gt; 0</span>) <span class="marker" id="mapping-856"></span><span class="token add" data-title="if_statement/block_statement">{
            <span class="marker" id="mapping-857"></span><span class="token mv" id="move-dst-45" data-title="block_statement/variable_declaration_statement">(bool success, ) = newImplementation.delegatecall(
                abi.encodeWithSelector(IAxelarGateway.setup.selector, setupParams)
            );</span>

            <span class="marker" id="mapping-858"></span><span class="token add" data-title="block_statement/if_statement">if (!success) revert SetupFailed();</span>
        }</span></span>

        _setImplementation(newImplementation);
    }

    /**********************\
    |* Internal Functions *|
    \**********************/

    <span class="marker" id="mapping-859"></span><span class="token add" data-title="contract_body/function_definition">function _burnTokenFrom(
        <span class="marker" id="mapping-860"></span><span class="token add" data-title="function_definition/parameter">address sender</span>,
        <span class="marker" id="mapping-861"></span><span class="token add" data-title="function_definition/parameter">string memory symbol</span>,
        <span class="marker" id="mapping-862"></span><span class="token add" data-title="function_definition/parameter">uint256 amount</span>
    ) <span class="marker" id="mapping-863"></span><span class="token mv" id="move-dst-216" data-title="function_definition/visibility">internal</span> <span class="marker" id="mapping-864"></span><span class="token add" data-title="function_definition/function_body">{
        <span class="marker" id="mapping-865"></span><span class="token add" data-title="function_body/variable_declaration_statement">address tokenAddress = tokenAddresses(symbol);</span>

        <span class="marker" id="mapping-866"></span><span class="token add" data-title="function_body/if_statement">if (<span class="marker" id="mapping-867"></span><span class="token mv" id="move-dst-58" data-title="if_statement/binary_expression">tokenAddress <span class="marker" id="mapping-868"></span><span class="token add" data-title="binary_expression/==">==</span> address(0)</span>) <span class="marker" id="mapping-869"></span><span class="token add" data-title="if_statement/revert_statement">revert TokenDoesNotExist(symbol);</span></span>
        <span class="marker" id="mapping-870"></span><span class="token add" data-title="function_body/if_statement">if (amount == 0) revert InvalidAmount();</span>

        <span class="marker" id="mapping-871"></span><span class="token add" data-title="function_body/variable_declaration_statement">TokenType tokenType = _getTokenType(symbol);</span>
        <span class="marker" id="mapping-872"></span><span class="token add" data-title="function_body/variable_declaration_statement">bool burnSuccess;</span>

        <span class="marker" id="mapping-873"></span><span class="token add" data-title="function_body/if_statement">if (tokenType == TokenType.External) {
            _checkTokenStatus(symbol);

            burnSuccess = _callERC20Token(
                tokenAddress,
                abi.encodeWithSelector(IERC20.transferFrom.selector, sender, address(this), amount)
            );

            if (!burnSuccess) revert BurnFailed(symbol);

            return;
        }</span>

        <span class="marker" id="mapping-874"></span><span class="token add" data-title="function_body/if_statement">if (tokenType == TokenType.InternalBurnableFrom) {
            burnSuccess = _callERC20Token(
                tokenAddress,
                abi.encodeWithSelector(IERC20BurnFrom.burnFrom.selector, sender, amount)
            );

            if (!burnSuccess) revert BurnFailed(symbol);

            return;
        }</span>

        <span class="marker" id="mapping-875"></span><span class="token add" data-title="function_body/expression_statement">burnSuccess = _callERC20Token(
            tokenAddress,
            abi.encodeWithSelector(
                IERC20.transferFrom.selector,
                sender,
                BurnableMintableCappedERC20(tokenAddress).depositAddress(bytes32(0)),
                amount
            )
        );</span>

        <span class="marker" id="mapping-876"></span><span class="token add" data-title="function_body/if_statement">if (!burnSuccess) revert BurnFailed(symbol);</span>

        <span class="marker" id="mapping-877"></span><span class="token add" data-title="function_body/expression_statement">BurnableMintableCappedERC20(tokenAddress).burn(bytes32(0));</span>
    }</span></span>

    <span class="marker" id="mapping-878"></span><span class="token add" data-title="contract_body/function_definition">function _deployToken(
        <span class="marker" id="mapping-879"></span><span class="token add" data-title="function_definition/parameter">string memory name</span>,
        <span class="marker" id="mapping-880"></span><span class="token add" data-title="function_definition/parameter">string memory symbol</span>,
        <span class="marker" id="mapping-881"></span><span class="token add" data-title="function_definition/parameter">uint8 decimals</span>,
        <span class="marker" id="mapping-882"></span><span class="token add" data-title="function_definition/parameter">uint256 cap</span>,
        <span class="marker" id="mapping-883"></span><span class="token mv" id="move-dst-16" data-title="function_definition/parameter">address tokenAddress</span>
    ) <span class="marker" id="mapping-884"></span><span class="token mv" id="move-dst-49" data-title="function_definition/visibility">internal</span> <span class="marker" id="mapping-885"></span><span class="token add" data-title="function_definition/function_body">{
        // Ensure that this symbol has not been taken.
        <span class="marker" id="mapping-886"></span><span class="token add" data-title="function_body/if_statement">if (<span class="marker" id="mapping-887"></span><span class="token mv" id="move-dst-50" data-title="if_statement/binary_expression">tokenAddresses(symbol) <span class="marker" id="mapping-888"></span><span class="token add" data-title="binary_expression/!=">!=</span> address(0)</span>) <span class="marker" id="mapping-889"></span><span class="token add" data-title="if_statement/revert_statement">revert TokenAlreadyExists(symbol);</span></span>

        <span class="marker" id="mapping-890"></span><span class="token add" data-title="function_body/if_statement">if (<span class="marker" id="mapping-891"></span><span class="token mv" id="move-dst-157" data-title="if_statement/binary_expression"><span class="marker" id="mapping-892"></span><span class="token upd" id="move-dst-158" data-title="binary_expression/identifier">t<span class="cupd">o</span>kenAddress</span> <span class="marker" id="mapping-893"></span><span class="token add" data-title="binary_expression/==">==</span> address(0)</span>) <span class="marker" id="mapping-894"></span><span class="token add" data-title="if_statement/block_statement">{
            // If token address is no specified, it indicates a request to deploy one.
            <span class="marker" id="mapping-895"></span><span class="token mv" id="move-dst-52" data-title="block_statement/variable_declaration_statement">bytes32 salt = keccak256(abi.encodePacked(symbol));</span>

            <span class="marker" id="mapping-896"></span><span class="token add" data-title="block_statement/variable_declaration_statement"><span class="marker" id="mapping-897"></span><span class="token add" data-title="variable_declaration_statement/variable_declaration_tuple">(bool success, bytes memory data)</span> = <span class="marker" id="mapping-898"></span><span class="token add" data-title="variable_declaration_statement/call_expression"><span class="marker" id="mapping-899"></span><span class="token add" data-title="call_expression/member_expression">TOKEN_DEPLOYER_IMPLEMENTATION.delegatecall</span>(
                <span class="marker" id="mapping-900"></span><span class="token add" data-title="call_expression/call_argument"><span class="marker" id="mapping-901"></span><span class="token add" data-title="call_argument/call_expression"><span class="marker" id="mapping-902"></span><span class="token add" data-title="call_expression/member_expression">abi.encodeWithSelector</span>(<span class="marker" id="mapping-903"></span><span class="token add" data-title="call_expression/call_argument">TokenDeployer.deployToken.selector</span>, <span class="marker" id="mapping-904"></span><span class="token add" data-title="call_expression/call_argument">name</span>, <span class="marker" id="mapping-905"></span><span class="token add" data-title="call_expression/call_argument">symbol</span>, <span class="marker" id="mapping-906"></span><span class="token add" data-title="call_expression/call_argument">decimals</span>, <span class="marker" id="mapping-907"></span><span class="token add" data-title="call_expression/call_argument">cap</span>, <span class="marker" id="mapping-908"></span><span class="token mv" id="move-dst-35" data-title="call_expression/call_argument">salt</span>)</span></span>
            )</span>;</span>

            <span class="marker" id="mapping-909"></span><span class="token add" data-title="block_statement/if_statement">if (!success) revert TokenDeployFailed(symbol);</span>

            <span class="marker" id="mapping-910"></span><span class="token add" data-title="block_statement/expression_statement">tokenAddress = abi.decode(data, (address));</span>

            <span class="marker" id="mapping-911"></span><span class="token add" data-title="block_statement/expression_statement">_setTokenType(symbol, TokenType.InternalBurnableFrom);</span>
        }</span> else <span class="marker" id="mapping-912"></span><span class="token add" data-title="if_statement/block_statement">{
            // If token address is specified, ensure that there is a contact at the specified addressed.
            if (tokenAddress.code.length == uint256(0)) revert TokenContractDoesNotExist(tokenAddress);

            // Mark that this symbol is an external token, which is needed to differentiate between operations on mint and burn.
            _setTokenType(symbol, TokenType.External);
        }</span></span>

        <span class="marker" id="mapping-913"></span><span class="token add" data-title="function_body/expression_statement"><span class="marker" id="mapping-914"></span><span class="token add" data-title="expression_statement/call_expression">_setTokenAddress(<span class="marker" id="mapping-915"></span><span class="token mv" id="move-dst-301" data-title="call_expression/call_argument">symbol</span>, <span class="marker" id="mapping-916"></span><span class="token add" data-title="call_expression/call_argument">tokenAddress</span>)</span>;</span>

        <span class="marker" id="mapping-917"></span><span class="token add" data-title="function_body/emit_statement">emit TokenDeployed(symbol, tokenAddress);</span>
    }</span></span>

    function _mintToken(
        string memory symbol,
        address account,
        uint256 amount
    ) internal {
        address tokenAddress = tokenAddresses(symbol);

        <span class="marker" id="mapping-918"></span><span class="token add" data-title="function_body/if_statement">if (<span class="marker" id="mapping-919"></span><span class="token add" data-title="if_statement/binary_expression">tokenAddress == <span class="marker" id="mapping-920"></span><span class="token mv" id="move-dst-18" data-title="binary_expression/type_cast_expression">address(0)</span></span>) <span class="marker" id="mapping-921"></span><span class="token add" data-title="if_statement/revert_statement">revert TokenDoesNotExist(symbol);</span></span>

        <span class="marker" id="mapping-922"></span><span class="token add" data-title="function_body/if_statement">if (<span class="marker" id="mapping-923"></span><span class="token add" data-title="if_statement/binary_expression">_getTokenType(symbol) == TokenType.External</span>) <span class="marker" id="mapping-924"></span><span class="token add" data-title="if_statement/block_statement">{
            <span class="marker" id="mapping-925"></span><span class="token add" data-title="block_statement/expression_statement">_checkTokenStatus(symbol);</span>

            <span class="marker" id="mapping-926"></span><span class="token add" data-title="block_statement/variable_declaration_statement"><span class="marker" id="mapping-927"></span><span class="token add" data-title="variable_declaration_statement/variable_declaration">bool success</span> = <span class="marker" id="mapping-928"></span><span class="token add" data-title="variable_declaration_statement/call_expression">_callERC20Token(
                <span class="marker" id="mapping-929"></span><span class="token add" data-title="call_expression/call_argument">tokenAddress</span>,
                <span class="marker" id="mapping-930"></span><span class="token add" data-title="call_expression/call_argument"><span class="marker" id="mapping-931"></span><span class="token add" data-title="call_argument/call_expression"><span class="marker" id="mapping-932"></span><span class="token add" data-title="call_expression/member_expression">abi.encodeWithSelector</span>(<span class="marker" id="mapping-933"></span><span class="token add" data-title="call_expression/call_argument">IERC20.transfer.selector</span>, <span class="marker" id="mapping-934"></span><span class="token mv" id="move-dst-173" data-title="call_expression/call_argument">account</span>, <span class="marker" id="mapping-935"></span><span class="token add" data-title="call_expression/call_argument">amount</span>)</span></span>
            )</span>;</span>

            <span class="marker" id="mapping-936"></span><span class="token add" data-title="block_statement/if_statement">if (!success) revert MintFailed(symbol);</span>
        }</span> else <span class="marker" id="mapping-937"></span><span class="token add" data-title="if_statement/block_statement">{
            <span class="marker" id="mapping-938"></span><span class="token mv" id="move-dst-59" data-title="block_statement/expression_statement">BurnableMintableCappedERC20(tokenAddress).mint(account, amount);</span>
        }</span></span>
    }

    function _burnToken(string memory symbol, bytes32 salt) internal {
        address tokenAddress = tokenAddresses(symbol);

        <span class="marker" id="mapping-939"></span><span class="token add" data-title="function_body/if_statement">if (tokenAddress == address(0)) revert TokenDoesNotExist(symbol);</span>

        <span class="marker" id="mapping-940"></span><span class="token add" data-title="function_body/if_statement">if (<span class="marker" id="mapping-941"></span><span class="token add" data-title="if_statement/binary_expression">_getTokenType(symbol) == TokenType.External</span>) <span class="marker" id="mapping-942"></span><span class="token add" data-title="if_statement/block_statement">{
            <span class="marker" id="mapping-943"></span><span class="token add" data-title="block_statement/expression_statement">_checkTokenStatus(symbol);</span>

            <span class="marker" id="mapping-944"></span><span class="token add" data-title="block_statement/variable_declaration_statement">DepositHandler depositHandler = new DepositHandler{ salt: salt }();</span>

            <span class="marker" id="mapping-945"></span><span class="token add" data-title="block_statement/variable_declaration_statement"><span class="marker" id="mapping-946"></span><span class="token add" data-title="variable_declaration_statement/variable_declaration_tuple">(bool success, bytes memory returnData)</span> = <span class="marker" id="mapping-947"></span><span class="token add" data-title="variable_declaration_statement/call_expression"><span class="marker" id="mapping-948"></span><span class="token add" data-title="call_expression/member_expression">depositHandler.execute</span>(
                <span class="marker" id="mapping-949"></span><span class="token add" data-title="call_expression/call_argument">tokenAddress</span>,
                <span class="marker" id="mapping-950"></span><span class="token add" data-title="call_expression/call_argument"><span class="marker" id="mapping-951"></span><span class="token add" data-title="call_argument/call_expression"><span class="marker" id="mapping-952"></span><span class="token add" data-title="call_expression/member_expression">abi.encodeWithSelector</span>(
                    <span class="marker" id="mapping-953"></span><span class="token add" data-title="call_expression/call_argument">IERC20.transfer.selector</span>,
                    <span class="marker" id="mapping-954"></span><span class="token mv" id="move-dst-34" data-title="call_expression/call_argument">address(this)</span>,
                    <span class="marker" id="mapping-955"></span><span class="token add" data-title="call_expression/call_argument">IERC20(tokenAddress).balanceOf(address(depositHandler))</span>
                )</span></span>
            )</span>;</span>

            <span class="marker" id="mapping-956"></span><span class="token add" data-title="block_statement/if_statement">if (!success || (returnData.length != uint256(0) &amp;&amp; !abi.decode(returnData, (bool))))
                revert BurnFailed(symbol);</span>

            <span class="marker" id="mapping-957"></span><span class="token add" data-title="block_statement/expression_statement">depositHandler.destroy(address(this));</span>
        }</span> else <span class="marker" id="mapping-958"></span><span class="token add" data-title="if_statement/block_statement">{
            <span class="marker" id="mapping-959"></span><span class="token mv" id="move-dst-62" data-title="block_statement/expression_statement">BurnableMintableCappedERC20(tokenAddress).burn(salt);</span>
        }</span></span>
    }

    <span class="marker" id="mapping-960"></span><span class="token add" data-title="contract_body/function_definition">function _approveContractCall(
        <span class="marker" id="mapping-961"></span><span class="token add" data-title="function_definition/parameter">bytes32 commandId</span>,
        <span class="marker" id="mapping-962"></span><span class="token add" data-title="function_definition/parameter">string memory sourceChain</span>,
        <span class="marker" id="mapping-963"></span><span class="token add" data-title="function_definition/parameter">string memory sourceAddress</span>,
        <span class="marker" id="mapping-964"></span><span class="token add" data-title="function_definition/parameter">address contractAddress</span>,
        <span class="marker" id="mapping-965"></span><span class="token add" data-title="function_definition/parameter">bytes32 payloadHash</span>,
        <span class="marker" id="mapping-966"></span><span class="token add" data-title="function_definition/parameter">bytes32 sourceTxHash</span>,
        <span class="marker" id="mapping-967"></span><span class="token mv" id="move-dst-94" data-title="function_definition/parameter">uint256 <span class="marker" id="mapping-968"></span><span class="token upd" id="move-dst-95" data-title="parameter/identifier">s<span class="cupd">o</span>urceEve<span class="cupd">n</span>tIndex</span></span>
    ) <span class="marker" id="mapping-969"></span><span class="token mv" id="move-dst-150" data-title="function_definition/visibility">internal</span> <span class="marker" id="mapping-970"></span><span class="token add" data-title="function_definition/function_body">{
        _setContractCallApproved(commandId, sourceChain, sourceAddress, contractAddress, payloadHash);
        emit ContractCallApproved(
            commandId,
            sourceChain,
            sourceAddress,
            contractAddress,
            payloadHash,
            sourceTxHash,
            sourceEventIndex
        );
    }</span></span>

    <span class="marker" id="mapping-971"></span><span class="token add" data-title="contract_body/function_definition">function _approveContractCallWithMint(
        <span class="marker" id="mapping-972"></span><span class="token add" data-title="function_definition/parameter">bytes32 commandId</span>,
        <span class="marker" id="mapping-973"></span><span class="token add" data-title="function_definition/parameter">string memory sourceChain</span>,
        <span class="marker" id="mapping-974"></span><span class="token add" data-title="function_definition/parameter">string memory sourceAddress</span>,
        <span class="marker" id="mapping-975"></span><span class="token add" data-title="function_definition/parameter">address contractAddress</span>,
        <span class="marker" id="mapping-976"></span><span class="token add" data-title="function_definition/parameter">bytes32 payloadHash</span>,
        <span class="marker" id="mapping-977"></span><span class="token add" data-title="function_definition/parameter">string memory symbol</span>,
        <span class="marker" id="mapping-978"></span><span class="token add" data-title="function_definition/parameter">uint256 amount</span>,
        <span class="marker" id="mapping-979"></span><span class="token add" data-title="function_definition/parameter">bytes32 sourceTxHash</span>,
        <span class="marker" id="mapping-980"></span><span class="token mv" id="move-dst-86" data-title="function_definition/parameter">uint256 <span class="marker" id="mapping-981"></span><span class="token upd" id="move-dst-87" data-title="parameter/identifier">s<span class="cupd">o</span>urceEve<span class="cupd">n</span>tIndex</span></span>
    ) <span class="marker" id="mapping-982"></span><span class="token add" data-title="function_definition/visibility">internal</span> <span class="marker" id="mapping-983"></span><span class="token add" data-title="function_definition/function_body">{
        _setContractCallApprovedWithMint(
            commandId,
            sourceChain,
            sourceAddress,
            contractAddress,
            payloadHash,
            symbol,
            amount
        );
        emit ContractCallApprovedWithMint(
            commandId,
            sourceChain,
            sourceAddress,
            contractAddress,
            payloadHash,
            symbol,
            amount,
            sourceTxHash,
            sourceEventIndex
        );
    }</span></span>

    /********************\
    |* Pure Key Getters *|
    \********************/

    <span class="marker" id="mapping-984"></span><span class="token add" data-title="contract_body/function_definition">function _getTokenTypeKey(string memory symbol) internal pure returns (bytes32) {
        return keccak256(abi.encodePacked(PREFIX_TOKEN_TYPE, symbol));
    }</span>

    function _getFreezeTokenKey(string memory symbol) internal pure returns (bytes32) {
        return keccak256(abi.encodePacked(PREFIX_TOKEN_FROZEN, symbol));
    }

    function _getTokenAddressKey(string memory symbol) internal pure returns (bytes32) {
        return keccak256(abi.encodePacked(PREFIX_TOKEN_ADDRESS, symbol));
    }

    function _getIsCommandExecutedKey(bytes32 commandId) internal pure returns (bytes32) {
        return keccak256(abi.encodePacked(PREFIX_COMMAND_EXECUTED, commandId));
    }

    <span class="marker" id="mapping-985"></span><span class="token add" data-title="contract_body/function_definition">function _getIsContractCallApprovedKey(
        bytes32 commandId,
        string memory sourceChain,
        string memory sourceAddress,
        address contractAddress,
        bytes32 payloadHash
    ) internal pure returns (bytes32) {
        return
            keccak256(
                abi.encode(
                    PREFIX_CONTRACT_CALL_APPROVED,
                    commandId,
                    sourceChain,
                    sourceAddress,
                    contractAddress,
                    payloadHash
                )
            );
    }</span>

    <span class="marker" id="mapping-986"></span><span class="token add" data-title="contract_body/function_definition">function _getIsContractCallApprovedWithMintKey(
        bytes32 commandId,
        string memory sourceChain,
        string memory sourceAddress,
        address contractAddress,
        bytes32 payloadHash,
        string memory symbol,
        uint256 amount
    ) internal pure returns (bytes32) {
        return
            keccak256(
                abi.encode(
                    PREFIX_CONTRACT_CALL_APPROVED_WITH_MINT,
                    commandId,
                    sourceChain,
                    sourceAddress,
                    contractAddress,
                    payloadHash,
                    symbol,
                    amount
                )
            );
    }</span>

    <span class="marker" id="mapping-987"></span><span class="token add" data-title="contract_body/comment">/********************\
    |* Internal Methods *|
    \********************/</span>

    <span class="marker" id="mapping-988"></span><span class="token add" data-title="contract_body/function_definition">function _callERC20Token(address tokenAddress, bytes memory callData) internal returns (bool) {
        (bool success, bytes memory returnData) = tokenAddress.call(callData);
        return success &amp;&amp; (returnData.length == uint256(0) || abi.decode(returnData, (bool)));
    }</span>

    /********************\
    |* Internal Getters *|
    \********************/

    <span class="marker" id="mapping-989"></span><span class="token add" data-title="contract_body/function_definition">function _getTokenType(string memory symbol) internal view returns (TokenType) {
        return TokenType(getUint(_getTokenTypeKey(symbol)));
    }</span>

    <span class="marker" id="mapping-990"></span><span class="token add" data-title="contract_body/function_definition">function _checkTokenStatus(string memory symbol) internal view {
        if (getBool(_getFreezeTokenKey(symbol)) || getBool(KEY_ALL_TOKENS_FROZEN)) revert TokenIsFrozen(symbol);
    }</span>

    /********************\
    |* Internal Setters *|
    \********************/

    <span class="marker" id="mapping-991"></span><span class="token add" data-title="contract_body/function_definition">function _setTokenType(string memory symbol, TokenType tokenType) internal {
        _setUint(_getTokenTypeKey(symbol), uint256(tokenType));
    }</span>

    function _setTokenAddress(string memory symbol, <span class="marker" id="mapping-992"></span><span class="token add" data-title="function_definition/parameter">address tokenAddress</span>) internal {
        _setAddress(_getTokenAddressKey(symbol), <span class="marker" id="mapping-993"></span><span class="token add" data-title="call_expression/call_argument">tokenAddress</span>);
    }

    function _setCommandExecuted(bytes32 commandId, bool executed) internal {
        _setBool(_getIsCommandExecutedKey(commandId), executed);
    }

    <span class="marker" id="mapping-994"></span><span class="token add" data-title="contract_body/function_definition">function _setContractCallApproved(
        bytes32 commandId,
        string memory sourceChain,
        string memory sourceAddress,
        address contractAddress,
        bytes32 payloadHash
    ) internal {
        _setBool(
            _getIsContractCallApprovedKey(commandId, sourceChain, sourceAddress, contractAddress, payloadHash),
            true
        );
    }</span>

    <span class="marker" id="mapping-995"></span><span class="token add" data-title="contract_body/function_definition">function _setContractCallApprovedWithMint(
        bytes32 commandId,
        string memory sourceChain,
        string memory sourceAddress,
        address contractAddress,
        bytes32 payloadHash,
        string memory symbol,
        uint256 amount
    ) internal {
        _setBool(
            _getIsContractCallApprovedWithMintKey(
                commandId,
                sourceChain,
                sourceAddress,
                contractAddress,
                payloadHash,
                symbol,
                amount
            ),
            true
        );
    }</span>

    function _setImplementation(address newImplementation) internal {
        _setAddress(KEY_IMPLEMENTATION, newImplementation);
    }
}

contract AxelarGatewayMultisig is IAxelarGatewayMultisig, AxelarGateway {
    <span class="marker" id="mapping-996"></span><span class="token add" data-title="contract_body/error_declaration">error InvalidAddress();</span>
    <span class="marker" id="mapping-997"></span><span class="token add" data-title="contract_body/error_declaration">error InvalidOwners();</span>
    <span class="marker" id="mapping-998"></span><span class="token add" data-title="contract_body/error_declaration">error InvalidOwnerThreshold();</span>
    <span class="marker" id="mapping-999"></span><span class="token add" data-title="contract_body/error_declaration">error DuplicateOwner(address owner);</span>
    <span class="marker" id="mapping-1000"></span><span class="token add" data-title="contract_body/error_declaration">error InvalidOperators();</span>
    <span class="marker" id="mapping-1001"></span><span class="token add" data-title="contract_body/error_declaration">error InvalidOperatorThreshold();</span>
    <span class="marker" id="mapping-1002"></span><span class="token add" data-title="contract_body/error_declaration">error DuplicateOperator(address operator);</span>
    <span class="marker" id="mapping-1003"></span><span class="token add" data-title="contract_body/error_declaration">error NotProxy();</span>
    <span class="marker" id="mapping-1004"></span><span class="token add" data-title="contract_body/error_declaration">error InvalidChainId();</span>
    <span class="marker" id="mapping-1005"></span><span class="token add" data-title="contract_body/error_declaration">error MalformedSigners();</span>
    <span class="marker" id="mapping-1006"></span><span class="token add" data-title="contract_body/error_declaration">error InvalidCommands();</span>

    <span class="marker" id="mapping-1007"></span><span class="token mv" id="move-dst-114" data-title="contract_body/comment"><span class="marker" id="mapping-1008"></span><span class="token upd" id="move-dst-114" data-title="contract_body/comment"><span class="cupd">//</span><span class="cupd"> </span>AUDIT:<span class="cupd"> </span><span class="cupd">s</span>lo<span class="cupd">t</span><span class="cupd"> </span>n<span class="cupd">a</span>mes<span class="cupd"> s</span>h<span class="cupd">o</span><span class="cupd">u</span>ld<span class="cupd"> </span>b<span class="cupd">e </span>pr<span class="cupd">e</span>f<span class="cupd">i</span>x<span class="cupd">e</span>d<span class="cupd"> </span><span class="cupd">w</span><span class="cupd">ith</span><span class="cupd"> </span>som<span class="cupd">e </span><span class="cupd">st</span>a<span class="cupd">n</span>da<span class="cupd">r</span>d<span class="cupd"> </span>string</span></span>
    <span class="marker" id="mapping-1009"></span><span class="token mv" id="move-dst-143" data-title="contract_body/comment"><span class="marker" id="mapping-1010"></span><span class="token upd" id="move-dst-143" data-title="contract_body/comment"><span class="cupd">//</span><span class="cupd"> </span>AUDIT:<span class="cupd"> </span>cons<span class="cupd">t</span>a<span class="cupd">n</span>t<span class="cupd">s </span>s<span class="cupd">h</span>ould b<span class="cupd">e </span>lite<span class="cupd">r</span><span class="cupd">a</span>l<span class="cupd"> </span>and<span class="cupd"> </span>th<span class="cupd">e</span>i<span class="cupd">r</span><span class="cupd"> </span>der<span class="cupd">i</span>va<span class="cupd">t</span><span class="cupd">i</span>o<span class="cupd">n </span>s<span class="cupd">h</span>ould b<span class="cupd">e </span>in <span class="cupd">c</span>omm<span class="cupd">ent</span>s</span></span>
    bytes32 internal constant KEY_OWNER_EPOCH = keccak256('owner-epoch');

    bytes32 internal constant PREFIX_OWNER = keccak256('owner');
    bytes32 internal constant PREFIX_OWNER_COUNT = keccak256('owner-count');
    bytes32 internal constant PREFIX_OWNER_THRESHOLD = keccak256('owner-threshold');
    bytes32 internal constant PREFIX_IS_OWNER = keccak256('is-owner');

    bytes32 internal constant KEY_OPERATOR_EPOCH = keccak256('operator-epoch');

    bytes32 internal constant PREFIX_OPERATOR = keccak256('operator');
    bytes32 internal constant PREFIX_OPERATOR_COUNT = keccak256('operator-count');
    bytes32 internal constant PREFIX_OPERATOR_THRESHOLD = keccak256('operator-threshold');
    bytes32 internal constant PREFIX_IS_OPERATOR = keccak256('is-operator');

    <span class="marker" id="mapping-1011"></span><span class="token add" data-title="contract_body/constructor_definition">constructor(address tokenDeployer) AxelarGateway(tokenDeployer) {}</span>

    function <span class="marker" id="mapping-1012"></span><span class="token upd" id="move-dst-71" data-title="function_definition/identifier"><span class="cupd">_</span>isSortedAs<span class="cupd">c</span>AndC<span class="cupd">ontains</span>No<span class="cupd">Duplicate</span></span>(address[] memory accounts) internal pure returns (bool) {
        <span class="marker" id="mapping-1013"></span><span class="token mv" id="move-dst-76" data-title="function_body/for_statement">for (<span class="marker" id="mapping-1014"></span><span class="token mv" id="move-dst-74" data-title="for_statement/variable_declaration_statement">uint256 i;</span> <span class="marker" id="mapping-1015"></span><span class="token add" data-title="binary_expression/member_expression">i &lt; accounts.length</span> <span class="marker" id="mapping-1016"></span><span class="token add" data-title="binary_expression/-">-</span> <span class="marker" id="mapping-1017"></span><span class="token add" data-title="binary_expression/number_literal">1</span>; <span class="marker" id="mapping-1018"></span><span class="token mv" id="move-dst-75" data-title="for_statement/update_expression">++i</span>) {
            if (accounts[i] <span class="marker" id="mapping-1019"></span><span class="token add" data-title="binary_expression/>=">&gt;=</span> accounts[<span class="marker" id="mapping-1020"></span><span class="token mv" id="move-dst-78" data-title="array_access/binary_expression">i + 1</span>]) <span class="marker" id="mapping-1021"></span><span class="token add" data-title="if_statement/block_statement">{
                <span class="marker" id="mapping-1022"></span><span class="token mv" id="move-dst-137" data-title="block_statement/return_statement">return false;</span>
            }</span>
        }</span>

        <span class="marker" id="mapping-1023"></span><span class="token mv" id="move-dst-79" data-title="function_body/return_statement">return true;</span>
    }

    /************************\
    |* Owners Functionality *|
    \************************/

    /********************\
    |* Pure Key Getters *|
    \********************/

    function _getOwnerKey(<span class="marker" id="mapping-1024"></span><span class="token mv" id="move-dst-135" data-title="function_definition/parameter">uint256 <span class="marker" id="mapping-1025"></span><span class="token upd" id="move-dst-136" data-title="parameter/identifier"><span class="cupd">e</span><span class="cupd">poch</span></span></span>, uint256 index) internal pure returns (bytes32) {
        return keccak256(abi.encodePacked(PREFIX_OWNER, <span class="marker" id="mapping-1026"></span><span class="token upd" id="move-dst-82" data-title="call_argument/identifier"><span class="cupd">e</span><span class="cupd">poch</span></span>, index));
    }

    function _getOwnerCountKey(<span class="marker" id="mapping-1027"></span><span class="token mv" id="move-dst-161" data-title="function_definition/parameter">uint256 <span class="marker" id="mapping-1028"></span><span class="token upd" id="move-dst-162" data-title="parameter/identifier"><span class="cupd">e</span><span class="cupd">poch</span></span></span>) internal pure returns (bytes32) {
        return keccak256(abi.encodePacked(PREFIX_OWNER_COUNT, <span class="marker" id="mapping-1029"></span><span class="token upd" id="move-dst-85" data-title="call_argument/identifier"><span class="cupd">e</span><span class="cupd">poch</span></span>));
    }

    function _getOwnerThresholdKey(<span class="marker" id="mapping-1030"></span><span class="token mv" id="move-dst-154" data-title="function_definition/parameter">uint256 <span class="marker" id="mapping-1031"></span><span class="token upd" id="move-dst-155" data-title="parameter/identifier"><span class="cupd">e</span><span class="cupd">poch</span></span></span>) internal pure returns (bytes32) {
        return keccak256(abi.encodePacked(PREFIX_OWNER_THRESHOLD, <span class="marker" id="mapping-1032"></span><span class="token upd" id="move-dst-88" data-title="call_argument/identifier"><span class="cupd">e</span><span class="cupd">poch</span></span>));
    }

    function _getIsOwnerKey(<span class="marker" id="mapping-1033"></span><span class="token mv" id="move-dst-148" data-title="function_definition/parameter">uint256 <span class="marker" id="mapping-1034"></span><span class="token upd" id="move-dst-149" data-title="parameter/identifier"><span class="cupd">e</span><span class="cupd">poch</span></span></span>, address account) internal pure returns (bytes32) {
        return keccak256(abi.encodePacked(PREFIX_IS_OWNER, <span class="marker" id="mapping-1035"></span><span class="token upd" id="move-dst-91" data-title="call_argument/identifier"><span class="cupd">e</span><span class="cupd">poch</span></span>, account));
    }

    /***********\
    |* Getters *|
    \***********/

    function _ownerEpoch() internal view returns (uint256) {
        return getUint(KEY_OWNER_EPOCH);
    }

    <span class="marker" id="mapping-1036"></span><span class="token mv" id="move-dst-200" data-title="contract_body/function_definition">function <span class="marker" id="mapping-1037"></span><span class="token upd" id="move-dst-201" data-title="function_definition/identifier"><span class="cupd">_getO</span>wn<span class="cupd">er</span></span>(<span class="marker" id="mapping-1038"></span><span class="token mv" id="move-dst-166" data-title="function_definition/parameter">uint256 <span class="marker" id="mapping-1039"></span><span class="token upd" id="move-dst-167" data-title="parameter/identifier"><span class="cupd">e</span><span class="cupd">poch</span></span></span>, uint256 index) internal view returns (address) {
        return getAddress(<span class="marker" id="mapping-1040"></span><span class="token upd" id="move-dst-204" data-title="call_expression/identifier"><span class="cupd">_getO</span>wn<span class="cupd">er</span><span class="cupd">Key</span></span>(<span class="marker" id="mapping-1041"></span><span class="token upd" id="move-dst-205" data-title="call_argument/identifier"><span class="cupd">e</span><span class="cupd">poch</span></span>, index));
    }</span>

    function <span class="marker" id="mapping-1042"></span><span class="token upd" id="move-dst-104" data-title="function_definition/identifier"><span class="cupd">_getOwner</span>Count</span>(<span class="marker" id="mapping-1043"></span><span class="token mv" id="move-dst-179" data-title="function_definition/parameter">uint256 <span class="marker" id="mapping-1044"></span><span class="token upd" id="move-dst-180" data-title="parameter/identifier"><span class="cupd">e</span><span class="cupd">poch</span></span></span>) internal view returns (uint256) {
        return getUint(<span class="marker" id="mapping-1045"></span><span class="token upd" id="move-dst-107" data-title="call_expression/identifier"><span class="cupd">_getOwner</span>C<span class="cupd">o</span>unt<span class="cupd">Key</span></span>(<span class="marker" id="mapping-1046"></span><span class="token upd" id="move-dst-108" data-title="call_argument/identifier"><span class="cupd">e</span><span class="cupd">poch</span></span>));
    }

    <span class="marker" id="mapping-1047"></span><span class="token mv" id="move-dst-98" data-title="contract_body/function_definition">function <span class="marker" id="mapping-1048"></span><span class="token upd" id="move-dst-99" data-title="function_definition/identifier"><span class="cupd">_getOwner</span>Threshold</span>(<span class="marker" id="mapping-1049"></span><span class="token mv" id="move-dst-184" data-title="function_definition/parameter">uint256 <span class="marker" id="mapping-1050"></span><span class="token upd" id="move-dst-185" data-title="parameter/identifier"><span class="cupd">e</span><span class="cupd">poch</span></span></span>) internal view returns (uint256) {
        return getUint(<span class="marker" id="mapping-1051"></span><span class="token upd" id="move-dst-102" data-title="call_expression/identifier"><span class="cupd">_getOwner</span>Thresh<span class="cupd">o</span>ld<span class="cupd">Key</span></span>(<span class="marker" id="mapping-1052"></span><span class="token upd" id="move-dst-103" data-title="call_argument/identifier"><span class="cupd">e</span><span class="cupd">poch</span></span>));
    }</span>

    function _isOwner(<span class="marker" id="mapping-1053"></span><span class="token mv" id="move-dst-188" data-title="function_definition/parameter">uint256 <span class="marker" id="mapping-1054"></span><span class="token upd" id="move-dst-189" data-title="parameter/identifier"><span class="cupd">e</span><span class="cupd">poch</span></span></span>, address account) internal view returns (bool) {
        return getBool(_getIsOwnerKey(<span class="marker" id="mapping-1055"></span><span class="token upd" id="move-dst-111" data-title="call_argument/identifier"><span class="cupd">e</span><span class="cupd">poch</span></span>, <span class="marker" id="mapping-1056"></span><span class="token mv" id="move-dst-224" data-title="call_expression/call_argument">account</span>));
    }

    <span class="marker" id="mapping-1057"></span><span class="token add" data-title="contract_body/comment">/// @dev Returns true if a sufficient quantity of `accounts` are owners within the last `OLD_KEY_RETENTION + 1` owner epochs (excluding the current one).</span>
    <span class="marker" id="mapping-1058"></span><span class="token mv" id="move-dst-225" data-title="contract_body/function_definition">function <span class="marker" id="mapping-1059"></span><span class="token upd" id="move-dst-226" data-title="function_definition/identifier"><span class="cupd">_areValid</span>Pr<span class="cupd">e</span>viousOw<span class="cupd">n</span><span class="cupd">er</span>s</span>(<span class="marker" id="mapping-1060"></span><span class="token mv" id="move-dst-117" data-title="function_definition/parameter">address[] memory accounts</span>) <span class="marker" id="mapping-1061"></span><span class="token mv" id="move-dst-118" data-title="function_definition/visibility">internal</span> <span class="marker" id="mapping-1062"></span><span class="token mv" id="move-dst-119" data-title="function_definition/state_mutability">view</span> <span class="marker" id="mapping-1063"></span><span class="token mv" id="move-dst-120" data-title="function_definition/return_type_definition">returns (bool)</span> {
        <span class="marker" id="mapping-1064"></span><span class="token mv" id="move-dst-144" data-title="function_body/variable_declaration_statement">uint256 <span class="marker" id="mapping-1065"></span><span class="token upd" id="move-dst-145" data-title="variable_declaration/identifier"><span class="cupd">e</span><span class="cupd">poch</span></span> = _ownerEpoch();</span>
        <span class="marker" id="mapping-1066"></span><span class="token mv" id="move-dst-124" data-title="function_body/variable_declaration_statement">uint256 recentEpochs = OLD_KEY_RETENTION + uint256(1);</span>
        <span class="marker" id="mapping-1067"></span><span class="token mv" id="move-dst-125" data-title="variable_declaration_statement/variable_declaration">uint256 lowerBoundOwnerEpoch</span> = <span class="marker" id="mapping-1068"></span><span class="token upd" id="move-dst-236" data-title="binary_expression/identifier"><span class="cupd">e</span><span class="cupd">poch</span></span> &gt; recentEpochs ? <span class="marker" id="mapping-1069"></span><span class="token upd" id="move-dst-237" data-title="binary_expression/identifier"><span class="cupd">e</span><span class="cupd">poch</span></span> - recentEpochs : uint256(0);

        <span class="marker" id="mapping-1070"></span><span class="token add" data-title="function_body/expression_statement">--epoch;</span>
        while (<span class="marker" id="mapping-1071"></span><span class="token upd" id="move-dst-238" data-title="binary_expression/identifier"><span class="cupd">e</span><span class="cupd">poch</span></span> &gt; <span class="marker" id="mapping-1072"></span><span class="token upd" id="move-dst-239" data-title="binary_expression/identifier"><span class="cupd">lowerBoundO</span>wn<span class="cupd">er</span><span class="cupd">Epoch</span></span>) {
            if (<span class="marker" id="mapping-1073"></span><span class="token upd" id="move-dst-240" data-title="call_expression/identifier"><span class="cupd">_areValidO</span>wn<span class="cupd">er</span><span class="cupd">sInEpoch</span></span>(<span class="marker" id="mapping-1074"></span><span class="token upd" id="move-dst-241" data-title="update_expression/identifier"><span class="cupd">e</span><span class="cupd">poch</span></span>--, accounts)) return true;
        }

        <span class="marker" id="mapping-1075"></span><span class="token mv" id="move-dst-132" data-title="function_body/return_statement">return false;</span>
    }</span>

    /// @dev Returns true if a sufficient quantity of `accounts` are owners in the `ownerEpoch`.
    <span class="marker" id="mapping-1076"></span><span class="token mv" id="move-dst-243" data-title="contract_body/function_definition">function <span class="marker" id="mapping-1077"></span><span class="token upd" id="move-dst-244" data-title="function_definition/identifier"><span class="cupd">_areValidO</span>wn<span class="cupd">er</span><span class="cupd">sInEpoch</span></span>(<span class="marker" id="mapping-1078"></span><span class="token mv" id="move-dst-194" data-title="function_definition/parameter">uint256 <span class="marker" id="mapping-1079"></span><span class="token upd" id="move-dst-195" data-title="parameter/identifier"><span class="cupd">e</span><span class="cupd">poch</span></span></span>, address[] memory accounts) internal view returns (bool) {
        uint256 threshold = <span class="marker" id="mapping-1080"></span><span class="token upd" id="move-dst-247" data-title="call_expression/identifier"><span class="cupd">_getO</span>wn<span class="cupd">er</span><span class="cupd">Threshold</span></span>(<span class="marker" id="mapping-1081"></span><span class="token upd" id="move-dst-248" data-title="call_argument/identifier"><span class="cupd">e</span><span class="cupd">poch</span></span>);
        uint256 validSignerCount;

        for (<span class="marker" id="mapping-1082"></span><span class="token mv" id="move-dst-171" data-title="for_statement/variable_declaration_statement">uint256 i;</span> i &lt; accounts.length; i++) {
            if (<span class="marker" id="mapping-1083"></span><span class="token upd" id="move-dst-250" data-title="call_expression/identifier"><span class="cupd">_isO</span>wn<span class="cupd">er</span></span>(<span class="marker" id="mapping-1084"></span><span class="token upd" id="move-dst-251" data-title="call_argument/identifier"><span class="cupd">e</span><span class="cupd">poch</span></span>, accounts[i]) &amp;&amp; ++validSignerCount &gt;= threshold) return true;
        }

        return false;
    }</span>

    <span class="marker" id="mapping-1085"></span><span class="token add" data-title="contract_body/comment">/// @dev Returns the current `ownerEpoch`.</span>
    <span class="marker" id="mapping-1086"></span><span class="token add" data-title="contract_body/function_definition">function ownerEpoch() <span class="marker" id="mapping-1087"></span><span class="token add" data-title="function_definition/visibility">external</span> <span class="marker" id="mapping-1088"></span><span class="token add" data-title="function_definition/state_mutability">view</span> <span class="marker" id="mapping-1089"></span><span class="token add" data-title="function_definition/override_specifier">override</span> <span class="marker" id="mapping-1090"></span><span class="token add" data-title="function_definition/return_type_definition">returns (uint256)</span> <span class="marker" id="mapping-1091"></span><span class="token add" data-title="function_definition/function_body">{
        <span class="marker" id="mapping-1092"></span><span class="token add" data-title="function_body/return_statement">return <span class="marker" id="mapping-1093"></span><span class="token mv" id="move-dst-123" data-title="return_statement/call_expression">_ownerEpoch()</span>;</span>
    }</span></span>

    <span class="marker" id="mapping-1094"></span><span class="token add" data-title="contract_body/comment">/// @dev Returns the threshold for a given `ownerEpoch`.</span>
    <span class="marker" id="mapping-1095"></span><span class="token mv" id="move-dst-206" data-title="contract_body/function_definition">function <span class="marker" id="mapping-1096"></span><span class="token upd" id="move-dst-207" data-title="function_definition/identifier">own<span class="cupd">e</span><span class="cupd">r</span>Th<span class="cupd">r</span>eshold</span>(<span class="marker" id="mapping-1097"></span><span class="token mv" id="move-dst-202" data-title="function_definition/parameter">uint256 <span class="marker" id="mapping-1098"></span><span class="token upd" id="move-dst-203" data-title="parameter/identifier"><span class="cupd">e</span><span class="cupd">poch</span></span></span>) <span class="marker" id="mapping-1099"></span><span class="token add" data-title="function_definition/visibility">external</span> view <span class="marker" id="mapping-1100"></span><span class="token add" data-title="function_definition/override_specifier">override</span> returns (uint256) {
        return <span class="marker" id="mapping-1101"></span><span class="token upd" id="move-dst-211" data-title="call_expression/identifier">_<span class="cupd">get</span>OwnerThreshold</span>(<span class="marker" id="mapping-1102"></span><span class="token add" data-title="call_argument/identifier">epoch</span>);
    }</span>

    <span class="marker" id="mapping-1103"></span><span class="token add" data-title="contract_body/comment">/// @dev Returns the array of owners within a given `ownerEpoch`.</span>
    function owners(<span class="marker" id="mapping-1104"></span><span class="token mv" id="move-dst-214" data-title="function_definition/parameter">uint256 <span class="marker" id="mapping-1105"></span><span class="token upd" id="move-dst-215" data-title="parameter/identifier"><span class="cupd">e</span><span class="cupd">poch</span></span></span>) public view override returns (address[] memory results) {
        uint256 ownerCount = _getOwnerCount(<span class="marker" id="mapping-1106"></span><span class="token upd" id="move-dst-146" data-title="call_argument/identifier"><span class="cupd">e</span><span class="cupd">poch</span></span>);
        results = new address[](ownerCount);

        for (uint256 i; i &lt; ownerCount; i++) {
            results[i] = _getOwner(<span class="marker" id="mapping-1107"></span><span class="token upd" id="move-dst-147" data-title="call_argument/identifier"><span class="cupd">e</span><span class="cupd">poch</span></span>, i);
        }
    }

    /***********\
    |* Setters *|
    \***********/

    <span class="marker" id="mapping-1108"></span><span class="token add" data-title="contract_body/function_definition">function _setOwnerEpoch(<span class="marker" id="mapping-1109"></span><span class="token mv" id="move-dst-218" data-title="function_definition/parameter">uint256 <span class="marker" id="mapping-1110"></span><span class="token upd" id="move-dst-219" data-title="parameter/identifier"><span class="cupd">e</span><span class="cupd">poch</span></span></span>) <span class="marker" id="mapping-1111"></span><span class="token mv" id="move-dst-221" data-title="function_definition/visibility">internal</span> <span class="marker" id="mapping-1112"></span><span class="token add" data-title="function_definition/function_body">{
        <span class="marker" id="mapping-1113"></span><span class="token add" data-title="function_body/expression_statement"><span class="marker" id="mapping-1114"></span><span class="token add" data-title="expression_statement/call_expression">_setUint(<span class="marker" id="mapping-1115"></span><span class="token mv" id="move-dst-151" data-title="call_expression/call_argument">KEY_OWNER_EPOCH</span>, <span class="marker" id="mapping-1116"></span><span class="token add" data-title="call_expression/call_argument">epoch</span>)</span>;</span>
    }</span></span>

    <span class="marker" id="mapping-1117"></span><span class="token mv" id="move-dst-267" data-title="contract_body/function_definition">function <span class="marker" id="mapping-1118"></span><span class="token upd" id="move-dst-268" data-title="function_definition/identifier"><span class="cupd">_setO</span>wn<span class="cupd">er</span></span>(
        <span class="marker" id="mapping-1119"></span><span class="token mv" id="move-dst-208" data-title="function_definition/parameter">uint256 <span class="marker" id="mapping-1120"></span><span class="token upd" id="move-dst-209" data-title="parameter/identifier"><span class="cupd">e</span><span class="cupd">poch</span></span></span>,
        uint256 index,
        <span class="marker" id="mapping-1121"></span><span class="token mv" id="move-dst-220" data-title="function_definition/parameter">address account</span>
    ) internal {
        <span class="marker" id="mapping-1122"></span><span class="token add" data-title="function_body/if_statement">if (<span class="marker" id="mapping-1123"></span><span class="token mv" id="move-dst-60" data-title="if_statement/binary_expression"><span class="marker" id="mapping-1124"></span><span class="token upd" id="move-dst-61" data-title="binary_expression/identifier">acc<span class="cupd">o</span>unt</span> <span class="marker" id="mapping-1125"></span><span class="token add" data-title="binary_expression/==">==</span> address(0)</span>) <span class="marker" id="mapping-1126"></span><span class="token add" data-title="if_statement/revert_statement">revert InvalidAddress();</span></span>

        _setAddress(<span class="marker" id="mapping-1127"></span><span class="token upd" id="move-dst-272" data-title="call_expression/identifier"><span class="cupd">_getO</span>wn<span class="cupd">er</span><span class="cupd">Key</span></span>(<span class="marker" id="mapping-1128"></span><span class="token upd" id="move-dst-273" data-title="call_argument/identifier"><span class="cupd">e</span><span class="cupd">poch</span></span>, index), account);
    }</span>

    function _setOwnerCount(<span class="marker" id="mapping-1129"></span><span class="token mv" id="move-dst-197" data-title="function_definition/parameter">uint256 <span class="marker" id="mapping-1130"></span><span class="token upd" id="move-dst-198" data-title="parameter/identifier"><span class="cupd">e</span><span class="cupd">poch</span></span></span>, uint256 ownerCount) internal {
        _setUint(_getOwnerCountKey(<span class="marker" id="mapping-1131"></span><span class="token upd" id="move-dst-163" data-title="call_argument/identifier"><span class="cupd">e</span><span class="cupd">poch</span></span>), ownerCount);
    }

    <span class="marker" id="mapping-1132"></span><span class="token mv" id="move-dst-277" data-title="contract_body/function_definition">function <span class="marker" id="mapping-1133"></span><span class="token upd" id="move-dst-278" data-title="function_definition/identifier"><span class="cupd">_setO</span>wn<span class="cupd">er</span>s</span>(
        <span class="marker" id="mapping-1134"></span><span class="token mv" id="move-dst-191" data-title="function_definition/parameter">uint256 <span class="marker" id="mapping-1135"></span><span class="token upd" id="move-dst-192" data-title="parameter/identifier"><span class="cupd">e</span><span class="cupd">poch</span></span></span>,
        address[] memory accounts,
        uint256 threshold
    ) internal {
        uint256 accountLength = accounts.length;

        <span class="marker" id="mapping-1136"></span><span class="token add" data-title="function_body/if_statement">if (accountLength &lt; threshold) revert InvalidOwners();</span>

        <span class="marker" id="mapping-1137"></span><span class="token add" data-title="function_body/if_statement">if (<span class="marker" id="mapping-1138"></span><span class="token mv" id="move-dst-168" data-title="if_statement/binary_expression">threshold <span class="marker" id="mapping-1139"></span><span class="token add" data-title="binary_expression/==">==</span> uint256(0)</span>) <span class="marker" id="mapping-1140"></span><span class="token add" data-title="if_statement/revert_statement">revert InvalidOwnerThreshold();</span></span>

        <span class="marker" id="mapping-1141"></span><span class="token add" data-title="function_body/expression_statement"><span class="marker" id="mapping-1142"></span><span class="token add" data-title="expression_statement/call_expression">_setOwnerThreshold(<span class="marker" id="mapping-1143"></span><span class="token add" data-title="call_expression/call_argument">epoch</span>, <span class="marker" id="mapping-1144"></span><span class="token mv" id="move-dst-282" data-title="call_expression/call_argument">threshold</span>)</span>;</span>
        <span class="marker" id="mapping-1145"></span><span class="token add" data-title="function_body/expression_statement"><span class="marker" id="mapping-1146"></span><span class="token add" data-title="expression_statement/call_expression">_setOwnerCount(<span class="marker" id="mapping-1147"></span><span class="token add" data-title="call_expression/call_argument">epoch</span>, <span class="marker" id="mapping-1148"></span><span class="token mv" id="move-dst-283" data-title="call_expression/call_argument">accountLength</span>)</span>;</span>

        for (<span class="marker" id="mapping-1149"></span><span class="token mv" id="move-dst-249" data-title="for_statement/variable_declaration_statement">uint256 i;</span> i &lt; accountLength; i++) {
            address account = accounts[i];

            <span class="marker" id="mapping-1150"></span><span class="token upd" id="move-dst-285" data-title="block_statement/comment"><span class="cupd">// Check that the account wasn't already set as an o</span>wn<span class="cupd">er</span><span class="cupd"> for this o</span>wn<span class="cupd">er</span><span class="cupd">Epoch.</span></span>
            <span class="marker" id="mapping-1151"></span><span class="token add" data-title="block_statement/if_statement">if (<span class="marker" id="mapping-1152"></span><span class="token add" data-title="if_statement/call_expression">_isOwner(<span class="marker" id="mapping-1153"></span><span class="token add" data-title="call_expression/call_argument">epoch</span>, <span class="marker" id="mapping-1154"></span><span class="token mv" id="move-dst-286" data-title="call_expression/call_argument">account</span>)</span>) <span class="marker" id="mapping-1155"></span><span class="token add" data-title="if_statement/revert_statement">revert DuplicateOwner(account);</span></span>

            <span class="marker" id="mapping-1156"></span><span class="token add" data-title="block_statement/if_statement">if (account == address(0)) revert InvalidOwners();</span>

            <span class="marker" id="mapping-1157"></span><span class="token upd" id="move-dst-287" data-title="block_statement/comment"><span class="cupd">// Set this account as the i-th o</span>wn<span class="cupd">er</span><span class="cupd"> in this o</span>wn<span class="cupd">er</span><span class="cupd">Epoch (needed to we can get all the o</span>wn<span class="cupd">er</span><span class="cupd">s for `o</span>wn<span class="cupd">er</span><span class="cupd">s`).</span></span>
            <span class="marker" id="mapping-1158"></span><span class="token upd" id="move-dst-288" data-title="call_expression/identifier"><span class="cupd">_setO</span>wn<span class="cupd">er</span></span>(<span class="marker" id="mapping-1159"></span><span class="token upd" id="move-dst-289" data-title="call_argument/identifier"><span class="cupd">e</span><span class="cupd">poch</span></span>, i, account);
            <span class="marker" id="mapping-1160"></span><span class="token upd" id="move-dst-290" data-title="call_expression/identifier"><span class="cupd">_setIsO</span>wn<span class="cupd">er</span></span>(<span class="marker" id="mapping-1161"></span><span class="token upd" id="move-dst-291" data-title="call_argument/identifier"><span class="cupd">e</span><span class="cupd">poch</span></span>, account, true);
        }
    }</span>

    function _setOwnerThreshold(uint256 <span class="marker" id="mapping-1162"></span><span class="token upd" id="move-dst-182" data-title="parameter/identifier">ep<span class="cupd">o</span>ch</span><span class="marker" id="mapping-1163"></span><span class="token mv" id="move-dst-181" data-title="function_definition/,">,</span> <span class="marker" id="mapping-1164"></span><span class="token add" data-title="function_definition/parameter">uint256 threshold</span>) internal {
        _setUint(_getOwnerThresholdKey(<span class="marker" id="mapping-1165"></span><span class="token upd" id="move-dst-183" data-title="call_argument/identifier"><span class="cupd">e</span><span class="cupd">poch</span></span>), <span class="marker" id="mapping-1166"></span><span class="token mv" id="move-dst-169" data-title="call_expression/call_argument">threshold</span>);
    }

    function _setIsOwner(
        <span class="marker" id="mapping-1167"></span><span class="token mv" id="move-dst-109" data-title="function_definition/parameter">uint256 <span class="marker" id="mapping-1168"></span><span class="token upd" id="move-dst-110" data-title="parameter/identifier"><span class="cupd">e</span><span class="cupd">poch</span></span></span>,
        address account,
        bool isOwner
    ) internal {
        _setBool(_getIsOwnerKey(<span class="marker" id="mapping-1169"></span><span class="token upd" id="move-dst-186" data-title="call_argument/identifier"><span class="cupd">e</span><span class="cupd">poch</span></span>, <span class="marker" id="mapping-1170"></span><span class="token mv" id="move-dst-300" data-title="call_expression/call_argument">account</span>), isOwner);
    }

    /**************************\
    |* Operator Functionality *|
    \**************************/

    /********************\
    |* Pure Key Getters *|
    \********************/

    function _getOperatorKey(<span class="marker" id="mapping-1171"></span><span class="token mv" id="move-dst-269" data-title="function_definition/parameter">uint256 <span class="marker" id="mapping-1172"></span><span class="token upd" id="move-dst-270" data-title="parameter/identifier"><span class="cupd">e</span><span class="cupd">poch</span></span></span>, uint256 index) internal pure returns (bytes32) {
        return keccak256(abi.encodePacked(PREFIX_OPERATOR, <span class="marker" id="mapping-1173"></span><span class="token upd" id="move-dst-190" data-title="call_argument/identifier"><span class="cupd">e</span><span class="cupd">poch</span></span>, index));
    }

    function _getOperatorCountKey(<span class="marker" id="mapping-1174"></span><span class="token mv" id="move-dst-274" data-title="function_definition/parameter">uint256 <span class="marker" id="mapping-1175"></span><span class="token upd" id="move-dst-275" data-title="parameter/identifier"><span class="cupd">e</span><span class="cupd">poch</span></span></span>) internal pure returns (bytes32) {
        return keccak256(abi.encodePacked(PREFIX_OPERATOR_COUNT, <span class="marker" id="mapping-1176"></span><span class="token upd" id="move-dst-193" data-title="call_argument/identifier"><span class="cupd">e</span><span class="cupd">poch</span></span>));
    }

    function _getOperatorThresholdKey(<span class="marker" id="mapping-1177"></span><span class="token mv" id="move-dst-279" data-title="function_definition/parameter">uint256 <span class="marker" id="mapping-1178"></span><span class="token upd" id="move-dst-280" data-title="parameter/identifier"><span class="cupd">e</span><span class="cupd">poch</span></span></span>) internal pure returns (bytes32) {
        return keccak256(abi.encodePacked(PREFIX_OPERATOR_THRESHOLD, <span class="marker" id="mapping-1179"></span><span class="token upd" id="move-dst-196" data-title="call_argument/identifier"><span class="cupd">e</span><span class="cupd">poch</span></span>));
    }

    function _getIsOperatorKey(<span class="marker" id="mapping-1180"></span><span class="token mv" id="move-dst-292" data-title="function_definition/parameter">uint256 <span class="marker" id="mapping-1181"></span><span class="token upd" id="move-dst-293" data-title="parameter/identifier"><span class="cupd">e</span><span class="cupd">poch</span></span></span>, address account) internal pure returns (bytes32) {
        return keccak256(abi.encodePacked(PREFIX_IS_OPERATOR, <span class="marker" id="mapping-1182"></span><span class="token upd" id="move-dst-199" data-title="call_argument/identifier"><span class="cupd">e</span><span class="cupd">poch</span></span>, account));
    }

    /***********\
    |* Getters *|
    \***********/

    function _operatorEpoch() internal view returns (uint256) {
        return getUint(KEY_OPERATOR_EPOCH);
    }

    <span class="marker" id="mapping-1183"></span><span class="token mv" id="move-dst-92" data-title="contract_body/function_definition">function <span class="marker" id="mapping-1184"></span><span class="token upd" id="move-dst-93" data-title="function_definition/identifier"><span class="cupd">_getO</span>p<span class="cupd">er</span>ator</span>(<span class="marker" id="mapping-1185"></span><span class="token mv" id="move-dst-297" data-title="function_definition/parameter">uint256 <span class="marker" id="mapping-1186"></span><span class="token upd" id="move-dst-298" data-title="parameter/identifier"><span class="cupd">e</span><span class="cupd">poch</span></span></span>, uint256 index) internal view returns (address) {
        return getAddress(<span class="marker" id="mapping-1187"></span><span class="token upd" id="move-dst-96" data-title="call_expression/identifier"><span class="cupd">_getO</span>p<span class="cupd">er</span>ator<span class="cupd">Key</span></span>(<span class="marker" id="mapping-1188"></span><span class="token upd" id="move-dst-97" data-title="call_argument/identifier"><span class="cupd">e</span><span class="cupd">poch</span></span>, index));
    }</span>

    <span class="marker" id="mapping-1189"></span><span class="token add" data-title="contract_body/function_definition">function _getOperatorCount(<span class="marker" id="mapping-1190"></span><span class="token mv" id="move-dst-294" data-title="function_definition/parameter">uint256 <span class="marker" id="mapping-1191"></span><span class="token upd" id="move-dst-295" data-title="parameter/identifier">e<span class="cupd">p</span><span class="cupd">o</span>ch</span></span>) <span class="marker" id="mapping-1192"></span><span class="token mv" id="move-dst-296" data-title="function_definition/visibility">internal</span> <span class="marker" id="mapping-1193"></span><span class="token add" data-title="function_definition/state_mutability">view</span> <span class="marker" id="mapping-1194"></span><span class="token add" data-title="function_definition/return_type_definition">returns (uint256)</span> <span class="marker" id="mapping-1195"></span><span class="token add" data-title="function_definition/function_body">{
        return getUint(_getOperatorCountKey(epoch));
    }</span></span>

    <span class="marker" id="mapping-1196"></span><span class="token add" data-title="contract_body/function_definition">function _getOperatorThreshold(<span class="marker" id="mapping-1197"></span><span class="token mv" id="move-dst-105" data-title="function_definition/parameter">uint256 <span class="marker" id="mapping-1198"></span><span class="token upd" id="move-dst-106" data-title="parameter/identifier"><span class="cupd">e</span><span class="cupd">poch</span></span></span>) <span class="marker" id="mapping-1199"></span><span class="token mv" id="move-dst-210" data-title="function_definition/visibility">internal</span> <span class="marker" id="mapping-1200"></span><span class="token add" data-title="function_definition/state_mutability">view</span> <span class="marker" id="mapping-1201"></span><span class="token add" data-title="function_definition/return_type_definition">returns (uint256)</span> <span class="marker" id="mapping-1202"></span><span class="token add" data-title="function_definition/function_body">{
        return getUint(_getOperatorThresholdKey(epoch));
    }</span></span>

    <span class="marker" id="mapping-1203"></span><span class="token add" data-title="contract_body/function_definition">function _isOperator(<span class="marker" id="mapping-1204"></span><span class="token mv" id="move-dst-100" data-title="function_definition/parameter">uint256 <span class="marker" id="mapping-1205"></span><span class="token upd" id="move-dst-101" data-title="parameter/identifier"><span class="cupd">e</span><span class="cupd">poch</span></span></span>, <span class="marker" id="mapping-1206"></span><span class="token mv" id="move-dst-271" data-title="function_definition/parameter">address account</span>) <span class="marker" id="mapping-1207"></span><span class="token mv" id="move-dst-65" data-title="function_definition/visibility">internal</span> <span class="marker" id="mapping-1208"></span><span class="token add" data-title="function_definition/state_mutability">view</span> <span class="marker" id="mapping-1209"></span><span class="token add" data-title="function_definition/return_type_definition">returns (bool)</span> <span class="marker" id="mapping-1210"></span><span class="token add" data-title="function_definition/function_body">{
        <span class="marker" id="mapping-1211"></span><span class="token add" data-title="function_body/return_statement">return <span class="marker" id="mapping-1212"></span><span class="token add" data-title="return_statement/call_expression">getBool(<span class="marker" id="mapping-1213"></span><span class="token add" data-title="call_expression/call_argument"><span class="marker" id="mapping-1214"></span><span class="token add" data-title="call_argument/call_expression">_getIsOperatorKey(<span class="marker" id="mapping-1215"></span><span class="token add" data-title="call_expression/call_argument">epoch</span>, <span class="marker" id="mapping-1216"></span><span class="token mv" id="move-dst-112" data-title="call_expression/call_argument">account</span>)</span></span>)</span>;</span>
    }</span></span>

    /// @dev Returns true if a sufficient quantity of `accounts` are operator in the same `operatorEpoch`, within the last `OLD_KEY_RETENTION + 1` operator epochs.
    <span class="marker" id="mapping-1217"></span><span class="token mv" id="move-dst-115" data-title="contract_body/function_definition">function <span class="marker" id="mapping-1218"></span><span class="token upd" id="move-dst-116" data-title="function_definition/identifier"><span class="cupd">_areValidRecentO</span>p<span class="cupd">er</span>ators</span>(<span class="marker" id="mapping-1219"></span><span class="token mv" id="move-dst-227" data-title="function_definition/parameter">address[] memory accounts</span>) <span class="marker" id="mapping-1220"></span><span class="token mv" id="move-dst-228" data-title="function_definition/visibility">internal</span> <span class="marker" id="mapping-1221"></span><span class="token mv" id="move-dst-229" data-title="function_definition/state_mutability">view</span> <span class="marker" id="mapping-1222"></span><span class="token mv" id="move-dst-230" data-title="function_definition/return_type_definition">returns (bool)</span> {
        <span class="marker" id="mapping-1223"></span><span class="token mv" id="move-dst-312" data-title="variable_declaration_statement/variable_declaration">uint256 <span class="marker" id="mapping-1224"></span><span class="token upd" id="move-dst-313" data-title="variable_declaration/identifier"><span class="cupd">e</span><span class="cupd">poch</span></span></span> = <span class="marker" id="mapping-1225"></span><span class="token mv" id="move-dst-321" data-title="variable_declaration_statement/call_expression">_operatorEpoch()</span>;
        <span class="marker" id="mapping-1226"></span><span class="token mv" id="move-dst-234" data-title="function_body/variable_declaration_statement">uint256 recentEpochs = OLD_KEY_RETENTION + uint256(1);</span>
        <span class="marker" id="mapping-1227"></span><span class="token mv" id="move-dst-235" data-title="variable_declaration_statement/variable_declaration">uint256 lowerBoundOperatorEpoch</span> = <span class="marker" id="mapping-1228"></span><span class="token upd" id="move-dst-126" data-title="binary_expression/identifier"><span class="cupd">e</span><span class="cupd">poch</span></span> &gt; recentEpochs ? <span class="marker" id="mapping-1229"></span><span class="token upd" id="move-dst-127" data-title="binary_expression/identifier"><span class="cupd">e</span><span class="cupd">poch</span></span> - recentEpochs : uint256(0);

        while (<span class="marker" id="mapping-1230"></span><span class="token upd" id="move-dst-128" data-title="binary_expression/identifier"><span class="cupd">e</span><span class="cupd">poch</span></span> &gt; <span class="marker" id="mapping-1231"></span><span class="token upd" id="move-dst-129" data-title="binary_expression/identifier"><span class="cupd">lowerBoundO</span>p<span class="cupd">er</span>ator<span class="cupd">Epoch</span></span>) {
            if (<span class="marker" id="mapping-1232"></span><span class="token upd" id="move-dst-130" data-title="call_expression/identifier"><span class="cupd">_areValidO</span>p<span class="cupd">er</span>ator<span class="cupd">sInEpoch</span></span>(<span class="marker" id="mapping-1233"></span><span class="token upd" id="move-dst-131" data-title="update_expression/identifier"><span class="cupd">e</span><span class="cupd">poch</span></span>--, accounts)) return true;
        }

        <span class="marker" id="mapping-1234"></span><span class="token mv" id="move-dst-242" data-title="function_body/return_statement">return false;</span>
    }</span>

    /// @dev Returns true if a sufficient quantity of `accounts` are operator in the `operatorEpoch`.
    <span class="marker" id="mapping-1235"></span><span class="token mv" id="move-dst-133" data-title="contract_body/function_definition">function <span class="marker" id="mapping-1236"></span><span class="token upd" id="move-dst-134" data-title="function_definition/identifier"><span class="cupd">_areValidO</span>p<span class="cupd">er</span>ator<span class="cupd">sInEpoch</span></span>(<span class="marker" id="mapping-1237"></span><span class="token mv" id="move-dst-89" data-title="function_definition/parameter">uint256 <span class="marker" id="mapping-1238"></span><span class="token upd" id="move-dst-90" data-title="parameter/identifier"><span class="cupd">e</span><span class="cupd">poch</span></span></span>, address[] memory accounts) internal view returns (bool) {
        uint256 threshold = <span class="marker" id="mapping-1239"></span><span class="token upd" id="move-dst-138" data-title="call_expression/identifier"><span class="cupd">_getO</span>p<span class="cupd">er</span>ator<span class="cupd">Threshold</span></span>(<span class="marker" id="mapping-1240"></span><span class="token upd" id="move-dst-139" data-title="call_argument/identifier"><span class="cupd">e</span><span class="cupd">poch</span></span>);
        uint256 validSignerCount;

        for (uint256 i; i &lt; accounts.length; i++) {
            if (<span class="marker" id="mapping-1241"></span><span class="token upd" id="move-dst-140" data-title="call_expression/identifier"><span class="cupd">_isO</span>p<span class="cupd">er</span>ator</span>(<span class="marker" id="mapping-1242"></span><span class="token upd" id="move-dst-141" data-title="call_argument/identifier"><span class="cupd">e</span><span class="cupd">poch</span></span>, accounts[i]) &amp;&amp; ++validSignerCount &gt;= threshold) return true;
        }

        return false;
    }</span>

    <span class="marker" id="mapping-1243"></span><span class="token upd" id="move-dst-252" data-title="contract_body/comment"><span class="cupd">/// @dev Returns the </span><span class="cupd">current `operatorEpoch`.</span></span>
    <span class="marker" id="mapping-1244"></span><span class="token add" data-title="contract_body/function_definition">function operatorEpoch() <span class="marker" id="mapping-1245"></span><span class="token add" data-title="function_definition/visibility">external</span> <span class="marker" id="mapping-1246"></span><span class="token add" data-title="function_definition/state_mutability">view</span> <span class="marker" id="mapping-1247"></span><span class="token add" data-title="function_definition/override_specifier">override</span> <span class="marker" id="mapping-1248"></span><span class="token add" data-title="function_definition/return_type_definition">returns (uint256)</span> <span class="marker" id="mapping-1249"></span><span class="token add" data-title="function_definition/function_body">{
        <span class="marker" id="mapping-1250"></span><span class="token add" data-title="function_body/return_statement">return <span class="marker" id="mapping-1251"></span><span class="token mv" id="move-dst-233" data-title="return_statement/call_expression">_operatorEpoch()</span>;</span>
    }</span></span>

    <span class="marker" id="mapping-1252"></span><span class="token add" data-title="contract_body/comment">/// @dev Returns the threshold for a given `operatorEpoch`.</span>
    <span class="marker" id="mapping-1253"></span><span class="token mv" id="move-dst-63" data-title="contract_body/function_definition">function <span class="marker" id="mapping-1254"></span><span class="token upd" id="move-dst-64" data-title="function_definition/identifier">op<span class="cupd">e</span>ra<span class="cupd">t</span>orThreshold</span>(<span class="marker" id="mapping-1255"></span><span class="token mv" id="move-dst-66" data-title="function_definition/parameter">uint256 <span class="marker" id="mapping-1256"></span><span class="token upd" id="move-dst-67" data-title="parameter/identifier">epoch</span></span>) <span class="marker" id="mapping-1257"></span><span class="token add" data-title="function_definition/visibility">external</span> view <span class="marker" id="mapping-1258"></span><span class="token add" data-title="function_definition/override_specifier">override</span> returns (<span class="marker" id="mapping-1259"></span><span class="token add" data-title="return_type_definition/parameter">uint256</span>) {
        <span class="marker" id="mapping-1260"></span><span class="token add" data-title="function_body/return_statement">return _getOperatorThreshold(epoch);</span>
    }</span>

    <span class="marker" id="mapping-1261"></span><span class="token add" data-title="contract_body/comment">/// @dev Returns the array of operators within a given `operatorEpoch`.</span>
    function operators(<span class="marker" id="mapping-1262"></span><span class="token add" data-title="function_definition/parameter"><span class="marker" id="mapping-1263"></span><span class="token mv" id="move-dst-77" data-title="parameter/type_name">uint256</span> epoch</span>) public view override returns (address[] memory results) {
        uint256 operatorCount = _getOperatorCount(<span class="marker" id="mapping-1264"></span><span class="token upd" id="move-dst-256" data-title="call_argument/identifier"><span class="cupd">e</span><span class="cupd">poch</span></span>);
        results = new address[](operatorCount);

        <span class="marker" id="mapping-1265"></span><span class="token add" data-title="function_body/for_statement">for (<span class="marker" id="mapping-1266"></span><span class="token mv" id="move-dst-258" data-title="for_statement/variable_declaration_statement">uint256 i;</span> <span class="marker" id="mapping-1267"></span><span class="token mv" id="move-dst-259" data-title="for_statement/expression_statement">i &lt; operatorCount;</span> <span class="marker" id="mapping-1268"></span><span class="token mv" id="move-dst-260" data-title="for_statement/update_expression">i++</span>) <span class="marker" id="mapping-1269"></span><span class="token add" data-title="for_statement/block_statement">{
            results[i] = _getOperator(epoch, i);
        }</span></span>
    }

    /***********\
    |* Setters *|
    \***********/

    <span class="marker" id="mapping-1270"></span><span class="token add" data-title="contract_body/function_definition">function _setOperatorEpoch(<span class="marker" id="mapping-1271"></span><span class="token add" data-title="function_definition/parameter">uint256 epoch</span>) <span class="marker" id="mapping-1272"></span><span class="token mv" id="move-dst-265" data-title="function_definition/visibility">internal</span> <span class="marker" id="mapping-1273"></span><span class="token add" data-title="function_definition/function_body">{
        <span class="marker" id="mapping-1274"></span><span class="token add" data-title="function_body/expression_statement"><span class="marker" id="mapping-1275"></span><span class="token add" data-title="expression_statement/call_expression">_setUint(<span class="marker" id="mapping-1276"></span><span class="token mv" id="move-dst-266" data-title="call_expression/call_argument">KEY_OPERATOR_EPOCH</span>, <span class="marker" id="mapping-1277"></span><span class="token add" data-title="call_expression/call_argument">epoch</span>)</span>;</span>
    }</span></span>

    <span class="marker" id="mapping-1278"></span><span class="token mv" id="move-dst-152" data-title="contract_body/function_definition">function <span class="marker" id="mapping-1279"></span><span class="token upd" id="move-dst-153" data-title="function_definition/identifier"><span class="cupd">_setO</span>p<span class="cupd">er</span>ator</span>(
        <span class="marker" id="mapping-1280"></span><span class="token add" data-title="function_definition/parameter">uint256 epoch</span>,
        uint256 index,
        <span class="marker" id="mapping-1281"></span><span class="token add" data-title="function_definition/parameter">address account</span>
    ) internal {
        _setAddress(<span class="marker" id="mapping-1282"></span><span class="token upd" id="move-dst-159" data-title="call_expression/identifier"><span class="cupd">_getO</span>p<span class="cupd">er</span>ator<span class="cupd">Key</span></span>(<span class="marker" id="mapping-1283"></span><span class="token upd" id="move-dst-160" data-title="call_argument/identifier"><span class="cupd">e</span><span class="cupd">poch</span></span>, index), account);
    }</span>

    function _setOperatorCount(<span class="marker" id="mapping-1284"></span><span class="token add" data-title="function_definition/parameter">uint256 epoch</span>, uint256 operatorCount) internal {
        _setUint(_getOperatorCountKey(<span class="marker" id="mapping-1285"></span><span class="token upd" id="move-dst-276" data-title="call_argument/identifier"><span class="cupd">e</span><span class="cupd">poch</span></span>), operatorCount);
    }

    <span class="marker" id="mapping-1286"></span><span class="token mv" id="move-dst-164" data-title="contract_body/function_definition">function <span class="marker" id="mapping-1287"></span><span class="token upd" id="move-dst-165" data-title="function_definition/identifier"><span class="cupd">_setO</span>p<span class="cupd">er</span>ators</span>(
        <span class="marker" id="mapping-1288"></span><span class="token add" data-title="function_definition/parameter">uint256 epoch</span>,
        address[] memory accounts,
        uint256 threshold
    ) internal {
        uint256 accountLength = accounts.length;

        <span class="marker" id="mapping-1289"></span><span class="token add" data-title="function_body/if_statement">if (accountLength &lt; threshold) revert InvalidOperators();</span>

        <span class="marker" id="mapping-1290"></span><span class="token add" data-title="function_body/if_statement">if (<span class="marker" id="mapping-1291"></span><span class="token mv" id="move-dst-281" data-title="if_statement/binary_expression">threshold <span class="marker" id="mapping-1292"></span><span class="token add" data-title="binary_expression/==">==</span> uint256(0)</span>) <span class="marker" id="mapping-1293"></span><span class="token add" data-title="if_statement/revert_statement">revert InvalidOperatorThreshold();</span></span>

        <span class="marker" id="mapping-1294"></span><span class="token add" data-title="function_body/expression_statement">_setOperatorThreshold(epoch, threshold);</span>
        <span class="marker" id="mapping-1295"></span><span class="token add" data-title="function_body/expression_statement"><span class="marker" id="mapping-1296"></span><span class="token add" data-title="expression_statement/call_expression">_setOperatorCount(<span class="marker" id="mapping-1297"></span><span class="token add" data-title="call_expression/call_argument">epoch</span>, <span class="marker" id="mapping-1298"></span><span class="token mv" id="move-dst-170" data-title="call_expression/call_argument">accountLength</span>)</span>;</span>

        for (<span class="marker" id="mapping-1299"></span><span class="token add" data-title="for_statement/variable_declaration_statement">uint256 i;</span> i &lt; accountLength; i++) {
            address account = accounts[i];

            <span class="marker" id="mapping-1300"></span><span class="token upd" id="move-dst-172" data-title="block_statement/comment"><span class="cupd">// Check that the account wasn't already set as an o</span>p<span class="cupd">er</span>ator<span class="cupd"> for this o</span>p<span class="cupd">er</span>ator<span class="cupd">Epoch.</span></span>
            <span class="marker" id="mapping-1301"></span><span class="token add" data-title="block_statement/if_statement">if (_isOperator(epoch, account)) revert DuplicateOperator(account);</span>

            <span class="marker" id="mapping-1302"></span><span class="token add" data-title="block_statement/if_statement">if (account == address(0)) revert InvalidOperators();</span>

            <span class="marker" id="mapping-1303"></span><span class="token upd" id="move-dst-174" data-title="block_statement/comment"><span class="cupd">// Set this account as the i-th o</span>p<span class="cupd">er</span>ator<span class="cupd"> in this o</span>p<span class="cupd">er</span>ator<span class="cupd">Epoch (needed to we can get all the o</span>p<span class="cupd">er</span>ator<span class="cupd">s for `o</span>p<span class="cupd">er</span>ator<span class="cupd">s`).</span></span>
            <span class="marker" id="mapping-1304"></span><span class="token upd" id="move-dst-175" data-title="call_expression/identifier"><span class="cupd">_setO</span>p<span class="cupd">er</span>ator</span>(<span class="marker" id="mapping-1305"></span><span class="token upd" id="move-dst-176" data-title="call_argument/identifier"><span class="cupd">e</span><span class="cupd">poch</span></span>, i, account);
            <span class="marker" id="mapping-1306"></span><span class="token upd" id="move-dst-177" data-title="call_expression/identifier"><span class="cupd">_setIsO</span>p<span class="cupd">er</span>ator</span>(<span class="marker" id="mapping-1307"></span><span class="token upd" id="move-dst-178" data-title="call_argument/identifier"><span class="cupd">e</span><span class="cupd">poch</span></span>, account, true);
        }
    }</span>

    <span class="marker" id="mapping-1308"></span><span class="token add" data-title="contract_body/function_definition">function _setOperatorThreshold(uint256 epoch, uint256 threshold) internal {
        _setUint(_getOperatorThresholdKey(epoch), threshold);
    }</span>

    function _setIsOperator(
        <span class="marker" id="mapping-1309"></span><span class="token add" data-title="function_definition/parameter">uint256 epoch</span>,
        address account,
        bool isOperator
    ) internal {
        _setBool(_getIsOperatorKey(<span class="marker" id="mapping-1310"></span><span class="token upd" id="move-dst-299" data-title="call_argument/identifier"><span class="cupd">e</span><span class="cupd">poch</span></span>, <span class="marker" id="mapping-1311"></span><span class="token mv" id="move-dst-187" data-title="call_expression/call_argument">account</span>), isOperator);
    }

    /**********************\
    |* Self Functionality *|
    \**********************/

    function deployToken(bytes calldata params<span class="marker" id="mapping-1312"></span><span class="token add" data-title="function_definition/,">,</span> <span class="marker" id="mapping-1313"></span><span class="token add" data-title="function_definition/parameter">bytes32</span>) external onlySelf {
        (string memory name, string memory symbol, uint8 decimals, uint256 cap<span class="marker" id="mapping-1314"></span><span class="token add" data-title="variable_declaration_tuple/,">,</span> <span class="marker" id="mapping-1315"></span><span class="token add" data-title="variable_declaration_tuple/variable_declaration">address tokenAddr</span>) = abi.decode(
            params,
            (string, string, uint8, uint256<span class="marker" id="mapping-1316"></span><span class="token add" data-title="tuple_expression/,">,</span> <span class="marker" id="mapping-1317"></span><span class="token add" data-title="tuple_expression/primitive_type">address</span>)
        );

        _deployToken(name, <span class="marker" id="mapping-1318"></span><span class="token add" data-title="call_expression/call_argument">symbol</span>, decimals, cap<span class="marker" id="mapping-1319"></span><span class="token add" data-title="call_expression/,">,</span> <span class="marker" id="mapping-1320"></span><span class="token mv" id="move-dst-70" data-title="call_expression/call_argument">tokenAddr</span>);
    }

    function mintToken(bytes calldata params<span class="marker" id="mapping-1321"></span><span class="token add" data-title="function_definition/,">,</span> <span class="marker" id="mapping-1322"></span><span class="token add" data-title="function_definition/parameter">bytes32</span>) external onlySelf {
        (string memory symbol, address account, uint256 amount) = abi.decode(params, (string, address, uint256));

        _mintToken(symbol, account, amount);
    }

    function burnToken(bytes calldata params<span class="marker" id="mapping-1323"></span><span class="token add" data-title="function_definition/,">,</span> <span class="marker" id="mapping-1324"></span><span class="token add" data-title="function_definition/parameter">bytes32</span>) external onlySelf {
        (string memory symbol, bytes32 salt) = abi.decode(params, (string, bytes32));

        _burnToken(symbol, salt);
    }

    <span class="marker" id="mapping-1325"></span><span class="token add" data-title="contract_body/function_definition">function approveContractCall(<span class="marker" id="mapping-1326"></span><span class="token add" data-title="function_definition/parameter">bytes calldata params</span>, <span class="marker" id="mapping-1327"></span><span class="token add" data-title="function_definition/parameter">bytes32 commandId</span>) <span class="marker" id="mapping-1328"></span><span class="token add" data-title="function_definition/visibility">external</span> <span class="marker" id="mapping-1329"></span><span class="token add" data-title="function_definition/modifier_invocation">onlySelf</span> <span class="marker" id="mapping-1330"></span><span class="token add" data-title="function_definition/function_body">{
        <span class="marker" id="mapping-1331"></span><span class="token add" data-title="function_body/variable_declaration_statement"><span class="marker" id="mapping-1332"></span><span class="token add" data-title="variable_declaration_statement/variable_declaration_tuple">(
            <span class="marker" id="mapping-1333"></span><span class="token add" data-title="variable_declaration_tuple/variable_declaration">string memory sourceChain</span>,
            <span class="marker" id="mapping-1334"></span><span class="token add" data-title="variable_declaration_tuple/variable_declaration">string memory sourceAddress</span>,
            <span class="marker" id="mapping-1335"></span><span class="token add" data-title="variable_declaration_tuple/variable_declaration">address contractAddress</span>,
            <span class="marker" id="mapping-1336"></span><span class="token add" data-title="variable_declaration_tuple/variable_declaration">bytes32 payloadHash</span>,
            <span class="marker" id="mapping-1337"></span><span class="token add" data-title="variable_declaration_tuple/variable_declaration">bytes32 sourceTxHash</span>,
            <span class="marker" id="mapping-1338"></span><span class="token mv" id="move-dst-329" data-title="variable_declaration_tuple/variable_declaration">uint256 <span class="marker" id="mapping-1339"></span><span class="token upd" id="move-dst-330" data-title="variable_declaration/identifier">s<span class="cupd">o</span>urc<span class="cupd">e</span>Even<span class="cupd">t</span>Index</span></span>
        )</span> = <span class="marker" id="mapping-1340"></span><span class="token add" data-title="variable_declaration_statement/call_expression">abi.decode(params, (string, string, address, bytes32, bytes32, uint256))</span>;</span>

        <span class="marker" id="mapping-1341"></span><span class="token add" data-title="function_body/expression_statement">_approveContractCall(
            commandId,
            sourceChain,
            sourceAddress,
            contractAddress,
            payloadHash,
            sourceTxHash,
            sourceEventIndex
        );</span>
    }</span></span>

    <span class="marker" id="mapping-1342"></span><span class="token add" data-title="contract_body/function_definition">function approveContractCallWithMint(<span class="marker" id="mapping-1343"></span><span class="token add" data-title="function_definition/parameter">bytes calldata params</span>, <span class="marker" id="mapping-1344"></span><span class="token add" data-title="function_definition/parameter">bytes32 commandId</span>) <span class="marker" id="mapping-1345"></span><span class="token add" data-title="function_definition/visibility">external</span> <span class="marker" id="mapping-1346"></span><span class="token add" data-title="function_definition/modifier_invocation">onlySelf</span> <span class="marker" id="mapping-1347"></span><span class="token add" data-title="function_definition/function_body">{
        <span class="marker" id="mapping-1348"></span><span class="token add" data-title="function_body/variable_declaration_statement"><span class="marker" id="mapping-1349"></span><span class="token add" data-title="variable_declaration_statement/variable_declaration_tuple">(
            <span class="marker" id="mapping-1350"></span><span class="token add" data-title="variable_declaration_tuple/variable_declaration">string memory sourceChain</span>,
            <span class="marker" id="mapping-1351"></span><span class="token add" data-title="variable_declaration_tuple/variable_declaration">string memory sourceAddress</span>,
            <span class="marker" id="mapping-1352"></span><span class="token add" data-title="variable_declaration_tuple/variable_declaration">address contractAddress</span>,
            <span class="marker" id="mapping-1353"></span><span class="token add" data-title="variable_declaration_tuple/variable_declaration">bytes32 payloadHash</span>,
            <span class="marker" id="mapping-1354"></span><span class="token add" data-title="variable_declaration_tuple/variable_declaration">string memory symbol</span>,
            <span class="marker" id="mapping-1355"></span><span class="token mv" id="move-dst-327" data-title="variable_declaration_tuple/variable_declaration">uint256 <span class="marker" id="mapping-1356"></span><span class="token upd" id="move-dst-328" data-title="variable_declaration/identifier">am<span class="cupd">o</span>unt</span></span>,
            <span class="marker" id="mapping-1357"></span><span class="token add" data-title="variable_declaration_tuple/variable_declaration">bytes32 sourceTxHash</span>,
            <span class="marker" id="mapping-1358"></span><span class="token mv" id="move-dst-325" data-title="variable_declaration_tuple/variable_declaration">uint256 <span class="marker" id="mapping-1359"></span><span class="token upd" id="move-dst-326" data-title="variable_declaration/identifier">sou<span class="cupd">r</span>c<span class="cupd">e</span>EventIndex</span></span>
        )</span> = <span class="marker" id="mapping-1360"></span><span class="token add" data-title="variable_declaration_statement/call_expression">abi.decode(params, (string, string, address, bytes32, string, uint256, bytes32, uint256))</span>;</span>

        <span class="marker" id="mapping-1361"></span><span class="token add" data-title="function_body/expression_statement">_approveContractCallWithMint(
            commandId,
            sourceChain,
            sourceAddress,
            contractAddress,
            payloadHash,
            symbol,
            amount,
            sourceTxHash,
            sourceEventIndex
        );</span>
    }</span></span>

    function transferOwnership(bytes calldata params<span class="marker" id="mapping-1362"></span><span class="token add" data-title="function_definition/,">,</span> <span class="marker" id="mapping-1363"></span><span class="token add" data-title="function_definition/parameter">bytes32</span>) external onlySelf {
        (address[] memory newOwners, uint256 newThreshold) = abi.decode(params, (address[], uint256));

        <span class="marker" id="mapping-1364"></span><span class="token mv" id="move-dst-311" data-title="function_body/variable_declaration_statement"><span class="marker" id="mapping-1365"></span><span class="token mv" id="move-dst-331" data-title="variable_declaration_statement/variable_declaration">uint256 <span class="marker" id="mapping-1366"></span><span class="token upd" id="move-dst-332" data-title="variable_declaration/identifier">e<span class="cupd">poch</span></span></span> = _ownerEpoch();</span>

        emit OwnershipTransferred(<span class="marker" id="mapping-1367"></span><span class="token upd" id="move-dst-307" data-title="call_expression/identifier">o<span class="cupd">wner</span>s</span>(<span class="marker" id="mapping-1368"></span><span class="token upd" id="move-dst-308" data-title="call_argument/identifier"><span class="cupd">e</span><span class="cupd">poch</span></span>)<span class="marker" id="mapping-1369"></span><span class="token mv" id="move-dst-306" data-title="emit_statement/,">,</span> <span class="marker" id="mapping-1370"></span><span class="token mv" id="move-dst-304" data-title="emit_statement/call_argument"><span class="marker" id="mapping-1371"></span><span class="token upd" id="move-dst-305" data-title="call_expression/identifier">_getO<span class="cupd">wner</span>Threshold</span>(<span class="marker" id="mapping-1372"></span><span class="token add" data-title="call_expression/call_argument">epoch</span>)</span>, newOwners, newThreshold);

        _setOwnerEpoch(++<span class="marker" id="mapping-1373"></span><span class="token upd" id="move-dst-309" data-title="update_expression/identifier"><span class="cupd">e</span><span class="cupd">poch</span></span>);
        _setOwners(<span class="marker" id="mapping-1374"></span><span class="token upd" id="move-dst-310" data-title="call_argument/identifier"><span class="cupd">e</span><span class="cupd">poch</span></span>, newOwners, newThreshold);
    }

    function transferOperatorship(bytes calldata params<span class="marker" id="mapping-1375"></span><span class="token add" data-title="function_definition/,">,</span> <span class="marker" id="mapping-1376"></span><span class="token add" data-title="function_definition/parameter">bytes32</span>) external onlySelf {
        (address[] memory newOperators, uint256 newThreshold) = abi.decode(params, (address[], uint256));

        <span class="marker" id="mapping-1377"></span><span class="token mv" id="move-dst-336" data-title="function_body/variable_declaration_statement">uint256 <span class="marker" id="mapping-1378"></span><span class="token upd" id="move-dst-337" data-title="variable_declaration/identifier"><span class="cupd">e</span><span class="cupd">poch</span></span> = <span class="marker" id="mapping-1379"></span><span class="token mv" id="move-dst-255" data-title="variable_declaration_statement/call_expression">_operatorEpoch()</span>;</span>

        emit OperatorshipTransferred(<span class="marker" id="mapping-1380"></span><span class="token upd" id="move-dst-317" data-title="call_expression/identifier">o<span class="cupd">perator</span>s</span>(<span class="marker" id="mapping-1381"></span><span class="token upd" id="move-dst-318" data-title="call_argument/identifier"><span class="cupd">e</span><span class="cupd">poch</span></span>)<span class="marker" id="mapping-1382"></span><span class="token mv" id="move-dst-316" data-title="emit_statement/,">,</span> <span class="marker" id="mapping-1383"></span><span class="token mv" id="move-dst-314" data-title="emit_statement/call_argument"><span class="marker" id="mapping-1384"></span><span class="token upd" id="move-dst-315" data-title="call_expression/identifier">_getO<span class="cupd">perator</span>Threshold</span>(<span class="marker" id="mapping-1385"></span><span class="token add" data-title="call_expression/call_argument">epoch</span>)</span>, newOperators, newThreshold);

        _setOperatorEpoch(++<span class="marker" id="mapping-1386"></span><span class="token upd" id="move-dst-322" data-title="update_expression/identifier"><span class="cupd">e</span><span class="cupd">poch</span></span>);
        _setOperators(<span class="marker" id="mapping-1387"></span><span class="token upd" id="move-dst-323" data-title="call_argument/identifier"><span class="cupd">e</span><span class="cupd">poch</span></span>, newOperators, newThreshold);
    }

    /**************************\
    |* External Functionality *|
    \**************************/

    function setup(bytes calldata params) external override {
        // Prevent setup from being called on a non-proxy (the implementation).
        <span class="marker" id="mapping-1388"></span><span class="token add" data-title="function_body/if_statement">if (<span class="marker" id="mapping-1389"></span><span class="token mv" id="move-dst-324" data-title="if_statement/binary_expression">implementation() <span class="marker" id="mapping-1390"></span><span class="token add" data-title="binary_expression/==">==</span> address(0)</span>) <span class="marker" id="mapping-1391"></span><span class="token add" data-title="if_statement/revert_statement">revert NotProxy();</span></span>

        (
            address[] memory adminAddresses,
            <span class="marker" id="mapping-1392"></span><span class="token mv" id="move-dst-72" data-title="variable_declaration_tuple/variable_declaration">uint256 <span class="marker" id="mapping-1393"></span><span class="token upd" id="move-dst-73" data-title="variable_declaration/identifier">newAdminThreshold</span></span>,
            address[] memory ownerAddresses,
            <span class="marker" id="mapping-1394"></span><span class="token mv" id="move-dst-121" data-title="variable_declaration_tuple/variable_declaration">uint256 <span class="marker" id="mapping-1395"></span><span class="token upd" id="move-dst-122" data-title="variable_declaration/identifier">ne<span class="cupd">w</span>Ow<span class="cupd">ner</span>Threshold</span></span>,
            address[] memory operatorAddresses,
            <span class="marker" id="mapping-1396"></span><span class="token mv" id="move-dst-231" data-title="variable_declaration_tuple/variable_declaration">uint256 <span class="marker" id="mapping-1397"></span><span class="token upd" id="move-dst-232" data-title="variable_declaration/identifier">newO<span class="cupd">perator</span>Threshold</span></span>
        ) = abi.decode(params, (address[], uint256, address[], uint256, address[], uint256));

        <span class="marker" id="mapping-1398"></span><span class="token mv" id="move-dst-319" data-title="function_body/variable_declaration_statement">uint256 <span class="marker" id="mapping-1399"></span><span class="token upd" id="move-dst-320" data-title="variable_declaration/identifier">n<span class="cupd">e</span>wAdmin<span class="cupd">Epoch</span></span> = <span class="marker" id="mapping-1400"></span><span class="token mv" id="move-dst-333" data-title="variable_declaration_statement/binary_expression">_adminEpoch() + uint256(1)</span>;</span>
        _setAdminEpoch(<span class="marker" id="mapping-1401"></span><span class="token upd" id="move-dst-334" data-title="call_argument/identifier">newA<span class="cupd">dminEpoch</span></span>);
        <span class="marker" id="mapping-1402"></span><span class="token add" data-title="function_body/expression_statement"><span class="marker" id="mapping-1403"></span><span class="token add" data-title="expression_statement/call_expression">_setAdmins(<span class="marker" id="mapping-1404"></span><span class="token add" data-title="call_expression/call_argument">newAdminEpoch</span>, <span class="marker" id="mapping-1405"></span><span class="token mv" id="move-dst-335" data-title="call_expression/call_argument">adminAddresses</span>, <span class="marker" id="mapping-1406"></span><span class="token add" data-title="call_expression/call_argument">newAdminThreshold</span>)</span>;</span>

        <span class="marker" id="mapping-1407"></span><span class="token mv" id="move-dst-302" data-title="function_body/variable_declaration_statement">uint256 <span class="marker" id="mapping-1408"></span><span class="token upd" id="move-dst-303" data-title="variable_declaration/identifier">ne<span class="cupd">w</span>Ow<span class="cupd">nerEpoch</span></span> = <span class="marker" id="mapping-1409"></span><span class="token mv" id="move-dst-338" data-title="variable_declaration_statement/binary_expression">_ownerEpoch() + uint256(1)</span>;</span>
        _setOwnerEpoch(<span class="marker" id="mapping-1410"></span><span class="token upd" id="move-dst-339" data-title="call_argument/identifier">ne<span class="cupd">w</span>Ow<span class="cupd">nerEpoch</span></span>);
        <span class="marker" id="mapping-1411"></span><span class="token add" data-title="function_body/expression_statement"><span class="marker" id="mapping-1412"></span><span class="token add" data-title="expression_statement/call_expression">_setOwners(<span class="marker" id="mapping-1413"></span><span class="token add" data-title="call_expression/call_argument">newOwnerEpoch</span>, <span class="marker" id="mapping-1414"></span><span class="token mv" id="move-dst-340" data-title="call_expression/call_argument">ownerAddresses</span>, <span class="marker" id="mapping-1415"></span><span class="token add" data-title="call_expression/call_argument">newOwnerThreshold</span>)</span>;</span>

        uint256 <span class="marker" id="mapping-1416"></span><span class="token upd" id="move-dst-341" data-title="variable_declaration/identifier">newO<span class="cupd">peratorEpoch</span></span> = _operatorEpoch() + uint256(1);
        _setOperatorEpoch(<span class="marker" id="mapping-1417"></span><span class="token upd" id="move-dst-342" data-title="call_argument/identifier">newO<span class="cupd">peratorEpoch</span></span>);
        <span class="marker" id="mapping-1418"></span><span class="token add" data-title="function_body/expression_statement"><span class="marker" id="mapping-1419"></span><span class="token add" data-title="expression_statement/call_expression">_setOperators(<span class="marker" id="mapping-1420"></span><span class="token add" data-title="call_expression/call_argument">newOperatorEpoch</span>, <span class="marker" id="mapping-1421"></span><span class="token mv" id="move-dst-343" data-title="call_expression/call_argument">operatorAddresses</span>, <span class="marker" id="mapping-1422"></span><span class="token add" data-title="call_expression/call_argument">newOperatorThreshold</span>)</span>;</span>

        emit OwnershipTransferred(new address[](uint256(0)), uint256(0), ownerAddresses, <span class="marker" id="mapping-1423"></span><span class="token upd" id="move-dst-344" data-title="call_argument/identifier">ne<span class="cupd">w</span>Ow<span class="cupd">nerThreshold</span></span>);
        emit OperatorshipTransferred(new address[](uint256(0)), uint256(0), operatorAddresses, <span class="marker" id="mapping-1424"></span><span class="token upd" id="move-dst-345" data-title="call_argument/identifier">newO<span class="cupd">peratorThreshold</span></span>);
    }

    function execute(bytes calldata input) external override {
        (bytes memory data, bytes[] memory signatures) = abi.decode(input, (bytes, bytes[]));

        _execute(data, signatures);
    }

    function _execute(bytes memory data, bytes[] memory signatures) internal {
        uint256 signatureCount = signatures.length;

        address[] memory signers = new address[](signatureCount);

        for (uint256 i; i &lt; signatureCount; i++) {
            signers[i] = ECDSA.recover(ECDSA.toEthSignedMessageHash(keccak256(data)), signatures[i]);
        }

        (
            uint256 chainId,
            <span class="marker" id="mapping-1425"></span><span class="token add" data-title="variable_declaration_tuple/variable_declaration">Role signersRole</span>,
            <span class="marker" id="mapping-1426"></span><span class="token mv" id="move-dst-346" data-title="variable_declaration_tuple/variable_declaration">bytes32[] memory commandIds</span>,
            <span class="marker" id="mapping-1427"></span><span class="token mv" id="move-dst-347" data-title="variable_declaration_tuple/variable_declaration">string[] memory commands</span><span class="marker" id="mapping-1428"></span><span class="token add" data-title="variable_declaration_tuple/,">,</span>
            bytes[] memory params
        ) = abi.decode(data, (uint256, <span class="marker" id="mapping-1429"></span><span class="token add" data-title="tuple_expression/identifier">Role</span>, <span class="marker" id="mapping-1430"></span><span class="token mv" id="move-dst-348" data-title="tuple_expression/array_access">bytes32[]</span>, <span class="marker" id="mapping-1431"></span><span class="token mv" id="move-dst-349" data-title="tuple_expression/array_access">string[]</span><span class="marker" id="mapping-1432"></span><span class="token add" data-title="tuple_expression/,">,</span> bytes[]));

        <span class="marker" id="mapping-1433"></span><span class="token add" data-title="function_body/if_statement">if (chainId != block.chainid) revert InvalidChainId();</span>

        <span class="marker" id="mapping-1434"></span><span class="token add" data-title="function_body/if_statement">if (<span class="marker" id="mapping-1435"></span><span class="token add" data-title="if_statement/unary_expression">!<span class="marker" id="mapping-1436"></span><span class="token mv" id="move-dst-352" data-title="unary_expression/call_expression"><span class="marker" id="mapping-1437"></span><span class="token upd" id="move-dst-353" data-title="call_expression/identifier"><span class="cupd">_</span>isSo<span class="cupd">r</span>t<span class="cupd">e</span>dAscAndCont<span class="cupd">a</span>insNoDup<span class="cupd">li</span><span class="cupd">c</span>a<span class="cupd">t</span>e</span>(signers)</span></span>) <span class="marker" id="mapping-1438"></span><span class="token add" data-title="if_statement/revert_statement">revert MalformedSigners();</span></span>

        uint256 commandsLength = commandIds.length;

        <span class="marker" id="mapping-1439"></span><span class="token add" data-title="function_body/if_statement">if (<span class="marker" id="mapping-1440"></span><span class="token mv" id="move-dst-350" data-title="if_statement/binary_expression">commandsLength <span class="marker" id="mapping-1441"></span><span class="token add" data-title="binary_expression/!=">!=</span> commands.length <span class="marker" id="mapping-1442"></span><span class="token add" data-title="binary_expression/||">||</span> commandsLength <span class="marker" id="mapping-1443"></span><span class="token add" data-title="binary_expression/!=">!=</span> params.length</span>) <span class="marker" id="mapping-1444"></span><span class="token add" data-title="if_statement/revert_statement">revert InvalidCommands();</span></span>

        bool areValidCurrentOwners;
        bool areValidRecentOwners;
        bool areValidRecentOperators;

        <span class="marker" id="mapping-1445"></span><span class="token add" data-title="function_body/if_statement">if (<span class="marker" id="mapping-1446"></span><span class="token add" data-title="if_statement/binary_expression">signersRole == Role.Owner</span>) <span class="marker" id="mapping-1447"></span><span class="token add" data-title="if_statement/block_statement">{
            <span class="marker" id="mapping-1448"></span><span class="token add" data-title="block_statement/expression_statement"><span class="marker" id="mapping-1449"></span><span class="token add" data-title="expression_statement/assignment_expression">areValidCurrentOwners = <span class="marker" id="mapping-1450"></span><span class="token mv" id="move-dst-351" data-title="assignment_expression/call_expression">_areValidOwnersInEpoch(_ownerEpoch(), signers)</span></span>;</span>
            <span class="marker" id="mapping-1451"></span><span class="token add" data-title="block_statement/expression_statement">areValidRecentOwners = areValidCurrentOwners || _areValidPreviousOwners(signers);</span>
        }</span> else <span class="marker" id="mapping-1452"></span><span class="token add" data-title="if_statement/if_statement">if (<span class="marker" id="mapping-1453"></span><span class="token add" data-title="if_statement/binary_expression">signersRole == Role.Operator</span>) <span class="marker" id="mapping-1454"></span><span class="token add" data-title="if_statement/block_statement">{
            <span class="marker" id="mapping-1455"></span><span class="token add" data-title="block_statement/expression_statement"><span class="marker" id="mapping-1456"></span><span class="token add" data-title="expression_statement/assignment_expression">areValidRecentOperators = <span class="marker" id="mapping-1457"></span><span class="token mv" id="move-dst-354" data-title="assignment_expression/call_expression">_areValidRecentOperators(signers)</span></span>;</span>
        }</span></span></span>

        for (uint256 i; i &lt; commandsLength; i++) {
            bytes32 commandId = commandIds[i];

            if (isCommandExecuted(commandId)) continue; /* Ignore if duplicate commandId received */

            bytes4 commandSelector;
            bytes32 commandHash = keccak256(abi.encodePacked(commands[i]));

            if (commandHash == SELECTOR_DEPLOY_TOKEN) {
                if (!areValidRecentOwners) continue;

                commandSelector = AxelarGatewayMultisig.deployToken.selector;
            } else <span class="marker" id="mapping-1458"></span><span class="token add" data-title="if_statement/if_statement">if (<span class="marker" id="mapping-1459"></span><span class="token mv" id="move-dst-356" data-title="if_statement/binary_expression">commandHash == SELECTOR_MINT_TOKEN</span>) <span class="marker" id="mapping-1460"></span><span class="token mv" id="move-dst-357" data-title="if_statement/block_statement">{
                if (!areValidRecentOperators &amp;&amp; !areValidRecentOwners) continue;

                commandSelector = AxelarGatewayMultisig.mintToken.selector;
            }</span> else <span class="marker" id="mapping-1461"></span><span class="token add" data-title="if_statement/if_statement">if (<span class="marker" id="mapping-1462"></span><span class="token add" data-title="if_statement/binary_expression">commandHash == SELECTOR_APPROVE_CONTRACT_CALL</span>) <span class="marker" id="mapping-1463"></span><span class="token add" data-title="if_statement/block_statement">{
                if (!areValidRecentOperators &amp;&amp; !areValidRecentOwners) continue;

                commandSelector = AxelarGatewayMultisig.approveContractCall.selector;
            }</span> else <span class="marker" id="mapping-1464"></span><span class="token mv" id="move-dst-355" data-title="if_statement/if_statement">if (<span class="marker" id="mapping-1465"></span><span class="token add" data-title="if_statement/binary_expression">commandHash == SELECTOR_APPROVE_CONTRACT_CALL_WITH_MINT</span>) <span class="marker" id="mapping-1466"></span><span class="token add" data-title="if_statement/block_statement">{
                if (!areValidRecentOperators &amp;&amp; !areValidRecentOwners) continue;

                commandSelector = AxelarGatewayMultisig.approveContractCallWithMint.selector;
            }</span> else if (commandHash == SELECTOR_BURN_TOKEN) {
                if (!areValidRecentOperators &amp;&amp; !areValidRecentOwners) continue;

                commandSelector = AxelarGatewayMultisig.burnToken.selector;
            } else if (commandHash == SELECTOR_TRANSFER_OWNERSHIP) {
                if (!areValidCurrentOwners) continue;

                commandSelector = AxelarGatewayMultisig.transferOwnership.selector;
            } else if (commandHash == SELECTOR_TRANSFER_OPERATORSHIP) {
                if (!areValidCurrentOwners) continue;

                commandSelector = AxelarGatewayMultisig.transferOperatorship.selector;
            } else {
                continue; /* Ignore if unknown command received */
            }</span></span></span>

            // Prevent a re-entrancy from executing this command before it can be marked as successful.
            _setCommandExecuted(commandId, true);
            (bool success, ) = address(this).call(abi.encodeWithSelector(commandSelector, params[i]<span class="marker" id="mapping-1467"></span><span class="token add" data-title="call_expression/,">,</span> <span class="marker" id="mapping-1468"></span><span class="token add" data-title="call_expression/call_argument">commandId</span>));
            _setCommandExecuted(commandId, success);

            if (success) {
                emit Executed(commandId);
            }
        }
    }
}</pre></div></div></div></body></html>