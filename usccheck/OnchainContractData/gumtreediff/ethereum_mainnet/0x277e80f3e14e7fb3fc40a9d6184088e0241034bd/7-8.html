<html lang="en"><head><meta charset="utf8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>GumTree</title><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css"><style type="text/css">/*
 * This file is part of GumTree.
 *
 * GumTree is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * GumTree is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with GumTree.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Copyright 2011-2015 Jean-Rémy Falleri <jr.falleri@gmail.com>
 * Copyright 2011-2015 Floréal Morandat <florealm@gmail.com>
 */

.add {
	border: 1px solid black;
	background-color: MediumSeaGreen;
}

.del {
	border: 1px solid black;
	background-color: IndianRed;
}

.mv {
	border: 1px solid black;
	background-color: Plum;
}

.upd {
	border: 1px solid black;
	background-color: DarkOrange;
	font-weight: bold;
}

.cupd {
	font-weight: normal;
	color: DimGray;
}

.selected {
	background-color: Gold;
}

.marker {
	margin: 0;
	padding: 0;
}

div {
	margin: 0px;
	padding: 0px;
}

.pre-scrollable {
	margin: 0px;
	padding: 0px;
	font-size: 10pt;
	color: black;
	max-height: 90vh;
	background-color: white;
	border: 1px solid black;
	font-family: "Hack, Inconsolata", "Consolas", "Liberation Sans Regular", "DejaVu Sans Mono", monospace;
}

.tooltip-inner {
    max-width: none;
}
</style><script type="text/javascript" src="https://code.jquery.com/jquery-3.4.1.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/js/bootstrap.bundle.min.js"></script><script type="text/javascript">/*
 * This file is part of GumTree.
 *
 * GumTree is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * GumTree is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with GumTree.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Copyright 2011-2015 Jean-Rémy Falleri <jr.falleri@gmail.com>
 * Copyright 2011-2015 Floréal Morandat <florealm@gmail.com>
 */

$(function(){
    let popoverTriggerList = [].slice.call(document.querySelectorAll('[data-bs-toggle="popover"]'))
    let popoverList = popoverTriggerList.map(function (popoverTriggerEl) {
      return new bootstrap.Popover(popoverTriggerEl)
    })

    $("body").keypress(function (event) {
        switch (event.which) {
            case 116:
                $('html, body').animate({scrollTop: 0}, 100);
                break;
            case 98:
                $("html, body").animate({ scrollTop: $(document).height() }, 100);
                break;
            case 113:
                window.location = "/quit";
                break;
            case 108:
                window.location = "/list";
                break;
        }
    });
});
</script><script type="text/javascript">/*
 * This file is part of GumTree.
 *
 * GumTree is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * GumTree is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with GumTree.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Copyright 2011-2015 Jean-Rémy Falleri <jr.falleri@gmail.com>
 * Copyright 2011-2015 Floréal Morandat <florealm@gmail.com>
 */

currentMapping = 0;

if (typeof String.prototype.startsWith != 'function') {
  String.prototype.startsWith = function (str){
    return this.slice(0, str.length) == str;
  };
}

function getMappedElement(eltId) {
	if (eltId.startsWith("move-src")) {
		return eltId.replace("src","dst");  	 	
  	}
  	else {
  		return eltId.replace("dst","src");
  	}
}

function nextMapping() {
	if (currentMapping == 0) {
		currentMapping = 1;
		return "#mapping-" + currentMapping.toString();
	} else {
		currentMapping++;
		
		if ($("#mapping-" + currentMapping.toString()).length > 0) {
			return "#mapping-" + currentMapping.toString();
		} else {
			currentMapping = 1;
			return "#mapping-" + currentMapping.toString();		
		}		
	}
}

function isSrc(eltId) {
	return eltId.startsWith("move-src");
}

$(function() {
    $("body").keypress(function (event) {
        switch(event.which) {
            case 110:
                const mapping = $(nextMapping());
                const pre = mapping.closest("pre");
                pre.animate({scrollTop: pre.scrollTop() + mapping.position().top - 200}, 100);
                break;
        }
    });

    // highlight
    $("span.mv.token, span.token.upd").click(function(event) {
        if ($(this).hasClass("selected")) {
            $("span.mv.token, span.token.upd").removeClass("selected");
        } else {
            $("span.mv.token, span.token.upd").removeClass("selected");
            const refElt = $("#" + getMappedElement($(this).attr("id")));
            $(this).addClass("selected");
            refElt.addClass("selected");
            const pre = refElt.closest("pre");
            console.log(pre);
            pre.animate({scrollTop: pre.scrollTop() + refElt.position().top - 200}, 100);
        }
        event.stopPropagation();
    });
    
    $("span.add.token, span.token.del").click(function(event) {
        $("span.mv.token, span.token.upd").removeClass("selected");
        event.stopPropagation();
    });

    // tooltip
    $("span.token").hover(
    	function (event) {
    		$(this).tooltip('show');
    		event.stopPropagation();
    	},
    	function (event) {
    		$(this).tooltip('hide');
    		event.stopPropagation();
    	}
    );
});
</script></head><body><div class="container-fluid"><div class="row"><div class="col"><div class="btn-toolbar justify-content-end"><div class="btn-group mr-2"><button class="btn btn-primary btn-sm" id="legend" data-bs-toggle="popover" data-bs-placement="bottom" data-bs-html="true" data-bs-content="<span class='del'>&nbsp;&nbsp;</span> deleted<br><span class='add'>&nbsp;&nbsp;</span> added<br><span class='mv'>&nbsp;&nbsp;</span> moved<br><span class='upd';>&nbsp;&nbsp;</span> updated<br>">Legend</button><button class="btn btn-primary btn-sm" id="shortcuts" data-bs-toggle="popover" data-bs-placement="bottom" data-bs-html="true" data-bs-content="<b>q</b> quit<br><b>l</b> list<br><b>n</b> next<br><b>t</b> top<br><b>b</b> bottom">Shortcuts</button></div><div class="btn-group"><a href="/list" class="btn btn-default btn-sm btn-primary">Back</a><a href="/quit" class="btn btn-default btn-sm btn-danger">Quit</a></div></div></div></div><div class="row"><div class="col-6"><h5>0x553845f9c44c43224620055eca64c6cc79f5ddfd.etherscan.io-VaultCore.sol</h5><pre class="pre-scrollable"><span class="marker" id="mapping-1"></span><span class="token upd" id="move-src-1" data-title="source_file/comment"><span class="cupd">/*
 * Origin Protocol
 * https://originprotocol.com
 *
 * Released under the MIT license
 * https://github.com/OriginPro</span><span class="cupd">tocol
 *
 * Copyr</span>ig<span class="cupd">ht 2019 Origin Protocol, Inc
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of t</span>h<span class="cupd">e Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS</span> IN THE
 * SOFTWARE.
 */</span>

// File: @openzeppelin/contracts/token/ERC20/IERC20.sol

pragma solidity ^0.5.0;

/**
 * @dev Interface of the ERC20 standard as defined in the EIP. Does not include
 * the optional functions; to access them see {ERC20Detailed}.
 */
interface IERC20 {
    /**
     * @dev Returns the amount of tokens in existence.
     */
    function totalSupply() external view returns (uint256);

    /**
     * @dev Returns the amount of tokens owned by `account`.
     */
    function balanceOf(address account) external view returns (uint256);

    /**
     * @dev Moves `amount` tokens from the caller's account to `recipient`.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * Emits a {Transfer} event.
     */
    function transfer(address recipient, uint256 amount) external returns (bool);

    /**
     * @dev Returns the remaining number of tokens that `spender` will be
     * allowed to spend on behalf of `owner` through {transferFrom}. This is
     * zero by default.
     *
     * This value changes when {approve} or {transferFrom} are called.
     */
    function allowance(address owner, address spender) external view returns (uint256);

    /**
     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * IMPORTANT: Beware that changing an allowance with this method brings the risk
     * that someone may use both the old and the new allowance by unfortunate
     * transaction ordering. One possible solution to mitigate this race
     * condition is to first reduce the spender's allowance to 0 and set the
     * desired value afterwards:
     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
     *
     * Emits an {Approval} event.
     */
    function approve(address spender, uint256 amount) external returns (bool);

    /**
     * @dev Moves `amount` tokens from `sender` to `recipient` using the
     * allowance mechanism. `amount` is then deducted from the caller's
     * allowance.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * Emits a {Transfer} event.
     */
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);

    /**
     * @dev Emitted when `value` tokens are moved from one account (`from`) to
     * another (`to`).
     *
     * Note that `value` may be zero.
     */
    event Transfer(address indexed from, address indexed to, uint256 value);

    /**
     * @dev Emitted when the allowance of a `spender` for an `owner` is set by
     * a call to {approve}. `value` is the new allowance.
     */
    event Approval(address indexed owner, address indexed spender, uint256 value);
}

// File: @openzeppelin/contracts/math/SafeMath.sol

pragma solidity ^0.5.0;

/**
 * @dev Wrappers over Solidity's arithmetic operations with added overflow
 * checks.
 *
 * Arithmetic operations in Solidity wrap on overflow. This can easily result
 * in bugs, because programmers usually assume that an overflow raises an
 * error, which is the standard behavior in high level programming languages.
 * `SafeMath` restores this intuition by reverting the transaction when an
 * operation overflows.
 *
 * Using this library instead of the unchecked operations eliminates an entire
 * class of bugs, so it's recommended to use it always.
 */
library SafeMath {
    /**
     * @dev Returns the addition of two unsigned integers, reverting on
     * overflow.
     *
     * Counterpart to Solidity's `+` operator.
     *
     * Requirements:
     * - Addition cannot overflow.
     */
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c &gt;= a, "SafeMath: addition overflow");

        return c;
    }

    /**
     * @dev Returns the subtraction of two unsigned integers, reverting on
     * overflow (when the result is negative).
     *
     * Counterpart to Solidity's `-` operator.
     *
     * Requirements:
     * - Subtraction cannot overflow.
     */
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        return sub(a, b, "SafeMath: subtraction overflow");
    }

    /**
     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on
     * overflow (when the result is negative).
     *
     * Counterpart to Solidity's `-` operator.
     *
     * Requirements:
     * - Subtraction cannot overflow.
     *
     * _Available since v2.4.0._
     */
    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
        require(b &lt;= a, errorMessage);
        uint256 c = a - b;

        return c;
    }

    /**
     * @dev Returns the multiplication of two unsigned integers, reverting on
     * overflow.
     *
     * Counterpart to Solidity's `*` operator.
     *
     * Requirements:
     * - Multiplication cannot overflow.
     */
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the
        // benefit is lost if 'b' is also tested.
        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522
        if (a == 0) {
            return 0;
        }

        uint256 c = a * b;
        require(c / a == b, "SafeMath: multiplication overflow");

        return c;
    }

    /**
     * @dev Returns the integer division of two unsigned integers. Reverts on
     * division by zero. The result is rounded towards zero.
     *
     * Counterpart to Solidity's `/` operator. Note: this function uses a
     * `revert` opcode (which leaves remaining gas untouched) while Solidity
     * uses an invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     * - The divisor cannot be zero.
     */
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        return div(a, b, "SafeMath: division by zero");
    }

    /**
     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on
     * division by zero. The result is rounded towards zero.
     *
     * Counterpart to Solidity's `/` operator. Note: this function uses a
     * `revert` opcode (which leaves remaining gas untouched) while Solidity
     * uses an invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     * - The divisor cannot be zero.
     *
     * _Available since v2.4.0._
     */
    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
        // Solidity only automatically asserts when dividing by 0
        require(b &gt; 0, errorMessage);
        uint256 c = a / b;
        // assert(a == b * c + a % b); // There is no case in which this doesn't hold

        return c;
    }

    /**
     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),
     * Reverts when dividing by zero.
     *
     * Counterpart to Solidity's `%` operator. This function uses a `revert`
     * opcode (which leaves remaining gas untouched) while Solidity uses an
     * invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     * - The divisor cannot be zero.
     */
    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
        return mod(a, b, "SafeMath: modulo by zero");
    }

    /**
     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),
     * Reverts with custom message when dividing by zero.
     *
     * Counterpart to Solidity's `%` operator. This function uses a `revert`
     * opcode (which leaves remaining gas untouched) while Solidity uses an
     * invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     * - The divisor cannot be zero.
     *
     * _Available since v2.4.0._
     */
    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
        require(b != 0, errorMessage);
        return a % b;
    }
}

// File: @openzeppelin/contracts/utils/Address.sol

pragma solidity ^0.5.5;

/**
 * @dev Collection of functions related to the address type
 */
library Address {
    /**
     * @dev Returns true if `account` is a contract.
     *
     * [IMPORTANT]
     * ====
     * It is unsafe to assume that an address for which this function returns
     * false is an externally-owned account (EOA) and not a contract.
     *
     * Among others, `isContract` will return false for the following 
     * types of addresses:
     *
     *  - an externally-owned account
     *  - a contract in construction
     *  - an address where a contract will be created
     *  - an address where a contract lived, but was destroyed
     * ====
     */
    function isContract(address account) internal view returns (bool) {
        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts
        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned
        // for accounts without code, i.e. `keccak256('')`
        bytes32 codehash;
        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;
        // solhint-disable-next-line no-inline-assembly
        assembly { codehash := extcodehash(account) }
        return (codehash != accountHash &amp;&amp; codehash != 0x0);
    }

    /**
     * @dev Converts an `address` into `address payable`. Note that this is
     * simply a type cast: the actual underlying value is not changed.
     *
     * _Available since v2.4.0._
     */
    function toPayable(address account) internal pure returns (address payable) {
        return address(uint160(account));
    }

    /**
     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to
     * `recipient`, forwarding all available gas and reverting on errors.
     *
     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost
     * of certain opcodes, possibly making contracts go over the 2300 gas limit
     * imposed by `transfer`, making them unable to receive funds via
     * `transfer`. {sendValue} removes this limitation.
     *
     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].
     *
     * IMPORTANT: because control is transferred to `recipient`, care must be
     * taken to not create reentrancy vulnerabilities. Consider using
     * {ReentrancyGuard} or the
     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].
     *
     * _Available since v2.4.0._
     */
    function sendValue(address payable recipient, uint256 amount) internal {
        require(address(this).balance &gt;= amount, "Address: insufficient balance");

        // solhint-disable-next-line avoid-call-value
        (bool success, ) = recipient.call.value(amount)("");
        require(success, "Address: unable to send value, recipient may have reverted");
    }
}

// File: @openzeppelin/contracts/token/ERC20/SafeERC20.sol

pragma solidity ^0.5.0;




/**
 * @title SafeERC20
 * @dev Wrappers around ERC20 operations that throw on failure (when the token
 * contract returns false). Tokens that return no value (and instead revert or
 * throw on failure) are also supported, non-reverting calls are assumed to be
 * successful.
 * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract,
 * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.
 */
library SafeERC20 {
    using SafeMath for uint256;
    using Address for address;

    function safeTransfer(IERC20 token, address to, uint256 value) internal {
        callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));
    }

    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {
        callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));
    }

    function safeApprove(IERC20 token, address spender, uint256 value) internal {
        // safeApprove should only be called when setting an initial allowance,
        // or when resetting it to zero. To increase and decrease it, use
        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'
        // solhint-disable-next-line max-line-length
        require((value == 0) || (token.allowance(address(this), spender) == 0),
            "SafeERC20: approve from non-zero to non-zero allowance"
        );
        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));
    }

    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {
        uint256 newAllowance = token.allowance(address(this), spender).add(value);
        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));
    }

    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {
        uint256 newAllowance = token.allowance(address(this), spender).sub(value, "SafeERC20: decreased allowance below zero");
        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));
    }

    /**
     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement
     * on the return value: the return value is optional (but if data is returned, it must not be false).
     * @param token The token targeted by the call.
     * @param data The call data (encoded using abi.encode or one of its variants).
     */
    function callOptionalReturn(IERC20 token, bytes memory data) private {
        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since
        // we're implementing it ourselves.

        // A Solidity high level call has three parts:
        //  1. The target address is checked to verify it contains contract code
        //  2. The call itself is made, and success asserted
        //  3. The return value is decoded, which in turn checks the size of the returned data.
        // solhint-disable-next-line max-line-length
        require(address(token).isContract(), "SafeERC20: call to non-contract");

        // solhint-disable-next-line avoid-low-level-calls
        (bool success, bytes memory returndata) = address(token).call(data);
        require(success, "SafeERC20: low-level call failed");

        if (returndata.length &gt; 0) { // Return data is optional
            // solhint-disable-next-line max-line-length
            require(abi.decode(returndata, (bool)), "SafeERC20: ERC20 operation did not succeed");
        }
    }
}

// File: @openzeppelin/upgrades/contracts/Initializable.sol

pragma solidity &gt;=0.4.24 &lt;0.7.0;


/**
 * @title Initializable
 *
 * @dev Helper contract to support initializer functions. To use it, replace
 * the constructor with a function that has the `initializer` modifier.
 * WARNING: Unlike constructors, initializer functions must be manually
 * invoked. This applies both to deploying an Initializable contract, as well
 * as extending an Initializable contract via inheritance.
 * WARNING: When used with inheritance, manual care must be taken to not invoke
 * a parent initializer twice, or ensure that all initializers are idempotent,
 * because this is not dealt with automatically as with constructors.
 */
contract Initializable {

  /**
   * @dev Indicates that the contract has been initialized.
   */
  bool private initialized;

  /**
   * @dev Indicates that the contract is in the process of being initialized.
   */
  bool private initializing;

  /**
   * @dev Modifier to use in the initializer function of a contract.
   */
  modifier initializer() {
    require(initializing || isConstructor() || !initialized, "Contract instance has already been initialized");

    bool isTopLevelCall = !initializing;
    if (isTopLevelCall) {
      initializing = true;
      initialized = true;
    }

    _;

    if (isTopLevelCall) {
      initializing = false;
    }
  }

  /// @dev Returns true if and only if the function is running in the constructor
  function isConstructor() private view returns (bool) {
    // extcodesize checks the size of the code stored in an address, and
    // address returns the current address. Since the code is still not
    // deployed when running a constructor, any checks on its code size will
    // yield zero, making it an effective way to detect if a contract is
    // under construction or not.
    address self = address(this);
    uint256 cs;
    assembly { cs := extcodesize(self) }
    return cs == 0;
  }

  // Reserved storage space to allow for layout changes in the future.
  uint256[50] private ______gap;
}

// File: contracts/interfaces/IStrategy.sol

pragma solidity 0.5.11;

/**
 * @title Platform interface to integrate with lending platform like Compound, AAVE etc.
 */
interface IStrategy {
    /**
     * @dev Deposit the given asset to Lending platform.
     * @param _asset asset address
     * @param _amount Amount to deposit
     */
    function deposit(address _asset, uint256 _amount)
        external
        returns (uint256 amountDeposited);

    /**
     * @dev Withdraw given asset from Lending platform
     */
    function withdraw(
        address _recipient,
        address _asset,
        uint256 _amount
    ) external returns (uint256 amountWithdrawn);

    /**
     * @dev Returns the current balance of the given asset.
     */
    function checkBalance(address _asset)
        external
        view
        returns (uint256 balance);

    /**
     * @dev Returns bool indicating whether strategy supports asset.
     */
    function supportsAsset(address _asset) external view returns (bool);

    /**
     * @dev Liquidate all assets in strategy and return them to Vault.
     */
    function liquidate() external;

    <span class="marker" id="mapping-2"></span><span class="token del" data-title="contract_body/comment">/**
     * @dev Get the APR for the Strategy.
     */</span>
    <span class="marker" id="mapping-3"></span><span class="token del" data-title="contract_body/function_definition">function getAPR() <span class="marker" id="mapping-4"></span><span class="token del" data-title="function_definition/visibility">external</span> <span class="marker" id="mapping-5"></span><span class="token mv" id="move-src-2" data-title="function_definition/state_mutability">view</span> <span class="marker" id="mapping-6"></span><span class="token del" data-title="function_definition/return_type_definition">returns (uint256)</span>;</span>

    /**
     * @dev Collect reward tokens from the Strategy.
     */
    function collectRewardToken() external;

    function rewardTokenAddress() external pure returns (address);
}

// File: contracts/governance/Governable.sol

pragma solidity 0.5.11;

/**
 * @title OUSD Governable Contract
 * @dev Copy of the openzeppelin Ownable.sol contract with nomenclature change
 *      from owner to governor and renounce methods removed. Does not use
 *      Context.sol like Ownable.sol does for simplification.
 * @author Origin Protocol Inc
 */
contract Governable {
    // Storage position of the owner and pendingOwner of the contract
    bytes32
        private constant governorPosition = 0x7bea13895fa79d2831e0a9e28edede30099005a50d652d8957cf8a607ee6ca4a;
    //keccak256("OUSD.governor");

    bytes32
        private constant pendingGovernorPosition = 0x44c4d30b2eaad5130ad70c3ba6972730566f3e6359ab83e800d905c61b1c51db;
    //keccak256("OUSD.pending.governor");

    event PendingGovernorshipTransfer(
        address indexed previousGovernor,
        address indexed newGovernor
    );

    event GovernorshipTransferred(
        address indexed previousGovernor,
        address indexed newGovernor
    );

    /**
     * @dev Initializes the contract setting the deployer as the initial Governor.
     */
    constructor() internal {
        _setGovernor(msg.sender);
        emit GovernorshipTransferred(address(0), _governor());
    }

    /**
     * @dev Returns the address of the current Governor.
     */
    function governor() public view returns (address) {
        return _governor();
    }

    function _governor() internal view returns (address governorOut) {
        bytes32 position = governorPosition;
        assembly {
            governorOut := sload(position)
        }
    }

    function _pendingGovernor()
        internal
        view
        returns (address pendingGovernor)
    {
        bytes32 position = pendingGovernorPosition;
        assembly {
            pendingGovernor := sload(position)
        }
    }

    /**
     * @dev Throws if called by any account other than the Governor.
     */
    modifier onlyGovernor() {
        require(isGovernor(), "Caller is not the Governor");
        _;
    }

    /**
     * @dev Returns true if the caller is the current Governor.
     */
    function isGovernor() public view returns (bool) {
        return msg.sender == _governor();
    }

    function _setGovernor(address newGovernor) internal {
        bytes32 position = governorPosition;
        assembly {
            sstore(position, newGovernor)
        }
    }

    function _setPendingGovernor(address newGovernor) internal {
        bytes32 position = pendingGovernorPosition;
        assembly {
            sstore(position, newGovernor)
        }
    }

    /**
     * @dev Transfers Governance of the contract to a new account (`newGovernor`).
     * Can only be called by the current Governor. Must be claimed for this to complete
     * @param _newGovernor Address of the new Governor
     */
    function transferGovernance(address _newGovernor) external onlyGovernor {
        _setPendingGovernor(_newGovernor);
        emit PendingGovernorshipTransfer(_governor(), _newGovernor);
    }

    /**
     * @dev Claim Governance of the contract to a new account (`newGovernor`).
     * Can only be called by the new Governor.
     */
    function claimGovernance() external {
        require(
            msg.sender == _pendingGovernor(),
            "Only the pending Governor can complete the claim"
        );
        _changeGovernor(msg.sender);
    }

    /**
     * @dev Change Governance of the contract to a new account (`newGovernor`).
     * @param _newGovernor Address of the new Governor
     */
    function _changeGovernor(address _newGovernor) internal {
        require(_newGovernor != address(0), "New Governor is address(0)");
        emit GovernorshipTransferred(_governor(), _newGovernor);
        _setGovernor(_newGovernor);
    }
}

// File: @openzeppelin/contracts/GSN/Context.sol

pragma solidity ^0.5.0;

/*
 * @dev Provides information about the current execution context, including the
 * sender of the transaction and its data. While these are generally available
 * via msg.sender and msg.data, they should not be accessed in such a direct
 * manner, since when dealing with GSN meta-transactions the account sending and
 * paying for execution may not be the actual sender (as far as an application
 * is concerned).
 *
 * This contract is only required for intermediate, library-like contracts.
 */
contract Context {
    // Empty internal constructor, to prevent people from mistakenly deploying
    // an instance of this contract, which should be used via inheritance.
    constructor () internal { }
    // solhint-disable-previous-line no-empty-blocks

    function _msgSender() internal view returns (address payable) {
        return msg.sender;
    }

    function _msgData() internal view returns (bytes memory) {
        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691
        return msg.data;
    }
}

// File: @openzeppelin/contracts/token/ERC20/ERC20.sol

pragma solidity ^0.5.0;




/**
 * @dev Implementation of the {IERC20} interface.
 *
 * This implementation is agnostic to the way tokens are created. This means
 * that a supply mechanism has to be added in a derived contract using {_mint}.
 * For a generic mechanism see {ERC20Mintable}.
 *
 * TIP: For a detailed writeup see our guide
 * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How
 * to implement supply mechanisms].
 *
 * We have followed general OpenZeppelin guidelines: functions revert instead
 * of returning `false` on failure. This behavior is nonetheless conventional
 * and does not conflict with the expectations of ERC20 applications.
 *
 * Additionally, an {Approval} event is emitted on calls to {transferFrom}.
 * This allows applications to reconstruct the allowance for all accounts just
 * by listening to said events. Other implementations of the EIP may not emit
 * these events, as it isn't required by the specification.
 *
 * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}
 * functions have been added to mitigate the well-known issues around setting
 * allowances. See {IERC20-approve}.
 */
contract ERC20 is Context, IERC20 {
    using SafeMath for uint256;

    mapping (address =&gt; uint256) private _balances;

    mapping (address =&gt; mapping (address =&gt; uint256)) private _allowances;

    uint256 private _totalSupply;

    /**
     * @dev See {IERC20-totalSupply}.
     */
    function totalSupply() public view returns (uint256) {
        return _totalSupply;
    }

    /**
     * @dev See {IERC20-balanceOf}.
     */
    function balanceOf(address account) public view returns (uint256) {
        return _balances[account];
    }

    /**
     * @dev See {IERC20-transfer}.
     *
     * Requirements:
     *
     * - `recipient` cannot be the zero address.
     * - the caller must have a balance of at least `amount`.
     */
    function transfer(address recipient, uint256 amount) public returns (bool) {
        _transfer(_msgSender(), recipient, amount);
        return true;
    }

    /**
     * @dev See {IERC20-allowance}.
     */
    function allowance(address owner, address spender) public view returns (uint256) {
        return _allowances[owner][spender];
    }

    /**
     * @dev See {IERC20-approve}.
     *
     * Requirements:
     *
     * - `spender` cannot be the zero address.
     */
    function approve(address spender, uint256 amount) public returns (bool) {
        _approve(_msgSender(), spender, amount);
        return true;
    }

    /**
     * @dev See {IERC20-transferFrom}.
     *
     * Emits an {Approval} event indicating the updated allowance. This is not
     * required by the EIP. See the note at the beginning of {ERC20};
     *
     * Requirements:
     * - `sender` and `recipient` cannot be the zero address.
     * - `sender` must have a balance of at least `amount`.
     * - the caller must have allowance for `sender`'s tokens of at least
     * `amount`.
     */
    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {
        _transfer(sender, recipient, amount);
        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, "ERC20: transfer amount exceeds allowance"));
        return true;
    }

    /**
     * @dev Atomically increases the allowance granted to `spender` by the caller.
     *
     * This is an alternative to {approve} that can be used as a mitigation for
     * problems described in {IERC20-approve}.
     *
     * Emits an {Approval} event indicating the updated allowance.
     *
     * Requirements:
     *
     * - `spender` cannot be the zero address.
     */
    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {
        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));
        return true;
    }

    /**
     * @dev Atomically decreases the allowance granted to `spender` by the caller.
     *
     * This is an alternative to {approve} that can be used as a mitigation for
     * problems described in {IERC20-approve}.
     *
     * Emits an {Approval} event indicating the updated allowance.
     *
     * Requirements:
     *
     * - `spender` cannot be the zero address.
     * - `spender` must have allowance for the caller of at least
     * `subtractedValue`.
     */
    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {
        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, "ERC20: decreased allowance below zero"));
        return true;
    }

    /**
     * @dev Moves tokens `amount` from `sender` to `recipient`.
     *
     * This is internal function is equivalent to {transfer}, and can be used to
     * e.g. implement automatic token fees, slashing mechanisms, etc.
     *
     * Emits a {Transfer} event.
     *
     * Requirements:
     *
     * - `sender` cannot be the zero address.
     * - `recipient` cannot be the zero address.
     * - `sender` must have a balance of at least `amount`.
     */
    function _transfer(address sender, address recipient, uint256 amount) internal {
        require(sender != address(0), "ERC20: transfer from the zero address");
        require(recipient != address(0), "ERC20: transfer to the zero address");

        _balances[sender] = _balances[sender].sub(amount, "ERC20: transfer amount exceeds balance");
        _balances[recipient] = _balances[recipient].add(amount);
        emit Transfer(sender, recipient, amount);
    }

    /** @dev Creates `amount` tokens and assigns them to `account`, increasing
     * the total supply.
     *
     * Emits a {Transfer} event with `from` set to the zero address.
     *
     * Requirements
     *
     * - `to` cannot be the zero address.
     */
    function _mint(address account, uint256 amount) internal {
        require(account != address(0), "ERC20: mint to the zero address");

        _totalSupply = _totalSupply.add(amount);
        _balances[account] = _balances[account].add(amount);
        emit Transfer(address(0), account, amount);
    }

    /**
     * @dev Destroys `amount` tokens from `account`, reducing the
     * total supply.
     *
     * Emits a {Transfer} event with `to` set to the zero address.
     *
     * Requirements
     *
     * - `account` cannot be the zero address.
     * - `account` must have at least `amount` tokens.
     */
    function _burn(address account, uint256 amount) internal {
        require(account != address(0), "ERC20: burn from the zero address");

        _balances[account] = _balances[account].sub(amount, "ERC20: burn amount exceeds balance");
        _totalSupply = _totalSupply.sub(amount);
        emit Transfer(account, address(0), amount);
    }

    /**
     * @dev Sets `amount` as the allowance of `spender` over the `owner`s tokens.
     *
     * This is internal function is equivalent to `approve`, and can be used to
     * e.g. set automatic allowances for certain subsystems, etc.
     *
     * Emits an {Approval} event.
     *
     * Requirements:
     *
     * - `owner` cannot be the zero address.
     * - `spender` cannot be the zero address.
     */
    function _approve(address owner, address spender, uint256 amount) internal {
        require(owner != address(0), "ERC20: approve from the zero address");
        require(spender != address(0), "ERC20: approve to the zero address");

        _allowances[owner][spender] = amount;
        emit Approval(owner, spender, amount);
    }

    /**
     * @dev Destroys `amount` tokens from `account`.`amount` is then deducted
     * from the caller's allowance.
     *
     * See {_burn} and {_approve}.
     */
    function _burnFrom(address account, uint256 amount) internal {
        _burn(account, amount);
        _approve(account, _msgSender(), _allowances[account][_msgSender()].sub(amount, "ERC20: burn amount exceeds allowance"));
    }
}

// File: contracts/utils/InitializableERC20Detailed.sol

pragma solidity 0.5.11;


/**
 * @dev Optional functions from the ERC20 standard.
 * Converted from openzeppelin/contracts/token/ERC20/ERC20Detailed.sol
 */
contract InitializableERC20Detailed is IERC20 {
    string private _name;
    string private _symbol;
    uint8 private _decimals;

    /**
     * @dev Sets the values for `name`, `symbol`, and `decimals`. All three of
     * these values are immutable: they can only be set once during
     * construction.
     * @notice To avoid variable shadowing appended `Arg` after arguments name.
     */
    function _initialize(
        string memory nameArg,
        string memory symbolArg,
        uint8 decimalsArg
    ) internal {
        _name = nameArg;
        _symbol = symbolArg;
        _decimals = decimalsArg;
    }

    /**
     * @dev Returns the name of the token.
     */
    function name() public view returns (string memory) {
        return _name;
    }

    /**
     * @dev Returns the symbol of the token, usually a shorter version of the
     * name.
     */
    function symbol() public view returns (string memory) {
        return _symbol;
    }

    /**
     * @dev Returns the number of decimals used to get its user representation.
     * For example, if `decimals` equals `2`, a balance of `505` tokens should
     * be displayed to a user as `5,05` (`505 / 10 ** 2`).
     *
     * Tokens usually opt for a value of 18, imitating the relationship between
     * Ether and Wei.
     *
     * NOTE: This information is only used for _display_ purposes: it in
     * no way affects any of the arithmetic of the contract, including
     * {IERC20-balanceOf} and {IERC20-transfer}.
     */
    function decimals() public view returns (uint8) {
        return _decimals;
    }
}

// File: contracts/utils/InitializableToken.sol

pragma solidity 0.5.11;



contract InitializableToken is ERC20, InitializableERC20Detailed {
    /**
     * @dev Initialization function for implementing contract
     * @notice To avoid variable shadowing appended `Arg` after arguments name.
     */
    function _initialize(string memory _nameArg, string memory _symbolArg)
        internal
    {
        InitializableERC20Detailed._initialize(_nameArg, _symbolArg, 18);
    }
}

// File: contracts/utils/StableMath.sol

pragma solidity 0.5.11;


// Based on StableMath from Stability Labs Pty. Ltd.
// https://github.com/mstable/mStable-contracts/blob/master/contracts/shared/StableMath.sol

library StableMath {
    using SafeMath for uint256;

    /**
     * @dev Scaling unit for use in specific calculations,
     * where 1 * 10**18, or 1e18 represents a unit '1'
     */
    uint256 private constant FULL_SCALE = 1e18;

    /***************************************
                    Helpers
    ****************************************/

    /**
     * @dev Adjust the scale of an integer
     * @param adjustment Amount to adjust by e.g. scaleBy(1e18, -1) == 1e17
     */
    function scaleBy(uint256 x, int8 adjustment)
        internal
        pure
        returns (uint256)
    {
        if (adjustment &gt; 0) {
            x = x.mul(10**uint256(adjustment));
        } else if (adjustment &lt; 0) {
            x = x.div(10**uint256(adjustment * -1));
        }
        return x;
    }

    /***************************************
               Precise Arithmetic
    ****************************************/

    /**
     * @dev Multiplies two precise units, and then truncates by the full scale
     * @param x Left hand input to multiplication
     * @param y Right hand input to multiplication
     * @return Result after multiplying the two inputs and then dividing by the shared
     *         scale unit
     */
    function mulTruncate(uint256 x, uint256 y) internal pure returns (uint256) {
        return mulTruncateScale(x, y, FULL_SCALE);
    }

    /**
     * @dev Multiplies two precise units, and then truncates by the given scale. For example,
     * when calculating 90% of 10e18, (10e18 * 9e17) / 1e18 = (9e36) / 1e18 = 9e18
     * @param x Left hand input to multiplication
     * @param y Right hand input to multiplication
     * @param scale Scale unit
     * @return Result after multiplying the two inputs and then dividing by the shared
     *         scale unit
     */
    function mulTruncateScale(
        uint256 x,
        uint256 y,
        uint256 scale
    ) internal pure returns (uint256) {
        // e.g. assume scale = fullScale
        // z = 10e18 * 9e17 = 9e36
        uint256 z = x.mul(y);
        // return 9e38 / 1e18 = 9e18
        return z.div(scale);
    }

    /**
     * @dev Multiplies two precise units, and then truncates by the full scale, rounding up the result
     * @param x Left hand input to multiplication
     * @param y Right hand input to multiplication
     * @return Result after multiplying the two inputs and then dividing by the shared
     *          scale unit, rounded up to the closest base unit.
     */
    function mulTruncateCeil(uint256 x, uint256 y)
        internal
        pure
        returns (uint256)
    {
        // e.g. 8e17 * 17268172638 = 138145381104e17
        uint256 scaled = x.mul(y);
        // e.g. 138145381104e17 + 9.99...e17 = 138145381113.99...e17
        uint256 ceil = scaled.add(FULL_SCALE.sub(1));
        // e.g. 13814538111.399...e18 / 1e18 = 13814538111
        return ceil.div(FULL_SCALE);
    }

    /**
     * @dev Precisely divides two units, by first scaling the left hand operand. Useful
     *      for finding percentage weightings, i.e. 8e18/10e18 = 80% (or 8e17)
     * @param x Left hand input to division
     * @param y Right hand input to division
     * @return Result after multiplying the left operand by the scale, and
     *         executing the division on the right hand input.
     */
    function divPrecisely(uint256 x, uint256 y)
        internal
        pure
        returns (uint256)
    {
        // e.g. 8e18 * 1e18 = 8e36
        uint256 z = x.mul(FULL_SCALE);
        // e.g. 8e36 / 10e18 = 8e17
        return z.div(y);
    }
}

// File: contracts/token/OUSD.sol

pragma solidity 0.5.11;

/**
 * @title OUSD Token Contract
 * @notice ERC20 compatible contract for OUSD
 * @dev Implements an elastic supply
 * @author Origin Protocol Inc
 */



contract OUSD is Initializable, InitializableToken, Governable {
    using SafeMath for uint256;
    using StableMath for uint256;

    event TotalSupplyUpdated(
        uint256 totalSupply,
        uint256 totalCredits,
        uint256 creditsPerToken
    );

    uint256 private constant MAX_SUPPLY = ~uint128(0); // (2^128) - 1

    uint256 private _totalSupply;
    uint256 private totalCredits;
    // Exchange rate between internal credits and OUSD
    uint256 private creditsPerToken;

    mapping(address =&gt; uint256) private _creditBalances;

    // Allowances denominated in OUSD
    mapping(address =&gt; mapping(address =&gt; uint256)) private _allowances;

    address public vaultAddress = address(0);

    function initialize(
        string calldata _nameArg,
        string calldata _symbolArg,
        address _vaultAddress
    ) external onlyGovernor initializer {
        InitializableToken._initialize(_nameArg, _symbolArg);

        _totalSupply = 0;
        totalCredits = 0;
        creditsPerToken = 1e18;

        vaultAddress = _vaultAddress;
    }

    /**
     * @dev Verifies that the caller is the Savings Manager contract
     */
    modifier onlyVault() {
        require(vaultAddress == msg.sender, "Caller is not the Vault");
        _;
    }

    /**
     * @return The total supply of OUSD.
     */
    function totalSupply() public view returns (uint256) {
        return _totalSupply;
    }

    /**
     * @dev Gets the balance of the specified address.
     * @param _account The address to query the balance of.
     * @return A unit256 representing the _amount of base units owned by the
     *         specified address.
     */
    function balanceOf(address _account) public view returns (uint256) {
        if (creditsPerToken == 0) return 0;
        return _creditBalances[_account].divPrecisely(creditsPerToken);
    }

    /**
     * @dev Gets the credits balance of the specified address.
     * @param _account The address to query the balance of.
     * @return A uint256 representing the _amount of base units owned by the
     *         specified address.
     */
    function creditsBalanceOf(address _account) public view returns (uint256) {
        return _creditBalances[_account];
    }

    /**
     * @dev Transfer tokens to a specified address.
     * @param _to the address to transfer to.
     * @param _value the _amount to be transferred.
     * @return true on success.
     */
    function transfer(address _to, uint256 _value) public returns (bool) {
        uint256 creditValue = _removeCredits(msg.sender, _value);
        _creditBalances[_to] = _creditBalances[_to].add(creditValue);

        emit Transfer(msg.sender, _to, _value);

        return true;
    }

    /**
     * @dev Transfer tokens from one address to another.
     * @param _from The address you want to send tokens from.
     * @param _to The address you want to transfer to.
     * @param _value The _amount of tokens to be transferred.
     */
    function transferFrom(
        address _from,
        address _to,
        uint256 _value
    ) public returns (bool) {
        _allowances[_from][msg.sender] = _allowances[_from][msg.sender].sub(
            _value
        );

        uint256 creditValue = _removeCredits(_from, _value);
        _creditBalances[_to] = _creditBalances[_to].add(creditValue);

        emit Transfer(_from, _to, _value);

        return true;
    }

    /**
     * @dev Function to check the _amount of tokens that an owner has allowed to a _spender.
     * @param _owner The address which owns the funds.
     * @param _spender The address which will spend the funds.
     * @return The number of tokens still available for the _spender.
     */
    function allowance(address _owner, address _spender)
        public
        view
        returns (uint256)
    {
        return _allowances[_owner][_spender];
    }

    /**
     * @dev Approve the passed address to spend the specified _amount of tokens on behalf of
     * msg.sender. This method is included for ERC20 compatibility.
     * increaseAllowance and decreaseAllowance should be used instead.
     * Changing an allowance with this method brings the risk that someone may transfer both
     * the old and the new allowance - if they are both greater than zero - if a transfer
     * transaction is mined before the later approve() call is mined.
     *
     * @param _spender The address which will spend the funds.
     * @param _value The _amount of tokens to be spent.
     */
    function approve(address _spender, uint256 _value) public returns (bool) {
        _allowances[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value);
        return true;
    }

    /**
     * @dev Increase the _amount of tokens that an owner has allowed to a _spender.
     * This method should be used instead of approve() to avoid the double approval vulnerability
     * described above.
     * @param _spender The address which will spend the funds.
     * @param _addedValue The _amount of tokens to increase the allowance by.
     */
    function increaseAllowance(address _spender, uint256 _addedValue)
        public
        returns (bool)
    {
        _allowances[msg.sender][_spender] = _allowances[msg.sender][_spender]
            .add(_addedValue);
        emit Approval(msg.sender, _spender, _allowances[msg.sender][_spender]);
        return true;
    }

    /**
     * @dev Decrease the _amount of tokens that an owner has allowed to a _spender.
     * @param _spender The address which will spend the funds.
     * @param _subtractedValue The _amount of tokens to decrease the allowance by.
     */
    function decreaseAllowance(address _spender, uint256 _subtractedValue)
        public
        returns (bool)
    {
        uint256 oldValue = _allowances[msg.sender][_spender];
        if (_subtractedValue &gt;= oldValue) {
            _allowances[msg.sender][_spender] = 0;
        } else {
            _allowances[msg.sender][_spender] = oldValue.sub(_subtractedValue);
        }
        emit Approval(msg.sender, _spender, _allowances[msg.sender][_spender]);
        return true;
    }

    /**
     * @notice Mints new tokens, increasing totalSupply.
     */
    function mint(address _account, uint256 _amount) external onlyVault {
        return _mint(_account, _amount);
    }

    /**
     * @dev Creates `_amount` tokens and assigns them to `_account`, increasing
     * the total supply.
     *
     * Emits a {Transfer} event with `from` set to the zero address.
     *
     * Requirements
     *
     * - `to` cannot be the zero address.
     */
    function _mint(address _account, uint256 _amount) internal {
        require(_account != address(0), "Mint to the zero address");

        _totalSupply = _totalSupply.add(_amount);

        uint256 creditAmount = _amount.mulTruncate(creditsPerToken);
        _creditBalances[_account] = _creditBalances[_account].add(creditAmount);
        totalCredits = totalCredits.add(creditAmount);

        emit Transfer(address(0), _account, _amount);
    }

    /**
     * @notice Burns tokens, decreasing totalSupply.
     */
    function burn(address account, uint256 amount) external onlyVault {
        return _burn(account, amount);
    }

    /**
     * @dev Destroys `_amount` tokens from `_account`, reducing the
     * total supply.
     *
     * Emits a {Transfer} event with `to` set to the zero address.
     *
     * Requirements
     *
     * - `_account` cannot be the zero address.
     * - `_account` must have at least `_amount` tokens.
     */
    function _burn(address _account, uint256 _amount) internal {
        require(_account != address(0), "Burn from the zero address");

        _totalSupply = _totalSupply.sub(_amount);
        uint256 creditAmount = _removeCredits(_account, _amount);
        totalCredits = totalCredits.sub(creditAmount);

        emit Transfer(_account, address(0), _amount);
    }

    /**
     * @dev Removes credits from a credit balance and burns rounding errors.
     * @param _account Account to remove credits from
     * @param _amount Amount in OUSD which will be converted to credits and
     *                removed
     */
    function _removeCredits(address _account, uint256 _amount)
        internal
        returns (uint256 creditAmount)
    {
        creditAmount = _amount.mulTruncate(creditsPerToken);
        uint256 currentCredits = _creditBalances[_account];
        if (
            currentCredits == creditAmount || currentCredits - 1 == creditAmount
        ) {
            _creditBalances[_account] = 0;
        } else if (currentCredits &gt; creditAmount) {
            _creditBalances[_account] = currentCredits - creditAmount;
        } else {
            revert("Remove exceeds balance");
        }
    }

    /**
     * @dev Modify the supply without minting new tokens. This uses a change in
     *      the exchange rate between "credits" and OUSD tokens to change balances.
     * @param _newTotalSupply New total supply of OUSD.
     * @return uint256 representing the new total supply.
     */
    function changeSupply(uint256 _newTotalSupply)
        external
        onlyVault
        returns (uint256)
    {
        require(_totalSupply &gt; 0, "Cannot increase 0 supply");

        if (_totalSupply == _newTotalSupply) {
            emit TotalSupplyUpdated(
                _totalSupply,
                totalCredits,
                creditsPerToken
            );
            return _totalSupply;
        }

        _totalSupply = _newTotalSupply;

        if (_totalSupply &gt; MAX_SUPPLY) _totalSupply = MAX_SUPPLY;

        creditsPerToken = totalCredits.divPrecisely(_totalSupply);

        emit TotalSupplyUpdated(_totalSupply, totalCredits, creditsPerToken);
        return _totalSupply;
    }
}

// File: contracts/interfaces/IBasicToken.sol

pragma solidity 0.5.11;

interface IBasicToken {
    function symbol() external view returns (string memory);

    function decimals() external view returns (uint8);
}

// File: contracts/utils/Helpers.sol

pragma solidity 0.5.11;


library Helpers {
    /**
     * @notice Fetch the `symbol()` from an ERC20 token
     * @dev Grabs the `symbol()` from a contract
     * @param _token Address of the ERC20 token
     * @return string Symbol of the ERC20 token
     */
    function getSymbol(address _token) internal view returns (string memory) {
        string memory symbol = IBasicToken(_token).symbol();
        return symbol;
    }

    /**
     * @notice Fetch the `decimals()` from an ERC20 token
     * @dev Grabs the `decimals()` from a contract and fails if
     *      the decimal value does not live within a certain range
     * @param _token Address of the ERC20 token
     * @return uint256 Decimals of the ERC20 token
     */
    function getDecimals(address _token) internal view returns (uint256) {
        uint256 decimals = IBasicToken(_token).decimals();
        require(
            decimals &gt;= 4 &amp;&amp; decimals &lt;= 18,
            "Token must have sufficient decimal places"
        );

        return decimals;
    }
}

// File: contracts/vault/VaultStorage.sol

pragma solidity 0.5.11;

/**
 * @title OUSD VaultStorage Contract
 * @notice The VaultStorage contract defines the storage for the Vault contracts
 * @author Origin Protocol Inc
 */




contract VaultStorage is Initializable, Governable {
    using SafeMath for uint256;
    using StableMath for uint256;
    using SafeMath for int256;
    using SafeERC20 for IERC20;

    event AssetSupported(address _asset);
    event StrategyAdded(address _addr);
    event StrategyRemoved(address _addr);
    event Mint(address _addr, uint256 _value);
    event Redeem(address _addr, uint256 _value);
    event StrategyWeightsUpdated(
        address[] _strategyAddresses,
        uint256[] weights
    );
    event DepositsPaused();
    event DepositsUnpaused();

    // Assets supported by the Vault, i.e. Stablecoins
    struct Asset {
        bool isSupported;
    }
    mapping(address =&gt; Asset) assets;
    address[] allAssets;

    // Strategies supported by the Vault
    struct Strategy {
        bool isSupported;
        uint256 targetWeight; // 18 decimals. 100% = 1e18
    }
    mapping(address =&gt; Strategy) strategies;
    address[] allStrategies;

    // Address of the Oracle price provider contract
    address public priceProvider;
    // Pausing bools
    bool public rebasePaused = false;
    bool public depositPaused = true;
    // Redemption fee in basis points
    uint256 public redeemFeeBps;
    // Buffer of assets to keep in Vault to handle (most) withdrawals
    uint256 public vaultBuffer;
    // Mints over this amount automatically allocate funds. 18 decimals.
    uint256 public autoAllocateThreshold;
    // Mints over this amount automatically rebase. 18 decimals.
    uint256 public rebaseThreshold;

    OUSD oUSD;

    //keccak256("OUSD.vault.governor.admin.impl");
    bytes32 constant adminImplPosition = 0xa2bd3d3cf188a41358c8b401076eb59066b09dec5775650c0de4c55187d17bd9;

    // Address of the contract responsible for post rebase syncs with AMMs
    address public rebaseHooksAddr = address(0);

    // Address of Uniswap
    address public uniswapAddr = address(0);

    /**
     * @dev set the implementation for the admin, this needs to be in a base class else we cannot set it
     * @param newImpl address pf the implementation
     */
    function setAdminImpl(address newImpl) external onlyGovernor {
        bytes32 position = adminImplPosition;
        assembly {
            sstore(position, newImpl)
        }
    }
}

// File: contracts/interfaces/IMinMaxOracle.sol

pragma solidity 0.5.11;

interface IMinMaxOracle {
    //Assuming 8 decimals
    function priceMin(string calldata symbol) external returns (uint256);

    function priceMax(string calldata symbol) external returns (uint256);
}

interface IViewMinMaxOracle {
    function priceMin(string calldata symbol) external view returns (uint256);

    function priceMax(string calldata symbol) external view returns (uint256);
}

// File: contracts/interfaces/IRebaseHooks.sol

pragma solidity 0.5.11;

interface IRebaseHooks {
    function postRebase(bool sync) external;
}

// File: contracts/vault/VaultCore.sol

pragma solidity 0.5.11;

/**
 * @title OUSD Vault Contract
 * @notice The Vault contract stores assets. On a deposit, OUSD will be minted
           and sent to the depositor. On a withdrawal, OUSD will be burned and
           assets will be sent to the withdrawer. The Vault accepts deposits of
           interest form yield bearing strategies which will modify the supply
           of OUSD.
 * @author Origin Protocol Inc
 */




contract VaultCore is VaultStorage {
    /**
     * @dev Verifies that the rebasing is not paused.
     */
    modifier whenNotRebasePaused() {
        require(!rebasePaused, "Rebasing paused");
        _;
    }

    /**
     * @dev Verifies that the deposits are not paused.
     */
    modifier whenNotDepositPaused() {
        require(!depositPaused, "Deposits paused");
        _;
    }

    /**
     * @dev Deposit a supported asset and mint OUSD.
     * @param _asset Address of the asset being deposited
     * @param _amount Amount of the asset being deposited
     */
    function mint(address _asset, uint256 _amount)
        external
        whenNotDepositPaused
    {
        require(assets[_asset].isSupported, "Asset is not supported");
        require(_amount &gt; 0, "Amount must be greater than 0");

        <span class="marker" id="mapping-7"></span><span class="token mv" id="move-src-3" data-title="function_body/variable_declaration_statement">uint256[] memory <span class="marker" id="mapping-8"></span><span class="token upd" id="move-src-4" data-title="variable_declaration/identifier"><span class="cupd">asset</span>Pri<span class="cupd">ces</span></span>;</span>
        <span class="marker" id="mapping-9"></span><span class="token del" data-title="function_body/comment">// For now we have to live with the +1 oracle call because we need to</span>
        <span class="marker" id="mapping-10"></span><span class="token del" data-title="function_body/comment">// know the priceAdjustedDeposit before we decide wether or not to grab</span>
        <span class="marker" id="mapping-11"></span><span class="token del" data-title="function_body/comment">// assets. This will not effect small non-rebase/allocate mints</span>
        <span class="marker" id="mapping-12"></span><span class="token mv" id="move-src-5" data-title="function_body/variable_declaration_statement">uint256 priceAdjustedDeposit = _amount.mulTruncateScale(
            <span class="marker" id="mapping-13"></span><span class="token mv" id="move-src-6" data-title="member_expression/call_expression">IMinMaxOracle(priceProvider)
                .priceMin(Helpers.getSymbol(_asset))</span>
                .scaleBy(int8(10)), // 18-8 because oracles have 8 decimals precision
            10**Helpers.getDecimals(_asset)
        );</span>
        if (
            <span class="marker" id="mapping-14"></span><span class="token del" data-title="binary_expression/parenthesized_expression">(priceAdjustedDeposit &gt; rebaseThreshold &amp;&amp; !rebasePaused)</span> <span class="marker" id="mapping-15"></span><span class="token del" data-title="binary_expression/||">||</span>
            <span class="marker" id="mapping-16"></span><span class="token del" data-title="binary_expression/parenthesized_expression">(priceAdjustedDeposit &gt;= autoAllocateThreshold)</span>
        ) {
            <span class="marker" id="mapping-17"></span><span class="token upd" id="move-src-7" data-title="assignment_expression/identifier">assetP<span class="cupd">rice</span>s</span> = <span class="marker" id="mapping-18"></span><span class="token del" data-title="assignment_expression/call_expression">_getAssetPrices(false)</span>;
        }

        // Rebase must happen before any transfers occur.
        if (priceAdjustedDeposit &gt; rebaseThreshold &amp;&amp; !rebasePaused) {
            rebase(<span class="marker" id="mapping-19"></span><span class="token del" data-title="call_expression/call_argument">assetPrices</span><span class="marker" id="mapping-20"></span><span class="token del" data-title="call_expression/,">,</span> true);
        }

        // Transfer the deposited coins to the vault
        IERC20 asset = IERC20(_asset);
        asset.safeTransferFrom(msg.sender, address(this), _amount);

        // Mint matching OUSD
        oUSD.mint(msg.sender, priceAdjustedDeposit);
        emit Mint(msg.sender, priceAdjustedDeposit);

        if (priceAdjustedDeposit &gt;= autoAllocateThreshold) {
            allocate(<span class="marker" id="mapping-21"></span><span class="token del" data-title="call_expression/call_argument">assetPrices</span>);
        }
    }

    /**
     * @dev Mint for multiple assets in the same call.
     * @param _assets Addresses of assets being deposited
     * @param _amounts Amount of each asset at the same index in the _assets
     *                 to deposit.
     */
    function mintMultiple(
        address[] calldata _assets,
        uint256[] calldata _amounts
    ) external whenNotDepositPaused {
        require(_assets.length == _amounts.length, "Parameter length mismatch");

        uint256 priceAdjustedTotal = 0;
        uint256[] memory assetPrices = _getAssetPrices(false);
        for (uint256 i = 0; i &lt; allAssets.length; i++) {
            for (uint256 j = 0; j &lt; _assets.length; j++) {
                if (_assets[j] == allAssets[i]) {
                    if (_amounts[j] &gt; 0) {
                        uint256 assetDecimals = Helpers.getDecimals(
                            allAssets[i]
                        );
                        priceAdjustedTotal += _amounts[j].mulTruncateScale(
                            <span class="marker" id="mapping-22"></span><span class="token mv" id="move-src-8" data-title="call_argument/array_access">assetPrices[i]</span>,
                            10**assetDecimals
                        );
                    }
                }
            }
        }
        // Rebase must happen before any transfers occur.
        if (priceAdjustedTotal &gt; rebaseThreshold &amp;&amp; !rebasePaused) {
            rebase(<span class="marker" id="mapping-23"></span><span class="token del" data-title="call_expression/call_argument">assetPrices</span><span class="marker" id="mapping-24"></span><span class="token del" data-title="call_expression/,">,</span> true);
        }

        for (uint256 i = 0; i &lt; _assets.length; i++) {
            IERC20 asset = IERC20(_assets[i]);
            asset.safeTransferFrom(msg.sender, address(this), _amounts[i]);
        }

        oUSD.mint(msg.sender, priceAdjustedTotal);
        emit Mint(msg.sender, priceAdjustedTotal);

        if (priceAdjustedTotal &gt;= autoAllocateThreshold) {
            allocate(<span class="marker" id="mapping-25"></span><span class="token del" data-title="call_expression/call_argument">assetPrices</span>);
        }
    }

    /**
     * @dev Withdraw a supported asset and burn OUSD.
     * @param _amount Amount of OUSD to burn
     */
    function redeem(uint256 _amount) public {
        <span class="marker" id="mapping-26"></span><span class="token del" data-title="function_body/variable_declaration_statement">uint256[] memory assetPrices = _getAssetPrices(false);</span>
        if (_amount &gt; rebaseThreshold &amp;&amp; !rebasePaused) {
            rebase(<span class="marker" id="mapping-27"></span><span class="token del" data-title="call_expression/call_argument">assetPrices</span><span class="marker" id="mapping-28"></span><span class="token del" data-title="call_expression/,">,</span> false);
        }
        _redeem(_amount<span class="marker" id="mapping-29"></span><span class="token del" data-title="call_expression/,">,</span> <span class="marker" id="mapping-30"></span><span class="token del" data-title="call_expression/call_argument">assetPrices</span>);
    }

    function _redeem(uint256 _amount<span class="marker" id="mapping-31"></span><span class="token del" data-title="function_definition/,">,</span> <span class="marker" id="mapping-32"></span><span class="token del" data-title="function_definition/parameter"><span class="marker" id="mapping-33"></span><span class="token mv" id="move-src-9" data-title="parameter/type_name">uint256[]</span> memory assetPrices</span>) internal {
        require(_amount &gt; 0, "Amount must be greater than 0");

        <span class="marker" id="mapping-34"></span><span class="token del" data-title="function_body/variable_declaration_statement"><span class="marker" id="mapping-35"></span><span class="token mv" id="move-src-10" data-title="variable_declaration_statement/variable_declaration">uint256 <span class="marker" id="mapping-36"></span><span class="token upd" id="move-src-11" data-title="variable_declaration/identifier">feeAdjustedAmount</span></span>;</span>
        <span class="marker" id="mapping-37"></span><span class="token mv" id="move-src-12" data-title="function_body/if_statement">if (redeemFeeBps &gt; 0) {
            uint256 redeemFee = _amount.mul(redeemFeeBps).div(10000);
            <span class="marker" id="mapping-38"></span><span class="token upd" id="move-src-13" data-title="assignment_expression/identifier">feeAdjustedA<span class="cupd">mount</span></span> = _amount.sub(redeemFee);
        } <span class="marker" id="mapping-39"></span><span class="token del" data-title="if_statement/else">else</span> <span class="marker" id="mapping-40"></span><span class="token del" data-title="if_statement/block_statement">{
            feeAdjustedAmount = _amount;
        }</span></span>

        // Calculate redemption outputs
        uint256[] memory outputs = _calculateRedeemOutputs(<span class="marker" id="mapping-41"></span><span class="token del" data-title="call_expression/call_argument">feeAdjustedAmount</span>);
        // Send outputs
        for (uint256 i = 0; i &lt; allAssets.length; i++) {
            if (outputs[i] == 0) continue;

            IERC20 asset = IERC20(allAssets[i]);

            if (asset.balanceOf(address(this)) &gt;= outputs[i]) {
                // Use Vault funds first if sufficient
                asset.safeTransfer(msg.sender, outputs[i]);
            } else {
                address strategyAddr = _selectWithdrawStrategyAddr(
                    allAssets[i],
                    outputs[i]<span class="marker" id="mapping-42"></span><span class="token del" data-title="call_expression/,">,</span>
                    <span class="marker" id="mapping-43"></span><span class="token del" data-title="call_expression/call_argument">assetPrices</span>
                );

                if (strategyAddr != address(0)) {
                    // Nothing in Vault, but something in Strategy, send from there
                    IStrategy strategy = IStrategy(strategyAddr);
                    strategy.withdraw(msg.sender, allAssets[i], outputs[i]);
                } else {
                    // Cant find funds anywhere
                    revert("Liquidity error");
                }
            }
        }

        oUSD.burn(msg.sender, _amount);

        // Until we can prove that we won't affect the prices of our assets
        // by withdrawing them, this should be here.
        // It's possible that a strategy was off on its asset total, perhaps
        // a reward token sold for more or for less than anticipated.
        if (_amount &gt; rebaseThreshold &amp;&amp; !rebasePaused) {
            rebase(<span class="marker" id="mapping-44"></span><span class="token del" data-title="call_expression/call_argument">assetPrices</span><span class="marker" id="mapping-45"></span><span class="token del" data-title="call_expression/,">,</span> true);
        }

        emit Redeem(msg.sender, _amount);
    }

    /**
     * @notice Withdraw a supported asset and burn all OUSD.
     */
    function redeemAll() external {
        <span class="marker" id="mapping-46"></span><span class="token del" data-title="function_body/variable_declaration_statement">uint256[] memory assetPrices = _getAssetPrices(false);</span>
        //unfortunately we have to do balanceOf twice
        if (oUSD.balanceOf(msg.sender) &gt; rebaseThreshold &amp;&amp; !rebasePaused) {
            rebase(<span class="marker" id="mapping-47"></span><span class="token del" data-title="call_expression/call_argument">assetPrices</span><span class="marker" id="mapping-48"></span><span class="token del" data-title="call_expression/,">,</span> false);
        }

        _redeem(oUSD.balanceOf(msg.sender)<span class="marker" id="mapping-49"></span><span class="token del" data-title="call_expression/,">,</span> <span class="marker" id="mapping-50"></span><span class="token del" data-title="call_expression/call_argument">assetPrices</span>);
    }

    /**
     * @notice Allocate unallocated funds on Vault to strategies.
     * @dev Allocate unallocated funds on Vault to strategies.
     **/
    <span class="marker" id="mapping-51"></span><span class="token del" data-title="contract_body/function_definition">function allocate() <span class="marker" id="mapping-52"></span><span class="token mv" id="move-src-14" data-title="function_definition/visibility">public</span> <span class="marker" id="mapping-53"></span><span class="token del" data-title="function_definition/function_body">{
        uint256[] memory assetPrices = _getAssetPrices(false);
        allocate(assetPrices);
    }</span></span>

    /**
     * @notice Allocate unallocated funds on Vault to strategies.
     * @dev Allocate unallocated funds on Vault to strategies.
     **/
    function <span class="marker" id="mapping-54"></span><span class="token upd" id="move-src-15" data-title="function_definition/identifier"><span class="cupd">allocate</span></span>(<span class="marker" id="mapping-55"></span><span class="token del" data-title="function_definition/parameter"><span class="marker" id="mapping-56"></span><span class="token mv" id="move-src-16" data-title="parameter/type_name">uint256[]</span> memory assetPrices</span>) internal {
        uint256 vaultValue = _totalValueInVault(<span class="marker" id="mapping-57"></span><span class="token del" data-title="call_expression/call_argument">assetPrices</span>);
        // Nothing in vault to allocate
        if (vaultValue == 0) return;
        uint256 strategiesValue = _totalValueInStrategies(<span class="marker" id="mapping-58"></span><span class="token del" data-title="call_expression/call_argument">assetPrices</span>);
        // We have a method that does the same as this, gas optimisation
        uint256 totalValue = vaultValue + strategiesValue;

        // We want to maintain a buffer on the Vault so calculate a percentage
        // modifier to multiply each amount being allocated by to enforce the
        // vault buffer
        uint256 vaultBufferModifier;
        if (strategiesValue == 0) {
            // Nothing in Strategies, allocate 100% minus the vault buffer to
            // strategies
            vaultBufferModifier = 1e18 - vaultBuffer;
        } else {
            vaultBufferModifier = vaultBuffer.mul(totalValue).div(vaultValue);
            if (1e18 &gt; vaultBufferModifier) {
                // E.g. 1e18 - (1e17 * 10e18)/5e18 = 8e17
                // (5e18 * 8e17) / 1e18 = 4e18 allocated from Vault
                vaultBufferModifier = 1e18 - vaultBufferModifier;
            } else {
                // We need to let the buffer fill
                return;
            }
        }

        if (vaultBufferModifier == 0) return;

        // Iterate over all assets in the Vault and allocate the the appropriate
        // strategy
        for (uint256 i = 0; i &lt; allAssets.length; i++) {
            IERC20 asset = IERC20(allAssets[i]);
            uint256 assetBalance = asset.balanceOf(address(this));
            // No balance, nothing to do here
            if (assetBalance == 0) continue;

            // Multiply the balance by the vault buffer modifier and truncate
            // to the scale of the asset decimals
            uint256 allocateAmount = assetBalance.mulTruncate(
                vaultBufferModifier
            );

            // Get the target Strategy to maintain weightings
            address depositStrategyAddr = _selectDepositStrategyAddr(
                address(asset)<span class="marker" id="mapping-59"></span><span class="token del" data-title="call_expression/,">,</span>
                <span class="marker" id="mapping-60"></span><span class="token del" data-title="call_expression/call_argument">assetPrices</span>
            );

            if (depositStrategyAddr != address(0) &amp;&amp; allocateAmount &gt; 0) {
                IStrategy strategy = IStrategy(depositStrategyAddr);
                // Transfer asset to Strategy and call deposit method to
                // mint or take required action
                asset.safeTransfer(address(strategy), allocateAmount);
                strategy.deposit(address(asset), allocateAmount);
            }
        }
    }

    /**
     * @dev Calculate the total value of assets held by the Vault and all
     *         strategies and update the supply of oUSD
     */
    function rebase() public whenNotRebasePaused returns (uint256) {
        <span class="marker" id="mapping-61"></span><span class="token del" data-title="function_body/variable_declaration_statement">uint256[] memory assetPrices = _getAssetPrices(false);</span>
        rebase(<span class="marker" id="mapping-62"></span><span class="token del" data-title="call_expression/call_argument">assetPrices</span><span class="marker" id="mapping-63"></span><span class="token del" data-title="call_expression/,">,</span> true);
    }

    /**
     * @dev Calculate the total value of assets held by the Vault and all
     *         strategies and update the supply of oUSD
     */
    function rebase(<span class="marker" id="mapping-64"></span><span class="token del" data-title="function_definition/parameter">uint256[] memory assetPrices</span><span class="marker" id="mapping-65"></span><span class="token del" data-title="function_definition/,">,</span> bool sync)
        internal
        whenNotRebasePaused
        returns (uint256)
    {
        if (oUSD.totalSupply() == 0) return 0;
        uint256 oldTotalSupply = oUSD.totalSupply();
        uint256 newTotalSupply = <span class="marker" id="mapping-66"></span><span class="token mv" id="move-src-17" data-title="variable_declaration_statement/call_expression">oUSD.changeSupply(<span class="marker" id="mapping-67"></span><span class="token del" data-title="call_argument/call_expression">_totalValue(assetPrices)</span>)</span>;
        <span class="marker" id="mapping-68"></span><span class="token mv" id="move-src-18" data-title="function_body/if_statement">if (<span class="marker" id="mapping-69"></span><span class="token del" data-title="if_statement/binary_expression"><span class="marker" id="mapping-70"></span><span class="token del" data-title="binary_expression/binary_expression">oldTotalSupply != newTotalSupply</span> &amp;&amp; <span class="marker" id="mapping-71"></span><span class="token mv" id="move-src-19" data-title="binary_expression/binary_expression">rebaseHooksAddr != address(0)</span></span>) {
            IRebaseHooks(rebaseHooksAddr).postRebase(sync);
        }</span>
    }

    /**
     * @dev Determine the total value of assets held by the vault and its
     *         strategies.
     * @return uint256 value Total value in USD (1e18)
     */
    function totalValue() external returns (uint256 value) {
        <span class="marker" id="mapping-72"></span><span class="token del" data-title="function_body/variable_declaration_statement">uint256[] memory assetPrices = _getAssetPrices(false);</span>
        value = _totalValue(<span class="marker" id="mapping-73"></span><span class="token del" data-title="call_expression/call_argument">assetPrices</span>);
    }

    /**
     * @dev Internal Calculate the total value of the assets held by the
     *         vault and its strategies.
     * @return uint256 value Total value in USD (1e18)
     */
    function _totalValue(<span class="marker" id="mapping-74"></span><span class="token del" data-title="function_definition/parameter">uint256[] memory assetPrices</span>)
        internal
        view
        returns (uint256 value)
    {
        return
            <span class="marker" id="mapping-75"></span><span class="token del" data-title="binary_expression/call_expression">_totalValueInVault(assetPrices)</span> +
            <span class="marker" id="mapping-76"></span><span class="token del" data-title="binary_expression/call_expression">_totalValueInStrategies(assetPrices)</span>;
    }

    /**
     * @dev Internal to calculate total value of all assets held in Vault.
     * @return uint256 Total value in ETH (1e18)
     */
    function _totalValueInVault(<span class="marker" id="mapping-77"></span><span class="token del" data-title="function_definition/parameter">uint256[] memory assetPrices</span>)
        internal
        view
        returns (uint256 value)
    {
        value = 0;
        for (uint256 y = 0; y &lt; allAssets.length; y++) {
            IERC20 asset = IERC20(allAssets[y]);
            uint256 assetDecimals = Helpers.getDecimals(allAssets[y]);
            uint256 balance = asset.balanceOf(address(this));
            if (balance &gt; 0) {
                value += balance.<span class="marker" id="mapping-78"></span><span class="token upd" id="move-src-20" data-title="member_expression/identifier">mulTrun<span class="cupd">ca</span>teSca<span class="cupd">le</span></span>(
                    <span class="marker" id="mapping-79"></span><span class="token del" data-title="call_expression/call_argument">assetPrices[y]</span><span class="marker" id="mapping-80"></span><span class="token del" data-title="call_expression/,">,</span>
                    <span class="marker" id="mapping-81"></span><span class="token del" data-title="call_expression/call_argument">10**assetDecimals</span>
                );
            }
        }
    }

    /**
     * @dev Internal to calculate total value of all assets held in Strategies.
     * @return uint256 Total value in ETH (1e18)
     */
    function _totalValueInStrategies(<span class="marker" id="mapping-82"></span><span class="token del" data-title="function_definition/parameter"><span class="marker" id="mapping-83"></span><span class="token mv" id="move-src-21" data-title="parameter/type_name">uint256[]</span> memory assetPrices</span>)
        internal
        view
        returns (uint256 value)
    {
        value = 0;
        for (uint256 i = 0; i &lt; allStrategies.length; i++) {
            value += _totalValueInStrategy(allStrategies[i]<span class="marker" id="mapping-84"></span><span class="token del" data-title="call_expression/,">,</span> <span class="marker" id="mapping-85"></span><span class="token del" data-title="call_expression/call_argument">assetPrices</span>);
        }
    }

    /**
     * @dev Internal to calculate total value of all assets held by strategy.
     * @param _strategyAddr Address of the strategy
     * @return uint256 Total value in ETH (1e18)
     */
    function _totalValueInStrategy(
        address _strategyAddr<span class="marker" id="mapping-86"></span><span class="token del" data-title="function_definition/,">,</span>
        <span class="marker" id="mapping-87"></span><span class="token del" data-title="function_definition/parameter">uint256[] memory assetPrices</span>
    ) internal view returns (uint256 value) {
        value = 0;
        IStrategy strategy = IStrategy(_strategyAddr);
        for (uint256 y = 0; y &lt; allAssets.length; y++) {
            uint256 assetDecimals = Helpers.getDecimals(allAssets[y]);
            if (strategy.supportsAsset(allAssets[y])) {
                uint256 balance = strategy.checkBalance(allAssets[y]);
                if (balance &gt; 0) {
                    value += balance.<span class="marker" id="mapping-88"></span><span class="token upd" id="move-src-22" data-title="member_expression/identifier">mulTrun<span class="cupd">ca</span>teSca<span class="cupd">le</span></span>(
                        <span class="marker" id="mapping-89"></span><span class="token del" data-title="call_expression/call_argument">assetPrices[y]</span><span class="marker" id="mapping-90"></span><span class="token del" data-title="call_expression/,">,</span>
                        <span class="marker" id="mapping-91"></span><span class="token del" data-title="call_expression/call_argument">10**assetDecimals</span>
                    );
                }
            }
        }
    }

    /**
     * @dev Calculate difference in percent of asset allocation for a
               strategy.
     * @param _strategyAddr Address of the strategy
     * @return int256 Difference between current and target. 18 decimals. For ex. 10%=1e17.
     */
    function _strategyWeightDifference(
        address _strategyAddr<span class="marker" id="mapping-92"></span><span class="token del" data-title="function_definition/,">,</span>
        <span class="marker" id="mapping-93"></span><span class="token del" data-title="function_definition/parameter">uint256[] memory assetPrices</span>
    ) internal view returns (int256 difference) {
        difference =
            int256(strategies[_strategyAddr].targetWeight) -
            int256(
                _totalValueInStrategy(_strategyAddr<span class="marker" id="mapping-94"></span><span class="token del" data-title="call_expression/,">,</span> <span class="marker" id="mapping-95"></span><span class="token del" data-title="call_expression/call_argument">assetPrices</span>).divPrecisely(
                    _totalValue(<span class="marker" id="mapping-96"></span><span class="token del" data-title="call_expression/call_argument">assetPrices</span>)
                )
            );
    }

    /**
     * @dev Select a strategy for allocating an asset to.
     * @param _asset Address of asset
     * @return address Address of the target strategy
     */
    function _selectDepositStrategyAddr(
        address _asset<span class="marker" id="mapping-97"></span><span class="token del" data-title="function_definition/,">,</span>
        <span class="marker" id="mapping-98"></span><span class="token del" data-title="function_definition/parameter">uint256[] memory assetPrices</span>
    ) internal view returns (address depositStrategyAddr) {
        depositStrategyAddr = address(0);
        int256 maxDifference = 0;

        for (uint256 i = 0; i &lt; allStrategies.length; i++) {
            IStrategy strategy = IStrategy(allStrategies[i]);
            if (strategy.supportsAsset(_asset)) {
                <span class="marker" id="mapping-99"></span><span class="token mv" id="move-src-23" data-title="block_statement/variable_declaration_statement">int256 diff = _strategyWeightDifference(
                    allStrategies[i]<span class="marker" id="mapping-100"></span><span class="token del" data-title="call_expression/,">,</span>
                    <span class="marker" id="mapping-101"></span><span class="token del" data-title="call_expression/call_argument">assetPrices</span>
                );</span>
                if (diff &gt;= maxDifference) {
                    maxDifference = diff;
                    depositStrategyAddr = allStrategies[i];
                }
            }
        }
    }

    /**
     * @dev Select a strategy for withdrawing an asset from.
     * @param _asset Address of asset
     * @return address Address of the target strategy for withdrawal
     */
    function _selectWithdrawStrategyAddr(
        address _asset,
        uint256 _amount<span class="marker" id="mapping-102"></span><span class="token del" data-title="function_definition/,">,</span>
        <span class="marker" id="mapping-103"></span><span class="token del" data-title="function_definition/parameter">uint256[] memory assetPrices</span>
    ) internal view returns (address withdrawStrategyAddr) {
        withdrawStrategyAddr = address(0);
        int256 minDifference = 1e18;

        for (uint256 i = 0; i &lt; allStrategies.length; i++) {
            IStrategy strategy = IStrategy(allStrategies[i]);
            if (
                strategy.supportsAsset(_asset) &amp;&amp;
                strategy.checkBalance(_asset) &gt; _amount
            ) {
                <span class="marker" id="mapping-104"></span><span class="token mv" id="move-src-24" data-title="block_statement/variable_declaration_statement">int256 diff = _strategyWeightDifference(
                    allStrategies[i]<span class="marker" id="mapping-105"></span><span class="token del" data-title="call_expression/,">,</span>
                    <span class="marker" id="mapping-106"></span><span class="token del" data-title="call_expression/call_argument">assetPrices</span>
                );</span>
                if (diff &lt;= minDifference) {
                    minDifference = diff;
                    withdrawStrategyAddr = allStrategies[i];
                }
            }
        }
    }

    /**
     * @notice Get the balance of an asset held in Vault and all strategies.
     * @param _asset Address of asset
     * @return uint256 Balance of asset in decimals of asset
     */
    function checkBalance(address _asset) external view returns (uint256) {
        return _checkBalance(_asset);
    }

    /**
     * @notice Get the balance of an asset held in Vault and all strategies.
     * @param _asset Address of asset
     * @return uint256 Balance of asset in decimals of asset
     */
    function _checkBalance(address _asset)
        internal
        view
        returns (uint256 balance)
    {
        IERC20 asset = IERC20(_asset);
        balance = asset.balanceOf(address(this));
        for (uint256 i = 0; i &lt; allStrategies.length; i++) {
            IStrategy strategy = IStrategy(allStrategies[i]);
            if (strategy.supportsAsset(_asset)) {
                balance += strategy.checkBalance(_asset);
            }
        }
    }

    /**
     * @notice Get the balance of all assets held in Vault and all strategies.
     * @return uint256 Balance of all assets (1e18)
     */
    function _checkBalance() internal view returns (uint256 balance) {
        balance = 0;
        for (uint256 i = 0; i &lt; allAssets.length; i++) {
            uint256 assetDecimals = Helpers.getDecimals(allAssets[i]);
            balance += _checkBalance(allAssets[i]).scaleBy(
                int8(18 - assetDecimals)
            );
        }
    }

    /**
     * @notice Calculate the outputs for a redeem function, i.e. the mix of
     * coins that will be returned
     */
    function calculateRedeemOutputs(uint256 _amount)
        external
        returns (uint256[] memory)
    {
        return _calculateRedeemOutputs(_amount);
    }

    /**
     * @notice Calculate the outputs for a redeem function, i.e. the mix of
     * coins that will be returned.
     * @return Array of amounts respective to the supported assets
     */
    function _calculateRedeemOutputs(uint256 _amount)
        internal
        returns (uint256[] memory outputs)
    {
        <span class="marker" id="mapping-107"></span><span class="token mv" id="move-src-25" data-title="function_body/variable_declaration_statement">uint256[] memory assetPrices = _getAssetPrices(true);</span>

        <span class="marker" id="mapping-108"></span><span class="token mv" id="move-src-26" data-title="function_body/variable_declaration_statement">uint256 totalBalance = <span class="marker" id="mapping-109"></span><span class="token del" data-title="variable_declaration_statement/call_expression">_checkBalance()</span>;</span>
        <span class="marker" id="mapping-110"></span><span class="token mv" id="move-src-27" data-title="function_body/variable_declaration_statement">uint256 <span class="marker" id="mapping-111"></span><span class="token upd" id="move-src-28" data-title="variable_declaration/identifier"><span class="cupd">totalOutput</span>Value</span> = 0;</span> <span class="marker" id="mapping-112"></span><span class="token upd" id="move-src-29" data-title="function_body/comment"><span class="cupd">// </span>R<span class="cupd">u</span><span class="cupd">n</span><span class="cupd">n</span><span class="cupd">i</span><span class="cupd">n</span>g<span class="cupd"> to</span>tal<span class="cupd"> </span><span class="cupd">o</span>f<span class="cupd"> </span>USD<span class="cupd"> </span>valu<span class="cupd">e </span>of <span class="cupd">a</span>ssets</span>
        <span class="marker" id="mapping-113"></span><span class="token mv" id="move-src-30" data-title="function_body/variable_declaration_statement">uint256 assetCount = getAssetCount();</span>

        <span class="marker" id="mapping-114"></span><span class="token upd" id="move-src-31" data-title="function_body/comment"><span class="cupd">// </span>In<span class="cupd">i</span>ti<span class="cupd">al</span><span class="cupd">i</span><span class="cupd">s</span><span class="cupd">e</span><span class="cupd"> </span><span class="cupd">a</span>rr<span class="cupd">a</span>ys</span>
        <span class="marker" id="mapping-115"></span><span class="token upd" id="move-src-32" data-title="function_body/comment"><span class="cupd">// </span>P<span class="cupd">r</span>i<span class="cupd">ce</span><span class="cupd"> of each </span>asset <span class="cupd">in</span><span class="cupd"> </span>USD<span class="cupd"> </span><span class="cupd">i</span>n<span class="cupd"> </span>1e18</span>
        <span class="marker" id="mapping-116"></span><span class="token mv" id="move-src-33" data-title="function_body/expression_statement">outputs = new uint256[](assetCount);</span>

        <span class="marker" id="mapping-117"></span><span class="token mv" id="move-src-34" data-title="function_body/for_statement">for (uint256 i = 0; i &lt; allAssets.length; i++) {
            <span class="marker" id="mapping-118"></span><span class="token mv" id="move-src-35" data-title="block_statement/variable_declaration_statement"><span class="marker" id="mapping-119"></span><span class="token del" data-title="variable_declaration_statement/variable_declaration">uint256 assetDecimals</span> = Helpers.getDecimals(allAssets[i]);</span>

            <span class="marker" id="mapping-120"></span><span class="token del" data-title="block_statement/comment">// Get the proportional amount of this token for the redeem in 1e18</span>
            <span class="marker" id="mapping-121"></span><span class="token mv" id="move-src-36" data-title="variable_declaration_statement/variable_declaration">uint256 <span class="marker" id="mapping-122"></span><span class="token upd" id="move-src-37" data-title="variable_declaration/identifier">proport<span class="cupd">i</span>on<span class="cupd">al</span>Amount</span></span> = <span class="marker" id="mapping-123"></span><span class="token del" data-title="variable_declaration_statement/call_expression"><span class="marker" id="mapping-124"></span><span class="token del" data-title="call_expression/member_expression"><span class="marker" id="mapping-125"></span><span class="token del" data-title="member_expression/call_expression"><span class="marker" id="mapping-126"></span><span class="token del" data-title="call_expression/member_expression"><span class="marker" id="mapping-127"></span><span class="token del" data-title="member_expression/call_expression"><span class="marker" id="mapping-128"></span><span class="token del" data-title="call_expression/member_expression"><span class="marker" id="mapping-129"></span><span class="token mv" id="move-src-38" data-title="member_expression/call_expression">_checkBalance(allAssets[i])</span>
                .scaleBy</span>(<span class="marker" id="mapping-130"></span><span class="token mv" id="move-src-39" data-title="call_expression/call_argument">int8(18 - assetDecimals)</span>)</span>
                .mul</span>(<span class="marker" id="mapping-131"></span><span class="token mv" id="move-src-40" data-title="call_expression/call_argument">_amount</span>)</span>
                .div</span>(<span class="marker" id="mapping-132"></span><span class="token mv" id="move-src-41" data-title="call_expression/call_argument">totalBalance</span>)</span>;

            <span class="marker" id="mapping-133"></span><span class="token del" data-title="block_statement/if_statement">if (<span class="marker" id="mapping-134"></span><span class="token del" data-title="if_statement/binary_expression">proportionalAmount &gt; 0</span>) <span class="marker" id="mapping-135"></span><span class="token del" data-title="if_statement/block_statement">{
                // Running USD total of all coins in the redeem outputs in 1e18
                <span class="marker" id="mapping-136"></span><span class="token del" data-title="block_statement/expression_statement"><span class="marker" id="mapping-137"></span><span class="token del" data-title="expression_statement/augmented_assignment_expression">totalOutputValue += <span class="marker" id="mapping-138"></span><span class="token del" data-title="augmented_assignment_expression/call_expression"><span class="marker" id="mapping-139"></span><span class="token del" data-title="call_expression/member_expression">proportionalAmount.mulTruncate</span>(
                    <span class="marker" id="mapping-140"></span><span class="token del" data-title="call_expression/call_argument"><span class="marker" id="mapping-141"></span><span class="token mv" id="move-src-42" data-title="call_argument/array_access">assetPrices[i]</span></span>
                )</span></span>;</span>
                // Save the output amount in the decimals of the asset
                <span class="marker" id="mapping-142"></span><span class="token del" data-title="block_statement/expression_statement"><span class="marker" id="mapping-143"></span><span class="token del" data-title="expression_statement/assignment_expression"><span class="marker" id="mapping-144"></span><span class="token mv" id="move-src-43" data-title="assignment_expression/array_access">outputs[i]</span> = <span class="marker" id="mapping-145"></span><span class="token del" data-title="assignment_expression/call_expression"><span class="marker" id="mapping-146"></span><span class="token del" data-title="call_expression/member_expression">proportionalAmount.scaleBy</span>(
                    <span class="marker" id="mapping-147"></span><span class="token del" data-title="call_expression/call_argument"><span class="marker" id="mapping-148"></span><span class="token del" data-title="call_argument/type_cast_expression"><span class="marker" id="mapping-149"></span><span class="token mv" id="move-src-44" data-title="type_cast_expression/primitive_type">int8</span>(<span class="marker" id="mapping-150"></span><span class="token del" data-title="type_cast_expression/call_argument">assetDecimals - 18</span>)</span></span>
                )</span></span>;</span>
            }</span></span>
        }</span>

        <span class="marker" id="mapping-151"></span><span class="token upd" id="move-src-45" data-title="function_body/comment"><span class="cupd">// </span>USD<span class="cupd"> </span>diff<span class="cupd">e</span>rence<span class="cupd"> </span><span class="cupd">i</span><span class="cupd">n </span>am<span class="cupd">ou</span>n<span class="cupd">t</span><span class="cupd"> </span>o<span class="cupd">f coins </span>c<span class="cupd">a</span>lculat<span class="cupd">e</span>d<span class="cupd"> </span>du<span class="cupd">e t</span>o v<span class="cupd">a</span>riatio<span class="cupd">n</span>s in</span>
        <span class="marker" id="mapping-152"></span><span class="token upd" id="move-src-46" data-title="function_body/comment"><span class="cupd">// </span><span class="cupd">p</span>r<span class="cupd">i</span><span class="cupd">c</span><span class="cupd">e </span>i<span class="cupd">n</span> 1e18</span>
        <span class="marker" id="mapping-153"></span><span class="token del" data-title="function_body/variable_declaration_statement">int256 outputValueDiff = int256(_amount - totalOutputValue);</span>
        <span class="marker" id="mapping-154"></span><span class="token upd" id="move-src-47" data-title="function_body/comment"><span class="cupd">// </span>M<span class="cupd">a</span>ke <span class="cupd">u</span>p <span class="cupd">t</span>he<span class="cupd"> </span>difference <span class="cupd">by </span>adding/r<span class="cupd">e</span>m<span class="cupd">o</span>ving <span class="cupd">a</span>n<span class="cupd"> </span>equ<span class="cupd">al</span><span class="cupd"> </span>pr<span class="cupd">o</span>p<span class="cupd">o</span>rt<span class="cupd">i</span>on of</span>
        <span class="marker" id="mapping-155"></span><span class="token upd" id="move-src-48" data-title="function_body/comment"><span class="cupd">//</span> each coin according to its USD value</span>
        <span class="marker" id="mapping-156"></span><span class="token del" data-title="function_body/for_statement">for (<span class="marker" id="mapping-157"></span><span class="token mv" id="move-src-49" data-title="for_statement/variable_declaration_statement">uint256 i = 0;</span> <span class="marker" id="mapping-158"></span><span class="token del" data-title="for_statement/expression_statement">i &lt; outputs.length;</span> <span class="marker" id="mapping-159"></span><span class="token mv" id="move-src-50" data-title="for_statement/update_expression">i++</span>) <span class="marker" id="mapping-160"></span><span class="token del" data-title="for_statement/block_statement">{
            if (outputs[i] == 0) continue;
            if (outputValueDiff &lt; 0) {
                outputs[i] -= uint256(-outputValueDiff).mul(outputs[i]).div(
                    totalOutputValue
                );
            } else if (outputValueDiff &gt; 0) {
                outputs[i] += uint256(outputValueDiff).mul(outputs[i]).div(
                    totalOutputValue
                );
            }
        }</span></span>
    }

    /**
     * @notice Get an array of the supported asset prices in USD.
     * @return uint256[] Array of asset prices in USD (1e18)
     */
    function _getAssetPrices(bool useMax)
        internal
        returns (uint256[] memory assetPrices)
    {
        assetPrices = new uint256[](getAssetCount());

        IMinMaxOracle oracle = IMinMaxOracle(priceProvider);
        // Price from Oracle is returned with 8 decimals
        // _amount is in assetDecimals

        for (uint256 i = 0; i &lt; allAssets.length; i++) {
            string memory symbol = Helpers.getSymbol(allAssets[i]);
            // Get all the USD prices of the asset in 1e18
            if (useMax) {
                assetPrices[i] = oracle.priceMax(symbol).scaleBy(int8(18 - 8));
            } else {
                assetPrices[i] = oracle.priceMin(symbol).scaleBy(int8(18 - 8));
            }
        }
    }

    /***************************************
                    Utils
    ****************************************/

    /**
     * @dev Return the number of assets suppported by the Vault.
     */
    function getAssetCount() public view returns (uint256) {
        return allAssets.length;
    }

    /**
     * @dev Return all asset addresses in order
     */
    function getAllAssets() external view returns (address[] memory) {
        return allAssets;
    }

    /**
     * @dev Return the number of strategies active on the Vault.
     */
    function getStrategyCount() public view returns (uint256) {
        return allStrategies.length;
    }

    <span class="marker" id="mapping-161"></span><span class="token del" data-title="contract_body/comment">/**
     * @dev Get the total APR of the Vault and all Strategies.
     */</span>
    <span class="marker" id="mapping-162"></span><span class="token del" data-title="contract_body/function_definition">function getAPR() <span class="marker" id="mapping-163"></span><span class="token del" data-title="function_definition/visibility">external</span> <span class="marker" id="mapping-164"></span><span class="token del" data-title="function_definition/return_type_definition">returns (uint256)</span> <span class="marker" id="mapping-165"></span><span class="token del" data-title="function_definition/function_body">{
        <span class="marker" id="mapping-166"></span><span class="token del" data-title="function_body/if_statement">if (getStrategyCount() == 0) return 0;</span>

        <span class="marker" id="mapping-167"></span><span class="token del" data-title="function_body/variable_declaration_statement">uint256[] memory assetPrices = _getAssetPrices(true);</span>

        <span class="marker" id="mapping-168"></span><span class="token mv" id="move-src-51" data-title="function_body/variable_declaration_statement">uint256 <span class="marker" id="mapping-169"></span><span class="token upd" id="move-src-52" data-title="variable_declaration/identifier"><span class="cupd">to</span>talAPR</span> = <span class="marker" id="mapping-170"></span><span class="token del" data-title="variable_declaration_statement/number_literal">0</span>;</span>
        // Get the value from strategies
        <span class="marker" id="mapping-171"></span><span class="token del" data-title="function_body/for_statement">for (<span class="marker" id="mapping-172"></span><span class="token mv" id="move-src-53" data-title="for_statement/variable_declaration_statement">uint256 i = 0;</span> <span class="marker" id="mapping-173"></span><span class="token del" data-title="for_statement/expression_statement">i &lt; allStrategies.length;</span> <span class="marker" id="mapping-174"></span><span class="token mv" id="move-src-54" data-title="for_statement/update_expression">i++</span>) <span class="marker" id="mapping-175"></span><span class="token del" data-title="for_statement/block_statement">{
            IStrategy strategy = IStrategy(allStrategies[i]);
            if (strategy.getAPR() &gt; 0) {
                totalAPR += _totalValueInStrategy(allStrategies[i], assetPrices)
                    .divPrecisely(_totalValue(assetPrices))
                    .mulTruncate(strategy.getAPR());
            }
        }</span></span>
        <span class="marker" id="mapping-176"></span><span class="token del" data-title="function_body/return_statement">return totalAPR;</span>
    }</span></span>

    function isSupportedAsset(address _asset) external view returns (bool) {
        return assets[_asset].isSupported;
    }

    /**
     * @dev Falldown to the admin implementation
     * @notice This is a catch all for all functions not declared in core
     */
    function() external payable {
        bytes32 slot = adminImplPosition;
        assembly {
            // Copy msg.data. We take full control of memory in this inline assembly
            // block because it will not return to Solidity code. We overwrite the
            // Solidity scratch pad at memory position 0.
            calldatacopy(0, 0, calldatasize)

            // Call the implementation.
            // out and outsize are 0 because we don't know the size yet.
            let result := delegatecall(gas, sload(slot), 0, calldatasize, 0, 0)

            // Copy the returned data.
            returndatacopy(0, 0, returndatasize)

            switch result
                // delegatecall returns 0 on error.
                case 0 {
                    revert(0, returndatasize)
                }
                default {
                    return(0, returndatasize)
                }
        }
    }
}</pre></div><div class="col-6"><h5>0x0660bf15a89d8e90cba1b3f0ccf493c415b1369d.etherscan.io-VaultCore.sol</h5><pre class="pre-scrollable"><span class="marker" id="mapping-177"></span><span class="token upd" id="move-dst-1" data-title="source_file/comment"><span class="cupd">/*
 * Origin Protocol
 * https://originprotocol.com
 *
 * Released under the MIT license
 * https://github.com/OriginProtocol</span>/origin-dollar<span class="cupd">
 *
 * Copyright 20</span>20<span class="cupd"> Origin Protocol, Inc
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 </span><span class="cupd">* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */</span></span>
// File: @openzeppelin/contracts/token/ERC20/IERC20.sol

pragma solidity ^0.5.0;

/**
 * @dev Interface of the ERC20 standard as defined in the EIP. Does not include
 * the optional functions; to access them see {ERC20Detailed}.
 */
interface IERC20 {
    /**
     * @dev Returns the amount of tokens in existence.
     */
    function totalSupply() external view returns (uint256);

    /**
     * @dev Returns the amount of tokens owned by `account`.
     */
    function balanceOf(address account) external view returns (uint256);

    /**
     * @dev Moves `amount` tokens from the caller's account to `recipient`.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * Emits a {Transfer} event.
     */
    function transfer(address recipient, uint256 amount) external returns (bool);

    /**
     * @dev Returns the remaining number of tokens that `spender` will be
     * allowed to spend on behalf of `owner` through {transferFrom}. This is
     * zero by default.
     *
     * This value changes when {approve} or {transferFrom} are called.
     */
    function allowance(address owner, address spender) external view returns (uint256);

    /**
     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * IMPORTANT: Beware that changing an allowance with this method brings the risk
     * that someone may use both the old and the new allowance by unfortunate
     * transaction ordering. One possible solution to mitigate this race
     * condition is to first reduce the spender's allowance to 0 and set the
     * desired value afterwards:
     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
     *
     * Emits an {Approval} event.
     */
    function approve(address spender, uint256 amount) external returns (bool);

    /**
     * @dev Moves `amount` tokens from `sender` to `recipient` using the
     * allowance mechanism. `amount` is then deducted from the caller's
     * allowance.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * Emits a {Transfer} event.
     */
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);

    /**
     * @dev Emitted when `value` tokens are moved from one account (`from`) to
     * another (`to`).
     *
     * Note that `value` may be zero.
     */
    event Transfer(address indexed from, address indexed to, uint256 value);

    /**
     * @dev Emitted when the allowance of a `spender` for an `owner` is set by
     * a call to {approve}. `value` is the new allowance.
     */
    event Approval(address indexed owner, address indexed spender, uint256 value);
}

// File: @openzeppelin/contracts/math/SafeMath.sol

pragma solidity ^0.5.0;

/**
 * @dev Wrappers over Solidity's arithmetic operations with added overflow
 * checks.
 *
 * Arithmetic operations in Solidity wrap on overflow. This can easily result
 * in bugs, because programmers usually assume that an overflow raises an
 * error, which is the standard behavior in high level programming languages.
 * `SafeMath` restores this intuition by reverting the transaction when an
 * operation overflows.
 *
 * Using this library instead of the unchecked operations eliminates an entire
 * class of bugs, so it's recommended to use it always.
 */
library SafeMath {
    /**
     * @dev Returns the addition of two unsigned integers, reverting on
     * overflow.
     *
     * Counterpart to Solidity's `+` operator.
     *
     * Requirements:
     * - Addition cannot overflow.
     */
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c &gt;= a, "SafeMath: addition overflow");

        return c;
    }

    /**
     * @dev Returns the subtraction of two unsigned integers, reverting on
     * overflow (when the result is negative).
     *
     * Counterpart to Solidity's `-` operator.
     *
     * Requirements:
     * - Subtraction cannot overflow.
     */
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        return sub(a, b, "SafeMath: subtraction overflow");
    }

    /**
     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on
     * overflow (when the result is negative).
     *
     * Counterpart to Solidity's `-` operator.
     *
     * Requirements:
     * - Subtraction cannot overflow.
     *
     * _Available since v2.4.0._
     */
    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
        require(b &lt;= a, errorMessage);
        uint256 c = a - b;

        return c;
    }

    /**
     * @dev Returns the multiplication of two unsigned integers, reverting on
     * overflow.
     *
     * Counterpart to Solidity's `*` operator.
     *
     * Requirements:
     * - Multiplication cannot overflow.
     */
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the
        // benefit is lost if 'b' is also tested.
        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522
        if (a == 0) {
            return 0;
        }

        uint256 c = a * b;
        require(c / a == b, "SafeMath: multiplication overflow");

        return c;
    }

    /**
     * @dev Returns the integer division of two unsigned integers. Reverts on
     * division by zero. The result is rounded towards zero.
     *
     * Counterpart to Solidity's `/` operator. Note: this function uses a
     * `revert` opcode (which leaves remaining gas untouched) while Solidity
     * uses an invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     * - The divisor cannot be zero.
     */
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        return div(a, b, "SafeMath: division by zero");
    }

    /**
     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on
     * division by zero. The result is rounded towards zero.
     *
     * Counterpart to Solidity's `/` operator. Note: this function uses a
     * `revert` opcode (which leaves remaining gas untouched) while Solidity
     * uses an invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     * - The divisor cannot be zero.
     *
     * _Available since v2.4.0._
     */
    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
        // Solidity only automatically asserts when dividing by 0
        require(b &gt; 0, errorMessage);
        uint256 c = a / b;
        // assert(a == b * c + a % b); // There is no case in which this doesn't hold

        return c;
    }

    /**
     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),
     * Reverts when dividing by zero.
     *
     * Counterpart to Solidity's `%` operator. This function uses a `revert`
     * opcode (which leaves remaining gas untouched) while Solidity uses an
     * invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     * - The divisor cannot be zero.
     */
    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
        return mod(a, b, "SafeMath: modulo by zero");
    }

    /**
     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),
     * Reverts with custom message when dividing by zero.
     *
     * Counterpart to Solidity's `%` operator. This function uses a `revert`
     * opcode (which leaves remaining gas untouched) while Solidity uses an
     * invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     * - The divisor cannot be zero.
     *
     * _Available since v2.4.0._
     */
    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
        require(b != 0, errorMessage);
        return a % b;
    }
}

// File: @openzeppelin/contracts/utils/Address.sol

pragma solidity ^0.5.5;

/**
 * @dev Collection of functions related to the address type
 */
library Address {
    /**
     * @dev Returns true if `account` is a contract.
     *
     * [IMPORTANT]
     * ====
     * It is unsafe to assume that an address for which this function returns
     * false is an externally-owned account (EOA) and not a contract.
     *
     * Among others, `isContract` will return false for the following 
     * types of addresses:
     *
     *  - an externally-owned account
     *  - a contract in construction
     *  - an address where a contract will be created
     *  - an address where a contract lived, but was destroyed
     * ====
     */
    function isContract(address account) internal view returns (bool) {
        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts
        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned
        // for accounts without code, i.e. `keccak256('')`
        bytes32 codehash;
        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;
        // solhint-disable-next-line no-inline-assembly
        assembly { codehash := extcodehash(account) }
        return (codehash != accountHash &amp;&amp; codehash != 0x0);
    }

    /**
     * @dev Converts an `address` into `address payable`. Note that this is
     * simply a type cast: the actual underlying value is not changed.
     *
     * _Available since v2.4.0._
     */
    function toPayable(address account) internal pure returns (address payable) {
        return address(uint160(account));
    }

    /**
     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to
     * `recipient`, forwarding all available gas and reverting on errors.
     *
     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost
     * of certain opcodes, possibly making contracts go over the 2300 gas limit
     * imposed by `transfer`, making them unable to receive funds via
     * `transfer`. {sendValue} removes this limitation.
     *
     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].
     *
     * IMPORTANT: because control is transferred to `recipient`, care must be
     * taken to not create reentrancy vulnerabilities. Consider using
     * {ReentrancyGuard} or the
     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].
     *
     * _Available since v2.4.0._
     */
    function sendValue(address payable recipient, uint256 amount) internal {
        require(address(this).balance &gt;= amount, "Address: insufficient balance");

        // solhint-disable-next-line avoid-call-value
        (bool success, ) = recipient.call.value(amount)("");
        require(success, "Address: unable to send value, recipient may have reverted");
    }
}

// File: @openzeppelin/contracts/token/ERC20/SafeERC20.sol

pragma solidity ^0.5.0;



/**
 * @title SafeERC20
 * @dev Wrappers around ERC20 operations that throw on failure (when the token
 * contract returns false). Tokens that return no value (and instead revert or
 * throw on failure) are also supported, non-reverting calls are assumed to be
 * successful.
 * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract,
 * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.
 */
library SafeERC20 {
    using SafeMath for uint256;
    using Address for address;

    function safeTransfer(IERC20 token, address to, uint256 value) internal {
        callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));
    }

    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {
        callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));
    }

    function safeApprove(IERC20 token, address spender, uint256 value) internal {
        // safeApprove should only be called when setting an initial allowance,
        // or when resetting it to zero. To increase and decrease it, use
        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'
        // solhint-disable-next-line max-line-length
        require((value == 0) || (token.allowance(address(this), spender) == 0),
            "SafeERC20: approve from non-zero to non-zero allowance"
        );
        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));
    }

    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {
        uint256 newAllowance = token.allowance(address(this), spender).add(value);
        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));
    }

    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {
        uint256 newAllowance = token.allowance(address(this), spender).sub(value, "SafeERC20: decreased allowance below zero");
        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));
    }

    /**
     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement
     * on the return value: the return value is optional (but if data is returned, it must not be false).
     * @param token The token targeted by the call.
     * @param data The call data (encoded using abi.encode or one of its variants).
     */
    function callOptionalReturn(IERC20 token, bytes memory data) private {
        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since
        // we're implementing it ourselves.

        // A Solidity high level call has three parts:
        //  1. The target address is checked to verify it contains contract code
        //  2. The call itself is made, and success asserted
        //  3. The return value is decoded, which in turn checks the size of the returned data.
        // solhint-disable-next-line max-line-length
        require(address(token).isContract(), "SafeERC20: call to non-contract");

        // solhint-disable-next-line avoid-low-level-calls
        (bool success, bytes memory returndata) = address(token).call(data);
        require(success, "SafeERC20: low-level call failed");

        if (returndata.length &gt; 0) { // Return data is optional
            // solhint-disable-next-line max-line-length
            require(abi.decode(returndata, (bool)), "SafeERC20: ERC20 operation did not succeed");
        }
    }
}

// File: @openzeppelin/upgrades/contracts/Initializable.sol

pragma solidity &gt;=0.4.24 &lt;0.7.0;


/**
 * @title Initializable
 *
 * @dev Helper contract to support initializer functions. To use it, replace
 * the constructor with a function that has the `initializer` modifier.
 * WARNING: Unlike constructors, initializer functions must be manually
 * invoked. This applies both to deploying an Initializable contract, as well
 * as extending an Initializable contract via inheritance.
 * WARNING: When used with inheritance, manual care must be taken to not invoke
 * a parent initializer twice, or ensure that all initializers are idempotent,
 * because this is not dealt with automatically as with constructors.
 */
contract Initializable {

  /**
   * @dev Indicates that the contract has been initialized.
   */
  bool private initialized;

  /**
   * @dev Indicates that the contract is in the process of being initialized.
   */
  bool private initializing;

  /**
   * @dev Modifier to use in the initializer function of a contract.
   */
  modifier initializer() {
    require(initializing || isConstructor() || !initialized, "Contract instance has already been initialized");

    bool isTopLevelCall = !initializing;
    if (isTopLevelCall) {
      initializing = true;
      initialized = true;
    }

    _;

    if (isTopLevelCall) {
      initializing = false;
    }
  }

  /// @dev Returns true if and only if the function is running in the constructor
  function isConstructor() private view returns (bool) {
    // extcodesize checks the size of the code stored in an address, and
    // address returns the current address. Since the code is still not
    // deployed when running a constructor, any checks on its code size will
    // yield zero, making it an effective way to detect if a contract is
    // under construction or not.
    address self = address(this);
    uint256 cs;
    assembly { cs := extcodesize(self) }
    return cs == 0;
  }

  // Reserved storage space to allow for layout changes in the future.
  uint256[50] private ______gap;
}

// File: contracts/interfaces/IStrategy.sol

pragma solidity 0.5.11;

/**
 * @title Platform interface to integrate with lending platform like Compound, AAVE etc.
 */
interface IStrategy {
    /**
     * @dev Deposit the given asset to Lending platform.
     * @param _asset asset address
     * @param _amount Amount to deposit
     */
    function deposit(address _asset, uint256 _amount)
        external
        returns (uint256 amountDeposited);

    /**
     * @dev Withdraw given asset from Lending platform
     */
    function withdraw(
        address _recipient,
        address _asset,
        uint256 _amount
    ) external returns (uint256 amountWithdrawn);

    /**
     * @dev Returns the current balance of the given asset.
     */
    function checkBalance(address _asset)
        external
        view
        returns (uint256 balance);

    /**
     * @dev Returns bool indicating whether strategy supports asset.
     */
    function supportsAsset(address _asset) external view returns (bool);

    /**
     * @dev Liquidate all assets in strategy and return them to Vault.
     */
    function liquidate() external;

    /**
     * @dev Collect reward tokens from the Strategy.
     */
    function collectRewardToken() external;

    function rewardTokenAddress() external pure returns (address);
}

// File: contracts/governance/Governable.sol

pragma solidity 0.5.11;

/**
 * @title OUSD Governable Contract
 * @dev Copy of the openzeppelin Ownable.sol contract with nomenclature change
 *      from owner to governor and renounce methods removed. Does not use
 *      Context.sol like Ownable.sol does for simplification.
 * @author Origin Protocol Inc
 */
contract Governable {
    // Storage position of the owner and pendingOwner of the contract
    bytes32
        private constant governorPosition = 0x7bea13895fa79d2831e0a9e28edede30099005a50d652d8957cf8a607ee6ca4a;
    //keccak256("OUSD.governor");

    bytes32
        private constant pendingGovernorPosition = 0x44c4d30b2eaad5130ad70c3ba6972730566f3e6359ab83e800d905c61b1c51db;
    //keccak256("OUSD.pending.governor");

    event PendingGovernorshipTransfer(
        address indexed previousGovernor,
        address indexed newGovernor
    );

    event GovernorshipTransferred(
        address indexed previousGovernor,
        address indexed newGovernor
    );

    /**
     * @dev Initializes the contract setting the deployer as the initial Governor.
     */
    constructor() internal {
        _setGovernor(msg.sender);
        emit GovernorshipTransferred(address(0), _governor());
    }

    /**
     * @dev Returns the address of the current Governor.
     */
    function governor() public view returns (address) {
        return _governor();
    }

    function _governor() internal view returns (address governorOut) {
        bytes32 position = governorPosition;
        assembly {
            governorOut := sload(position)
        }
    }

    function _pendingGovernor()
        internal
        view
        returns (address pendingGovernor)
    {
        bytes32 position = pendingGovernorPosition;
        assembly {
            pendingGovernor := sload(position)
        }
    }

    /**
     * @dev Throws if called by any account other than the Governor.
     */
    modifier onlyGovernor() {
        require(isGovernor(), "Caller is not the Governor");
        _;
    }

    /**
     * @dev Returns true if the caller is the current Governor.
     */
    function isGovernor() public view returns (bool) {
        return msg.sender == _governor();
    }

    function _setGovernor(address newGovernor) internal {
        bytes32 position = governorPosition;
        assembly {
            sstore(position, newGovernor)
        }
    }

    function _setPendingGovernor(address newGovernor) internal {
        bytes32 position = pendingGovernorPosition;
        assembly {
            sstore(position, newGovernor)
        }
    }

    /**
     * @dev Transfers Governance of the contract to a new account (`newGovernor`).
     * Can only be called by the current Governor. Must be claimed for this to complete
     * @param _newGovernor Address of the new Governor
     */
    function transferGovernance(address _newGovernor) external onlyGovernor {
        _setPendingGovernor(_newGovernor);
        emit PendingGovernorshipTransfer(_governor(), _newGovernor);
    }

    /**
     * @dev Claim Governance of the contract to a new account (`newGovernor`).
     * Can only be called by the new Governor.
     */
    function claimGovernance() external {
        require(
            msg.sender == _pendingGovernor(),
            "Only the pending Governor can complete the claim"
        );
        _changeGovernor(msg.sender);
    }

    /**
     * @dev Change Governance of the contract to a new account (`newGovernor`).
     * @param _newGovernor Address of the new Governor
     */
    function _changeGovernor(address _newGovernor) internal {
        require(_newGovernor != address(0), "New Governor is address(0)");
        emit GovernorshipTransferred(_governor(), _newGovernor);
        _setGovernor(_newGovernor);
    }
}

// File: @openzeppelin/contracts/GSN/Context.sol

pragma solidity ^0.5.0;

/*
 * @dev Provides information about the current execution context, including the
 * sender of the transaction and its data. While these are generally available
 * via msg.sender and msg.data, they should not be accessed in such a direct
 * manner, since when dealing with GSN meta-transactions the account sending and
 * paying for execution may not be the actual sender (as far as an application
 * is concerned).
 *
 * This contract is only required for intermediate, library-like contracts.
 */
contract Context {
    // Empty internal constructor, to prevent people from mistakenly deploying
    // an instance of this contract, which should be used via inheritance.
    constructor () internal { }
    // solhint-disable-previous-line no-empty-blocks

    function _msgSender() internal view returns (address payable) {
        return msg.sender;
    }

    function _msgData() internal view returns (bytes memory) {
        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691
        return msg.data;
    }
}

// File: @openzeppelin/contracts/token/ERC20/ERC20.sol

pragma solidity ^0.5.0;



/**
 * @dev Implementation of the {IERC20} interface.
 *
 * This implementation is agnostic to the way tokens are created. This means
 * that a supply mechanism has to be added in a derived contract using {_mint}.
 * For a generic mechanism see {ERC20Mintable}.
 *
 * TIP: For a detailed writeup see our guide
 * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How
 * to implement supply mechanisms].
 *
 * We have followed general OpenZeppelin guidelines: functions revert instead
 * of returning `false` on failure. This behavior is nonetheless conventional
 * and does not conflict with the expectations of ERC20 applications.
 *
 * Additionally, an {Approval} event is emitted on calls to {transferFrom}.
 * This allows applications to reconstruct the allowance for all accounts just
 * by listening to said events. Other implementations of the EIP may not emit
 * these events, as it isn't required by the specification.
 *
 * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}
 * functions have been added to mitigate the well-known issues around setting
 * allowances. See {IERC20-approve}.
 */
contract ERC20 is Context, IERC20 {
    using SafeMath for uint256;

    mapping (address =&gt; uint256) private _balances;

    mapping (address =&gt; mapping (address =&gt; uint256)) private _allowances;

    uint256 private _totalSupply;

    /**
     * @dev See {IERC20-totalSupply}.
     */
    function totalSupply() public view returns (uint256) {
        return _totalSupply;
    }

    /**
     * @dev See {IERC20-balanceOf}.
     */
    function balanceOf(address account) public view returns (uint256) {
        return _balances[account];
    }

    /**
     * @dev See {IERC20-transfer}.
     *
     * Requirements:
     *
     * - `recipient` cannot be the zero address.
     * - the caller must have a balance of at least `amount`.
     */
    function transfer(address recipient, uint256 amount) public returns (bool) {
        _transfer(_msgSender(), recipient, amount);
        return true;
    }

    /**
     * @dev See {IERC20-allowance}.
     */
    function allowance(address owner, address spender) public view returns (uint256) {
        return _allowances[owner][spender];
    }

    /**
     * @dev See {IERC20-approve}.
     *
     * Requirements:
     *
     * - `spender` cannot be the zero address.
     */
    function approve(address spender, uint256 amount) public returns (bool) {
        _approve(_msgSender(), spender, amount);
        return true;
    }

    /**
     * @dev See {IERC20-transferFrom}.
     *
     * Emits an {Approval} event indicating the updated allowance. This is not
     * required by the EIP. See the note at the beginning of {ERC20};
     *
     * Requirements:
     * - `sender` and `recipient` cannot be the zero address.
     * - `sender` must have a balance of at least `amount`.
     * - the caller must have allowance for `sender`'s tokens of at least
     * `amount`.
     */
    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {
        _transfer(sender, recipient, amount);
        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, "ERC20: transfer amount exceeds allowance"));
        return true;
    }

    /**
     * @dev Atomically increases the allowance granted to `spender` by the caller.
     *
     * This is an alternative to {approve} that can be used as a mitigation for
     * problems described in {IERC20-approve}.
     *
     * Emits an {Approval} event indicating the updated allowance.
     *
     * Requirements:
     *
     * - `spender` cannot be the zero address.
     */
    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {
        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));
        return true;
    }

    /**
     * @dev Atomically decreases the allowance granted to `spender` by the caller.
     *
     * This is an alternative to {approve} that can be used as a mitigation for
     * problems described in {IERC20-approve}.
     *
     * Emits an {Approval} event indicating the updated allowance.
     *
     * Requirements:
     *
     * - `spender` cannot be the zero address.
     * - `spender` must have allowance for the caller of at least
     * `subtractedValue`.
     */
    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {
        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, "ERC20: decreased allowance below zero"));
        return true;
    }

    /**
     * @dev Moves tokens `amount` from `sender` to `recipient`.
     *
     * This is internal function is equivalent to {transfer}, and can be used to
     * e.g. implement automatic token fees, slashing mechanisms, etc.
     *
     * Emits a {Transfer} event.
     *
     * Requirements:
     *
     * - `sender` cannot be the zero address.
     * - `recipient` cannot be the zero address.
     * - `sender` must have a balance of at least `amount`.
     */
    function _transfer(address sender, address recipient, uint256 amount) internal {
        require(sender != address(0), "ERC20: transfer from the zero address");
        require(recipient != address(0), "ERC20: transfer to the zero address");

        _balances[sender] = _balances[sender].sub(amount, "ERC20: transfer amount exceeds balance");
        _balances[recipient] = _balances[recipient].add(amount);
        emit Transfer(sender, recipient, amount);
    }

    /** @dev Creates `amount` tokens and assigns them to `account`, increasing
     * the total supply.
     *
     * Emits a {Transfer} event with `from` set to the zero address.
     *
     * Requirements
     *
     * - `to` cannot be the zero address.
     */
    function _mint(address account, uint256 amount) internal {
        require(account != address(0), "ERC20: mint to the zero address");

        _totalSupply = _totalSupply.add(amount);
        _balances[account] = _balances[account].add(amount);
        emit Transfer(address(0), account, amount);
    }

    /**
     * @dev Destroys `amount` tokens from `account`, reducing the
     * total supply.
     *
     * Emits a {Transfer} event with `to` set to the zero address.
     *
     * Requirements
     *
     * - `account` cannot be the zero address.
     * - `account` must have at least `amount` tokens.
     */
    function _burn(address account, uint256 amount) internal {
        require(account != address(0), "ERC20: burn from the zero address");

        _balances[account] = _balances[account].sub(amount, "ERC20: burn amount exceeds balance");
        _totalSupply = _totalSupply.sub(amount);
        emit Transfer(account, address(0), amount);
    }

    /**
     * @dev Sets `amount` as the allowance of `spender` over the `owner`s tokens.
     *
     * This is internal function is equivalent to `approve`, and can be used to
     * e.g. set automatic allowances for certain subsystems, etc.
     *
     * Emits an {Approval} event.
     *
     * Requirements:
     *
     * - `owner` cannot be the zero address.
     * - `spender` cannot be the zero address.
     */
    function _approve(address owner, address spender, uint256 amount) internal {
        require(owner != address(0), "ERC20: approve from the zero address");
        require(spender != address(0), "ERC20: approve to the zero address");

        _allowances[owner][spender] = amount;
        emit Approval(owner, spender, amount);
    }

    /**
     * @dev Destroys `amount` tokens from `account`.`amount` is then deducted
     * from the caller's allowance.
     *
     * See {_burn} and {_approve}.
     */
    function _burnFrom(address account, uint256 amount) internal {
        _burn(account, amount);
        _approve(account, _msgSender(), _allowances[account][_msgSender()].sub(amount, "ERC20: burn amount exceeds allowance"));
    }
}

// File: contracts/utils/InitializableERC20Detailed.sol

pragma solidity 0.5.11;

/**
 * @dev Optional functions from the ERC20 standard.
 * Converted from openzeppelin/contracts/token/ERC20/ERC20Detailed.sol
 */
contract InitializableERC20Detailed is IERC20 {
    string private _name;
    string private _symbol;
    uint8 private _decimals;

    /**
     * @dev Sets the values for `name`, `symbol`, and `decimals`. All three of
     * these values are immutable: they can only be set once during
     * construction.
     * @notice To avoid variable shadowing appended `Arg` after arguments name.
     */
    function _initialize(
        string memory nameArg,
        string memory symbolArg,
        uint8 decimalsArg
    ) internal {
        _name = nameArg;
        _symbol = symbolArg;
        _decimals = decimalsArg;
    }

    /**
     * @dev Returns the name of the token.
     */
    function name() public view returns (string memory) {
        return _name;
    }

    /**
     * @dev Returns the symbol of the token, usually a shorter version of the
     * name.
     */
    function symbol() public view returns (string memory) {
        return _symbol;
    }

    /**
     * @dev Returns the number of decimals used to get its user representation.
     * For example, if `decimals` equals `2`, a balance of `505` tokens should
     * be displayed to a user as `5,05` (`505 / 10 ** 2`).
     *
     * Tokens usually opt for a value of 18, imitating the relationship between
     * Ether and Wei.
     *
     * NOTE: This information is only used for _display_ purposes: it in
     * no way affects any of the arithmetic of the contract, including
     * {IERC20-balanceOf} and {IERC20-transfer}.
     */
    function decimals() public view returns (uint8) {
        return _decimals;
    }
}

// File: contracts/utils/InitializableToken.sol

pragma solidity 0.5.11;


contract InitializableToken is ERC20, InitializableERC20Detailed {
    /**
     * @dev Initialization function for implementing contract
     * @notice To avoid variable shadowing appended `Arg` after arguments name.
     */
    function _initialize(string memory _nameArg, string memory _symbolArg)
        internal
    {
        InitializableERC20Detailed._initialize(_nameArg, _symbolArg, 18);
    }
}

// File: contracts/utils/StableMath.sol

pragma solidity 0.5.11;

// Based on StableMath from Stability Labs Pty. Ltd.
// https://github.com/mstable/mStable-contracts/blob/master/contracts/shared/StableMath.sol

library StableMath {
    using SafeMath for uint256;

    /**
     * @dev Scaling unit for use in specific calculations,
     * where 1 * 10**18, or 1e18 represents a unit '1'
     */
    uint256 private constant FULL_SCALE = 1e18;

    /***************************************
                    Helpers
    ****************************************/

    /**
     * @dev Adjust the scale of an integer
     * @param adjustment Amount to adjust by e.g. scaleBy(1e18, -1) == 1e17
     */
    function scaleBy(uint256 x, int8 adjustment)
        internal
        pure
        returns (uint256)
    {
        if (adjustment &gt; 0) {
            x = x.mul(10**uint256(adjustment));
        } else if (adjustment &lt; 0) {
            x = x.div(10**uint256(adjustment * -1));
        }
        return x;
    }

    /***************************************
               Precise Arithmetic
    ****************************************/

    /**
     * @dev Multiplies two precise units, and then truncates by the full scale
     * @param x Left hand input to multiplication
     * @param y Right hand input to multiplication
     * @return Result after multiplying the two inputs and then dividing by the shared
     *         scale unit
     */
    function mulTruncate(uint256 x, uint256 y) internal pure returns (uint256) {
        return mulTruncateScale(x, y, FULL_SCALE);
    }

    /**
     * @dev Multiplies two precise units, and then truncates by the given scale. For example,
     * when calculating 90% of 10e18, (10e18 * 9e17) / 1e18 = (9e36) / 1e18 = 9e18
     * @param x Left hand input to multiplication
     * @param y Right hand input to multiplication
     * @param scale Scale unit
     * @return Result after multiplying the two inputs and then dividing by the shared
     *         scale unit
     */
    function mulTruncateScale(
        uint256 x,
        uint256 y,
        uint256 scale
    ) internal pure returns (uint256) {
        // e.g. assume scale = fullScale
        // z = 10e18 * 9e17 = 9e36
        uint256 z = x.mul(y);
        // return 9e38 / 1e18 = 9e18
        return z.div(scale);
    }

    /**
     * @dev Multiplies two precise units, and then truncates by the full scale, rounding up the result
     * @param x Left hand input to multiplication
     * @param y Right hand input to multiplication
     * @return Result after multiplying the two inputs and then dividing by the shared
     *          scale unit, rounded up to the closest base unit.
     */
    function mulTruncateCeil(uint256 x, uint256 y)
        internal
        pure
        returns (uint256)
    {
        // e.g. 8e17 * 17268172638 = 138145381104e17
        uint256 scaled = x.mul(y);
        // e.g. 138145381104e17 + 9.99...e17 = 138145381113.99...e17
        uint256 ceil = scaled.add(FULL_SCALE.sub(1));
        // e.g. 13814538111.399...e18 / 1e18 = 13814538111
        return ceil.div(FULL_SCALE);
    }

    /**
     * @dev Precisely divides two units, by first scaling the left hand operand. Useful
     *      for finding percentage weightings, i.e. 8e18/10e18 = 80% (or 8e17)
     * @param x Left hand input to division
     * @param y Right hand input to division
     * @return Result after multiplying the left operand by the scale, and
     *         executing the division on the right hand input.
     */
    function divPrecisely(uint256 x, uint256 y)
        internal
        pure
        returns (uint256)
    {
        // e.g. 8e18 * 1e18 = 8e36
        uint256 z = x.mul(FULL_SCALE);
        // e.g. 8e36 / 10e18 = 8e17
        return z.div(y);
    }
}

// File: contracts/token/OUSD.sol

pragma solidity 0.5.11;

/**
 * @title OUSD Token Contract
 * @notice ERC20 compatible contract for OUSD
 * @dev Implements an elastic supply
 * @author Origin Protocol Inc
 */




contract OUSD is Initializable, InitializableToken, Governable {
    using SafeMath for uint256;
    using StableMath for uint256;

    event TotalSupplyUpdated(
        uint256 totalSupply,
        uint256 totalCredits,
        uint256 creditsPerToken
    );

    uint256 private constant MAX_SUPPLY = ~uint128(0); // (2^128) - 1

    uint256 private _totalSupply;
    uint256 private totalCredits;
    // Exchange rate between internal credits and OUSD
    uint256 private creditsPerToken;

    mapping(address =&gt; uint256) private _creditBalances;

    // Allowances denominated in OUSD
    mapping(address =&gt; mapping(address =&gt; uint256)) private _allowances;

    address public vaultAddress = address(0);

    function initialize(
        string calldata _nameArg,
        string calldata _symbolArg,
        address _vaultAddress
    ) external onlyGovernor initializer {
        InitializableToken._initialize(_nameArg, _symbolArg);

        _totalSupply = 0;
        totalCredits = 0;
        creditsPerToken = 1e18;

        vaultAddress = _vaultAddress;
    }

    /**
     * @dev Verifies that the caller is the Savings Manager contract
     */
    modifier onlyVault() {
        require(vaultAddress == msg.sender, "Caller is not the Vault");
        _;
    }

    /**
     * @return The total supply of OUSD.
     */
    function totalSupply() public view returns (uint256) {
        return _totalSupply;
    }

    /**
     * @dev Gets the balance of the specified address.
     * @param _account The address to query the balance of.
     * @return A unit256 representing the _amount of base units owned by the
     *         specified address.
     */
    function balanceOf(address _account) public view returns (uint256) {
        if (creditsPerToken == 0) return 0;
        return _creditBalances[_account].divPrecisely(creditsPerToken);
    }

    /**
     * @dev Gets the credits balance of the specified address.
     * @param _account The address to query the balance of.
     * @return A uint256 representing the _amount of base units owned by the
     *         specified address.
     */
    function creditsBalanceOf(address _account) public view returns (uint256) {
        return _creditBalances[_account];
    }

    /**
     * @dev Transfer tokens to a specified address.
     * @param _to the address to transfer to.
     * @param _value the _amount to be transferred.
     * @return true on success.
     */
    function transfer(address _to, uint256 _value) public returns (bool) {
        uint256 creditValue = _removeCredits(msg.sender, _value);
        _creditBalances[_to] = _creditBalances[_to].add(creditValue);

        emit Transfer(msg.sender, _to, _value);

        return true;
    }

    /**
     * @dev Transfer tokens from one address to another.
     * @param _from The address you want to send tokens from.
     * @param _to The address you want to transfer to.
     * @param _value The _amount of tokens to be transferred.
     */
    function transferFrom(
        address _from,
        address _to,
        uint256 _value
    ) public returns (bool) {
        _allowances[_from][msg.sender] = _allowances[_from][msg.sender].sub(
            _value
        );

        uint256 creditValue = _removeCredits(_from, _value);
        _creditBalances[_to] = _creditBalances[_to].add(creditValue);

        emit Transfer(_from, _to, _value);

        return true;
    }

    /**
     * @dev Function to check the _amount of tokens that an owner has allowed to a _spender.
     * @param _owner The address which owns the funds.
     * @param _spender The address which will spend the funds.
     * @return The number of tokens still available for the _spender.
     */
    function allowance(address _owner, address _spender)
        public
        view
        returns (uint256)
    {
        return _allowances[_owner][_spender];
    }

    /**
     * @dev Approve the passed address to spend the specified _amount of tokens on behalf of
     * msg.sender. This method is included for ERC20 compatibility.
     * increaseAllowance and decreaseAllowance should be used instead.
     * Changing an allowance with this method brings the risk that someone may transfer both
     * the old and the new allowance - if they are both greater than zero - if a transfer
     * transaction is mined before the later approve() call is mined.
     *
     * @param _spender The address which will spend the funds.
     * @param _value The _amount of tokens to be spent.
     */
    function approve(address _spender, uint256 _value) public returns (bool) {
        _allowances[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value);
        return true;
    }

    /**
     * @dev Increase the _amount of tokens that an owner has allowed to a _spender.
     * This method should be used instead of approve() to avoid the double approval vulnerability
     * described above.
     * @param _spender The address which will spend the funds.
     * @param _addedValue The _amount of tokens to increase the allowance by.
     */
    function increaseAllowance(address _spender, uint256 _addedValue)
        public
        returns (bool)
    {
        _allowances[msg.sender][_spender] = _allowances[msg.sender][_spender]
            .add(_addedValue);
        emit Approval(msg.sender, _spender, _allowances[msg.sender][_spender]);
        return true;
    }

    /**
     * @dev Decrease the _amount of tokens that an owner has allowed to a _spender.
     * @param _spender The address which will spend the funds.
     * @param _subtractedValue The _amount of tokens to decrease the allowance by.
     */
    function decreaseAllowance(address _spender, uint256 _subtractedValue)
        public
        returns (bool)
    {
        uint256 oldValue = _allowances[msg.sender][_spender];
        if (_subtractedValue &gt;= oldValue) {
            _allowances[msg.sender][_spender] = 0;
        } else {
            _allowances[msg.sender][_spender] = oldValue.sub(_subtractedValue);
        }
        emit Approval(msg.sender, _spender, _allowances[msg.sender][_spender]);
        return true;
    }

    /**
     * @notice Mints new tokens, increasing totalSupply.
     */
    function mint(address _account, uint256 _amount) external onlyVault {
        return _mint(_account, _amount);
    }

    /**
     * @dev Creates `_amount` tokens and assigns them to `_account`, increasing
     * the total supply.
     *
     * Emits a {Transfer} event with `from` set to the zero address.
     *
     * Requirements
     *
     * - `to` cannot be the zero address.
     */
    function _mint(address _account, uint256 _amount) internal {
        require(_account != address(0), "Mint to the zero address");

        _totalSupply = _totalSupply.add(_amount);

        uint256 creditAmount = _amount.mulTruncate(creditsPerToken);
        _creditBalances[_account] = _creditBalances[_account].add(creditAmount);
        totalCredits = totalCredits.add(creditAmount);

        emit Transfer(address(0), _account, _amount);
    }

    /**
     * @notice Burns tokens, decreasing totalSupply.
     */
    function burn(address account, uint256 amount) external onlyVault {
        return _burn(account, amount);
    }

    /**
     * @dev Destroys `_amount` tokens from `_account`, reducing the
     * total supply.
     *
     * Emits a {Transfer} event with `to` set to the zero address.
     *
     * Requirements
     *
     * - `_account` cannot be the zero address.
     * - `_account` must have at least `_amount` tokens.
     */
    function _burn(address _account, uint256 _amount) internal {
        require(_account != address(0), "Burn from the zero address");

        _totalSupply = _totalSupply.sub(_amount);
        uint256 creditAmount = _removeCredits(_account, _amount);
        totalCredits = totalCredits.sub(creditAmount);

        emit Transfer(_account, address(0), _amount);
    }

    /**
     * @dev Removes credits from a credit balance and burns rounding errors.
     * @param _account Account to remove credits from
     * @param _amount Amount in OUSD which will be converted to credits and
     *                removed
     */
    function _removeCredits(address _account, uint256 _amount)
        internal
        returns (uint256 creditAmount)
    {
        creditAmount = _amount.mulTruncate(creditsPerToken);
        uint256 currentCredits = _creditBalances[_account];
        if (
            currentCredits == creditAmount || currentCredits - 1 == creditAmount
        ) {
            _creditBalances[_account] = 0;
        } else if (currentCredits &gt; creditAmount) {
            _creditBalances[_account] = currentCredits - creditAmount;
        } else {
            revert("Remove exceeds balance");
        }
    }

    /**
     * @dev Modify the supply without minting new tokens. This uses a change in
     *      the exchange rate between "credits" and OUSD tokens to change balances.
     * @param _newTotalSupply New total supply of OUSD.
     * @return uint256 representing the new total supply.
     */
    function changeSupply(uint256 _newTotalSupply)
        external
        onlyVault
        returns (uint256)
    {
        require(_totalSupply &gt; 0, "Cannot increase 0 supply");

        if (_totalSupply == _newTotalSupply) {
            emit TotalSupplyUpdated(
                _totalSupply,
                totalCredits,
                creditsPerToken
            );
            return _totalSupply;
        }

        _totalSupply = _newTotalSupply;

        if (_totalSupply &gt; MAX_SUPPLY) _totalSupply = MAX_SUPPLY;

        creditsPerToken = totalCredits.divPrecisely(_totalSupply);

        emit TotalSupplyUpdated(_totalSupply, totalCredits, creditsPerToken);
        return _totalSupply;
    }
}

// File: contracts/interfaces/IBasicToken.sol

pragma solidity 0.5.11;

interface IBasicToken {
    function symbol() external view returns (string memory);

    function decimals() external view returns (uint8);
}

// File: contracts/utils/Helpers.sol

pragma solidity 0.5.11;

library Helpers {
    /**
     * @notice Fetch the `symbol()` from an ERC20 token
     * @dev Grabs the `symbol()` from a contract
     * @param _token Address of the ERC20 token
     * @return string Symbol of the ERC20 token
     */
    function getSymbol(address _token) internal view returns (string memory) {
        string memory symbol = IBasicToken(_token).symbol();
        return symbol;
    }

    /**
     * @notice Fetch the `decimals()` from an ERC20 token
     * @dev Grabs the `decimals()` from a contract and fails if
     *      the decimal value does not live within a certain range
     * @param _token Address of the ERC20 token
     * @return uint256 Decimals of the ERC20 token
     */
    function getDecimals(address _token) internal view returns (uint256) {
        uint256 decimals = IBasicToken(_token).decimals();
        require(
            decimals &gt;= 4 &amp;&amp; decimals &lt;= 18,
            "Token must have sufficient decimal places"
        );

        return decimals;
    }
}

// File: contracts/vault/VaultStorage.sol

pragma solidity 0.5.11;

/**
 * @title OUSD VaultStorage Contract
 * @notice The VaultStorage contract defines the storage for the Vault contracts
 * @author Origin Protocol Inc
 */








contract VaultStorage is Initializable, Governable {
    using SafeMath for uint256;
    using StableMath for uint256;
    using SafeMath for int256;
    using SafeERC20 for IERC20;

    event AssetSupported(address _asset);
    event StrategyAdded(address _addr);
    event StrategyRemoved(address _addr);
    event Mint(address _addr, uint256 _value);
    event Redeem(address _addr, uint256 _value);
    event StrategyWeightsUpdated(
        address[] _strategyAddresses,
        uint256[] weights
    );
    event DepositsPaused();
    event DepositsUnpaused();

    // Assets supported by the Vault, i.e. Stablecoins
    struct Asset {
        bool isSupported;
    }
    mapping(address =&gt; Asset) assets;
    address[] allAssets;

    // Strategies supported by the Vault
    struct Strategy {
        bool isSupported;
        uint256 targetWeight; // 18 decimals. 100% = 1e18
    }
    mapping(address =&gt; Strategy) strategies;
    address[] allStrategies;

    // Address of the Oracle price provider contract
    address public priceProvider;
    // Pausing bools
    bool public rebasePaused = false;
    bool public depositPaused = true;
    // Redemption fee in basis points
    uint256 public redeemFeeBps;
    // Buffer of assets to keep in Vault to handle (most) withdrawals
    uint256 public vaultBuffer;
    // Mints over this amount automatically allocate funds. 18 decimals.
    uint256 public autoAllocateThreshold;
    // Mints over this amount automatically rebase. 18 decimals.
    uint256 public rebaseThreshold;

    OUSD oUSD;

    //keccak256("OUSD.vault.governor.admin.impl");
    bytes32 constant adminImplPosition = 0xa2bd3d3cf188a41358c8b401076eb59066b09dec5775650c0de4c55187d17bd9;

    // Address of the contract responsible for post rebase syncs with AMMs
    address public rebaseHooksAddr = address(0);

    // Address of Uniswap
    address public uniswapAddr = address(0);

    /**
     * @dev set the implementation for the admin, this needs to be in a base class else we cannot set it
     * @param newImpl address pf the implementation
     */
    function setAdminImpl(address newImpl) external onlyGovernor {
        bytes32 position = adminImplPosition;
        assembly {
            sstore(position, newImpl)
        }
    }
}

// File: contracts/interfaces/IMinMaxOracle.sol

pragma solidity 0.5.11;

interface IMinMaxOracle {
    //Assuming 8 decimals
    function priceMin(string calldata symbol) external returns (uint256);

    function priceMax(string calldata symbol) external returns (uint256);
}

interface IViewMinMaxOracle {
    function priceMin(string calldata symbol) external view returns (uint256);

    function priceMax(string calldata symbol) external view returns (uint256);
}

// File: contracts/interfaces/IRebaseHooks.sol

pragma solidity 0.5.11;

interface IRebaseHooks {
    function postRebase(bool sync) external;
}

// File: contracts/vault/VaultCore.sol

pragma solidity 0.5.11;

/**
 * @title OUSD Vault Contract
 * @notice The Vault contract stores assets. On a deposit, OUSD will be minted
           and sent to the depositor. On a withdrawal, OUSD will be burned and
           assets will be sent to the withdrawer. The Vault accepts deposits of
           interest form yield bearing strategies which will modify the supply
           of OUSD.
 * @author Origin Protocol Inc
 */



contract VaultCore is VaultStorage {
    /**
     * @dev Verifies that the rebasing is not paused.
     */
    modifier whenNotRebasePaused() {
        require(!rebasePaused, "Rebasing paused");
        _;
    }

    /**
     * @dev Verifies that the deposits are not paused.
     */
    modifier whenNotDepositPaused() {
        require(!depositPaused, "Deposits paused");
        _;
    }

    /**
     * @dev Deposit a supported asset and mint OUSD.
     * @param _asset Address of the asset being deposited
     * @param _amount Amount of the asset being deposited
     */
    function mint(address _asset, uint256 _amount)
        external
        whenNotDepositPaused
    {
        require(assets[_asset].isSupported, "Asset is not supported");
        require(_amount &gt; 0, "Amount must be greater than 0");

        <span class="marker" id="mapping-178"></span><span class="token add" data-title="function_body/variable_declaration_statement"><span class="marker" id="mapping-179"></span><span class="token mv" id="move-dst-10" data-title="variable_declaration_statement/variable_declaration">uint256 <span class="marker" id="mapping-180"></span><span class="token upd" id="move-dst-11" data-title="variable_declaration/identifier">price</span></span> = <span class="marker" id="mapping-181"></span><span class="token mv" id="move-dst-6" data-title="variable_declaration_statement/call_expression">IMinMaxOracle(priceProvider).priceMin(
            Helpers.getSymbol(_asset)
        )</span>;</span>
        if (<span class="marker" id="mapping-182"></span><span class="token add" data-title="binary_expression/identifier">price</span> <span class="marker" id="mapping-183"></span><span class="token add" data-title="binary_expression/>">&gt;</span> <span class="marker" id="mapping-184"></span><span class="token add" data-title="binary_expression/number_literal">1e8</span>) {
            <span class="marker" id="mapping-185"></span><span class="token upd" id="move-dst-7" data-title="assignment_expression/identifier">p<span class="cupd">rice</span></span> = <span class="marker" id="mapping-186"></span><span class="token add" data-title="assignment_expression/number_literal">1e8</span>;
        }
        <span class="marker" id="mapping-187"></span><span class="token mv" id="move-dst-5" data-title="function_body/variable_declaration_statement">uint256 priceAdjustedDeposit = _amount.mulTruncateScale(
            <span class="marker" id="mapping-188"></span><span class="token add" data-title="member_expression/identifier">price</span>.scaleBy(int8(10)), // 18-8 because oracles have 8 decimals precision
            10**Helpers.getDecimals(_asset)
        );</span>

        // Rebase must happen before any transfers occur.
        if (priceAdjustedDeposit &gt; rebaseThreshold &amp;&amp; !rebasePaused) {
            rebase(true);
        }

        // Transfer the deposited coins to the vault
        IERC20 asset = IERC20(_asset);
        asset.safeTransferFrom(msg.sender, address(this), _amount);

        // Mint matching OUSD
        oUSD.mint(msg.sender, priceAdjustedDeposit);
        emit Mint(msg.sender, priceAdjustedDeposit);

        if (priceAdjustedDeposit &gt;= autoAllocateThreshold) {
            allocate();
        }
    }

    /**
     * @dev Mint for multiple assets in the same call.
     * @param _assets Addresses of assets being deposited
     * @param _amounts Amount of each asset at the same index in the _assets
     *                 to deposit.
     */
    function mintMultiple(
        address[] calldata _assets,
        uint256[] calldata _amounts
    ) external whenNotDepositPaused {
        require(_assets.length == _amounts.length, "Parameter length mismatch");

        uint256 priceAdjustedTotal = 0;
        uint256[] memory assetPrices = _getAssetPrices(false);
        for (uint256 i = 0; i &lt; allAssets.length; i++) {
            for (uint256 j = 0; j &lt; _assets.length; j++) {
                if (_assets[j] == allAssets[i]) {
                    if (_amounts[j] &gt; 0) {
                        uint256 assetDecimals = Helpers.getDecimals(
                            allAssets[i]
                        );
                        <span class="marker" id="mapping-189"></span><span class="token add" data-title="block_statement/variable_declaration_statement"><span class="marker" id="mapping-190"></span><span class="token add" data-title="variable_declaration_statement/variable_declaration">uint256 price</span> = <span class="marker" id="mapping-191"></span><span class="token mv" id="move-dst-8" data-title="variable_declaration_statement/array_access">assetPrices[i]</span>;</span>
                        <span class="marker" id="mapping-192"></span><span class="token add" data-title="block_statement/if_statement">if (price &gt; 1e18) {
                            price = 1e18;
                        }</span>
                        priceAdjustedTotal += _amounts[j].mulTruncateScale(
                            <span class="marker" id="mapping-193"></span><span class="token add" data-title="call_argument/identifier">price</span>,
                            10**assetDecimals
                        );
                    }
                }
            }
        }
        // Rebase must happen before any transfers occur.
        if (priceAdjustedTotal &gt; rebaseThreshold &amp;&amp; !rebasePaused) {
            rebase(true);
        }

        for (uint256 i = 0; i &lt; _assets.length; i++) {
            IERC20 asset = IERC20(_assets[i]);
            asset.safeTransferFrom(msg.sender, address(this), _amounts[i]);
        }

        oUSD.mint(msg.sender, priceAdjustedTotal);
        emit Mint(msg.sender, priceAdjustedTotal);

        if (priceAdjustedTotal &gt;= autoAllocateThreshold) {
            allocate();
        }
    }

    /**
     * @dev Withdraw a supported asset and burn OUSD.
     * @param _amount Amount of OUSD to burn
     */
    function redeem(uint256 _amount) public {
        if (_amount &gt; rebaseThreshold &amp;&amp; !rebasePaused) {
            rebase(false);
        }
        _redeem(_amount);
    }

    function _redeem(uint256 _amount) internal {
        require(_amount &gt; 0, "Amount must be greater than 0");

        // Calculate redemption outputs
        uint256[] memory outputs = _calculateRedeemOutputs(<span class="marker" id="mapping-194"></span><span class="token mv" id="move-dst-40" data-title="call_expression/call_argument">_amount</span>);
        // Send outputs
        for (uint256 i = 0; i &lt; allAssets.length; i++) {
            if (outputs[i] == 0) continue;

            IERC20 asset = IERC20(allAssets[i]);

            if (asset.balanceOf(address(this)) &gt;= outputs[i]) {
                // Use Vault funds first if sufficient
                asset.safeTransfer(msg.sender, outputs[i]);
            } else {
                address strategyAddr = _selectWithdrawStrategyAddr(
                    allAssets[i],
                    outputs[i]
                );

                if (strategyAddr != address(0)) {
                    // Nothing in Vault, but something in Strategy, send from there
                    IStrategy strategy = IStrategy(strategyAddr);
                    strategy.withdraw(msg.sender, allAssets[i], outputs[i]);
                } else {
                    // Cant find funds anywhere
                    revert("Liquidity error");
                }
            }
        }

        oUSD.burn(msg.sender, _amount);

        // Until we can prove that we won't affect the prices of our assets
        // by withdrawing them, this should be here.
        // It's possible that a strategy was off on its asset total, perhaps
        // a reward token sold for more or for less than anticipated.
        if (_amount &gt; rebaseThreshold &amp;&amp; !rebasePaused) {
            rebase(true);
        }

        emit Redeem(msg.sender, _amount);
    }

    /**
     * @notice Withdraw a supported asset and burn all OUSD.
     */
    function redeemAll() external {
        //unfortunately we have to do balanceOf twice
        if (oUSD.balanceOf(msg.sender) &gt; rebaseThreshold &amp;&amp; !rebasePaused) {
            rebase(false);
        }
        _redeem(oUSD.balanceOf(msg.sender));
    }

    /**
     * @notice Allocate unallocated funds on Vault to strategies.
     * @dev Allocate unallocated funds on Vault to strategies.
     **/
    <span class="marker" id="mapping-195"></span><span class="token add" data-title="contract_body/function_definition">function allocate() <span class="marker" id="mapping-196"></span><span class="token mv" id="move-dst-14" data-title="function_definition/visibility">public</span> <span class="marker" id="mapping-197"></span><span class="token add" data-title="function_definition/function_body">{
        _allocate();
    }</span></span>

    /**
     * @notice Allocate unallocated funds on Vault to strategies.
     * @dev Allocate unallocated funds on Vault to strategies.
     **/
    function <span class="marker" id="mapping-198"></span><span class="token upd" id="move-dst-15" data-title="function_definition/identifier">_<span class="cupd">allocate</span></span>() internal {
        uint256 vaultValue = _totalValueInVault();
        // Nothing in vault to allocate
        if (vaultValue == 0) return;
        uint256 strategiesValue = _totalValueInStrategies();
        // We have a method that does the same as this, gas optimisation
        uint256 totalValue = vaultValue + strategiesValue;

        // We want to maintain a buffer on the Vault so calculate a percentage
        // modifier to multiply each amount being allocated by to enforce the
        // vault buffer
        uint256 vaultBufferModifier;
        if (strategiesValue == 0) {
            // Nothing in Strategies, allocate 100% minus the vault buffer to
            // strategies
            vaultBufferModifier = 1e18 - vaultBuffer;
        } else {
            vaultBufferModifier = vaultBuffer.mul(totalValue).div(vaultValue);
            if (1e18 &gt; vaultBufferModifier) {
                // E.g. 1e18 - (1e17 * 10e18)/5e18 = 8e17
                // (5e18 * 8e17) / 1e18 = 4e18 allocated from Vault
                vaultBufferModifier = 1e18 - vaultBufferModifier;
            } else {
                // We need to let the buffer fill
                return;
            }
        }
        if (vaultBufferModifier == 0) return;

        // Iterate over all assets in the Vault and allocate the the appropriate
        // strategy
        for (uint256 i = 0; i &lt; allAssets.length; i++) {
            IERC20 asset = IERC20(allAssets[i]);
            uint256 assetBalance = asset.balanceOf(address(this));
            // No balance, nothing to do here
            if (assetBalance == 0) continue;

            // Multiply the balance by the vault buffer modifier and truncate
            // to the scale of the asset decimals
            uint256 allocateAmount = assetBalance.mulTruncate(
                vaultBufferModifier
            );

            // Get the target Strategy to maintain weightings
            address depositStrategyAddr = _selectDepositStrategyAddr(
                address(asset)
            );

            if (depositStrategyAddr != address(0) &amp;&amp; allocateAmount &gt; 0) {
                IStrategy strategy = IStrategy(depositStrategyAddr);
                // Transfer asset to Strategy and call deposit method to
                // mint or take required action
                asset.safeTransfer(address(strategy), allocateAmount);
                strategy.deposit(address(asset), allocateAmount);
            }
        }
    }

    /**
     * @dev Calculate the total value of assets held by the Vault and all
     *         strategies and update the supply of oUSD
     */
    function rebase() public whenNotRebasePaused returns (uint256) {
        rebase(true);
    }

    /**
     * @dev Calculate the total value of assets held by the Vault and all
     *         strategies and update the supply of oUSD
     */
    function rebase(bool sync) internal whenNotRebasePaused returns (uint256) {
        if (oUSD.totalSupply() == 0) return 0;
        uint256 oldTotalSupply = oUSD.totalSupply();
        uint256 newTotalSupply = <span class="marker" id="mapping-199"></span><span class="token add" data-title="variable_declaration_statement/call_expression">_totalValue()</span>;
        <span class="marker" id="mapping-200"></span><span class="token add" data-title="function_body/comment">// Only rachet upwards</span>
        <span class="marker" id="mapping-201"></span><span class="token add" data-title="function_body/if_statement">if (<span class="marker" id="mapping-202"></span><span class="token add" data-title="if_statement/binary_expression">newTotalSupply &gt; oldTotalSupply</span>) <span class="marker" id="mapping-203"></span><span class="token add" data-title="if_statement/block_statement">{
            <span class="marker" id="mapping-204"></span><span class="token add" data-title="block_statement/expression_statement"><span class="marker" id="mapping-205"></span><span class="token mv" id="move-dst-17" data-title="expression_statement/call_expression">oUSD.changeSupply(<span class="marker" id="mapping-206"></span><span class="token add" data-title="call_argument/identifier">newTotalSupply</span>)</span>;</span>
            <span class="marker" id="mapping-207"></span><span class="token mv" id="move-dst-18" data-title="block_statement/if_statement">if (<span class="marker" id="mapping-208"></span><span class="token mv" id="move-dst-19" data-title="if_statement/binary_expression">rebaseHooksAddr != address(0)</span>) {
                IRebaseHooks(rebaseHooksAddr).postRebase(sync);
            }</span>
        }</span></span>
    }

    /**
     * @dev Determine the total value of assets held by the vault and its
     *         strategies.
     * @return uint256 value Total value in USD (1e18)
     */
    function totalValue() external <span class="marker" id="mapping-209"></span><span class="token mv" id="move-dst-2" data-title="function_definition/state_mutability">view</span> returns (uint256 value) {
        value = _totalValue();
    }

    /**
     * @dev Internal Calculate the total value of the assets held by the
     *         vault and its strategies.
     * @return uint256 value Total value in USD (1e18)
     */
    function _totalValue() internal view returns (uint256 value) {
        return <span class="marker" id="mapping-210"></span><span class="token add" data-title="binary_expression/call_expression">_totalValueInVault()</span> + <span class="marker" id="mapping-211"></span><span class="token add" data-title="binary_expression/call_expression">_totalValueInStrategies()</span>;
    }

    /**
     * @dev Internal to calculate total value of all assets held in Vault.
     * @return uint256 Total value in ETH (1e18)
     */
    function _totalValueInVault() internal view returns (uint256 value) {
        value = 0;
        for (uint256 y = 0; y &lt; allAssets.length; y++) {
            IERC20 asset = IERC20(allAssets[y]);
            uint256 assetDecimals = Helpers.getDecimals(allAssets[y]);
            uint256 balance = asset.balanceOf(address(this));
            if (balance &gt; 0) {
                value += balance.<span class="marker" id="mapping-212"></span><span class="token upd" id="move-dst-20" data-title="member_expression/identifier">s<span class="cupd">ca</span><span class="cupd">le</span>By</span>(<span class="marker" id="mapping-213"></span><span class="token mv" id="move-dst-39" data-title="call_expression/call_argument">int8(18 - assetDecimals)</span>);
            }
        }
    }

    /**
     * @dev Internal to calculate total value of all assets held in Strategies.
     * @return uint256 Total value in ETH (1e18)
     */
    function _totalValueInStrategies() internal view returns (uint256 value) {
        value = 0;
        for (uint256 i = 0; i &lt; allStrategies.length; i++) {
            value += _totalValueInStrategy(allStrategies[i]);
        }
    }

    /**
     * @dev Internal to calculate total value of all assets held by strategy.
     * @param _strategyAddr Address of the strategy
     * @return uint256 Total value in ETH (1e18)
     */
    function _totalValueInStrategy(address _strategyAddr)
        internal
        view
        returns (uint256 value)
    {
        value = 0;
        IStrategy strategy = IStrategy(_strategyAddr);
        for (uint256 y = 0; y &lt; allAssets.length; y++) {
            uint256 assetDecimals = Helpers.getDecimals(allAssets[y]);
            if (strategy.supportsAsset(allAssets[y])) {
                uint256 balance = strategy.checkBalance(allAssets[y]);
                if (balance &gt; 0) {
                    value += balance.<span class="marker" id="mapping-214"></span><span class="token upd" id="move-dst-22" data-title="member_expression/identifier">s<span class="cupd">ca</span><span class="cupd">le</span>By</span>(<span class="marker" id="mapping-215"></span><span class="token add" data-title="call_expression/call_argument">int8(18 - assetDecimals)</span>);
                }
            }
        }
    }

    /**
     * @dev Calculate difference in percent of asset allocation for a
               strategy.
     * @param _strategyAddr Address of the strategy
     * @return int256 Difference between current and target. 18 decimals. For ex. 10%=1e17.
     */
    function _strategyWeightDifference(address _strategyAddr)
        internal
        view
        returns (int256 difference)
    {
        difference =
            int256(strategies[_strategyAddr].targetWeight) -
            int256(
                _totalValueInStrategy(_strategyAddr).divPrecisely(_totalValue())
            );
    }

    /**
     * @dev Select a strategy for allocating an asset to.
     * @param _asset Address of asset
     * @return address Address of the target strategy
     */
    function _selectDepositStrategyAddr(address _asset)
        internal
        view
        returns (address depositStrategyAddr)
    {
        depositStrategyAddr = address(0);
        int256 maxDifference = 0;
        for (uint256 i = 0; i &lt; allStrategies.length; i++) {
            IStrategy strategy = IStrategy(allStrategies[i]);
            if (strategy.supportsAsset(_asset)) {
                <span class="marker" id="mapping-216"></span><span class="token mv" id="move-dst-24" data-title="block_statement/variable_declaration_statement">int256 diff = _strategyWeightDifference(allStrategies[i]);</span>
                if (diff &gt;= maxDifference) {
                    maxDifference = diff;
                    depositStrategyAddr = allStrategies[i];
                }
            }
        }
    }

    /**
     * @dev Select a strategy for withdrawing an asset from.
     * @param _asset Address of asset
     * @return address Address of the target strategy for withdrawal
     */
    function _selectWithdrawStrategyAddr(address _asset, uint256 _amount)
        internal
        view
        returns (address withdrawStrategyAddr)
    {
        withdrawStrategyAddr = address(0);
        int256 minDifference = 1e18;

        for (uint256 i = 0; i &lt; allStrategies.length; i++) {
            IStrategy strategy = IStrategy(allStrategies[i]);
            if (
                strategy.supportsAsset(_asset) &amp;&amp;
                strategy.checkBalance(_asset) &gt; _amount
            ) {
                <span class="marker" id="mapping-217"></span><span class="token mv" id="move-dst-23" data-title="block_statement/variable_declaration_statement">int256 diff = _strategyWeightDifference(allStrategies[i]);</span>
                if (diff &lt;= minDifference) {
                    minDifference = diff;
                    withdrawStrategyAddr = allStrategies[i];
                }
            }
        }
    }

    /**
     * @notice Get the balance of an asset held in Vault and all strategies.
     * @param _asset Address of asset
     * @return uint256 Balance of asset in decimals of asset
     */
    function checkBalance(address _asset) external view returns (uint256) {
        return _checkBalance(_asset);
    }

    /**
     * @notice Get the balance of an asset held in Vault and all strategies.
     * @param _asset Address of asset
     * @return uint256 Balance of asset in decimals of asset
     */
    function _checkBalance(address _asset)
        internal
        view
        returns (uint256 balance)
    {
        IERC20 asset = IERC20(_asset);
        balance = asset.balanceOf(address(this));
        for (uint256 i = 0; i &lt; allStrategies.length; i++) {
            IStrategy strategy = IStrategy(allStrategies[i]);
            if (strategy.supportsAsset(_asset)) {
                balance += strategy.checkBalance(_asset);
            }
        }
    }

    /**
     * @notice Get the balance of all assets held in Vault and all strategies.
     * @return uint256 Balance of all assets (1e18)
     */
    function _checkBalance() internal view returns (uint256 balance) {
        balance = 0;
        for (uint256 i = 0; i &lt; allAssets.length; i++) {
            uint256 assetDecimals = Helpers.getDecimals(allAssets[i]);
            balance += _checkBalance(allAssets[i]).scaleBy(
                int8(18 - assetDecimals)
            );
        }
    }

    /**
     * @notice Calculate the outputs for a redeem function, i.e. the mix of
     * coins that will be returned
     */
    function calculateRedeemOutputs(uint256 _amount)
        external
        returns (uint256[] memory)
    {
        return _calculateRedeemOutputs(_amount);
    }

    /**
     * @notice Calculate the outputs for a redeem function, i.e. the mix of
     * coins that will be returned.
     * @return Array of amounts respective to the supported assets
     */
    function _calculateRedeemOutputs(uint256 _amount)
        internal
        returns (uint256[] memory outputs)
    {
        <span class="marker" id="mapping-218"></span><span class="token upd" id="move-dst-29" data-title="function_body/comment"><span class="cupd">// </span>We always give o<span class="cupd">u</span>t coi<span class="cupd">n</span>s i<span class="cupd">n</span> proport<span class="cupd">i</span>o<span class="cupd">n</span><span class="cupd"> to</span><span class="cupd"> </span>h<span class="cupd">o</span>w<span class="cupd"> </span>many<span class="cupd"> </span>w<span class="cupd">e </span>h<span class="cupd">a</span>ve,</span>
        <span class="marker" id="mapping-219"></span><span class="token upd" id="move-dst-31" data-title="function_body/comment"><span class="cupd">// </span>Now <span class="cupd">i</span>f <span class="cupd">al</span>l co<span class="cupd">i</span>n<span class="cupd">s</span> w<span class="cupd">e</span>re<span class="cupd"> </span>the s<span class="cupd">a</span>me v<span class="cupd">a</span>lue, this math would easy,</span>
        <span class="marker" id="mapping-220"></span><span class="token upd" id="move-dst-32" data-title="function_body/comment"><span class="cupd">// </span>just take the pe<span class="cupd">r</span><span class="cupd">ce</span>ntage<span class="cupd"> of each </span>co<span class="cupd">in</span>,<span class="cupd"> </span>and<span class="cupd"> </span>mult<span class="cupd">i</span>ply<span class="cupd"> </span>by the</span>
        <span class="marker" id="mapping-221"></span><span class="token upd" id="move-dst-45" data-title="function_body/comment"><span class="cupd">// </span>value<span class="cupd"> </span>to b<span class="cupd">e</span><span class="cupd"> </span>g<span class="cupd">i</span>ve<span class="cupd">n </span><span class="cupd">ou</span><span class="cupd">t</span>.<span class="cupd"> </span>But i<span class="cupd">f coins </span><span class="cupd">a</span>r<span class="cupd">e</span><span class="cupd"> </span>worth mor<span class="cupd">e t</span>h<span class="cupd">a</span><span class="cupd">n</span> $1,</span>
        <span class="marker" id="mapping-222"></span><span class="token upd" id="move-dst-46" data-title="function_body/comment"><span class="cupd">// </span>then we would end u<span class="cupd">p</span> hand<span class="cupd">i</span>ng out too many <span class="cupd">c</span>oins. W<span class="cupd">e </span><span class="cupd">n</span>eed to</span>
        <span class="marker" id="mapping-223"></span><span class="token upd" id="move-dst-47" data-title="function_body/comment"><span class="cupd">// </span><span class="cupd">a</span>dj<span class="cupd">u</span>s<span class="cupd">t</span><span class="cupd"> </span><span class="cupd">by </span>th<span class="cupd">e</span> t<span class="cupd">o</span>t<span class="cupd">a</span>l<span class="cupd"> </span>v<span class="cupd">al</span>ue<span class="cupd"> </span><span class="cupd">o</span>f c<span class="cupd">o</span><span class="cupd">i</span>ns.</span>
        <span class="marker" id="mapping-224"></span><span class="token upd" id="move-dst-48" data-title="function_body/comment"><span class="cupd">//</span></span>
        <span class="marker" id="mapping-225"></span><span class="token add" data-title="function_body/comment">// To do this, we total up the value of our coins, by their</span>
        <span class="marker" id="mapping-226"></span><span class="token add" data-title="function_body/comment">// percentages. Then divide what we would otherwise give out by</span>
        <span class="marker" id="mapping-227"></span><span class="token add" data-title="function_body/comment">// this number.</span>
        <span class="marker" id="mapping-228"></span><span class="token add" data-title="function_body/comment">//</span>
        <span class="marker" id="mapping-229"></span><span class="token add" data-title="function_body/comment">// Let say we have 100 DAI at $1.06  and 200 USDT at $1.00.</span>
        <span class="marker" id="mapping-230"></span><span class="token add" data-title="function_body/comment">// So for every 1 DAI we give out, we'll be handing out 2 USDT</span>
        <span class="marker" id="mapping-231"></span><span class="token add" data-title="function_body/comment">// Our total output ratio is: 33% * 1.06 + 66% * 1.00 = 1.02</span>
        <span class="marker" id="mapping-232"></span><span class="token add" data-title="function_body/comment">//</span>
        <span class="marker" id="mapping-233"></span><span class="token add" data-title="function_body/comment">// So when calculating the output, we take the percentage of</span>
        <span class="marker" id="mapping-234"></span><span class="token add" data-title="function_body/comment">// each coin, times the desired output value, divided by the</span>
        <span class="marker" id="mapping-235"></span><span class="token add" data-title="function_body/comment">// totalOutputRatio.</span>
        <span class="marker" id="mapping-236"></span><span class="token add" data-title="function_body/comment">//</span>
        <span class="marker" id="mapping-237"></span><span class="token add" data-title="function_body/comment">// For example, withdrawing: 30 OUSD:</span>
        <span class="marker" id="mapping-238"></span><span class="token add" data-title="function_body/comment">// DAI 33% * 30 / 1.02 = 9.80 DAI</span>
        <span class="marker" id="mapping-239"></span><span class="token add" data-title="function_body/comment">// USDT = 66 % * 30 / 1.02 = 19.60 USDT</span>
        <span class="marker" id="mapping-240"></span><span class="token add" data-title="function_body/comment">//</span>
        <span class="marker" id="mapping-241"></span><span class="token add" data-title="function_body/comment">// Checking these numbers:</span>
        <span class="marker" id="mapping-242"></span><span class="token add" data-title="function_body/comment">// 9.80 DAI * 1.06 = $10.40</span>
        <span class="marker" id="mapping-243"></span><span class="token add" data-title="function_body/comment">// 19.60 USDT * 1.00 = $19.60</span>
        <span class="marker" id="mapping-244"></span><span class="token add" data-title="function_body/comment">//</span>
        <span class="marker" id="mapping-245"></span><span class="token add" data-title="function_body/comment">// And so the user gets $10.40 + $19.60 = $30 worth of value.</span>

        <span class="marker" id="mapping-246"></span><span class="token mv" id="move-dst-30" data-title="function_body/variable_declaration_statement">uint256 assetCount = getAssetCount();</span>
        <span class="marker" id="mapping-247"></span><span class="token mv" id="move-dst-25" data-title="function_body/variable_declaration_statement">uint256[] memory assetPrices = _getAssetPrices(true);</span>
        <span class="marker" id="mapping-248"></span><span class="token mv" id="move-dst-3" data-title="function_body/variable_declaration_statement">uint256[] memory <span class="marker" id="mapping-249"></span><span class="token upd" id="move-dst-4" data-title="variable_declaration/identifier"><span class="cupd">asset</span>Balan<span class="cupd">ces</span></span> <span class="marker" id="mapping-250"></span><span class="token add" data-title="variable_declaration_statement/=">=</span> <span class="marker" id="mapping-251"></span><span class="token add" data-title="variable_declaration_statement/call_expression"><span class="marker" id="mapping-252"></span><span class="token add" data-title="call_expression/new_expression">new <span class="marker" id="mapping-253"></span><span class="token mv" id="move-dst-9" data-title="new_expression/type_name">uint256[]</span></span>(<span class="marker" id="mapping-254"></span><span class="token add" data-title="call_expression/call_argument">assetCount</span>)</span>;</span>
        <span class="marker" id="mapping-255"></span><span class="token add" data-title="function_body/variable_declaration_statement"><span class="marker" id="mapping-256"></span><span class="token add" data-title="variable_declaration_statement/variable_declaration"><span class="marker" id="mapping-257"></span><span class="token mv" id="move-dst-21" data-title="variable_declaration/type_name">uint256[]</span> memory assetDecimals</span> = <span class="marker" id="mapping-258"></span><span class="token add" data-title="variable_declaration_statement/call_expression"><span class="marker" id="mapping-259"></span><span class="token add" data-title="call_expression/new_expression">new <span class="marker" id="mapping-260"></span><span class="token mv" id="move-dst-16" data-title="new_expression/type_name">uint256[]</span></span>(<span class="marker" id="mapping-261"></span><span class="token add" data-title="call_expression/call_argument">assetCount</span>)</span>;</span>
        <span class="marker" id="mapping-262"></span><span class="token mv" id="move-dst-26" data-title="function_body/variable_declaration_statement">uint256 totalBalance = <span class="marker" id="mapping-263"></span><span class="token add" data-title="variable_declaration_statement/number_literal">0</span>;</span>
        <span class="marker" id="mapping-264"></span><span class="token mv" id="move-dst-27" data-title="function_body/variable_declaration_statement">uint256 <span class="marker" id="mapping-265"></span><span class="token upd" id="move-dst-28" data-title="variable_declaration/identifier"><span class="cupd">totalOutput</span>Ratio</span> = 0;</span>
        <span class="marker" id="mapping-266"></span><span class="token mv" id="move-dst-33" data-title="function_body/expression_statement">outputs = new uint256[](assetCount);</span>

        <span class="marker" id="mapping-267"></span><span class="token add" data-title="function_body/comment">// Calculate redeem fee</span>
        <span class="marker" id="mapping-268"></span><span class="token mv" id="move-dst-12" data-title="function_body/if_statement">if (redeemFeeBps &gt; 0) {
            uint256 redeemFee = _amount.mul(redeemFeeBps).div(10000);
            <span class="marker" id="mapping-269"></span><span class="token upd" id="move-dst-13" data-title="assignment_expression/identifier">_a<span class="cupd">mount</span></span> = _amount.sub(redeemFee);
        }</span>

        <span class="marker" id="mapping-270"></span><span class="token add" data-title="function_body/comment">// Calculate assets balances and decimals once,</span>
        <span class="marker" id="mapping-271"></span><span class="token add" data-title="function_body/comment">// for a large gas savings.</span>
        <span class="marker" id="mapping-272"></span><span class="token mv" id="move-dst-34" data-title="function_body/for_statement">for (uint256 i = 0; i &lt; allAssets.length; i++) {
            <span class="marker" id="mapping-273"></span><span class="token add" data-title="variable_declaration_statement/variable_declaration">uint256 balance</span> = <span class="marker" id="mapping-274"></span><span class="token mv" id="move-dst-38" data-title="variable_declaration_statement/call_expression">_checkBalance(allAssets[i])</span>;
            <span class="marker" id="mapping-275"></span><span class="token mv" id="move-dst-35" data-title="block_statement/variable_declaration_statement"><span class="marker" id="mapping-276"></span><span class="token mv" id="move-dst-36" data-title="variable_declaration_statement/variable_declaration">uint256 <span class="marker" id="mapping-277"></span><span class="token upd" id="move-dst-37" data-title="variable_declaration/identifier">dec<span class="cupd">i</span>m<span class="cupd">al</span>s</span></span> = Helpers.getDecimals(allAssets[i]);</span>
            <span class="marker" id="mapping-278"></span><span class="token add" data-title="block_statement/expression_statement">assetBalances[i] = balance;</span>
            <span class="marker" id="mapping-279"></span><span class="token add" data-title="block_statement/expression_statement">assetDecimals[i] = decimals;</span>
            <span class="marker" id="mapping-280"></span><span class="token add" data-title="block_statement/expression_statement"><span class="marker" id="mapping-281"></span><span class="token add" data-title="expression_statement/augmented_assignment_expression">totalBalance += <span class="marker" id="mapping-282"></span><span class="token add" data-title="augmented_assignment_expression/call_expression"><span class="marker" id="mapping-283"></span><span class="token add" data-title="call_expression/member_expression">balance.scaleBy</span>(<span class="marker" id="mapping-284"></span><span class="token add" data-title="call_expression/call_argument"><span class="marker" id="mapping-285"></span><span class="token add" data-title="call_argument/type_cast_expression"><span class="marker" id="mapping-286"></span><span class="token mv" id="move-dst-44" data-title="type_cast_expression/primitive_type">int8</span>(<span class="marker" id="mapping-287"></span><span class="token add" data-title="type_cast_expression/call_argument">18 - decimals</span>)</span></span>)</span></span>;</span>
        }</span>
        <span class="marker" id="mapping-288"></span><span class="token add" data-title="function_body/comment">// Calculate totalOutputRatio</span>
        <span class="marker" id="mapping-289"></span><span class="token add" data-title="function_body/for_statement">for (<span class="marker" id="mapping-290"></span><span class="token mv" id="move-dst-49" data-title="for_statement/variable_declaration_statement">uint256 i = 0;</span> <span class="marker" id="mapping-291"></span><span class="token add" data-title="for_statement/expression_statement">i &lt; allAssets.length;</span> <span class="marker" id="mapping-292"></span><span class="token mv" id="move-dst-50" data-title="for_statement/update_expression">i++</span>) <span class="marker" id="mapping-293"></span><span class="token add" data-title="for_statement/block_statement">{
            <span class="marker" id="mapping-294"></span><span class="token add" data-title="block_statement/variable_declaration_statement"><span class="marker" id="mapping-295"></span><span class="token add" data-title="variable_declaration_statement/variable_declaration">uint256 price</span> = <span class="marker" id="mapping-296"></span><span class="token mv" id="move-dst-42" data-title="variable_declaration_statement/array_access">assetPrices[i]</span>;</span>
            // Never give out more than one
            // stablecoin per dollar of OUSD
            <span class="marker" id="mapping-297"></span><span class="token add" data-title="block_statement/if_statement">if (price &lt; 1e18) {
                price = 1e18;
            }</span>
            <span class="marker" id="mapping-298"></span><span class="token add" data-title="block_statement/variable_declaration_statement"><span class="marker" id="mapping-299"></span><span class="token add" data-title="variable_declaration_statement/variable_declaration">uint256 ratio</span> = <span class="marker" id="mapping-300"></span><span class="token add" data-title="variable_declaration_statement/call_expression"><span class="marker" id="mapping-301"></span><span class="token add" data-title="call_expression/member_expression">assetBalances[i]
                .scaleBy(int8(18 - assetDecimals[i]))
                .mul(price)
                .div</span>(<span class="marker" id="mapping-302"></span><span class="token mv" id="move-dst-41" data-title="call_expression/call_argument">totalBalance</span>)</span>;</span>
            <span class="marker" id="mapping-303"></span><span class="token add" data-title="block_statement/expression_statement">totalOutputRatio += ratio;</span>
        }</span></span>
        <span class="marker" id="mapping-304"></span><span class="token add" data-title="function_body/comment">// Calculate final outputs</span>
        <span class="marker" id="mapping-305"></span><span class="token mv" id="move-dst-51" data-title="function_body/variable_declaration_statement">uint256 <span class="marker" id="mapping-306"></span><span class="token upd" id="move-dst-52" data-title="variable_declaration/identifier">fac<span class="cupd">to</span>r</span> = <span class="marker" id="mapping-307"></span><span class="token add" data-title="variable_declaration_statement/call_expression">_amount.divPrecisely(totalOutputRatio)</span>;</span>
        <span class="marker" id="mapping-308"></span><span class="token add" data-title="function_body/for_statement">for (<span class="marker" id="mapping-309"></span><span class="token mv" id="move-dst-53" data-title="for_statement/variable_declaration_statement">uint256 i = 0;</span> <span class="marker" id="mapping-310"></span><span class="token add" data-title="for_statement/expression_statement">i &lt; allAssets.length;</span> <span class="marker" id="mapping-311"></span><span class="token mv" id="move-dst-54" data-title="for_statement/update_expression">i++</span>) <span class="marker" id="mapping-312"></span><span class="token add" data-title="for_statement/block_statement">{
            <span class="marker" id="mapping-313"></span><span class="token add" data-title="block_statement/expression_statement"><span class="marker" id="mapping-314"></span><span class="token add" data-title="expression_statement/assignment_expression"><span class="marker" id="mapping-315"></span><span class="token mv" id="move-dst-43" data-title="assignment_expression/array_access">outputs[i]</span> = <span class="marker" id="mapping-316"></span><span class="token add" data-title="assignment_expression/call_expression">assetBalances[i].mul(factor).div(totalBalance)</span></span>;</span>
        }</span></span>
    }

    /**
     * @notice Get an array of the supported asset prices in USD.
     * @return uint256[] Array of asset prices in USD (1e18)
     */
    function _getAssetPrices(bool useMax)
        internal
        returns (uint256[] memory assetPrices)
    {
        assetPrices = new uint256[](getAssetCount());

        IMinMaxOracle oracle = IMinMaxOracle(priceProvider);
        // Price from Oracle is returned with 8 decimals
        // _amount is in assetDecimals

        for (uint256 i = 0; i &lt; allAssets.length; i++) {
            string memory symbol = Helpers.getSymbol(allAssets[i]);
            // Get all the USD prices of the asset in 1e18
            if (useMax) {
                assetPrices[i] = oracle.priceMax(symbol).scaleBy(int8(18 - 8));
            } else {
                assetPrices[i] = oracle.priceMin(symbol).scaleBy(int8(18 - 8));
            }
        }
    }

    /***************************************
                    Utils
    ****************************************/

    /**
     * @dev Return the number of assets suppported by the Vault.
     */
    function getAssetCount() public view returns (uint256) {
        return allAssets.length;
    }

    /**
     * @dev Return all asset addresses in order
     */
    function getAllAssets() external view returns (address[] memory) {
        return allAssets;
    }

    /**
     * @dev Return the number of strategies active on the Vault.
     */
    function getStrategyCount() public view returns (uint256) {
        return allStrategies.length;
    }

    function isSupportedAsset(address _asset) external view returns (bool) {
        return assets[_asset].isSupported;
    }

    /**
     * @dev Falldown to the admin implementation
     * @notice This is a catch all for all functions not declared in core
     */
    function() external payable {
        bytes32 slot = adminImplPosition;
        assembly {
            // Copy msg.data. We take full control of memory in this inline assembly
            // block because it will not return to Solidity code. We overwrite the
            // Solidity scratch pad at memory position 0.
            calldatacopy(0, 0, calldatasize)

            // Call the implementation.
            // out and outsize are 0 because we don't know the size yet.
            let result := delegatecall(gas, sload(slot), 0, calldatasize, 0, 0)

            // Copy the returned data.
            returndatacopy(0, 0, returndatasize)

            switch result
                // delegatecall returns 0 on error.
                case 0 {
                    revert(0, returndatasize)
                }
                default {
                    return(0, returndatasize)
                }
        }
    }
}
</pre></div></div></div></body></html>