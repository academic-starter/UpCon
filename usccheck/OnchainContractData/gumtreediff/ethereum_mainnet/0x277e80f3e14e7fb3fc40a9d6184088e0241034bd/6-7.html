<html lang="en"><head><meta charset="utf8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>GumTree</title><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css"><style type="text/css">/*
 * This file is part of GumTree.
 *
 * GumTree is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * GumTree is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with GumTree.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Copyright 2011-2015 Jean-Rémy Falleri <jr.falleri@gmail.com>
 * Copyright 2011-2015 Floréal Morandat <florealm@gmail.com>
 */

.add {
	border: 1px solid black;
	background-color: MediumSeaGreen;
}

.del {
	border: 1px solid black;
	background-color: IndianRed;
}

.mv {
	border: 1px solid black;
	background-color: Plum;
}

.upd {
	border: 1px solid black;
	background-color: DarkOrange;
	font-weight: bold;
}

.cupd {
	font-weight: normal;
	color: DimGray;
}

.selected {
	background-color: Gold;
}

.marker {
	margin: 0;
	padding: 0;
}

div {
	margin: 0px;
	padding: 0px;
}

.pre-scrollable {
	margin: 0px;
	padding: 0px;
	font-size: 10pt;
	color: black;
	max-height: 90vh;
	background-color: white;
	border: 1px solid black;
	font-family: "Hack, Inconsolata", "Consolas", "Liberation Sans Regular", "DejaVu Sans Mono", monospace;
}

.tooltip-inner {
    max-width: none;
}
</style><script type="text/javascript" src="https://code.jquery.com/jquery-3.4.1.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/js/bootstrap.bundle.min.js"></script><script type="text/javascript">/*
 * This file is part of GumTree.
 *
 * GumTree is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * GumTree is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with GumTree.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Copyright 2011-2015 Jean-Rémy Falleri <jr.falleri@gmail.com>
 * Copyright 2011-2015 Floréal Morandat <florealm@gmail.com>
 */

$(function(){
    let popoverTriggerList = [].slice.call(document.querySelectorAll('[data-bs-toggle="popover"]'))
    let popoverList = popoverTriggerList.map(function (popoverTriggerEl) {
      return new bootstrap.Popover(popoverTriggerEl)
    })

    $("body").keypress(function (event) {
        switch (event.which) {
            case 116:
                $('html, body').animate({scrollTop: 0}, 100);
                break;
            case 98:
                $("html, body").animate({ scrollTop: $(document).height() }, 100);
                break;
            case 113:
                window.location = "/quit";
                break;
            case 108:
                window.location = "/list";
                break;
        }
    });
});
</script><script type="text/javascript">/*
 * This file is part of GumTree.
 *
 * GumTree is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * GumTree is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with GumTree.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Copyright 2011-2015 Jean-Rémy Falleri <jr.falleri@gmail.com>
 * Copyright 2011-2015 Floréal Morandat <florealm@gmail.com>
 */

currentMapping = 0;

if (typeof String.prototype.startsWith != 'function') {
  String.prototype.startsWith = function (str){
    return this.slice(0, str.length) == str;
  };
}

function getMappedElement(eltId) {
	if (eltId.startsWith("move-src")) {
		return eltId.replace("src","dst");  	 	
  	}
  	else {
  		return eltId.replace("dst","src");
  	}
}

function nextMapping() {
	if (currentMapping == 0) {
		currentMapping = 1;
		return "#mapping-" + currentMapping.toString();
	} else {
		currentMapping++;
		
		if ($("#mapping-" + currentMapping.toString()).length > 0) {
			return "#mapping-" + currentMapping.toString();
		} else {
			currentMapping = 1;
			return "#mapping-" + currentMapping.toString();		
		}		
	}
}

function isSrc(eltId) {
	return eltId.startsWith("move-src");
}

$(function() {
    $("body").keypress(function (event) {
        switch(event.which) {
            case 110:
                const mapping = $(nextMapping());
                const pre = mapping.closest("pre");
                pre.animate({scrollTop: pre.scrollTop() + mapping.position().top - 200}, 100);
                break;
        }
    });

    // highlight
    $("span.mv.token, span.token.upd").click(function(event) {
        if ($(this).hasClass("selected")) {
            $("span.mv.token, span.token.upd").removeClass("selected");
        } else {
            $("span.mv.token, span.token.upd").removeClass("selected");
            const refElt = $("#" + getMappedElement($(this).attr("id")));
            $(this).addClass("selected");
            refElt.addClass("selected");
            const pre = refElt.closest("pre");
            console.log(pre);
            pre.animate({scrollTop: pre.scrollTop() + refElt.position().top - 200}, 100);
        }
        event.stopPropagation();
    });
    
    $("span.add.token, span.token.del").click(function(event) {
        $("span.mv.token, span.token.upd").removeClass("selected");
        event.stopPropagation();
    });

    // tooltip
    $("span.token").hover(
    	function (event) {
    		$(this).tooltip('show');
    		event.stopPropagation();
    	},
    	function (event) {
    		$(this).tooltip('hide');
    		event.stopPropagation();
    	}
    );
});
</script></head><body><div class="container-fluid"><div class="row"><div class="col"><div class="btn-toolbar justify-content-end"><div class="btn-group mr-2"><button class="btn btn-primary btn-sm" id="legend" data-bs-toggle="popover" data-bs-placement="bottom" data-bs-html="true" data-bs-content="<span class='del'>&nbsp;&nbsp;</span> deleted<br><span class='add'>&nbsp;&nbsp;</span> added<br><span class='mv'>&nbsp;&nbsp;</span> moved<br><span class='upd';>&nbsp;&nbsp;</span> updated<br>">Legend</button><button class="btn btn-primary btn-sm" id="shortcuts" data-bs-toggle="popover" data-bs-placement="bottom" data-bs-html="true" data-bs-content="<b>q</b> quit<br><b>l</b> list<br><b>n</b> next<br><b>t</b> top<br><b>b</b> bottom">Shortcuts</button></div><div class="btn-group"><a href="/list" class="btn btn-default btn-sm btn-primary">Back</a><a href="/quit" class="btn btn-default btn-sm btn-danger">Quit</a></div></div></div></div><div class="row"><div class="col-6"><h5>0xf251cb9129fdb7e9ca5cad097de3ea70cab9d8f9.etherscan.io-Vault.sol</h5><pre class="pre-scrollable"><span class="marker" id="mapping-1"></span><span class="token mv" id="move-src-1" data-title="source_file/pragma_directive">pragma solidity 0.5.11;</span>

<span class="marker" id="mapping-2"></span><span class="token mv" id="move-src-2" data-title="source_file/comment">/**
 * @title OUSD Vault Contract
 * @notice The Vault contract stores assets. On a deposit, OUSD will be minted
           and sent to the depositor. On a withdrawal, OUSD will be burned and
           assets will be sent to the withdrawer. The Vault accepts deposits of
           interest form yield bearing strategies which will modify the supply
           of OUSD.
 * @author Origin Protocol Inc
 */</span>
<span class="marker" id="mapping-3"></span><span class="token mv" id="move-src-3" data-title="source_file/contract_declaration">contract Context {
    // Empty internal constructor, to prevent people from mistakenly deploying
    // an instance of this contract, which should be used via inheritance.
    constructor () internal { }
    // solhint-disable-previous-line no-empty-blocks

    function _msgSender() internal view returns (address payable) {
        return msg.sender;
    }

    function _msgData() internal view returns (bytes memory) {
        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691
        return msg.data;
    }
}</span>

<span class="marker" id="mapping-4"></span><span class="token mv" id="move-src-4" data-title="source_file/library_declaration">library SafeMath {
    /**
     * @dev Returns the addition of two unsigned integers, reverting on
     * overflow.
     *
     * Counterpart to Solidity's `+` operator.
     *
     * Requirements:
     * - Addition cannot overflow.
     */
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c &gt;= a, "SafeMath: addition overflow");

        return c;
    }

    /**
     * @dev Returns the subtraction of two unsigned integers, reverting on
     * overflow (when the result is negative).
     *
     * Counterpart to Solidity's `-` operator.
     *
     * Requirements:
     * - Subtraction cannot overflow.
     */
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        return sub(a, b, "SafeMath: subtraction overflow");
    }

    /**
     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on
     * overflow (when the result is negative).
     *
     * Counterpart to Solidity's `-` operator.
     *
     * Requirements:
     * - Subtraction cannot overflow.
     *
     * _Available since v2.4.0._
     */
    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
        require(b &lt;= a, errorMessage);
        uint256 c = a - b;

        return c;
    }

    /**
     * @dev Returns the multiplication of two unsigned integers, reverting on
     * overflow.
     *
     * Counterpart to Solidity's `*` operator.
     *
     * Requirements:
     * - Multiplication cannot overflow.
     */
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the
        // benefit is lost if 'b' is also tested.
        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522
        if (a == 0) {
            return 0;
        }

        uint256 c = a * b;
        require(c / a == b, "SafeMath: multiplication overflow");

        return c;
    }

    /**
     * @dev Returns the integer division of two unsigned integers. Reverts on
     * division by zero. The result is rounded towards zero.
     *
     * Counterpart to Solidity's `/` operator. Note: this function uses a
     * `revert` opcode (which leaves remaining gas untouched) while Solidity
     * uses an invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     * - The divisor cannot be zero.
     */
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        return div(a, b, "SafeMath: division by zero");
    }

    /**
     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on
     * division by zero. The result is rounded towards zero.
     *
     * Counterpart to Solidity's `/` operator. Note: this function uses a
     * `revert` opcode (which leaves remaining gas untouched) while Solidity
     * uses an invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     * - The divisor cannot be zero.
     *
     * _Available since v2.4.0._
     */
    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
        // Solidity only automatically asserts when dividing by 0
        require(b &gt; 0, errorMessage);
        uint256 c = a / b;
        // assert(a == b * c + a % b); // There is no case in which this doesn't hold

        return c;
    }

    /**
     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),
     * Reverts when dividing by zero.
     *
     * Counterpart to Solidity's `%` operator. This function uses a `revert`
     * opcode (which leaves remaining gas untouched) while Solidity uses an
     * invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     * - The divisor cannot be zero.
     */
    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
        return mod(a, b, "SafeMath: modulo by zero");
    }

    /**
     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),
     * Reverts with custom message when dividing by zero.
     *
     * Counterpart to Solidity's `%` operator. This function uses a `revert`
     * opcode (which leaves remaining gas untouched) while Solidity uses an
     * invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     * - The divisor cannot be zero.
     *
     * _Available since v2.4.0._
     */
    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
        require(b != 0, errorMessage);
        return a % b;
    }
}</span>

interface IERC20 {
    /**
     * @dev Returns the amount of tokens in existence.
     */
    function totalSupply() external view returns (uint256);

    /**
     * @dev Returns the amount of tokens owned by `account`.
     */
    function balanceOf(address account) external view returns (uint256);

    /**
     * @dev Moves `amount` tokens from the caller's account to `recipient`.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * Emits a {Transfer} event.
     */
    function transfer(address recipient, uint256 amount) external returns (bool);

    /**
     * @dev Returns the remaining number of tokens that `spender` will be
     * allowed to spend on behalf of `owner` through {transferFrom}. This is
     * zero by default.
     *
     * This value changes when {approve} or {transferFrom} are called.
     */
    function allowance(address owner, address spender) external view returns (uint256);

    /**
     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * IMPORTANT: Beware that changing an allowance with this method brings the risk
     * that someone may use both the old and the new allowance by unfortunate
     * transaction ordering. One possible solution to mitigate this race
     * condition is to first reduce the spender's allowance to 0 and set the
     * desired value afterwards:
     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
     *
     * Emits an {Approval} event.
     */
    function approve(address spender, uint256 amount) external returns (bool);

    /**
     * @dev Moves `amount` tokens from `sender` to `recipient` using the
     * allowance mechanism. `amount` is then deducted from the caller's
     * allowance.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * Emits a {Transfer} event.
     */
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);

    /**
     * @dev Emitted when `value` tokens are moved from one account (`from`) to
     * another (`to`).
     *
     * Note that `value` may be zero.
     */
    event Transfer(address indexed from, address indexed to, uint256 value);

    /**
     * @dev Emitted when the allowance of a `spender` for an `owner` is set by
     * a call to {approve}. `value` is the new allowance.
     */
    event Approval(address indexed owner, address indexed spender, uint256 value);
}

<span class="marker" id="mapping-5"></span><span class="token mv" id="move-src-5" data-title="source_file/contract_declaration">contract ERC20 is Context, IERC20 {
    using SafeMath for uint256;

    mapping (address =&gt; uint256) private _balances;

    mapping (address =&gt; mapping (address =&gt; uint256)) private _allowances;

    uint256 private _totalSupply;

    /**
     * @dev See {IERC20-totalSupply}.
     */
    function totalSupply() public view returns (uint256) {
        return _totalSupply;
    }

    /**
     * @dev See {IERC20-balanceOf}.
     */
    function balanceOf(address account) public view returns (uint256) {
        return _balances[account];
    }

    /**
     * @dev See {IERC20-transfer}.
     *
     * Requirements:
     *
     * - `recipient` cannot be the zero address.
     * - the caller must have a balance of at least `amount`.
     */
    function transfer(address recipient, uint256 amount) public returns (bool) {
        _transfer(_msgSender(), recipient, amount);
        return true;
    }

    /**
     * @dev See {IERC20-allowance}.
     */
    function allowance(address owner, address spender) public view returns (uint256) {
        return _allowances[owner][spender];
    }

    /**
     * @dev See {IERC20-approve}.
     *
     * Requirements:
     *
     * - `spender` cannot be the zero address.
     */
    function approve(address spender, uint256 amount) public returns (bool) {
        _approve(_msgSender(), spender, amount);
        return true;
    }

    /**
     * @dev See {IERC20-transferFrom}.
     *
     * Emits an {Approval} event indicating the updated allowance. This is not
     * required by the EIP. See the note at the beginning of {ERC20};
     *
     * Requirements:
     * - `sender` and `recipient` cannot be the zero address.
     * - `sender` must have a balance of at least `amount`.
     * - the caller must have allowance for `sender`'s tokens of at least
     * `amount`.
     */
    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {
        _transfer(sender, recipient, amount);
        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, "ERC20: transfer amount exceeds allowance"));
        return true;
    }

    /**
     * @dev Atomically increases the allowance granted to `spender` by the caller.
     *
     * This is an alternative to {approve} that can be used as a mitigation for
     * problems described in {IERC20-approve}.
     *
     * Emits an {Approval} event indicating the updated allowance.
     *
     * Requirements:
     *
     * - `spender` cannot be the zero address.
     */
    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {
        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));
        return true;
    }

    /**
     * @dev Atomically decreases the allowance granted to `spender` by the caller.
     *
     * This is an alternative to {approve} that can be used as a mitigation for
     * problems described in {IERC20-approve}.
     *
     * Emits an {Approval} event indicating the updated allowance.
     *
     * Requirements:
     *
     * - `spender` cannot be the zero address.
     * - `spender` must have allowance for the caller of at least
     * `subtractedValue`.
     */
    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {
        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, "ERC20: decreased allowance below zero"));
        return true;
    }

    /**
     * @dev Moves tokens `amount` from `sender` to `recipient`.
     *
     * This is internal function is equivalent to {transfer}, and can be used to
     * e.g. implement automatic token fees, slashing mechanisms, etc.
     *
     * Emits a {Transfer} event.
     *
     * Requirements:
     *
     * - `sender` cannot be the zero address.
     * - `recipient` cannot be the zero address.
     * - `sender` must have a balance of at least `amount`.
     */
    function _transfer(address sender, address recipient, uint256 amount) internal {
        require(sender != address(0), "ERC20: transfer from the zero address");
        require(recipient != address(0), "ERC20: transfer to the zero address");

        _balances[sender] = _balances[sender].sub(amount, "ERC20: transfer amount exceeds balance");
        _balances[recipient] = _balances[recipient].add(amount);
        emit Transfer(sender, recipient, amount);
    }

    /** @dev Creates `amount` tokens and assigns them to `account`, increasing
     * the total supply.
     *
     * Emits a {Transfer} event with `from` set to the zero address.
     *
     * Requirements
     *
     * - `to` cannot be the zero address.
     */
    function _mint(address account, uint256 amount) internal {
        require(account != address(0), "ERC20: mint to the zero address");

        _totalSupply = _totalSupply.add(amount);
        _balances[account] = _balances[account].add(amount);
        emit Transfer(address(0), account, amount);
    }

    /**
     * @dev Destroys `amount` tokens from `account`, reducing the
     * total supply.
     *
     * Emits a {Transfer} event with `to` set to the zero address.
     *
     * Requirements
     *
     * - `account` cannot be the zero address.
     * - `account` must have at least `amount` tokens.
     */
    function _burn(address account, uint256 amount) internal {
        require(account != address(0), "ERC20: burn from the zero address");

        _balances[account] = _balances[account].sub(amount, "ERC20: burn amount exceeds balance");
        _totalSupply = _totalSupply.sub(amount);
        emit Transfer(account, address(0), amount);
    }

    /**
     * @dev Sets `amount` as the allowance of `spender` over the `owner`s tokens.
     *
     * This is internal function is equivalent to `approve`, and can be used to
     * e.g. set automatic allowances for certain subsystems, etc.
     *
     * Emits an {Approval} event.
     *
     * Requirements:
     *
     * - `owner` cannot be the zero address.
     * - `spender` cannot be the zero address.
     */
    function _approve(address owner, address spender, uint256 amount) internal {
        require(owner != address(0), "ERC20: approve from the zero address");
        require(spender != address(0), "ERC20: approve to the zero address");

        _allowances[owner][spender] = amount;
        emit Approval(owner, spender, amount);
    }

    /**
     * @dev Destroys `amount` tokens from `account`.`amount` is then deducted
     * from the caller's allowance.
     *
     * See {_burn} and {_approve}.
     */
    function _burnFrom(address account, uint256 amount) internal {
        _burn(account, amount);
        _approve(account, _msgSender(), _allowances[account][_msgSender()].sub(amount, "ERC20: burn amount exceeds allowance"));
    }
}</span>

<span class="marker" id="mapping-6"></span><span class="token mv" id="move-src-6" data-title="source_file/library_declaration">library SafeERC20 {
    using SafeMath for uint256;
    using Address for address;

    function safeTransfer(IERC20 token, address to, uint256 value) internal {
        callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));
    }

    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {
        callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));
    }

    function safeApprove(IERC20 token, address spender, uint256 value) internal {
        // safeApprove should only be called when setting an initial allowance,
        // or when resetting it to zero. To increase and decrease it, use
        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'
        // solhint-disable-next-line max-line-length
        require((value == 0) || (token.allowance(address(this), spender) == 0),
            "SafeERC20: approve from non-zero to non-zero allowance"
        );
        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));
    }

    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {
        uint256 newAllowance = token.allowance(address(this), spender).add(value);
        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));
    }

    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {
        uint256 newAllowance = token.allowance(address(this), spender).sub(value, "SafeERC20: decreased allowance below zero");
        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));
    }

    /**
     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement
     * on the return value: the return value is optional (but if data is returned, it must not be false).
     * @param token The token targeted by the call.
     * @param data The call data (encoded using abi.encode or one of its variants).
     */
    function callOptionalReturn(IERC20 token, bytes memory data) private {
        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since
        // we're implementing it ourselves.

        // A Solidity high level call has three parts:
        //  1. The target address is checked to verify it contains contract code
        //  2. The call itself is made, and success asserted
        //  3. The return value is decoded, which in turn checks the size of the returned data.
        // solhint-disable-next-line max-line-length
        require(address(token).isContract(), "SafeERC20: call to non-contract");

        // solhint-disable-next-line avoid-low-level-calls
        (bool success, bytes memory returndata) = address(token).call(data);
        require(success, "SafeERC20: low-level call failed");

        if (returndata.length &gt; 0) { // Return data is optional
            // solhint-disable-next-line max-line-length
            require(abi.decode(returndata, (bool)), "SafeERC20: ERC20 operation did not succeed");
        }
    }
}</span>

library Address {
    <span class="marker" id="mapping-7"></span><span class="token upd" id="move-src-7" data-title="contract_body/comment"><span class="cupd">/**
     * @dev Returns true if `account` is a contract.
     *
     * [IMPORTANT]
     * ====
     * It is unsafe to assume that an address for which this function returns
     * false is an externally-owned account (EOA) and not a contract.
     *
     * Among others, `isContract` will return false for the followi</span><span class="cupd">ng
     * types of addresses:
     *
     *  - an externally-owned account
     *  - a contract in construction
     *  - an address where a contract will be created
     *  - an address where a contract lived, but was destroyed
    </span> * ====
     */</span>
    function isContract(address account) internal view returns (bool) {
        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts
        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned
        // for accounts without code, i.e. `keccak256('')`
        bytes32 codehash;
        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;
        // solhint-disable-next-line no-inline-assembly
        assembly { codehash := extcodehash(account) }
        return (codehash != accountHash &amp;&amp; codehash != 0x0);
    }

    /**
     * @dev Converts an `address` into `address payable`. Note that this is
     * simply a type cast: the actual underlying value is not changed.
     *
     * _Available since v2.4.0._
     */
    function toPayable(address account) internal pure returns (address payable) {
        return address(uint160(account));
    }

    /**
     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to
     * `recipient`, forwarding all available gas and reverting on errors.
     *
     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost
     * of certain opcodes, possibly making contracts go over the 2300 gas limit
     * imposed by `transfer`, making them unable to receive funds via
     * `transfer`. {sendValue} removes this limitation.
     *
     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].
     *
     * IMPORTANT: because control is transferred to `recipient`, care must be
     * taken to not create reentrancy vulnerabilities. Consider using
     * {ReentrancyGuard} or the
     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].
     *
     * _Available since v2.4.0._
     */
    function sendValue(address payable recipient, uint256 amount) internal {
        require(address(this).balance &gt;= amount, "Address: insufficient balance");

        // solhint-disable-next-line avoid-call-value
        (bool success, ) = recipient.call.value(amount)("");
        require(success, "Address: unable to send value, recipient may have reverted");
    }
}

contract Initializable {

  /**
   * @dev Indicates that the contract has been initialized.
   */
  bool private initialized;

  /**
   * @dev Indicates that the contract is in the process of being initialized.
   */
  bool private initializing;

  /**
   * @dev Modifier to use in the initializer function of a contract.
   */
  modifier initializer() {
    require(initializing || isConstructor() || !initialized, "Contract instance has already been initialized");

    bool isTopLevelCall = !initializing;
    if (isTopLevelCall) {
      initializing = true;
      initialized = true;
    }

    _;

    if (isTopLevelCall) {
      initializing = false;
    }
  }

  /// @dev Returns true if and only if the function is running in the constructor
  function isConstructor() private view returns (bool) {
    // extcodesize checks the size of the code stored in an address, and
    // address returns the current address. Since the code is still not
    // deployed when running a constructor, any checks on its code size will
    // yield zero, making it an effective way to detect if a contract is
    // under construction or not.
    address self = address(this);
    uint256 cs;
    assembly { cs := extcodesize(self) }
    return cs == 0;
  }

  // Reserved storage space to allow for layout changes in the future.
  uint256[50] private ______gap;
}

<span class="marker" id="mapping-8"></span><span class="token mv" id="move-src-8" data-title="source_file/contract_declaration">contract Governable {
    // Storage position of the owner and pendingOwner of the contract
    bytes32
        private constant governorPosition = 0x7bea13895fa79d2831e0a9e28edede30099005a50d652d8957cf8a607ee6ca4a;
    //keccak256("OUSD.governor");

    bytes32
        private constant pendingGovernorPosition = 0x44c4d30b2eaad5130ad70c3ba6972730566f3e6359ab83e800d905c61b1c51db;
    //keccak256("OUSD.pending.governor");

    event PendingGovernorshipTransfer(
        address indexed previousGovernor,
        address indexed newGovernor
    );

    event GovernorshipTransferred(
        address indexed previousGovernor,
        address indexed newGovernor
    );

    /**
     * @dev Initializes the contract setting the deployer as the initial Governor.
     */
    constructor() internal {
        _setGovernor(msg.sender);
        emit GovernorshipTransferred(address(0), _governor());
    }

    /**
     * @dev Returns the address of the current Governor.
     */
    function governor() public view returns (address) {
        return _governor();
    }

    function _governor() internal view returns (address governorOut) {
        bytes32 position = governorPosition;
        assembly {
            governorOut := sload(position)
        }
    }

    function _pendingGovernor()
        internal
        view
        returns (address pendingGovernor)
    {
        bytes32 position = pendingGovernorPosition;
        assembly {
            pendingGovernor := sload(position)
        }
    }

    /**
     * @dev Throws if called by any account other than the Governor.
     */
    modifier onlyGovernor() {
        require(isGovernor(), "Caller is not the Governor");
        _;
    }

    /**
     * @dev Returns true if the caller is the current Governor.
     */
    function isGovernor() public view returns (bool) {
        return msg.sender == _governor();
    }

    function _setGovernor(address newGovernor) internal {
        bytes32 position = governorPosition;
        assembly {
            sstore(position, newGovernor)
        }
    }

    function _setPendingGovernor(address newGovernor) internal {
        bytes32 position = pendingGovernorPosition;
        assembly {
            sstore(position, newGovernor)
        }
    }

    /**
     * @dev Transfers Governance of the contract to a new account (`newGovernor`).
     * Can only be called by the current Governor. Must be claimed for this to complete
     * @param _newGovernor Address of the new Governor
     */
    function transferGovernance(address _newGovernor) external onlyGovernor {
        _setPendingGovernor(_newGovernor);
        emit PendingGovernorshipTransfer(_governor(), _newGovernor);
    }

    /**
     * @dev Claim Governance of the contract to a new account (`newGovernor`).
     * Can only be called by the new Governor.
     */
    function claimGovernance() external {
        require(
            msg.sender == _pendingGovernor(),
            "Only the pending Governor can complete the claim"
        );
        _changeGovernor(msg.sender);
    }

    /**
     * @dev Change Governance of the contract to a new account (`newGovernor`).
     * @param _newGovernor Address of the new Governor
     */
    function _changeGovernor(address _newGovernor) internal {
        require(_newGovernor != address(0), "New Governor is address(0)");
        emit GovernorshipTransferred(_governor(), _newGovernor);
        _setGovernor(_newGovernor);
    }
}</span>

<span class="marker" id="mapping-9"></span><span class="token mv" id="move-src-9" data-title="source_file/interface_declaration">interface IBasicToken {
    function symbol() external view returns (string memory);

    function decimals() external view returns (uint8);
}</span>

<span class="marker" id="mapping-10"></span><span class="token mv" id="move-src-10" data-title="source_file/interface_declaration">interface IMinMaxOracle {
    //Assuming 8 decimals
    function priceMin(string calldata symbol) external returns (uint256);

    function priceMax(string calldata symbol) external returns (uint256);
}</span>

<span class="marker" id="mapping-11"></span><span class="token mv" id="move-src-11" data-title="source_file/interface_declaration">interface IViewMinMaxOracle {
    function priceMin(string calldata symbol) external view returns (uint256);

    function priceMax(string calldata symbol) external view returns (uint256);
}</span>

interface IStrategy {
    /**
     * @dev Deposit the given asset to Lending platform.
     * @param _asset asset address
     * @param _amount Amount to deposit
     */
    function deposit(address _asset, uint256 _amount)
        external
        returns (uint256 amountDeposited);

    /**
     * @dev Withdraw given asset from Lending platform
     */
    function withdraw(
        address _recipient,
        address _asset,
        uint256 _amount
    ) external returns (uint256 amountWithdrawn);

    /**
     * @dev Returns the current balance of the given asset.
     */
    function checkBalance(address _asset)
        external
        view
        returns (uint256 balance);

    /**
     * @dev Returns bool indicating whether strategy supports asset.
     */
    function supportsAsset(address _asset) external view returns (bool);

    /**
     * @dev Liquidate all assets in strategy and return them to Vault.
     */
    function liquidate() external;

    /**
     * @dev Get the APR for the Strategy.
     */
    function getAPR() external view returns (uint256);

    /**
     * @dev Collect reward tokens from the Strategy.
     */
    function collectRewardToken() external;
}

<span class="marker" id="mapping-12"></span><span class="token mv" id="move-src-12" data-title="source_file/library_declaration">library Helpers {
    /**
     * @notice Fetch the `symbol()` from an ERC20 token
     * @dev Grabs the `symbol()` from a contract
     * @param _token Address of the ERC20 token
     * @return string Symbol of the ERC20 token
     */
    function getSymbol(address _token) internal view returns (string memory) {
        string memory symbol = IBasicToken(_token).symbol();
        return symbol;
    }

    /**
     * @notice Fetch the `decimals()` from an ERC20 token
     * @dev Grabs the `decimals()` from a contract and fails if
     *      the decimal value does not live within a certain range
     * @param _token Address of the ERC20 token
     * @return uint256 Decimals of the ERC20 token
     */
    function getDecimals(address _token) internal view returns (uint256) {
        uint256 decimals = IBasicToken(_token).decimals();
        require(
            decimals &gt;= 4 &amp;&amp; decimals &lt;= 18,
            "Token must have sufficient decimal places"
        );

        return decimals;
    }
}</span>

contract InitializableERC20Detailed is IERC20 {
    string private _name;
    string private _symbol;
    uint8 private _decimals;

    /**
     * @dev Sets the values for `name`, `symbol`, and `decimals`. All three of
     * these values are immutable: they can only be set once during
     * construction.
     * @notice To avoid variable shadowing appended `Arg` after arguments name.
     */
    function _initialize(
        string memory nameArg,
        string memory symbolArg,
        uint8 decimalsArg
    ) internal {
        _name = nameArg;
        _symbol = symbolArg;
        _decimals = decimalsArg;
    }

    /**
     * @dev Returns the name of the token.
     */
    function name() public view returns (string memory) {
        return _name;
    }

    /**
     * @dev Returns the symbol of the token, usually a shorter version of the
     * name.
     */
    function symbol() public view returns (string memory) {
        return _symbol;
    }

    /**
     * @dev Returns the number of decimals used to get its user representation.
     * For example, if `decimals` equals `2`, a balance of `505` tokens should
     * be displayed to a user as `5,05` (`505 / 10 ** 2`).
     *
     * Tokens usually opt for a value of 18, imitating the relationship between
     * Ether and Wei.
     *
     * NOTE: This information is only used for _display_ purposes: it in
     * no way affects any of the arithmetic of the contract, including
     * {IERC20-balanceOf} and {IERC20-transfer}.
     */
    function decimals() public view returns (uint8) {
        return _decimals;
    }
}

contract InitializableToken is ERC20, InitializableERC20Detailed {
    /**
     * @dev Initialization function for implementing contract
     * @notice To avoid variable shadowing appended `Arg` after arguments name.
     */
    function _initialize(string memory _nameArg, string memory _symbolArg)
        internal
    {
        InitializableERC20Detailed._initialize(_nameArg, _symbolArg, 18);
    }
}

<span class="marker" id="mapping-13"></span><span class="token mv" id="move-src-13" data-title="source_file/contract_declaration">contract OUSD is Initializable, InitializableToken, Governable {
    using SafeMath for uint256;
    using StableMath for uint256;

    event TotalSupplyUpdated(
        uint256 totalSupply,
        uint256 totalCredits,
        uint256 creditsPerToken
    );

    uint256 private constant MAX_SUPPLY = ~uint128(0); // (2^128) - 1

    uint256 private _totalSupply;
    uint256 private totalCredits;
    // Exchange rate between internal credits and OUSD
    uint256 private creditsPerToken;

    mapping(address =&gt; uint256) private _creditBalances;

    // Allowances denominated in OUSD
    mapping(address =&gt; mapping(address =&gt; uint256)) private _allowances;

    address public vaultAddress = address(0);

    function initialize(
        string calldata _nameArg,
        string calldata _symbolArg,
        address _vaultAddress
    ) external onlyGovernor initializer {
        InitializableToken._initialize(_nameArg, _symbolArg);

        _totalSupply = 0;
        totalCredits = 0;
        creditsPerToken = 1e18;

        vaultAddress = _vaultAddress;
    }

    /**
     * @dev Verifies that the caller is the Savings Manager contract
     */
    modifier onlyVault() {
        require(vaultAddress == msg.sender, "Caller is not the Vault");
        _;
    }

    /**
     * @return The total supply of OUSD.
     */
    function totalSupply() public view returns (uint256) {
        return _totalSupply;
    }

    /**
     * @dev Gets the balance of the specified address.
     * @param _account The address to query the balance of.
     * @return A unit256 representing the _amount of base units owned by the
     *         specified address.
     */
    function balanceOf(address _account) public view returns (uint256) {
        if (creditsPerToken == 0) return 0;
        return _creditBalances[_account].divPrecisely(creditsPerToken);
    }

    /**
     * @dev Gets the credits balance of the specified address.
     * @param _account The address to query the balance of.
     * @return A uint256 representing the _amount of base units owned by the
     *         specified address.
     */
    function creditsBalanceOf(address _account) public view returns (uint256) {
        return _creditBalances[_account];
    }

    /**
     * @dev Transfer tokens to a specified address.
     * @param _to the address to transfer to.
     * @param _value the _amount to be transferred.
     * @return true on success.
     */
    function transfer(address _to, uint256 _value) public returns (bool) {
        uint256 creditValue = _removeCredits(msg.sender, _value);
        _creditBalances[_to] = _creditBalances[_to].add(creditValue);

        emit Transfer(msg.sender, _to, _value);

        return true;
    }

    /**
     * @dev Transfer tokens from one address to another.
     * @param _from The address you want to send tokens from.
     * @param _to The address you want to transfer to.
     * @param _value The _amount of tokens to be transferred.
     */
    function transferFrom(
        address _from,
        address _to,
        uint256 _value
    ) public returns (bool) {
        _allowances[_from][msg.sender] = _allowances[_from][msg.sender].sub(
            _value
        );

        uint256 creditValue = _removeCredits(_from, _value);
        _creditBalances[_to] = _creditBalances[_to].add(creditValue);

        emit Transfer(_from, _to, _value);

        return true;
    }

    /**
     * @dev Function to check the _amount of tokens that an owner has allowed to a _spender.
     * @param _owner The address which owns the funds.
     * @param _spender The address which will spend the funds.
     * @return The number of tokens still available for the _spender.
     */
    function allowance(address _owner, address _spender)
        public
        view
        returns (uint256)
    {
        return _allowances[_owner][_spender];
    }

    /**
     * @dev Approve the passed address to spend the specified _amount of tokens on behalf of
     * msg.sender. This method is included for ERC20 compatibility.
     * increaseAllowance and decreaseAllowance should be used instead.
     * Changing an allowance with this method brings the risk that someone may transfer both
     * the old and the new allowance - if they are both greater than zero - if a transfer
     * transaction is mined before the later approve() call is mined.
     *
     * @param _spender The address which will spend the funds.
     * @param _value The _amount of tokens to be spent.
     */
    function approve(address _spender, uint256 _value) public returns (bool) {
        _allowances[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value);
        return true;
    }

    /**
     * @dev Increase the _amount of tokens that an owner has allowed to a _spender.
     * This method should be used instead of approve() to avoid the double approval vulnerability
     * described above.
     * @param _spender The address which will spend the funds.
     * @param _addedValue The _amount of tokens to increase the allowance by.
     */
    function increaseAllowance(address _spender, uint256 _addedValue)
        public
        returns (bool)
    {
        _allowances[msg.sender][_spender] = _allowances[msg.sender][_spender]
            .add(_addedValue);
        emit Approval(msg.sender, _spender, _allowances[msg.sender][_spender]);
        return true;
    }

    /**
     * @dev Decrease the _amount of tokens that an owner has allowed to a _spender.
     * @param _spender The address which will spend the funds.
     * @param _subtractedValue The _amount of tokens to decrease the allowance by.
     */
    function decreaseAllowance(address _spender, uint256 _subtractedValue)
        public
        returns (bool)
    {
        uint256 oldValue = _allowances[msg.sender][_spender];
        if (_subtractedValue &gt;= oldValue) {
            _allowances[msg.sender][_spender] = 0;
        } else {
            _allowances[msg.sender][_spender] = oldValue.sub(_subtractedValue);
        }
        emit Approval(msg.sender, _spender, _allowances[msg.sender][_spender]);
        return true;
    }

    /**
     * @notice Mints new tokens, increasing totalSupply.
     */
    function mint(address _account, uint256 _amount) external onlyVault {
        return _mint(_account, _amount);
    }

    /**
     * @dev Creates `_amount` tokens and assigns them to `_account`, increasing
     * the total supply.
     *
     * Emits a {Transfer} event with `from` set to the zero address.
     *
     * Requirements
     *
     * - `to` cannot be the zero address.
     */
    function _mint(address _account, uint256 _amount) internal {
        require(_account != address(0), "Mint to the zero address");

        _totalSupply = _totalSupply.add(_amount);

        uint256 creditAmount = _amount.mulTruncate(creditsPerToken);
        _creditBalances[_account] = _creditBalances[_account].add(creditAmount);
        totalCredits = totalCredits.add(creditAmount);

        emit Transfer(address(0), _account, _amount);
    }

    /**
     * @notice Burns tokens, decreasing totalSupply.
     */
    function burn(address account, uint256 amount) external onlyVault {
        return _burn(account, amount);
    }

    /**
     * @dev Destroys `_amount` tokens from `_account`, reducing the
     * total supply.
     *
     * Emits a {Transfer} event with `to` set to the zero address.
     *
     * Requirements
     *
     * - `_account` cannot be the zero address.
     * - `_account` must have at least `_amount` tokens.
     */
    function _burn(address _account, uint256 _amount) internal {
        require(_account != address(0), "Burn from the zero address");

        _totalSupply = _totalSupply.sub(_amount);
        uint256 creditAmount = _removeCredits(_account, _amount);
        totalCredits = totalCredits.sub(creditAmount);

        emit Transfer(_account, address(0), _amount);
    }

    /**
     * @dev Removes credits from a credit balance and burns rounding errors.
     * @param _account Account to remove credits from
     * @param _amount Amount in OUSD which will be converted to credits and
     *                removed
     */
    function _removeCredits(address _account, uint256 _amount)
        internal
        returns (uint256 creditAmount)
    {
        creditAmount = _amount.mulTruncate(creditsPerToken);
        uint256 currentCredits = _creditBalances[_account];
        if (
            currentCredits == creditAmount || currentCredits - 1 == creditAmount
        ) {
            _creditBalances[_account] = 0;
        } else if (currentCredits &gt; creditAmount) {
            _creditBalances[_account] = currentCredits - creditAmount;
        } else {
            revert("Remove exceeds balance");
        }
    }

    /**
     * @dev Modify the supply without minting new tokens. This uses a change in
     *      the exchange rate between "credits" and OUSD tokens to change balances.
     * @param _newTotalSupply New total supply of OUSD.
     * @return uint256 representing the new total supply.
     */
    function changeSupply(uint256 _newTotalSupply)
        external
        onlyVault
        returns (uint256)
    {
        require(_totalSupply &gt; 0, "Cannot increase 0 supply");

        if (_totalSupply == _newTotalSupply) {
            emit TotalSupplyUpdated(
                _totalSupply,
                totalCredits,
                creditsPerToken
            );
            return _totalSupply;
        }

        _totalSupply = _newTotalSupply;

        if (_totalSupply &gt; MAX_SUPPLY) _totalSupply = MAX_SUPPLY;

        creditsPerToken = totalCredits.divPrecisely(_totalSupply);

        emit TotalSupplyUpdated(_totalSupply, totalCredits, creditsPerToken);
        return _totalSupply;
    }
}</span>

library StableMath {
    using SafeMath for uint256;

    /**
     * @dev Scaling unit for use in specific calculations,
     * where 1 * 10**18, or 1e18 represents a unit '1'
     */
    uint256 private constant FULL_SCALE = 1e18;

    /***************************************
                    Helpers
    ****************************************/

    /**
     * @dev Adjust the scale of an integer
     * @param adjustment Amount to adjust by e.g. scaleBy(1e18, -1) == 1e17
     */
    function scaleBy(uint256 x, int8 adjustment)
        internal
        pure
        returns (uint256)
    {
        if (adjustment &gt; 0) {
            x = x.mul(10**uint256(adjustment));
        } else if (adjustment &lt; 0) {
            x = x.div(10**uint256(adjustment * -1));
        }
        return x;
    }

    /***************************************
               Precise Arithmetic
    ****************************************/

    /**
     * @dev Multiplies two precise units, and then truncates by the full scale
     * @param x Left hand input to multiplication
     * @param y Right hand input to multiplication
     * @return Result after multiplying the two inputs and then dividing by the shared
     *         scale unit
     */
    function mulTruncate(uint256 x, uint256 y) internal pure returns (uint256) {
        return mulTruncateScale(x, y, FULL_SCALE);
    }

    /**
     * @dev Multiplies two precise units, and then truncates by the given scale. For example,
     * when calculating 90% of 10e18, (10e18 * 9e17) / 1e18 = (9e36) / 1e18 = 9e18
     * @param x Left hand input to multiplication
     * @param y Right hand input to multiplication
     * @param scale Scale unit
     * @return Result after multiplying the two inputs and then dividing by the shared
     *         scale unit
     */
    function mulTruncateScale(
        uint256 x,
        uint256 y,
        uint256 scale
    ) internal pure returns (uint256) {
        // e.g. assume scale = fullScale
        // z = 10e18 * 9e17 = 9e36
        uint256 z = x.mul(y);
        // return 9e38 / 1e18 = 9e18
        return z.div(scale);
    }

    /**
     * @dev Multiplies two precise units, and then truncates by the full scale, rounding up the result
     * @param x Left hand input to multiplication
     * @param y Right hand input to multiplication
     * @return Result after multiplying the two inputs and then dividing by the shared
     *          scale unit, rounded up to the closest base unit.
     */
    function mulTruncateCeil(uint256 x, uint256 y)
        internal
        pure
        returns (uint256)
    {
        // e.g. 8e17 * 17268172638 = 138145381104e17
        uint256 scaled = x.mul(y);
        // e.g. 138145381104e17 + 9.99...e17 = 138145381113.99...e17
        uint256 ceil = scaled.add(FULL_SCALE.sub(1));
        // e.g. 13814538111.399...e18 / 1e18 = 13814538111
        return ceil.div(FULL_SCALE);
    }

    /**
     * @dev Precisely divides two units, by first scaling the left hand operand. Useful
     *      for finding percentage weightings, i.e. 8e18/10e18 = 80% (or 8e17)
     * @param x Left hand input to division
     * @param y Right hand input to division
     * @return Result after multiplying the left operand by the scale, and
     *         executing the division on the right hand input.
     */
    function divPrecisely(uint256 x, uint256 y)
        internal
        pure
        returns (uint256)
    {
        // e.g. 8e18 * 1e18 = 8e36
        uint256 z = x.mul(FULL_SCALE);
        // e.g. 8e36 / 10e18 = 8e17
        return z.div(y);
    }
}

contract <span class="marker" id="mapping-14"></span><span class="token upd" id="move-src-14" data-title="contract_declaration/identifier"><span class="cupd">Vault</span></span> is <span class="marker" id="mapping-15"></span><span class="token mv" id="move-src-15" data-title="contract_declaration/inheritance_specifier">Initializable</span><span class="marker" id="mapping-16"></span><span class="token del" data-title="contract_declaration/,">,</span> <span class="marker" id="mapping-17"></span><span class="token mv" id="move-src-16" data-title="contract_declaration/inheritance_specifier">Governable</span> {
    <span class="marker" id="mapping-18"></span><span class="token mv" id="move-src-17" data-title="contract_body/using_directive">using SafeMath for uint256;</span>
    <span class="marker" id="mapping-19"></span><span class="token mv" id="move-src-18" data-title="contract_body/using_directive">using StableMath for uint256;</span>
    <span class="marker" id="mapping-20"></span><span class="token mv" id="move-src-19" data-title="contract_body/using_directive">using SafeMath for int256;</span>
    <span class="marker" id="mapping-21"></span><span class="token mv" id="move-src-20" data-title="contract_body/using_directive">using SafeERC20 for IERC20;</span>

    <span class="marker" id="mapping-22"></span><span class="token mv" id="move-src-21" data-title="contract_body/event_definition">event AssetSupported(address _asset);</span>
    <span class="marker" id="mapping-23"></span><span class="token mv" id="move-src-22" data-title="contract_body/event_definition">event StrategyAdded(address _addr);</span>
    <span class="marker" id="mapping-24"></span><span class="token mv" id="move-src-23" data-title="contract_body/event_definition">event StrategyRemoved(address _addr);</span>
    <span class="marker" id="mapping-25"></span><span class="token mv" id="move-src-24" data-title="contract_body/event_definition">event Mint(address _addr, uint256 _value);</span>
    <span class="marker" id="mapping-26"></span><span class="token mv" id="move-src-25" data-title="contract_body/event_definition">event Redeem(address _addr, uint256 _value);</span>
    <span class="marker" id="mapping-27"></span><span class="token mv" id="move-src-26" data-title="contract_body/event_definition">event StrategyWeightsUpdated(
        address[] _strategyAddresses,
        uint256[] weights
    );</span>
    <span class="marker" id="mapping-28"></span><span class="token mv" id="move-src-27" data-title="contract_body/event_definition">event DepositsPaused();</span>
    <span class="marker" id="mapping-29"></span><span class="token mv" id="move-src-28" data-title="contract_body/event_definition">event DepositsUnpaused();</span>

    <span class="marker" id="mapping-30"></span><span class="token mv" id="move-src-29" data-title="contract_body/comment"><span class="marker" id="mapping-31"></span><span class="token upd" id="move-src-30" data-title="contract_body/comment"><span class="cupd">/</span>/<span class="cupd"> </span>Ass<span class="cupd">e</span>ts<span class="cupd"> </span>suppo<span class="cupd">r</span>t<span class="cupd">e</span>d<span class="cupd"> </span>by<span class="cupd"> the </span>Vaul<span class="cupd">t</span>,<span class="cupd"> </span>i.<span class="cupd">e</span>.<span class="cupd"> </span>S<span class="cupd">t</span><span class="cupd">a</span>blecoins</span></span>
    <span class="marker" id="mapping-32"></span><span class="token mv" id="move-src-31" data-title="contract_body/struct_declaration">struct Asset {
        bool isSupported;
    }</span>
    <span class="marker" id="mapping-33"></span><span class="token mv" id="move-src-32" data-title="contract_body/state_variable_declaration">mapping(address =&gt; Asset) assets;</span>
    <span class="marker" id="mapping-34"></span><span class="token mv" id="move-src-33" data-title="contract_body/state_variable_declaration">address[] allAssets;</span>

    <span class="marker" id="mapping-35"></span><span class="token mv" id="move-src-34" data-title="contract_body/comment"><span class="marker" id="mapping-36"></span><span class="token upd" id="move-src-35" data-title="contract_body/comment"><span class="cupd">/</span>/<span class="cupd"> </span>S<span class="cupd">t</span>r<span class="cupd">a</span><span class="cupd">t</span><span class="cupd">e</span>g<span class="cupd">i</span>e<span class="cupd">s </span><span class="cupd">s</span>upp<span class="cupd">or</span><span class="cupd">t</span><span class="cupd">e</span><span class="cupd">d </span>by<span class="cupd"> </span>th<span class="cupd">e </span>Vault</span></span>
    <span class="marker" id="mapping-37"></span><span class="token mv" id="move-src-36" data-title="contract_body/struct_declaration">struct Strategy {
        bool isSupported;
        uint256 targetWeight; // 18 decimals. 100% = 1e18
    }</span>
    <span class="marker" id="mapping-38"></span><span class="token mv" id="move-src-37" data-title="contract_body/state_variable_declaration">mapping(address =&gt; Strategy) strategies;</span>
    <span class="marker" id="mapping-39"></span><span class="token mv" id="move-src-38" data-title="contract_body/state_variable_declaration">address[] allStrategies;</span>

    <span class="marker" id="mapping-40"></span><span class="token del" data-title="contract_body/comment">// Address of the Oracle price provider contract</span>
    <span class="marker" id="mapping-41"></span><span class="token mv" id="move-src-39" data-title="contract_body/state_variable_declaration">address public priceProvider;</span>
    <span class="marker" id="mapping-42"></span><span class="token del" data-title="contract_body/comment">// Pausing bools</span>
    <span class="marker" id="mapping-43"></span><span class="token mv" id="move-src-40" data-title="contract_body/state_variable_declaration">bool public rebasePaused = false;</span>
    <span class="marker" id="mapping-44"></span><span class="token mv" id="move-src-41" data-title="contract_body/state_variable_declaration">bool public depositPaused = true;</span>
    <span class="marker" id="mapping-45"></span><span class="token del" data-title="contract_body/comment">// Redemption fee in basis points</span>
    <span class="marker" id="mapping-46"></span><span class="token mv" id="move-src-42" data-title="contract_body/state_variable_declaration">uint256 public redeemFeeBps;</span>
    <span class="marker" id="mapping-47"></span><span class="token del" data-title="contract_body/comment">// Buffer of assets to keep in Vault to handle (most) withdrawals</span>
    <span class="marker" id="mapping-48"></span><span class="token mv" id="move-src-43" data-title="contract_body/state_variable_declaration">uint256 public vaultBuffer;</span>
    <span class="marker" id="mapping-49"></span><span class="token del" data-title="contract_body/comment">// Mints over this amount automatically allocate funds. 18 decimals.</span>
    <span class="marker" id="mapping-50"></span><span class="token mv" id="move-src-44" data-title="contract_body/state_variable_declaration">uint256 public autoAllocateThreshold;</span>
    <span class="marker" id="mapping-51"></span><span class="token del" data-title="contract_body/comment">// Mints over this amount automatically rebase. 18 decimals.</span>
    <span class="marker" id="mapping-52"></span><span class="token mv" id="move-src-45" data-title="contract_body/state_variable_declaration">uint256 public rebaseThreshold;</span>

    <span class="marker" id="mapping-53"></span><span class="token mv" id="move-src-46" data-title="contract_body/state_variable_declaration">OUSD oUSD;</span>

    /**
     * @dev Verifies that the rebasing is not paused.
     */
    modifier whenNotRebasePaused() {
        require(!rebasePaused, "Rebasing paused");
        _;
    }

    <span class="marker" id="mapping-54"></span><span class="token del" data-title="contract_body/comment">/***************************************
                 Configuration
    ****************************************/</span>

    <span class="marker" id="mapping-55"></span><span class="token del" data-title="contract_body/comment">/**
     * @dev Set address of price provider.
     * @param _priceProvider Address of price provider
     */</span>
    <span class="marker" id="mapping-56"></span><span class="token mv" id="move-src-47" data-title="contract_body/function_definition">function <span class="marker" id="mapping-57"></span><span class="token upd" id="move-src-48" data-title="function_definition/identifier"><span class="cupd">set</span>PriceProvider</span>(address <span class="marker" id="mapping-58"></span><span class="token upd" id="move-src-49" data-title="parameter/identifier">_priceProvider</span>) external onlyGovernor {
        <span class="marker" id="mapping-59"></span><span class="token del" data-title="function_body/expression_statement">priceProvider = _priceProvider;</span>
    }</span>

    <span class="marker" id="mapping-60"></span><span class="token del" data-title="contract_body/comment">/**
     * @dev Set a fee in basis points to be charged for a redeem.
     * @param _redeemFeeBps Basis point fee to be charged
     */</span>
    <span class="marker" id="mapping-61"></span><span class="token del" data-title="contract_body/function_definition">function setRedeemFeeBps(<span class="marker" id="mapping-62"></span><span class="token del" data-title="function_definition/parameter">uint256 _redeemFeeBps</span>) <span class="marker" id="mapping-63"></span><span class="token mv" id="move-src-50" data-title="function_definition/visibility">external</span> <span class="marker" id="mapping-64"></span><span class="token del" data-title="function_definition/modifier_invocation">onlyGovernor</span> <span class="marker" id="mapping-65"></span><span class="token del" data-title="function_definition/function_body">{
        redeemFeeBps = _redeemFeeBps;
    }</span></span>

    <span class="marker" id="mapping-66"></span><span class="token del" data-title="contract_body/comment">/**
     * @dev Set a buffer of assets to keep in the Vault to handle most
     * redemptions without needing to spend gas unwinding assets from a Strategy.
     * @param _vaultBuffer Percentage using 18 decimals. 100% = 1e18.
     */</span>
    <span class="marker" id="mapping-67"></span><span class="token del" data-title="contract_body/function_definition">function setVaultBuffer(uint256 _vaultBuffer) external onlyGovernor {
        vaultBuffer = _vaultBuffer;
    }</span>

    <span class="marker" id="mapping-68"></span><span class="token del" data-title="contract_body/comment">/**
     * @dev Sets the minimum amount of OUSD in a mint to trigger an
     * automatic allocation of funds afterwords.
     * @param _threshold OUSD amount with 18 fixed decimals.
     */</span>
    <span class="marker" id="mapping-69"></span><span class="token del" data-title="contract_body/function_definition">function setAutoAllocateThreshold(uint256 _threshold)
        external
        onlyGovernor
    {
        autoAllocateThreshold = _threshold;
    }</span>

    <span class="marker" id="mapping-70"></span><span class="token del" data-title="contract_body/comment">/**
     * @dev Set a minimum amount of OUSD in a mint or redeem that triggers a
     * rebase
     * @param _threshold OUSD amount with 18 fixed decimals.
     */</span>
    <span class="marker" id="mapping-71"></span><span class="token del" data-title="contract_body/function_definition">function setRebaseThreshold(uint256 _threshold) external onlyGovernor {
        rebaseThreshold = _threshold;
    }</span>

    <span class="marker" id="mapping-72"></span><span class="token del" data-title="contract_body/comment">/** @dev Add a supported asset to the contract, i.e. one that can be
     *         to mint OUSD.
     * @param _asset Address of asset
     */</span>
    <span class="marker" id="mapping-73"></span><span class="token del" data-title="contract_body/function_definition">function supportAsset(<span class="marker" id="mapping-74"></span><span class="token del" data-title="function_definition/parameter">address _asset</span>) <span class="marker" id="mapping-75"></span><span class="token del" data-title="function_definition/visibility">external</span> <span class="marker" id="mapping-76"></span><span class="token del" data-title="function_definition/modifier_invocation">onlyGovernor</span> <span class="marker" id="mapping-77"></span><span class="token del" data-title="function_definition/function_body">{
        <span class="marker" id="mapping-78"></span><span class="token del" data-title="function_body/expression_statement">require(!assets[_asset].isSupported, "Asset already supported");</span>

        <span class="marker" id="mapping-79"></span><span class="token mv" id="move-src-51" data-title="function_body/expression_statement"><span class="marker" id="mapping-80"></span><span class="token del" data-title="expression_statement/assignment_expression"><span class="marker" id="mapping-81"></span><span class="token del" data-title="assignment_expression/array_access">assets[_asset]</span> = <span class="marker" id="mapping-82"></span><span class="token mv" id="move-src-52" data-title="assignment_expression/call_expression"><span class="marker" id="mapping-83"></span><span class="token upd" id="move-src-53" data-title="call_expression/identifier">A<span class="cupd">s</span>set</span>(<span class="marker" id="mapping-84"></span><span class="token del" data-title="call_argument/{">{</span> <span class="marker" id="mapping-85"></span><span class="token del" data-title="call_argument/call_struct_argument">isSupported: <span class="marker" id="mapping-86"></span><span class="token mv" id="move-src-54" data-title="call_struct_argument/boolean_literal">true</span></span> <span class="marker" id="mapping-87"></span><span class="token del" data-title="call_argument/}">}</span>)</span></span>;</span>
        <span class="marker" id="mapping-88"></span><span class="token del" data-title="function_body/expression_statement">allAssets.push(_asset);</span>

        <span class="marker" id="mapping-89"></span><span class="token del" data-title="function_body/emit_statement">emit AssetSupported(_asset);</span>
    }</span></span>

    <span class="marker" id="mapping-90"></span><span class="token del" data-title="contract_body/comment">/**
     * @dev Add a strategy to the Vault.
     * @param _addr Address of the strategy to add
     * @param _targetWeight Target percentage of asset allocation to strategy
     */</span>
    <span class="marker" id="mapping-91"></span><span class="token del" data-title="contract_body/function_definition">function addStrategy(<span class="marker" id="mapping-92"></span><span class="token mv" id="move-src-55" data-title="function_definition/parameter">address <span class="marker" id="mapping-93"></span><span class="token del" data-title="parameter/identifier">_addr</span></span>, <span class="marker" id="mapping-94"></span><span class="token del" data-title="function_definition/parameter">uint256 _targetWeight</span>)
        <span class="marker" id="mapping-95"></span><span class="token mv" id="move-src-56" data-title="function_definition/visibility">external</span>
        <span class="marker" id="mapping-96"></span><span class="token del" data-title="function_definition/modifier_invocation">onlyGovernor</span>
    <span class="marker" id="mapping-97"></span><span class="token del" data-title="function_definition/function_body">{
        <span class="marker" id="mapping-98"></span><span class="token del" data-title="function_body/expression_statement">require(!strategies[_addr].isSupported, "Strategy already added");</span>

        <span class="marker" id="mapping-99"></span><span class="token del" data-title="function_body/expression_statement"><span class="marker" id="mapping-100"></span><span class="token del" data-title="expression_statement/assignment_expression"><span class="marker" id="mapping-101"></span><span class="token del" data-title="assignment_expression/array_access">strategies[_addr]</span> = <span class="marker" id="mapping-102"></span><span class="token del" data-title="assignment_expression/call_expression">Strategy(<span class="marker" id="mapping-103"></span><span class="token del" data-title="call_expression/call_argument">{
            <span class="marker" id="mapping-104"></span><span class="token del" data-title="call_argument/call_struct_argument">isSupported: <span class="marker" id="mapping-105"></span><span class="token mv" id="move-src-57" data-title="call_struct_argument/boolean_literal">true</span></span>,
            <span class="marker" id="mapping-106"></span><span class="token del" data-title="call_argument/call_struct_argument">targetWeight: _targetWeight</span>
        }</span>)</span></span>;</span>
        <span class="marker" id="mapping-107"></span><span class="token del" data-title="function_body/expression_statement">allStrategies.push(_addr);</span>

        <span class="marker" id="mapping-108"></span><span class="token del" data-title="function_body/emit_statement">emit StrategyAdded(_addr);</span>
    }</span></span>

    <span class="marker" id="mapping-109"></span><span class="token del" data-title="contract_body/comment">/**
     * @dev Remove a strategy from the Vault. Removes all invested assets and
     * returns them to the Vault.
     * @param _addr Address of the strategy to remove
     */</span>

    <span class="marker" id="mapping-110"></span><span class="token del" data-title="contract_body/function_definition">function removeStrategy(<span class="marker" id="mapping-111"></span><span class="token del" data-title="function_definition/parameter"><span class="marker" id="mapping-112"></span><span class="token mv" id="move-src-58" data-title="parameter/type_name">address</span> _addr</span>) <span class="marker" id="mapping-113"></span><span class="token del" data-title="function_definition/visibility">external</span> <span class="marker" id="mapping-114"></span><span class="token del" data-title="function_definition/modifier_invocation">onlyGovernor</span> <span class="marker" id="mapping-115"></span><span class="token del" data-title="function_definition/function_body">{
        <span class="marker" id="mapping-116"></span><span class="token del" data-title="function_body/expression_statement">require(strategies[_addr].isSupported, "Strategy not added");</span>

        // Initialize strategyIndex with out of bounds result so function will
        // revert if no valid index found
        <span class="marker" id="mapping-117"></span><span class="token mv" id="move-src-59" data-title="function_body/variable_declaration_statement">uint256 <span class="marker" id="mapping-118"></span><span class="token upd" id="move-src-60" data-title="variable_declaration/identifier">s<span class="cupd">t</span>r<span class="cupd">a</span>tegyIndex</span> = <span class="marker" id="mapping-119"></span><span class="token del" data-title="variable_declaration_statement/member_expression">allStrategies.length</span>;</span>
        <span class="marker" id="mapping-120"></span><span class="token del" data-title="function_body/for_statement">for (<span class="marker" id="mapping-121"></span><span class="token mv" id="move-src-61" data-title="for_statement/variable_declaration_statement">uint256 <span class="marker" id="mapping-122"></span><span class="token upd" id="move-src-62" data-title="variable_declaration/identifier">i</span> = <span class="marker" id="mapping-123"></span><span class="token del" data-title="variable_declaration_statement/number_literal">0</span>;</span> <span class="marker" id="mapping-124"></span><span class="token del" data-title="for_statement/expression_statement">i &lt; allStrategies.length;</span> <span class="marker" id="mapping-125"></span><span class="token del" data-title="for_statement/update_expression">i++</span>) <span class="marker" id="mapping-126"></span><span class="token del" data-title="for_statement/block_statement">{
            if (allStrategies[i] == _addr) {
                strategyIndex = i;
                break;
            }
        }</span></span>

        <span class="marker" id="mapping-127"></span><span class="token del" data-title="function_body/expression_statement">assert(strategyIndex &lt; allStrategies.length);</span>

        <span class="marker" id="mapping-128"></span><span class="token del" data-title="function_body/expression_statement">allStrategies[strategyIndex] = allStrategies[allStrategies.length - 1];</span>
        <span class="marker" id="mapping-129"></span><span class="token del" data-title="function_body/expression_statement">allStrategies.length--;</span>

        // Liquidate all assets
        <span class="marker" id="mapping-130"></span><span class="token del" data-title="function_body/variable_declaration_statement">IStrategy strategy = IStrategy(_addr);</span>
        <span class="marker" id="mapping-131"></span><span class="token del" data-title="function_body/expression_statement">strategy.liquidate();</span>

        <span class="marker" id="mapping-132"></span><span class="token del" data-title="function_body/emit_statement">emit StrategyRemoved(_addr);</span>
    }</span></span>

    <span class="marker" id="mapping-133"></span><span class="token del" data-title="contract_body/comment">/**
     * @notice Set the weights for multiple strategies.
     * @param _strategyAddresses Array of strategy addresses
     * @param _weights Array of corresponding weights, with 18 decimals.
     *                 For ex. 100%=1e18, 30%=3e17.
     */</span>
    <span class="marker" id="mapping-134"></span><span class="token del" data-title="contract_body/function_definition">function setStrategyWeights(
        <span class="marker" id="mapping-135"></span><span class="token del" data-title="function_definition/parameter">address[] calldata _strategyAddresses</span>,
        <span class="marker" id="mapping-136"></span><span class="token del" data-title="function_definition/parameter">uint256[] calldata _weights</span>
    ) <span class="marker" id="mapping-137"></span><span class="token mv" id="move-src-63" data-title="function_definition/visibility">external</span> <span class="marker" id="mapping-138"></span><span class="token del" data-title="function_definition/modifier_invocation">onlyGovernor</span> <span class="marker" id="mapping-139"></span><span class="token del" data-title="function_definition/function_body">{
        require(
            _strategyAddresses.length == _weights.length,
            "Parameter length mismatch"
        );

        for (uint256 i = 0; i &lt; _strategyAddresses.length; i++) {
            strategies[_strategyAddresses[i]].targetWeight = _weights[i];
        }

        emit StrategyWeightsUpdated(_strategyAddresses, _weights);
    }</span></span>

    <span class="marker" id="mapping-140"></span><span class="token del" data-title="contract_body/comment">/***************************************
                      Core
    ****************************************/</span>

    /**
     * @dev Deposit a supported asset and mint OUSD.
     * @param _asset Address of the asset being deposited
     * @param _amount Amount of the asset being deposited
     */
    function mint(address _asset, uint256 _amount) external {
        <span class="marker" id="mapping-141"></span><span class="token mv" id="move-src-64" data-title="function_body/expression_statement">require(!depositPaused, "Deposits are paused");</span>
        require(assets[_asset].isSupported, "Asset is not supported");
        require(_amount &gt; 0, "Amount must be greater than 0");

        uint256[] memory assetPrices;
        // For now we have to live with the +1 oracle call because we need to
        // know the priceAdjustedDeposit before we decide wether or not to grab
        // assets. This will not effect small non-rebase/allocate mints
        uint256 priceAdjustedDeposit = _amount.mulTruncateScale(
            IMinMaxOracle(priceProvider)
                .priceMin(Helpers.getSymbol(_asset))
                .scaleBy(int8(10)), // 18-8 because oracles have 8 decimals precision
            10**Helpers.getDecimals(_asset)
        );
        if (
            (priceAdjustedDeposit &gt; rebaseThreshold &amp;&amp; !rebasePaused) ||
            (priceAdjustedDeposit &gt;= autoAllocateThreshold)
        ) {
            assetPrices = _getAssetPrices(false);
        }

        // Rebase must happen before any transfers occur.
        if (priceAdjustedDeposit &gt; rebaseThreshold &amp;&amp; !rebasePaused) {
            rebase(<span class="marker" id="mapping-142"></span><span class="token mv" id="move-src-65" data-title="call_expression/call_argument">assetPrices</span>);
        }

        // Transfer the deposited coins to the vault
        IERC20 asset = IERC20(_asset);
        asset.safeTransferFrom(msg.sender, address(this), _amount);

        // Mint matching OUSD
        oUSD.mint(msg.sender, priceAdjustedDeposit);
        emit Mint(msg.sender, priceAdjustedDeposit);

        if (priceAdjustedDeposit &gt;= autoAllocateThreshold) {
            allocate(assetPrices);
        }
    }

    /**
     * @dev Mint for multiple assets in the same call.
     * @param _assets Addresses of assets being deposited
     * @param _amounts Amount of each asset at the same index in the _assets
     *                 to deposit.
     */
    function mintMultiple(
        address[] calldata _assets,
        uint256[] calldata _amounts
    ) external {
        require(_assets.length == _amounts.length, "Parameter length mismatch");

        uint256 priceAdjustedTotal = 0;
        uint256[] memory assetPrices = _getAssetPrices(false);
        for (uint256 i = 0; i &lt; allAssets.length; i++) {
            for (uint256 j = 0; j &lt; _assets.length; j++) {
                if (_assets[j] == allAssets[i]) {
                    if (_amounts[j] &gt; 0) {
                        uint256 assetDecimals = Helpers.getDecimals(
                            allAssets[i]
                        );
                        priceAdjustedTotal += _amounts[j].mulTruncateScale(
                            assetPrices[i],
                            10**assetDecimals
                        );
                    }
                }
            }
        }
        // Rebase must happen before any transfers occur.
        if (priceAdjustedTotal &gt; rebaseThreshold &amp;&amp; !rebasePaused) {
            rebase(<span class="marker" id="mapping-143"></span><span class="token mv" id="move-src-66" data-title="call_expression/call_argument">assetPrices</span>);
        }

        for (uint256 i = 0; i &lt; _assets.length; i++) {
            IERC20 asset = IERC20(_assets[i]);
            asset.safeTransferFrom(msg.sender, address(this), _amounts[i]);
        }

        oUSD.mint(msg.sender, priceAdjustedTotal);
        emit Mint(msg.sender, priceAdjustedTotal);

        if (priceAdjustedTotal &gt;= autoAllocateThreshold) {
            allocate(assetPrices);
        }
    }

    /**
     * @dev Withdraw a supported asset and burn OUSD.
     * @param _amount Amount of OUSD to burn
     */
    function redeem(uint256 _amount) public {
        uint256[] memory assetPrices = _getAssetPrices(false);
        if (_amount &gt; rebaseThreshold &amp;&amp; !rebasePaused) {
            rebase(assetPrices);
        }
        _redeem(_amount, assetPrices);
    }

    function _redeem(uint256 _amount, uint256[] memory assetPrices) internal {
        require(_amount &gt; 0, "Amount must be greater than 0");

        uint256 feeAdjustedAmount;
        if (redeemFeeBps &gt; 0) {
            uint256 redeemFee = _amount.mul(redeemFeeBps).div(10000);
            feeAdjustedAmount = _amount.sub(redeemFee);
        } else {
            feeAdjustedAmount = _amount;
        }

        // Calculate redemption outputs
        uint256[] memory outputs = _calculateRedeemOutputs(feeAdjustedAmount);
        // Send outputs
        for (uint256 i = 0; i &lt; allAssets.length; i++) {
            if (outputs[i] == 0) continue;

            IERC20 asset = IERC20(allAssets[i]);

            if (asset.balanceOf(address(this)) &gt;= outputs[i]) {
                // Use Vault funds first if sufficient
                asset.safeTransfer(msg.sender, outputs[i]);
            } else {
                address strategyAddr = _selectWithdrawStrategyAddr(
                    allAssets[i],
                    outputs[i],
                    assetPrices
                );

                if (strategyAddr != address(0)) {
                    // Nothing in Vault, but something in Strategy, send from there
                    IStrategy strategy = IStrategy(strategyAddr);
                    strategy.withdraw(msg.sender, allAssets[i], outputs[i]);
                } else {
                    // Cant find funds anywhere
                    revert("Liquidity error");
                }
            }
        }

        oUSD.burn(msg.sender, _amount);

        // Until we can prove that we won't affect the prices of our assets
        // by withdrawing them, this should be here.
        // It's possible that a strategy was off on its asset total, perhaps
        // a reward token sold for more or for less than anticipated.
        if (_amount &gt; rebaseThreshold &amp;&amp; !rebasePaused) {
            <span class="marker" id="mapping-144"></span><span class="token del" data-title="block_statement/expression_statement"><span class="marker" id="mapping-145"></span><span class="token del" data-title="expression_statement/call_expression">rebase(<span class="marker" id="mapping-146"></span><span class="token mv" id="move-src-67" data-title="call_expression/call_argument">assetPrices</span>)</span>;</span>
        }

        emit Redeem(msg.sender, _amount);
    }

    /**
     * @notice Withdraw a supported asset and burn all OUSD.
     */
    function redeemAll() external {
        uint256[] memory assetPrices = _getAssetPrices(false);
        //unfortunately we have to do balanceOf twice
        if (oUSD.balanceOf(msg.sender) &gt; rebaseThreshold &amp;&amp; !rebasePaused) {
            rebase(<span class="marker" id="mapping-147"></span><span class="token mv" id="move-src-68" data-title="call_expression/call_argument">assetPrices</span>);
        }

        _redeem(oUSD.balanceOf(msg.sender), assetPrices);
    }

    /**
     * @notice Allocate unallocated funds on Vault to strategies.
     * @dev Allocate unallocated funds on Vault to strategies.
     **/
    function allocate() public {
        uint256[] memory assetPrices = _getAssetPrices(false);
        allocate(assetPrices);
    }

    /**
     * @notice Allocate unallocated funds on Vault to strategies.
     * @dev Allocate unallocated funds on Vault to strategies.
     **/
    function allocate(uint256[] memory assetPrices) internal {
        uint256 vaultValue = _totalValueInVault(assetPrices);
        // Nothing in vault to allocate
        if (vaultValue == 0) return;
        uint256 strategiesValue = _totalValueInStrategies(assetPrices);
        // We have a method that does the same as this, gas optimisation
        uint256 totalValue = vaultValue + strategiesValue;

        // We want to maintain a buffer on the Vault so calculate a percentage
        // modifier to multiply each amount being allocated by to enforce the
        // vault buffer
        uint256 vaultBufferModifier;
        if (strategiesValue == 0) {
            // Nothing in Strategies, allocate 100% minus the vault buffer to
            // strategies
            vaultBufferModifier = 1e18 - vaultBuffer;
        } else {
            vaultBufferModifier = vaultBuffer.mul(totalValue).div(vaultValue);
            if (1e18 &gt; vaultBufferModifier) {
                // E.g. 1e18 - (1e17 * 10e18)/5e18 = 8e17
                // (5e18 * 8e17) / 1e18 = 4e18 allocated from Vault
                vaultBufferModifier = 1e18 - vaultBufferModifier;
            } else {
                // We need to let the buffer fill
                return;
            }
        }

        if (vaultBufferModifier == 0) return;

        // Iterate over all assets in the Vault and allocate the the appropriate
        // strategy
        for (uint256 i = 0; i &lt; allAssets.length; i++) {
            IERC20 asset = IERC20(allAssets[i]);
            uint256 assetBalance = asset.balanceOf(address(this));
            // No balance, nothing to do here
            if (assetBalance == 0) continue;

            // Multiply the balance by the vault buffer modifier and truncate
            // to the scale of the asset decimals
            uint256 allocateAmount = assetBalance.mulTruncate(
                vaultBufferModifier
            );

            // Get the target Strategy to maintain weightings
            address depositStrategyAddr = _selectDepositStrategyAddr(
                address(asset),
                assetPrices
            );

            if (depositStrategyAddr != address(0) &amp;&amp; allocateAmount &gt; 0) {
                IStrategy strategy = IStrategy(depositStrategyAddr);
                // Transfer asset to Strategy and call deposit method to
                // mint or take required action
                asset.safeTransfer(address(strategy), allocateAmount);
                strategy.deposit(address(asset), allocateAmount);
            }
        }
    }

    /**
     * @dev Calculate the total value of assets held by the Vault and all
     *         strategies and update the supply of oUSD
     */
    function rebase() public whenNotRebasePaused returns (uint256) {
        uint256[] memory assetPrices = _getAssetPrices(false);
        rebase(assetPrices);
    }

    /**
     * @dev Calculate the total value of assets held by the Vault and all
     *         strategies and update the supply of oUSD
     */
    function rebase(uint256[] memory assetPrices)
        internal
        whenNotRebasePaused
        returns (uint256)
    {
        if (oUSD.totalSupply() == 0) return 0;
        <span class="marker" id="mapping-148"></span><span class="token del" data-title="function_body/return_statement">return <span class="marker" id="mapping-149"></span><span class="token mv" id="move-src-69" data-title="return_statement/call_expression">oUSD.changeSupply(_totalValue(assetPrices))</span>;</span>
    }

    /**
     * @dev Determine the total value of assets held by the vault and its
     *         strategies.
     * @return uint256 value Total value in USD (1e18)
     */
    function totalValue() external returns (uint256 value) {
        uint256[] memory assetPrices = _getAssetPrices(false);
        value = _totalValue(assetPrices);
    }

    /**
     * @dev Internal Calculate the total value of the assets held by the
     *         vault and its strategies.
     * @return uint256 value Total value in USD (1e18)
     */
    function _totalValue(uint256[] memory assetPrices)
        internal
        view
        returns (uint256 value)
    {
        return
            _totalValueInVault(assetPrices) +
            _totalValueInStrategies(assetPrices);
    }

    /**
     * @dev Internal to calculate total value of all assets held in Vault.
     * @return uint256 Total value in ETH (1e18)
     */
    function _totalValueInVault(uint256[] memory assetPrices)
        internal
        view
        returns (uint256 value)
    {
        value = 0;
        for (uint256 y = 0; y &lt; allAssets.length; y++) {
            IERC20 asset = IERC20(allAssets[y]);
            uint256 assetDecimals = Helpers.getDecimals(allAssets[y]);
            uint256 balance = asset.balanceOf(address(this));
            if (balance &gt; 0) {
                value += balance.mulTruncateScale(
                    assetPrices[y],
                    10**assetDecimals
                );
            }
        }
    }

    /**
     * @dev Internal to calculate total value of all assets held in Strategies.
     * @return uint256 Total value in ETH (1e18)
     */
    function _totalValueInStrategies(uint256[] memory assetPrices)
        internal
        view
        returns (uint256 value)
    {
        value = 0;
        for (uint256 i = 0; i &lt; allStrategies.length; i++) {
            value += _totalValueInStrategy(allStrategies[i], assetPrices);
        }
    }

    /**
     * @dev Internal to calculate total value of all assets held by strategy.
     * @param _strategyAddr Address of the strategy
     * @return uint256 Total value in ETH (1e18)
     */
    function _totalValueInStrategy(
        address _strategyAddr,
        uint256[] memory assetPrices
    ) internal view returns (uint256 value) {
        value = 0;
        IStrategy strategy = IStrategy(_strategyAddr);
        for (uint256 y = 0; y &lt; allAssets.length; y++) {
            uint256 assetDecimals = Helpers.getDecimals(allAssets[y]);
            if (strategy.supportsAsset(allAssets[y])) {
                uint256 balance = strategy.checkBalance(allAssets[y]);
                if (balance &gt; 0) {
                    value += balance.mulTruncateScale(
                        assetPrices[y],
                        10**assetDecimals
                    );
                }
            }
        }
    }

    /**
     * @dev Calculate difference in percent of asset allocation for a
               strategy.
     * @param _strategyAddr Address of the strategy
     * @return int256 Difference between current and target. 18 decimals. For ex. 10%=1e17.
     */
    function _strategyWeightDifference(
        address _strategyAddr,
        uint256[] memory assetPrices
    ) internal view returns (int256 difference) {
        difference =
            int256(strategies[_strategyAddr].targetWeight) -
            int256(
                _totalValueInStrategy(_strategyAddr, assetPrices).divPrecisely(
                    _totalValue(assetPrices)
                )
            );
    }

    /**
     * @dev Select a strategy for allocating an asset to.
     * @param _asset Address of asset
     * @return address Address of the target strategy
     */
    function _selectDepositStrategyAddr(
        address _asset,
        uint256[] memory assetPrices
    ) internal view returns (address depositStrategyAddr) {
        depositStrategyAddr = address(0);
        int256 maxDifference = 0;

        for (uint256 i = 0; i &lt; allStrategies.length; i++) {
            IStrategy strategy = IStrategy(allStrategies[i]);
            if (strategy.supportsAsset(_asset)) {
                int256 diff = _strategyWeightDifference(
                    allStrategies[i],
                    assetPrices
                );
                if (diff &gt;= maxDifference) {
                    maxDifference = diff;
                    depositStrategyAddr = allStrategies[i];
                }
            }
        }
    }

    /**
     * @dev Select a strategy for withdrawing an asset from.
     * @param _asset Address of asset
     * @return address Address of the target strategy for withdrawal
     */
    function _selectWithdrawStrategyAddr(
        address _asset,
        uint256 _amount,
        uint256[] memory assetPrices
    ) internal view returns (address withdrawStrategyAddr) {
        withdrawStrategyAddr = address(0);
        int256 minDifference = 1e18;

        for (uint256 i = 0; i &lt; allStrategies.length; i++) {
            IStrategy strategy = IStrategy(allStrategies[i]);
            if (
                strategy.supportsAsset(_asset) &amp;&amp;
                strategy.checkBalance(_asset) &gt; _amount
            ) {
                int256 diff = _strategyWeightDifference(
                    allStrategies[i],
                    assetPrices
                );
                if (diff &lt;= minDifference) {
                    minDifference = diff;
                    withdrawStrategyAddr = allStrategies[i];
                }
            }
        }
    }

    /**
     * @notice Get the balance of an asset held in Vault and all strategies.
     * @param _asset Address of asset
     * @return uint256 Balance of asset in decimals of asset
     */
    function checkBalance(address _asset) external view returns (uint256) {
        return _checkBalance(_asset);
    }

    /**
     * @notice Get the balance of an asset held in Vault and all strategies.
     * @param _asset Address of asset
     * @return uint256 Balance of asset in decimals of asset
     */
    function _checkBalance(address _asset)
        internal
        view
        returns (uint256 balance)
    {
        IERC20 asset = IERC20(_asset);
        balance = asset.balanceOf(address(this));
        for (uint256 i = 0; i &lt; allStrategies.length; i++) {
            IStrategy strategy = IStrategy(allStrategies[i]);
            if (strategy.supportsAsset(_asset)) {
                balance += strategy.checkBalance(_asset);
            }
        }
    }

    /**
     * @notice Get the balance of all assets held in Vault and all strategies.
     * @return uint256 Balance of all assets (1e18)
     */
    function _checkBalance() internal view returns (uint256 balance) {
        balance = 0;
        for (uint256 i = 0; i &lt; allAssets.length; i++) {
            uint256 assetDecimals = Helpers.getDecimals(allAssets[i]);
            balance += _checkBalance(allAssets[i]).scaleBy(
                int8(18 - assetDecimals)
            );
        }
    }

    /**
     * @notice Calculate the outputs for a redeem function, i.e. the mix of
     * coins that will be returned
     */
    function calculateRedeemOutputs(uint256 _amount)
        external
        returns (uint256[] memory)
    {
        return _calculateRedeemOutputs(_amount);
    }

    /**
     * @notice Calculate the outputs for a redeem function, i.e. the mix of
     * coins that will be returned.
     * @return Array of amounts respective to the supported assets
     */
    function _calculateRedeemOutputs(uint256 _amount)
        internal
        returns (uint256[] memory outputs)
    {
        uint256[] memory assetPrices = _getAssetPrices(true);

        uint256 totalBalance = _checkBalance();
        uint256 totalOutputValue = 0; // Running total of USD value of assets
        uint256 assetCount = getAssetCount();

        // Initialise arrays
        // Price of each asset in USD in 1e18
        outputs = new uint256[](assetCount);

        for (uint256 i = 0; i &lt; allAssets.length; i++) {
            uint256 assetDecimals = Helpers.getDecimals(allAssets[i]);

            // Get the proportional amount of this token for the redeem in 1e18
            uint256 proportionalAmount = _checkBalance(allAssets[i])
                .scaleBy(int8(18 - assetDecimals))
                .mul(_amount)
                .div(totalBalance);

            if (proportionalAmount &gt; 0) {
                // Running USD total of all coins in the redeem outputs in 1e18
                totalOutputValue += proportionalAmount.mulTruncate(
                    assetPrices[i]
                );
                // Save the output amount in the decimals of the asset
                outputs[i] = proportionalAmount.scaleBy(
                    int8(assetDecimals - 18)
                );
            }
        }

        // USD difference in amount of coins calculated due to variations in
        // price in 1e18
        int256 outputValueDiff = int256(_amount - totalOutputValue);
        // Make up the difference by adding/removing an equal proportion of
        // each coin according to its USD value
        for (uint256 i = 0; i &lt; outputs.length; i++) {
            if (outputs[i] == 0) continue;
            if (outputValueDiff &lt; 0) {
                outputs[i] -= uint256(-outputValueDiff).mul(outputs[i]).div(
                    totalOutputValue
                );
            } else if (outputValueDiff &gt; 0) {
                outputs[i] += uint256(outputValueDiff).mul(outputs[i]).div(
                    totalOutputValue
                );
            }
        }
    }

    /**
     * @notice Get an array of the supported asset prices in USD.
     * @return uint256[] Array of asset prices in USD (1e18)
     */
    function _getAssetPrices(bool useMax)
        internal
        returns (uint256[] memory assetPrices)
    {
        assetPrices = new uint256[](getAssetCount());

        IMinMaxOracle oracle = IMinMaxOracle(priceProvider);
        // Price from Oracle is returned with 8 decimals
        // _amount is in assetDecimals

        for (uint256 i = 0; i &lt; allAssets.length; i++) {
            string memory symbol = Helpers.getSymbol(allAssets[i]);
            // Get all the USD prices of the asset in 1e18
            if (useMax) {
                assetPrices[i] = oracle.priceMax(symbol).scaleBy(int8(18 - 8));
            } else {
                assetPrices[i] = oracle.priceMin(symbol).scaleBy(int8(18 - 8));
            }
        }
    }

    <span class="marker" id="mapping-150"></span><span class="token del" data-title="contract_body/comment">/***************************************
                    Pause
    ****************************************/</span>

    <span class="marker" id="mapping-151"></span><span class="token del" data-title="contract_body/comment">/**
     * @dev Set the deposit paused flag to true to prevent rebasing.
     */</span>
    <span class="marker" id="mapping-152"></span><span class="token del" data-title="contract_body/function_definition">function pauseRebase() <span class="marker" id="mapping-153"></span><span class="token del" data-title="function_definition/visibility">external</span> <span class="marker" id="mapping-154"></span><span class="token del" data-title="function_definition/modifier_invocation">onlyGovernor</span> <span class="marker" id="mapping-155"></span><span class="token del" data-title="function_definition/function_body">{
        <span class="marker" id="mapping-156"></span><span class="token del" data-title="function_body/expression_statement"><span class="marker" id="mapping-157"></span><span class="token del" data-title="expression_statement/assignment_expression">rebasePaused = <span class="marker" id="mapping-158"></span><span class="token mv" id="move-src-70" data-title="assignment_expression/boolean_literal">true</span></span>;</span>
    }</span></span>

    <span class="marker" id="mapping-159"></span><span class="token del" data-title="contract_body/comment">/**
     * @dev Set the deposit paused flag to true to allow rebasing.
     */</span>
    <span class="marker" id="mapping-160"></span><span class="token del" data-title="contract_body/function_definition">function unpauseRebase() <span class="marker" id="mapping-161"></span><span class="token del" data-title="function_definition/visibility">external</span> <span class="marker" id="mapping-162"></span><span class="token del" data-title="function_definition/modifier_invocation">onlyGovernor</span> <span class="marker" id="mapping-163"></span><span class="token del" data-title="function_definition/function_body">{
        <span class="marker" id="mapping-164"></span><span class="token del" data-title="function_body/expression_statement"><span class="marker" id="mapping-165"></span><span class="token del" data-title="expression_statement/assignment_expression">rebasePaused = <span class="marker" id="mapping-166"></span><span class="token mv" id="move-src-71" data-title="assignment_expression/boolean_literal">false</span></span>;</span>
    }</span></span>

    <span class="marker" id="mapping-167"></span><span class="token del" data-title="contract_body/comment">/**
     * @dev Set the deposit paused flag to true to prevent deposits.
     */</span>
    <span class="marker" id="mapping-168"></span><span class="token del" data-title="contract_body/function_definition">function pauseDeposits() <span class="marker" id="mapping-169"></span><span class="token del" data-title="function_definition/visibility">external</span> <span class="marker" id="mapping-170"></span><span class="token del" data-title="function_definition/modifier_invocation">onlyGovernor</span> <span class="marker" id="mapping-171"></span><span class="token del" data-title="function_definition/function_body">{
        <span class="marker" id="mapping-172"></span><span class="token del" data-title="function_body/expression_statement"><span class="marker" id="mapping-173"></span><span class="token del" data-title="expression_statement/assignment_expression">depositPaused = <span class="marker" id="mapping-174"></span><span class="token mv" id="move-src-72" data-title="assignment_expression/boolean_literal">true</span></span>;</span>

        <span class="marker" id="mapping-175"></span><span class="token del" data-title="function_body/emit_statement">emit DepositsPaused();</span>
    }</span></span>

    <span class="marker" id="mapping-176"></span><span class="token del" data-title="contract_body/comment">/**
     * @dev Set the deposit paused flag to false to enable deposits.
     */</span>
    <span class="marker" id="mapping-177"></span><span class="token del" data-title="contract_body/function_definition">function unpauseDeposits() <span class="marker" id="mapping-178"></span><span class="token del" data-title="function_definition/visibility">external</span> <span class="marker" id="mapping-179"></span><span class="token del" data-title="function_definition/modifier_invocation">onlyGovernor</span> <span class="marker" id="mapping-180"></span><span class="token del" data-title="function_definition/function_body">{
        <span class="marker" id="mapping-181"></span><span class="token del" data-title="function_body/expression_statement"><span class="marker" id="mapping-182"></span><span class="token del" data-title="expression_statement/assignment_expression">depositPaused = <span class="marker" id="mapping-183"></span><span class="token mv" id="move-src-73" data-title="assignment_expression/boolean_literal">false</span></span>;</span>

        <span class="marker" id="mapping-184"></span><span class="token del" data-title="function_body/emit_statement">emit DepositsUnpaused();</span>
    }</span></span>

    /***************************************
                    Utils
    ****************************************/

    /**
     * @dev Return the number of assets suppported by the Vault.
     */
    function getAssetCount() public view returns (uint256) {
        return allAssets.length;
    }

    /**
     * @dev Return all asset addresses in order
     */
    function getAllAssets() external view returns (address[] memory) {
        return allAssets;
    }

    /**
     * @dev Return the number of strategies active on the Vault.
     */
    function getStrategyCount() public view returns (uint256) {
        return allStrategies.length;
    }

    /**
     * @dev Get the total APR of the Vault and all Strategies.
     */
    function getAPR() external returns (uint256) {
        if (getStrategyCount() == 0) return 0;

        uint256[] memory assetPrices = _getAssetPrices(true);

        uint256 totalAPR = 0;
        // Get the value from strategies
        for (uint256 i = 0; i &lt; allStrategies.length; i++) {
            IStrategy strategy = IStrategy(allStrategies[i]);
            if (strategy.getAPR() &gt; 0) {
                totalAPR += _totalValueInStrategy(allStrategies[i], assetPrices)
                    .divPrecisely(_totalValue(assetPrices))
                    .mulTruncate(strategy.getAPR());
            }
        }
        return totalAPR;
    }

    <span class="marker" id="mapping-185"></span><span class="token del" data-title="contract_body/comment">/**
     * @dev Transfer token to governor. Intended for recovering tokens stuck in
     *      contract, i.e. mistaken sends.
     * @param _asset Address for the asset
     * @param _amount Amount of the asset to transfer
     */</span>
    <span class="marker" id="mapping-186"></span><span class="token del" data-title="contract_body/function_definition">function transferToken(address _asset, uint256 _amount)
        external
        onlyGovernor
    {
        IERC20(_asset).transfer(governor(), _amount);
    }</span>

    <span class="marker" id="mapping-187"></span><span class="token del" data-title="contract_body/comment">/**
     * @dev Collect reward tokens from all strategies.
     */</span>
    <span class="marker" id="mapping-188"></span><span class="token del" data-title="contract_body/function_definition">function collectRewardTokens() external onlyGovernor {
        for (uint256 i = 0; i &lt; allStrategies.length; i++) {
            collectRewardTokens(allStrategies[i]);
        }
    }</span>

    <span class="marker" id="mapping-189"></span><span class="token del" data-title="contract_body/comment">/**
     * @dev Collect reward tokens from a single strategy and transfer them to
            Vault.
     * @param _strategyAddr Address of the strategy to collect rewards from
     */</span>
    <span class="marker" id="mapping-190"></span><span class="token del" data-title="contract_body/function_definition">function collectRewardTokens(<span class="marker" id="mapping-191"></span><span class="token del" data-title="function_definition/parameter"><span class="marker" id="mapping-192"></span><span class="token mv" id="move-src-74" data-title="parameter/type_name">address</span> _strategyAddr</span>) <span class="marker" id="mapping-193"></span><span class="token mv" id="move-src-75" data-title="function_definition/visibility">public</span> <span class="marker" id="mapping-194"></span><span class="token del" data-title="function_definition/modifier_invocation">onlyGovernor</span> <span class="marker" id="mapping-195"></span><span class="token del" data-title="function_definition/function_body">{
        IStrategy strategy = IStrategy(_strategyAddr);
        strategy.collectRewardToken();
    }</span></span>

    <span class="marker" id="mapping-196"></span><span class="token del" data-title="contract_body/comment">/**
     * @dev Determines if an asset is supported by the vault.
     * @param _asset Address of the asset
     */</span>
    function isSupportedAsset(address _asset) external view returns (bool) {
        return assets[_asset].isSupported;
    }

    <span class="marker" id="mapping-197"></span><span class="token del" data-title="contract_body/function_definition">function _priceUSDMint(string memory symbol) internal returns (uint256) {
        // Price from Oracle is returned with 8 decimals
        // scale to 18 so 18-8=10
        return IMinMaxOracle(priceProvider).priceMin(symbol).scaleBy(10);
    }</span>

    <span class="marker" id="mapping-198"></span><span class="token del" data-title="contract_body/comment">/**
     * @dev Returns the total price in 18 digit USD for a given asset.
     *      Using Min since min is what we use for mint pricing
     * @param symbol String symbol of the asset
     * @return uint256 USD price of 1 of the asset
     */</span>
    <span class="marker" id="mapping-199"></span><span class="token del" data-title="contract_body/function_definition">function priceUSDMint(string calldata symbol) external returns (uint256) {
        return _priceUSDMint(symbol);
    }</span>

    <span class="marker" id="mapping-200"></span><span class="token del" data-title="contract_body/comment">/**
     * @dev Returns the total price in 18 digit USD for a given asset.
     *      Using Max since max is what we use for redeem pricing
     * @param symbol String symbol of the asset
     * @return uint256 USD price of 1 of the asset
     */</span>
    <span class="marker" id="mapping-201"></span><span class="token del" data-title="contract_body/function_definition">function _priceUSDRedeem(string memory symbol) internal returns (uint256) {
        // Price from Oracle is returned with 8 decimals
        // scale to 18 so 18-8=10
        return IMinMaxOracle(priceProvider).priceMax(symbol).scaleBy(10);
    }</span>

    <span class="marker" id="mapping-202"></span><span class="token del" data-title="contract_body/comment">/**
     * @dev Returns the total price in 18 digit USD for a given asset.
     *      Using Max since max is what we use for redeem pricing
     * @param symbol String symbol of the asset
     * @return uint256 USD price of 1 of the asset
     */</span>
    <span class="marker" id="mapping-203"></span><span class="token del" data-title="contract_body/function_definition">function priceUSDRedeem(string calldata symbol) external returns (uint256) {
        // Price from Oracle is returned with 8 decimals
        // scale to 18 so 18-8=10
        return _priceUSDRedeem(symbol);
    }</span>
}</pre></div><div class="col-6"><h5>0x553845f9c44c43224620055eca64c6cc79f5ddfd.etherscan.io-VaultCore.sol</h5><pre class="pre-scrollable"><span class="marker" id="mapping-204"></span><span class="token add" data-title="source_file/comment">/*
 * Origin Protocol
 * https://originprotocol.com
 *
 * Released under the MIT license
 * https://github.com/OriginProtocol
 *
 * Copyright 2019 Origin Protocol, Inc
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */</span>

<span class="marker" id="mapping-205"></span><span class="token add" data-title="source_file/comment">// File: @openzeppelin/contracts/token/ERC20/IERC20.sol</span>

<span class="marker" id="mapping-206"></span><span class="token add" data-title="source_file/pragma_directive">pragma solidity ^0.5.0;</span>

<span class="marker" id="mapping-207"></span><span class="token add" data-title="source_file/comment">/**
 * @dev Interface of the ERC20 standard as defined in the EIP. Does not include
 * the optional functions; to access them see {ERC20Detailed}.
 */</span>
interface IERC20 {
    /**
     * @dev Returns the amount of tokens in existence.
     */
    function totalSupply() external view returns (uint256);

    /**
     * @dev Returns the amount of tokens owned by `account`.
     */
    function balanceOf(address account) external view returns (uint256);

    /**
     * @dev Moves `amount` tokens from the caller's account to `recipient`.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * Emits a {Transfer} event.
     */
    function transfer(address recipient, uint256 amount) external returns (bool);

    /**
     * @dev Returns the remaining number of tokens that `spender` will be
     * allowed to spend on behalf of `owner` through {transferFrom}. This is
     * zero by default.
     *
     * This value changes when {approve} or {transferFrom} are called.
     */
    function allowance(address owner, address spender) external view returns (uint256);

    /**
     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * IMPORTANT: Beware that changing an allowance with this method brings the risk
     * that someone may use both the old and the new allowance by unfortunate
     * transaction ordering. One possible solution to mitigate this race
     * condition is to first reduce the spender's allowance to 0 and set the
     * desired value afterwards:
     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
     *
     * Emits an {Approval} event.
     */
    function approve(address spender, uint256 amount) external returns (bool);

    /**
     * @dev Moves `amount` tokens from `sender` to `recipient` using the
     * allowance mechanism. `amount` is then deducted from the caller's
     * allowance.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * Emits a {Transfer} event.
     */
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);

    /**
     * @dev Emitted when `value` tokens are moved from one account (`from`) to
     * another (`to`).
     *
     * Note that `value` may be zero.
     */
    event Transfer(address indexed from, address indexed to, uint256 value);

    /**
     * @dev Emitted when the allowance of a `spender` for an `owner` is set by
     * a call to {approve}. `value` is the new allowance.
     */
    event Approval(address indexed owner, address indexed spender, uint256 value);
}

<span class="marker" id="mapping-208"></span><span class="token add" data-title="source_file/comment">// File: @openzeppelin/contracts/math/SafeMath.sol</span>

<span class="marker" id="mapping-209"></span><span class="token add" data-title="source_file/pragma_directive">pragma solidity ^0.5.0;</span>

<span class="marker" id="mapping-210"></span><span class="token add" data-title="source_file/comment">/**
 * @dev Wrappers over Solidity's arithmetic operations with added overflow
 * checks.
 *
 * Arithmetic operations in Solidity wrap on overflow. This can easily result
 * in bugs, because programmers usually assume that an overflow raises an
 * error, which is the standard behavior in high level programming languages.
 * `SafeMath` restores this intuition by reverting the transaction when an
 * operation overflows.
 *
 * Using this library instead of the unchecked operations eliminates an entire
 * class of bugs, so it's recommended to use it always.
 */</span>
<span class="marker" id="mapping-211"></span><span class="token mv" id="move-dst-4" data-title="source_file/library_declaration">library SafeMath {
    /**
     * @dev Returns the addition of two unsigned integers, reverting on
     * overflow.
     *
     * Counterpart to Solidity's `+` operator.
     *
     * Requirements:
     * - Addition cannot overflow.
     */
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c &gt;= a, "SafeMath: addition overflow");

        return c;
    }

    /**
     * @dev Returns the subtraction of two unsigned integers, reverting on
     * overflow (when the result is negative).
     *
     * Counterpart to Solidity's `-` operator.
     *
     * Requirements:
     * - Subtraction cannot overflow.
     */
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        return sub(a, b, "SafeMath: subtraction overflow");
    }

    /**
     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on
     * overflow (when the result is negative).
     *
     * Counterpart to Solidity's `-` operator.
     *
     * Requirements:
     * - Subtraction cannot overflow.
     *
     * _Available since v2.4.0._
     */
    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
        require(b &lt;= a, errorMessage);
        uint256 c = a - b;

        return c;
    }

    /**
     * @dev Returns the multiplication of two unsigned integers, reverting on
     * overflow.
     *
     * Counterpart to Solidity's `*` operator.
     *
     * Requirements:
     * - Multiplication cannot overflow.
     */
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the
        // benefit is lost if 'b' is also tested.
        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522
        if (a == 0) {
            return 0;
        }

        uint256 c = a * b;
        require(c / a == b, "SafeMath: multiplication overflow");

        return c;
    }

    /**
     * @dev Returns the integer division of two unsigned integers. Reverts on
     * division by zero. The result is rounded towards zero.
     *
     * Counterpart to Solidity's `/` operator. Note: this function uses a
     * `revert` opcode (which leaves remaining gas untouched) while Solidity
     * uses an invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     * - The divisor cannot be zero.
     */
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        return div(a, b, "SafeMath: division by zero");
    }

    /**
     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on
     * division by zero. The result is rounded towards zero.
     *
     * Counterpart to Solidity's `/` operator. Note: this function uses a
     * `revert` opcode (which leaves remaining gas untouched) while Solidity
     * uses an invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     * - The divisor cannot be zero.
     *
     * _Available since v2.4.0._
     */
    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
        // Solidity only automatically asserts when dividing by 0
        require(b &gt; 0, errorMessage);
        uint256 c = a / b;
        // assert(a == b * c + a % b); // There is no case in which this doesn't hold

        return c;
    }

    /**
     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),
     * Reverts when dividing by zero.
     *
     * Counterpart to Solidity's `%` operator. This function uses a `revert`
     * opcode (which leaves remaining gas untouched) while Solidity uses an
     * invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     * - The divisor cannot be zero.
     */
    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
        return mod(a, b, "SafeMath: modulo by zero");
    }

    /**
     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),
     * Reverts with custom message when dividing by zero.
     *
     * Counterpart to Solidity's `%` operator. This function uses a `revert`
     * opcode (which leaves remaining gas untouched) while Solidity uses an
     * invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     * - The divisor cannot be zero.
     *
     * _Available since v2.4.0._
     */
    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
        require(b != 0, errorMessage);
        return a % b;
    }
}</span>

<span class="marker" id="mapping-212"></span><span class="token add" data-title="source_file/comment">// File: @openzeppelin/contracts/utils/Address.sol</span>

<span class="marker" id="mapping-213"></span><span class="token add" data-title="source_file/pragma_directive">pragma solidity ^0.5.5;</span>

<span class="marker" id="mapping-214"></span><span class="token add" data-title="source_file/comment">/**
 * @dev Collection of functions related to the address type
 */</span>
library Address {
    <span class="marker" id="mapping-215"></span><span class="token upd" id="move-dst-7" data-title="contract_body/comment"><span class="cupd">/**
     * @dev Returns true if `account` is a contract.
     *
     * [IMPORTANT]
     * ====
     * It is unsafe to assume that an address for which this function returns
     * false is an externally-owned account (EOA) and not a contract.
     *
     * Among others, `isContract` will return false for the followi</span>n<span class="cupd">g 
     * types of addresses:
     *
     *  - an externally-owned account
     *  - a contract in construction
     *  - an address where a contract will be created
     *  - an address where a contract lived, but was destroyed
    </span> * ====
     */</span>
    function isContract(address account) internal view returns (bool) {
        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts
        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned
        // for accounts without code, i.e. `keccak256('')`
        bytes32 codehash;
        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;
        // solhint-disable-next-line no-inline-assembly
        assembly { codehash := extcodehash(account) }
        return (codehash != accountHash &amp;&amp; codehash != 0x0);
    }

    /**
     * @dev Converts an `address` into `address payable`. Note that this is
     * simply a type cast: the actual underlying value is not changed.
     *
     * _Available since v2.4.0._
     */
    function toPayable(address account) internal pure returns (address payable) {
        return address(uint160(account));
    }

    /**
     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to
     * `recipient`, forwarding all available gas and reverting on errors.
     *
     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost
     * of certain opcodes, possibly making contracts go over the 2300 gas limit
     * imposed by `transfer`, making them unable to receive funds via
     * `transfer`. {sendValue} removes this limitation.
     *
     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].
     *
     * IMPORTANT: because control is transferred to `recipient`, care must be
     * taken to not create reentrancy vulnerabilities. Consider using
     * {ReentrancyGuard} or the
     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].
     *
     * _Available since v2.4.0._
     */
    function sendValue(address payable recipient, uint256 amount) internal {
        require(address(this).balance &gt;= amount, "Address: insufficient balance");

        // solhint-disable-next-line avoid-call-value
        (bool success, ) = recipient.call.value(amount)("");
        require(success, "Address: unable to send value, recipient may have reverted");
    }
}

<span class="marker" id="mapping-216"></span><span class="token add" data-title="source_file/comment">// File: @openzeppelin/contracts/token/ERC20/SafeERC20.sol</span>

<span class="marker" id="mapping-217"></span><span class="token add" data-title="source_file/pragma_directive">pragma solidity ^0.5.0;</span>




<span class="marker" id="mapping-218"></span><span class="token add" data-title="source_file/comment">/**
 * @title SafeERC20
 * @dev Wrappers around ERC20 operations that throw on failure (when the token
 * contract returns false). Tokens that return no value (and instead revert or
 * throw on failure) are also supported, non-reverting calls are assumed to be
 * successful.
 * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract,
 * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.
 */</span>
<span class="marker" id="mapping-219"></span><span class="token mv" id="move-dst-6" data-title="source_file/library_declaration">library SafeERC20 {
    using SafeMath for uint256;
    using Address for address;

    function safeTransfer(IERC20 token, address to, uint256 value) internal {
        callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));
    }

    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {
        callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));
    }

    function safeApprove(IERC20 token, address spender, uint256 value) internal {
        // safeApprove should only be called when setting an initial allowance,
        // or when resetting it to zero. To increase and decrease it, use
        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'
        // solhint-disable-next-line max-line-length
        require((value == 0) || (token.allowance(address(this), spender) == 0),
            "SafeERC20: approve from non-zero to non-zero allowance"
        );
        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));
    }

    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {
        uint256 newAllowance = token.allowance(address(this), spender).add(value);
        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));
    }

    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {
        uint256 newAllowance = token.allowance(address(this), spender).sub(value, "SafeERC20: decreased allowance below zero");
        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));
    }

    /**
     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement
     * on the return value: the return value is optional (but if data is returned, it must not be false).
     * @param token The token targeted by the call.
     * @param data The call data (encoded using abi.encode or one of its variants).
     */
    function callOptionalReturn(IERC20 token, bytes memory data) private {
        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since
        // we're implementing it ourselves.

        // A Solidity high level call has three parts:
        //  1. The target address is checked to verify it contains contract code
        //  2. The call itself is made, and success asserted
        //  3. The return value is decoded, which in turn checks the size of the returned data.
        // solhint-disable-next-line max-line-length
        require(address(token).isContract(), "SafeERC20: call to non-contract");

        // solhint-disable-next-line avoid-low-level-calls
        (bool success, bytes memory returndata) = address(token).call(data);
        require(success, "SafeERC20: low-level call failed");

        if (returndata.length &gt; 0) { // Return data is optional
            // solhint-disable-next-line max-line-length
            require(abi.decode(returndata, (bool)), "SafeERC20: ERC20 operation did not succeed");
        }
    }
}</span>

<span class="marker" id="mapping-220"></span><span class="token add" data-title="source_file/comment">// File: @openzeppelin/upgrades/contracts/Initializable.sol</span>

<span class="marker" id="mapping-221"></span><span class="token add" data-title="source_file/pragma_directive">pragma solidity &gt;=0.4.24 &lt;0.7.0;</span>


<span class="marker" id="mapping-222"></span><span class="token add" data-title="source_file/comment">/**
 * @title Initializable
 *
 * @dev Helper contract to support initializer functions. To use it, replace
 * the constructor with a function that has the `initializer` modifier.
 * WARNING: Unlike constructors, initializer functions must be manually
 * invoked. This applies both to deploying an Initializable contract, as well
 * as extending an Initializable contract via inheritance.
 * WARNING: When used with inheritance, manual care must be taken to not invoke
 * a parent initializer twice, or ensure that all initializers are idempotent,
 * because this is not dealt with automatically as with constructors.
 */</span>
contract Initializable {

  /**
   * @dev Indicates that the contract has been initialized.
   */
  bool private initialized;

  /**
   * @dev Indicates that the contract is in the process of being initialized.
   */
  bool private initializing;

  /**
   * @dev Modifier to use in the initializer function of a contract.
   */
  modifier initializer() {
    require(initializing || isConstructor() || !initialized, "Contract instance has already been initialized");

    bool isTopLevelCall = !initializing;
    if (isTopLevelCall) {
      initializing = true;
      initialized = true;
    }

    _;

    if (isTopLevelCall) {
      initializing = false;
    }
  }

  /// @dev Returns true if and only if the function is running in the constructor
  function isConstructor() private view returns (bool) {
    // extcodesize checks the size of the code stored in an address, and
    // address returns the current address. Since the code is still not
    // deployed when running a constructor, any checks on its code size will
    // yield zero, making it an effective way to detect if a contract is
    // under construction or not.
    address self = address(this);
    uint256 cs;
    assembly { cs := extcodesize(self) }
    return cs == 0;
  }

  // Reserved storage space to allow for layout changes in the future.
  uint256[50] private ______gap;
}

<span class="marker" id="mapping-223"></span><span class="token add" data-title="source_file/comment">// File: contracts/interfaces/IStrategy.sol</span>

<span class="marker" id="mapping-224"></span><span class="token mv" id="move-dst-1" data-title="source_file/pragma_directive">pragma solidity 0.5.11;</span>

<span class="marker" id="mapping-225"></span><span class="token add" data-title="source_file/comment">/**
 * @title Platform interface to integrate with lending platform like Compound, AAVE etc.
 */</span>
interface IStrategy {
    /**
     * @dev Deposit the given asset to Lending platform.
     * @param _asset asset address
     * @param _amount Amount to deposit
     */
    function deposit(address _asset, uint256 _amount)
        external
        returns (uint256 amountDeposited);

    /**
     * @dev Withdraw given asset from Lending platform
     */
    function withdraw(
        address _recipient,
        address _asset,
        uint256 _amount
    ) external returns (uint256 amountWithdrawn);

    /**
     * @dev Returns the current balance of the given asset.
     */
    function checkBalance(address _asset)
        external
        view
        returns (uint256 balance);

    /**
     * @dev Returns bool indicating whether strategy supports asset.
     */
    function supportsAsset(address _asset) external view returns (bool);

    /**
     * @dev Liquidate all assets in strategy and return them to Vault.
     */
    function liquidate() external;

    /**
     * @dev Get the APR for the Strategy.
     */
    function getAPR() external view returns (uint256);

    /**
     * @dev Collect reward tokens from the Strategy.
     */
    function collectRewardToken() external;

    <span class="marker" id="mapping-226"></span><span class="token add" data-title="contract_body/function_definition">function rewardTokenAddress() <span class="marker" id="mapping-227"></span><span class="token mv" id="move-dst-56" data-title="function_definition/visibility">external</span> <span class="marker" id="mapping-228"></span><span class="token add" data-title="function_definition/state_mutability">pure</span> <span class="marker" id="mapping-229"></span><span class="token add" data-title="function_definition/return_type_definition">returns (<span class="marker" id="mapping-230"></span><span class="token mv" id="move-dst-55" data-title="return_type_definition/parameter">address</span>)</span>;</span>
}

<span class="marker" id="mapping-231"></span><span class="token add" data-title="source_file/comment">// File: contracts/governance/Governable.sol</span>

<span class="marker" id="mapping-232"></span><span class="token add" data-title="source_file/pragma_directive">pragma solidity 0.5.11;</span>

<span class="marker" id="mapping-233"></span><span class="token add" data-title="source_file/comment">/**
 * @title OUSD Governable Contract
 * @dev Copy of the openzeppelin Ownable.sol contract with nomenclature change
 *      from owner to governor and renounce methods removed. Does not use
 *      Context.sol like Ownable.sol does for simplification.
 * @author Origin Protocol Inc
 */</span>
<span class="marker" id="mapping-234"></span><span class="token mv" id="move-dst-8" data-title="source_file/contract_declaration">contract Governable {
    // Storage position of the owner and pendingOwner of the contract
    bytes32
        private constant governorPosition = 0x7bea13895fa79d2831e0a9e28edede30099005a50d652d8957cf8a607ee6ca4a;
    //keccak256("OUSD.governor");

    bytes32
        private constant pendingGovernorPosition = 0x44c4d30b2eaad5130ad70c3ba6972730566f3e6359ab83e800d905c61b1c51db;
    //keccak256("OUSD.pending.governor");

    event PendingGovernorshipTransfer(
        address indexed previousGovernor,
        address indexed newGovernor
    );

    event GovernorshipTransferred(
        address indexed previousGovernor,
        address indexed newGovernor
    );

    /**
     * @dev Initializes the contract setting the deployer as the initial Governor.
     */
    constructor() internal {
        _setGovernor(msg.sender);
        emit GovernorshipTransferred(address(0), _governor());
    }

    /**
     * @dev Returns the address of the current Governor.
     */
    function governor() public view returns (address) {
        return _governor();
    }

    function _governor() internal view returns (address governorOut) {
        bytes32 position = governorPosition;
        assembly {
            governorOut := sload(position)
        }
    }

    function _pendingGovernor()
        internal
        view
        returns (address pendingGovernor)
    {
        bytes32 position = pendingGovernorPosition;
        assembly {
            pendingGovernor := sload(position)
        }
    }

    /**
     * @dev Throws if called by any account other than the Governor.
     */
    modifier onlyGovernor() {
        require(isGovernor(), "Caller is not the Governor");
        _;
    }

    /**
     * @dev Returns true if the caller is the current Governor.
     */
    function isGovernor() public view returns (bool) {
        return msg.sender == _governor();
    }

    function _setGovernor(address newGovernor) internal {
        bytes32 position = governorPosition;
        assembly {
            sstore(position, newGovernor)
        }
    }

    function _setPendingGovernor(address newGovernor) internal {
        bytes32 position = pendingGovernorPosition;
        assembly {
            sstore(position, newGovernor)
        }
    }

    /**
     * @dev Transfers Governance of the contract to a new account (`newGovernor`).
     * Can only be called by the current Governor. Must be claimed for this to complete
     * @param _newGovernor Address of the new Governor
     */
    function transferGovernance(address _newGovernor) external onlyGovernor {
        _setPendingGovernor(_newGovernor);
        emit PendingGovernorshipTransfer(_governor(), _newGovernor);
    }

    /**
     * @dev Claim Governance of the contract to a new account (`newGovernor`).
     * Can only be called by the new Governor.
     */
    function claimGovernance() external {
        require(
            msg.sender == _pendingGovernor(),
            "Only the pending Governor can complete the claim"
        );
        _changeGovernor(msg.sender);
    }

    /**
     * @dev Change Governance of the contract to a new account (`newGovernor`).
     * @param _newGovernor Address of the new Governor
     */
    function _changeGovernor(address _newGovernor) internal {
        require(_newGovernor != address(0), "New Governor is address(0)");
        emit GovernorshipTransferred(_governor(), _newGovernor);
        _setGovernor(_newGovernor);
    }
}</span>

<span class="marker" id="mapping-235"></span><span class="token add" data-title="source_file/comment">// File: @openzeppelin/contracts/GSN/Context.sol</span>

<span class="marker" id="mapping-236"></span><span class="token add" data-title="source_file/pragma_directive">pragma solidity ^0.5.0;</span>

<span class="marker" id="mapping-237"></span><span class="token add" data-title="source_file/comment">/*
 * @dev Provides information about the current execution context, including the
 * sender of the transaction and its data. While these are generally available
 * via msg.sender and msg.data, they should not be accessed in such a direct
 * manner, since when dealing with GSN meta-transactions the account sending and
 * paying for execution may not be the actual sender (as far as an application
 * is concerned).
 *
 * This contract is only required for intermediate, library-like contracts.
 */</span>
<span class="marker" id="mapping-238"></span><span class="token mv" id="move-dst-3" data-title="source_file/contract_declaration">contract Context {
    // Empty internal constructor, to prevent people from mistakenly deploying
    // an instance of this contract, which should be used via inheritance.
    constructor () internal { }
    // solhint-disable-previous-line no-empty-blocks

    function _msgSender() internal view returns (address payable) {
        return msg.sender;
    }

    function _msgData() internal view returns (bytes memory) {
        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691
        return msg.data;
    }
}</span>

<span class="marker" id="mapping-239"></span><span class="token add" data-title="source_file/comment">// File: @openzeppelin/contracts/token/ERC20/ERC20.sol</span>

<span class="marker" id="mapping-240"></span><span class="token add" data-title="source_file/pragma_directive">pragma solidity ^0.5.0;</span>




<span class="marker" id="mapping-241"></span><span class="token add" data-title="source_file/comment">/**
 * @dev Implementation of the {IERC20} interface.
 *
 * This implementation is agnostic to the way tokens are created. This means
 * that a supply mechanism has to be added in a derived contract using {_mint}.
 * For a generic mechanism see {ERC20Mintable}.
 *
 * TIP: For a detailed writeup see our guide
 * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How
 * to implement supply mechanisms].
 *
 * We have followed general OpenZeppelin guidelines: functions revert instead
 * of returning `false` on failure. This behavior is nonetheless conventional
 * and does not conflict with the expectations of ERC20 applications.
 *
 * Additionally, an {Approval} event is emitted on calls to {transferFrom}.
 * This allows applications to reconstruct the allowance for all accounts just
 * by listening to said events. Other implementations of the EIP may not emit
 * these events, as it isn't required by the specification.
 *
 * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}
 * functions have been added to mitigate the well-known issues around setting
 * allowances. See {IERC20-approve}.
 */</span>
<span class="marker" id="mapping-242"></span><span class="token mv" id="move-dst-5" data-title="source_file/contract_declaration">contract ERC20 is Context, IERC20 {
    using SafeMath for uint256;

    mapping (address =&gt; uint256) private _balances;

    mapping (address =&gt; mapping (address =&gt; uint256)) private _allowances;

    uint256 private _totalSupply;

    /**
     * @dev See {IERC20-totalSupply}.
     */
    function totalSupply() public view returns (uint256) {
        return _totalSupply;
    }

    /**
     * @dev See {IERC20-balanceOf}.
     */
    function balanceOf(address account) public view returns (uint256) {
        return _balances[account];
    }

    /**
     * @dev See {IERC20-transfer}.
     *
     * Requirements:
     *
     * - `recipient` cannot be the zero address.
     * - the caller must have a balance of at least `amount`.
     */
    function transfer(address recipient, uint256 amount) public returns (bool) {
        _transfer(_msgSender(), recipient, amount);
        return true;
    }

    /**
     * @dev See {IERC20-allowance}.
     */
    function allowance(address owner, address spender) public view returns (uint256) {
        return _allowances[owner][spender];
    }

    /**
     * @dev See {IERC20-approve}.
     *
     * Requirements:
     *
     * - `spender` cannot be the zero address.
     */
    function approve(address spender, uint256 amount) public returns (bool) {
        _approve(_msgSender(), spender, amount);
        return true;
    }

    /**
     * @dev See {IERC20-transferFrom}.
     *
     * Emits an {Approval} event indicating the updated allowance. This is not
     * required by the EIP. See the note at the beginning of {ERC20};
     *
     * Requirements:
     * - `sender` and `recipient` cannot be the zero address.
     * - `sender` must have a balance of at least `amount`.
     * - the caller must have allowance for `sender`'s tokens of at least
     * `amount`.
     */
    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {
        _transfer(sender, recipient, amount);
        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, "ERC20: transfer amount exceeds allowance"));
        return true;
    }

    /**
     * @dev Atomically increases the allowance granted to `spender` by the caller.
     *
     * This is an alternative to {approve} that can be used as a mitigation for
     * problems described in {IERC20-approve}.
     *
     * Emits an {Approval} event indicating the updated allowance.
     *
     * Requirements:
     *
     * - `spender` cannot be the zero address.
     */
    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {
        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));
        return true;
    }

    /**
     * @dev Atomically decreases the allowance granted to `spender` by the caller.
     *
     * This is an alternative to {approve} that can be used as a mitigation for
     * problems described in {IERC20-approve}.
     *
     * Emits an {Approval} event indicating the updated allowance.
     *
     * Requirements:
     *
     * - `spender` cannot be the zero address.
     * - `spender` must have allowance for the caller of at least
     * `subtractedValue`.
     */
    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {
        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, "ERC20: decreased allowance below zero"));
        return true;
    }

    /**
     * @dev Moves tokens `amount` from `sender` to `recipient`.
     *
     * This is internal function is equivalent to {transfer}, and can be used to
     * e.g. implement automatic token fees, slashing mechanisms, etc.
     *
     * Emits a {Transfer} event.
     *
     * Requirements:
     *
     * - `sender` cannot be the zero address.
     * - `recipient` cannot be the zero address.
     * - `sender` must have a balance of at least `amount`.
     */
    function _transfer(address sender, address recipient, uint256 amount) internal {
        require(sender != address(0), "ERC20: transfer from the zero address");
        require(recipient != address(0), "ERC20: transfer to the zero address");

        _balances[sender] = _balances[sender].sub(amount, "ERC20: transfer amount exceeds balance");
        _balances[recipient] = _balances[recipient].add(amount);
        emit Transfer(sender, recipient, amount);
    }

    /** @dev Creates `amount` tokens and assigns them to `account`, increasing
     * the total supply.
     *
     * Emits a {Transfer} event with `from` set to the zero address.
     *
     * Requirements
     *
     * - `to` cannot be the zero address.
     */
    function _mint(address account, uint256 amount) internal {
        require(account != address(0), "ERC20: mint to the zero address");

        _totalSupply = _totalSupply.add(amount);
        _balances[account] = _balances[account].add(amount);
        emit Transfer(address(0), account, amount);
    }

    /**
     * @dev Destroys `amount` tokens from `account`, reducing the
     * total supply.
     *
     * Emits a {Transfer} event with `to` set to the zero address.
     *
     * Requirements
     *
     * - `account` cannot be the zero address.
     * - `account` must have at least `amount` tokens.
     */
    function _burn(address account, uint256 amount) internal {
        require(account != address(0), "ERC20: burn from the zero address");

        _balances[account] = _balances[account].sub(amount, "ERC20: burn amount exceeds balance");
        _totalSupply = _totalSupply.sub(amount);
        emit Transfer(account, address(0), amount);
    }

    /**
     * @dev Sets `amount` as the allowance of `spender` over the `owner`s tokens.
     *
     * This is internal function is equivalent to `approve`, and can be used to
     * e.g. set automatic allowances for certain subsystems, etc.
     *
     * Emits an {Approval} event.
     *
     * Requirements:
     *
     * - `owner` cannot be the zero address.
     * - `spender` cannot be the zero address.
     */
    function _approve(address owner, address spender, uint256 amount) internal {
        require(owner != address(0), "ERC20: approve from the zero address");
        require(spender != address(0), "ERC20: approve to the zero address");

        _allowances[owner][spender] = amount;
        emit Approval(owner, spender, amount);
    }

    /**
     * @dev Destroys `amount` tokens from `account`.`amount` is then deducted
     * from the caller's allowance.
     *
     * See {_burn} and {_approve}.
     */
    function _burnFrom(address account, uint256 amount) internal {
        _burn(account, amount);
        _approve(account, _msgSender(), _allowances[account][_msgSender()].sub(amount, "ERC20: burn amount exceeds allowance"));
    }
}</span>

<span class="marker" id="mapping-243"></span><span class="token add" data-title="source_file/comment">// File: contracts/utils/InitializableERC20Detailed.sol</span>

<span class="marker" id="mapping-244"></span><span class="token add" data-title="source_file/pragma_directive">pragma solidity 0.5.11;</span>


<span class="marker" id="mapping-245"></span><span class="token add" data-title="source_file/comment">/**
 * @dev Optional functions from the ERC20 standard.
 * Converted from openzeppelin/contracts/token/ERC20/ERC20Detailed.sol
 */</span>
contract InitializableERC20Detailed is IERC20 {
    string private _name;
    string private _symbol;
    uint8 private _decimals;

    /**
     * @dev Sets the values for `name`, `symbol`, and `decimals`. All three of
     * these values are immutable: they can only be set once during
     * construction.
     * @notice To avoid variable shadowing appended `Arg` after arguments name.
     */
    function _initialize(
        string memory nameArg,
        string memory symbolArg,
        uint8 decimalsArg
    ) internal {
        _name = nameArg;
        _symbol = symbolArg;
        _decimals = decimalsArg;
    }

    /**
     * @dev Returns the name of the token.
     */
    function name() public view returns (string memory) {
        return _name;
    }

    /**
     * @dev Returns the symbol of the token, usually a shorter version of the
     * name.
     */
    function symbol() public view returns (string memory) {
        return _symbol;
    }

    /**
     * @dev Returns the number of decimals used to get its user representation.
     * For example, if `decimals` equals `2`, a balance of `505` tokens should
     * be displayed to a user as `5,05` (`505 / 10 ** 2`).
     *
     * Tokens usually opt for a value of 18, imitating the relationship between
     * Ether and Wei.
     *
     * NOTE: This information is only used for _display_ purposes: it in
     * no way affects any of the arithmetic of the contract, including
     * {IERC20-balanceOf} and {IERC20-transfer}.
     */
    function decimals() public view returns (uint8) {
        return _decimals;
    }
}

<span class="marker" id="mapping-246"></span><span class="token add" data-title="source_file/comment">// File: contracts/utils/InitializableToken.sol</span>

<span class="marker" id="mapping-247"></span><span class="token add" data-title="source_file/pragma_directive">pragma solidity 0.5.11;</span>



contract InitializableToken is ERC20, InitializableERC20Detailed {
    /**
     * @dev Initialization function for implementing contract
     * @notice To avoid variable shadowing appended `Arg` after arguments name.
     */
    function _initialize(string memory _nameArg, string memory _symbolArg)
        internal
    {
        InitializableERC20Detailed._initialize(_nameArg, _symbolArg, 18);
    }
}

<span class="marker" id="mapping-248"></span><span class="token add" data-title="source_file/comment">// File: contracts/utils/StableMath.sol</span>

<span class="marker" id="mapping-249"></span><span class="token add" data-title="source_file/pragma_directive">pragma solidity 0.5.11;</span>


<span class="marker" id="mapping-250"></span><span class="token add" data-title="source_file/comment">// Based on StableMath from Stability Labs Pty. Ltd.</span>
<span class="marker" id="mapping-251"></span><span class="token add" data-title="source_file/comment">// https://github.com/mstable/mStable-contracts/blob/master/contracts/shared/StableMath.sol</span>

library StableMath {
    using SafeMath for uint256;

    /**
     * @dev Scaling unit for use in specific calculations,
     * where 1 * 10**18, or 1e18 represents a unit '1'
     */
    uint256 private constant FULL_SCALE = 1e18;

    /***************************************
                    Helpers
    ****************************************/

    /**
     * @dev Adjust the scale of an integer
     * @param adjustment Amount to adjust by e.g. scaleBy(1e18, -1) == 1e17
     */
    function scaleBy(uint256 x, int8 adjustment)
        internal
        pure
        returns (uint256)
    {
        if (adjustment &gt; 0) {
            x = x.mul(10**uint256(adjustment));
        } else if (adjustment &lt; 0) {
            x = x.div(10**uint256(adjustment * -1));
        }
        return x;
    }

    /***************************************
               Precise Arithmetic
    ****************************************/

    /**
     * @dev Multiplies two precise units, and then truncates by the full scale
     * @param x Left hand input to multiplication
     * @param y Right hand input to multiplication
     * @return Result after multiplying the two inputs and then dividing by the shared
     *         scale unit
     */
    function mulTruncate(uint256 x, uint256 y) internal pure returns (uint256) {
        return mulTruncateScale(x, y, FULL_SCALE);
    }

    /**
     * @dev Multiplies two precise units, and then truncates by the given scale. For example,
     * when calculating 90% of 10e18, (10e18 * 9e17) / 1e18 = (9e36) / 1e18 = 9e18
     * @param x Left hand input to multiplication
     * @param y Right hand input to multiplication
     * @param scale Scale unit
     * @return Result after multiplying the two inputs and then dividing by the shared
     *         scale unit
     */
    function mulTruncateScale(
        uint256 x,
        uint256 y,
        uint256 scale
    ) internal pure returns (uint256) {
        // e.g. assume scale = fullScale
        // z = 10e18 * 9e17 = 9e36
        uint256 z = x.mul(y);
        // return 9e38 / 1e18 = 9e18
        return z.div(scale);
    }

    /**
     * @dev Multiplies two precise units, and then truncates by the full scale, rounding up the result
     * @param x Left hand input to multiplication
     * @param y Right hand input to multiplication
     * @return Result after multiplying the two inputs and then dividing by the shared
     *          scale unit, rounded up to the closest base unit.
     */
    function mulTruncateCeil(uint256 x, uint256 y)
        internal
        pure
        returns (uint256)
    {
        // e.g. 8e17 * 17268172638 = 138145381104e17
        uint256 scaled = x.mul(y);
        // e.g. 138145381104e17 + 9.99...e17 = 138145381113.99...e17
        uint256 ceil = scaled.add(FULL_SCALE.sub(1));
        // e.g. 13814538111.399...e18 / 1e18 = 13814538111
        return ceil.div(FULL_SCALE);
    }

    /**
     * @dev Precisely divides two units, by first scaling the left hand operand. Useful
     *      for finding percentage weightings, i.e. 8e18/10e18 = 80% (or 8e17)
     * @param x Left hand input to division
     * @param y Right hand input to division
     * @return Result after multiplying the left operand by the scale, and
     *         executing the division on the right hand input.
     */
    function divPrecisely(uint256 x, uint256 y)
        internal
        pure
        returns (uint256)
    {
        // e.g. 8e18 * 1e18 = 8e36
        uint256 z = x.mul(FULL_SCALE);
        // e.g. 8e36 / 10e18 = 8e17
        return z.div(y);
    }
}

<span class="marker" id="mapping-252"></span><span class="token add" data-title="source_file/comment">// File: contracts/token/OUSD.sol</span>

<span class="marker" id="mapping-253"></span><span class="token add" data-title="source_file/pragma_directive">pragma solidity 0.5.11;</span>

<span class="marker" id="mapping-254"></span><span class="token add" data-title="source_file/comment">/**
 * @title OUSD Token Contract
 * @notice ERC20 compatible contract for OUSD
 * @dev Implements an elastic supply
 * @author Origin Protocol Inc
 */</span>



<span class="marker" id="mapping-255"></span><span class="token mv" id="move-dst-13" data-title="source_file/contract_declaration">contract OUSD is Initializable, InitializableToken, Governable {
    using SafeMath for uint256;
    using StableMath for uint256;

    event TotalSupplyUpdated(
        uint256 totalSupply,
        uint256 totalCredits,
        uint256 creditsPerToken
    );

    uint256 private constant MAX_SUPPLY = ~uint128(0); // (2^128) - 1

    uint256 private _totalSupply;
    uint256 private totalCredits;
    // Exchange rate between internal credits and OUSD
    uint256 private creditsPerToken;

    mapping(address =&gt; uint256) private _creditBalances;

    // Allowances denominated in OUSD
    mapping(address =&gt; mapping(address =&gt; uint256)) private _allowances;

    address public vaultAddress = address(0);

    function initialize(
        string calldata _nameArg,
        string calldata _symbolArg,
        address _vaultAddress
    ) external onlyGovernor initializer {
        InitializableToken._initialize(_nameArg, _symbolArg);

        _totalSupply = 0;
        totalCredits = 0;
        creditsPerToken = 1e18;

        vaultAddress = _vaultAddress;
    }

    /**
     * @dev Verifies that the caller is the Savings Manager contract
     */
    modifier onlyVault() {
        require(vaultAddress == msg.sender, "Caller is not the Vault");
        _;
    }

    /**
     * @return The total supply of OUSD.
     */
    function totalSupply() public view returns (uint256) {
        return _totalSupply;
    }

    /**
     * @dev Gets the balance of the specified address.
     * @param _account The address to query the balance of.
     * @return A unit256 representing the _amount of base units owned by the
     *         specified address.
     */
    function balanceOf(address _account) public view returns (uint256) {
        if (creditsPerToken == 0) return 0;
        return _creditBalances[_account].divPrecisely(creditsPerToken);
    }

    /**
     * @dev Gets the credits balance of the specified address.
     * @param _account The address to query the balance of.
     * @return A uint256 representing the _amount of base units owned by the
     *         specified address.
     */
    function creditsBalanceOf(address _account) public view returns (uint256) {
        return _creditBalances[_account];
    }

    /**
     * @dev Transfer tokens to a specified address.
     * @param _to the address to transfer to.
     * @param _value the _amount to be transferred.
     * @return true on success.
     */
    function transfer(address _to, uint256 _value) public returns (bool) {
        uint256 creditValue = _removeCredits(msg.sender, _value);
        _creditBalances[_to] = _creditBalances[_to].add(creditValue);

        emit Transfer(msg.sender, _to, _value);

        return true;
    }

    /**
     * @dev Transfer tokens from one address to another.
     * @param _from The address you want to send tokens from.
     * @param _to The address you want to transfer to.
     * @param _value The _amount of tokens to be transferred.
     */
    function transferFrom(
        address _from,
        address _to,
        uint256 _value
    ) public returns (bool) {
        _allowances[_from][msg.sender] = _allowances[_from][msg.sender].sub(
            _value
        );

        uint256 creditValue = _removeCredits(_from, _value);
        _creditBalances[_to] = _creditBalances[_to].add(creditValue);

        emit Transfer(_from, _to, _value);

        return true;
    }

    /**
     * @dev Function to check the _amount of tokens that an owner has allowed to a _spender.
     * @param _owner The address which owns the funds.
     * @param _spender The address which will spend the funds.
     * @return The number of tokens still available for the _spender.
     */
    function allowance(address _owner, address _spender)
        public
        view
        returns (uint256)
    {
        return _allowances[_owner][_spender];
    }

    /**
     * @dev Approve the passed address to spend the specified _amount of tokens on behalf of
     * msg.sender. This method is included for ERC20 compatibility.
     * increaseAllowance and decreaseAllowance should be used instead.
     * Changing an allowance with this method brings the risk that someone may transfer both
     * the old and the new allowance - if they are both greater than zero - if a transfer
     * transaction is mined before the later approve() call is mined.
     *
     * @param _spender The address which will spend the funds.
     * @param _value The _amount of tokens to be spent.
     */
    function approve(address _spender, uint256 _value) public returns (bool) {
        _allowances[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value);
        return true;
    }

    /**
     * @dev Increase the _amount of tokens that an owner has allowed to a _spender.
     * This method should be used instead of approve() to avoid the double approval vulnerability
     * described above.
     * @param _spender The address which will spend the funds.
     * @param _addedValue The _amount of tokens to increase the allowance by.
     */
    function increaseAllowance(address _spender, uint256 _addedValue)
        public
        returns (bool)
    {
        _allowances[msg.sender][_spender] = _allowances[msg.sender][_spender]
            .add(_addedValue);
        emit Approval(msg.sender, _spender, _allowances[msg.sender][_spender]);
        return true;
    }

    /**
     * @dev Decrease the _amount of tokens that an owner has allowed to a _spender.
     * @param _spender The address which will spend the funds.
     * @param _subtractedValue The _amount of tokens to decrease the allowance by.
     */
    function decreaseAllowance(address _spender, uint256 _subtractedValue)
        public
        returns (bool)
    {
        uint256 oldValue = _allowances[msg.sender][_spender];
        if (_subtractedValue &gt;= oldValue) {
            _allowances[msg.sender][_spender] = 0;
        } else {
            _allowances[msg.sender][_spender] = oldValue.sub(_subtractedValue);
        }
        emit Approval(msg.sender, _spender, _allowances[msg.sender][_spender]);
        return true;
    }

    /**
     * @notice Mints new tokens, increasing totalSupply.
     */
    function mint(address _account, uint256 _amount) external onlyVault {
        return _mint(_account, _amount);
    }

    /**
     * @dev Creates `_amount` tokens and assigns them to `_account`, increasing
     * the total supply.
     *
     * Emits a {Transfer} event with `from` set to the zero address.
     *
     * Requirements
     *
     * - `to` cannot be the zero address.
     */
    function _mint(address _account, uint256 _amount) internal {
        require(_account != address(0), "Mint to the zero address");

        _totalSupply = _totalSupply.add(_amount);

        uint256 creditAmount = _amount.mulTruncate(creditsPerToken);
        _creditBalances[_account] = _creditBalances[_account].add(creditAmount);
        totalCredits = totalCredits.add(creditAmount);

        emit Transfer(address(0), _account, _amount);
    }

    /**
     * @notice Burns tokens, decreasing totalSupply.
     */
    function burn(address account, uint256 amount) external onlyVault {
        return _burn(account, amount);
    }

    /**
     * @dev Destroys `_amount` tokens from `_account`, reducing the
     * total supply.
     *
     * Emits a {Transfer} event with `to` set to the zero address.
     *
     * Requirements
     *
     * - `_account` cannot be the zero address.
     * - `_account` must have at least `_amount` tokens.
     */
    function _burn(address _account, uint256 _amount) internal {
        require(_account != address(0), "Burn from the zero address");

        _totalSupply = _totalSupply.sub(_amount);
        uint256 creditAmount = _removeCredits(_account, _amount);
        totalCredits = totalCredits.sub(creditAmount);

        emit Transfer(_account, address(0), _amount);
    }

    /**
     * @dev Removes credits from a credit balance and burns rounding errors.
     * @param _account Account to remove credits from
     * @param _amount Amount in OUSD which will be converted to credits and
     *                removed
     */
    function _removeCredits(address _account, uint256 _amount)
        internal
        returns (uint256 creditAmount)
    {
        creditAmount = _amount.mulTruncate(creditsPerToken);
        uint256 currentCredits = _creditBalances[_account];
        if (
            currentCredits == creditAmount || currentCredits - 1 == creditAmount
        ) {
            _creditBalances[_account] = 0;
        } else if (currentCredits &gt; creditAmount) {
            _creditBalances[_account] = currentCredits - creditAmount;
        } else {
            revert("Remove exceeds balance");
        }
    }

    /**
     * @dev Modify the supply without minting new tokens. This uses a change in
     *      the exchange rate between "credits" and OUSD tokens to change balances.
     * @param _newTotalSupply New total supply of OUSD.
     * @return uint256 representing the new total supply.
     */
    function changeSupply(uint256 _newTotalSupply)
        external
        onlyVault
        returns (uint256)
    {
        require(_totalSupply &gt; 0, "Cannot increase 0 supply");

        if (_totalSupply == _newTotalSupply) {
            emit TotalSupplyUpdated(
                _totalSupply,
                totalCredits,
                creditsPerToken
            );
            return _totalSupply;
        }

        _totalSupply = _newTotalSupply;

        if (_totalSupply &gt; MAX_SUPPLY) _totalSupply = MAX_SUPPLY;

        creditsPerToken = totalCredits.divPrecisely(_totalSupply);

        emit TotalSupplyUpdated(_totalSupply, totalCredits, creditsPerToken);
        return _totalSupply;
    }
}</span>

<span class="marker" id="mapping-256"></span><span class="token add" data-title="source_file/comment">// File: contracts/interfaces/IBasicToken.sol</span>

<span class="marker" id="mapping-257"></span><span class="token add" data-title="source_file/pragma_directive">pragma solidity 0.5.11;</span>

<span class="marker" id="mapping-258"></span><span class="token mv" id="move-dst-9" data-title="source_file/interface_declaration">interface IBasicToken {
    function symbol() external view returns (string memory);

    function decimals() external view returns (uint8);
}</span>

<span class="marker" id="mapping-259"></span><span class="token add" data-title="source_file/comment">// File: contracts/utils/Helpers.sol</span>

<span class="marker" id="mapping-260"></span><span class="token add" data-title="source_file/pragma_directive">pragma solidity 0.5.11;</span>


<span class="marker" id="mapping-261"></span><span class="token mv" id="move-dst-12" data-title="source_file/library_declaration">library Helpers {
    /**
     * @notice Fetch the `symbol()` from an ERC20 token
     * @dev Grabs the `symbol()` from a contract
     * @param _token Address of the ERC20 token
     * @return string Symbol of the ERC20 token
     */
    function getSymbol(address _token) internal view returns (string memory) {
        string memory symbol = IBasicToken(_token).symbol();
        return symbol;
    }

    /**
     * @notice Fetch the `decimals()` from an ERC20 token
     * @dev Grabs the `decimals()` from a contract and fails if
     *      the decimal value does not live within a certain range
     * @param _token Address of the ERC20 token
     * @return uint256 Decimals of the ERC20 token
     */
    function getDecimals(address _token) internal view returns (uint256) {
        uint256 decimals = IBasicToken(_token).decimals();
        require(
            decimals &gt;= 4 &amp;&amp; decimals &lt;= 18,
            "Token must have sufficient decimal places"
        );

        return decimals;
    }
}</span>

<span class="marker" id="mapping-262"></span><span class="token add" data-title="source_file/comment">// File: contracts/vault/VaultStorage.sol</span>

<span class="marker" id="mapping-263"></span><span class="token add" data-title="source_file/pragma_directive">pragma solidity 0.5.11;</span>

<span class="marker" id="mapping-264"></span><span class="token add" data-title="source_file/comment">/**
 * @title OUSD VaultStorage Contract
 * @notice The VaultStorage contract defines the storage for the Vault contracts
 * @author Origin Protocol Inc
 */</span>




<span class="marker" id="mapping-265"></span><span class="token add" data-title="source_file/contract_declaration">contract VaultStorage is <span class="marker" id="mapping-266"></span><span class="token mv" id="move-dst-15" data-title="contract_declaration/inheritance_specifier">Initializable</span>, <span class="marker" id="mapping-267"></span><span class="token mv" id="move-dst-16" data-title="contract_declaration/inheritance_specifier">Governable</span> <span class="marker" id="mapping-268"></span><span class="token add" data-title="contract_declaration/contract_body">{
    <span class="marker" id="mapping-269"></span><span class="token mv" id="move-dst-17" data-title="contract_body/using_directive">using SafeMath for uint256;</span>
    <span class="marker" id="mapping-270"></span><span class="token mv" id="move-dst-18" data-title="contract_body/using_directive">using StableMath for uint256;</span>
    <span class="marker" id="mapping-271"></span><span class="token mv" id="move-dst-19" data-title="contract_body/using_directive">using SafeMath for int256;</span>
    <span class="marker" id="mapping-272"></span><span class="token mv" id="move-dst-20" data-title="contract_body/using_directive">using SafeERC20 for IERC20;</span>

    <span class="marker" id="mapping-273"></span><span class="token mv" id="move-dst-21" data-title="contract_body/event_definition">event AssetSupported(address _asset);</span>
    <span class="marker" id="mapping-274"></span><span class="token mv" id="move-dst-22" data-title="contract_body/event_definition">event StrategyAdded(address _addr);</span>
    <span class="marker" id="mapping-275"></span><span class="token mv" id="move-dst-23" data-title="contract_body/event_definition">event StrategyRemoved(address _addr);</span>
    <span class="marker" id="mapping-276"></span><span class="token mv" id="move-dst-24" data-title="contract_body/event_definition">event Mint(address _addr, uint256 _value);</span>
    <span class="marker" id="mapping-277"></span><span class="token mv" id="move-dst-25" data-title="contract_body/event_definition">event Redeem(address _addr, uint256 _value);</span>
    <span class="marker" id="mapping-278"></span><span class="token mv" id="move-dst-26" data-title="contract_body/event_definition">event StrategyWeightsUpdated(
        address[] _strategyAddresses,
        uint256[] weights
    );</span>
    <span class="marker" id="mapping-279"></span><span class="token mv" id="move-dst-27" data-title="contract_body/event_definition">event DepositsPaused();</span>
    <span class="marker" id="mapping-280"></span><span class="token mv" id="move-dst-28" data-title="contract_body/event_definition">event DepositsUnpaused();</span>

    // Assets supported by the Vault, i.e. Stablecoins
    <span class="marker" id="mapping-281"></span><span class="token mv" id="move-dst-31" data-title="contract_body/struct_declaration">struct Asset {
        bool isSupported;
    }</span>
    <span class="marker" id="mapping-282"></span><span class="token mv" id="move-dst-32" data-title="contract_body/state_variable_declaration">mapping(address =&gt; Asset) assets;</span>
    <span class="marker" id="mapping-283"></span><span class="token mv" id="move-dst-33" data-title="contract_body/state_variable_declaration">address[] allAssets;</span>

    // Strategies supported by the Vault
    <span class="marker" id="mapping-284"></span><span class="token mv" id="move-dst-36" data-title="contract_body/struct_declaration">struct Strategy {
        bool isSupported;
        uint256 targetWeight; // 18 decimals. 100% = 1e18
    }</span>
    <span class="marker" id="mapping-285"></span><span class="token mv" id="move-dst-37" data-title="contract_body/state_variable_declaration">mapping(address =&gt; Strategy) strategies;</span>
    <span class="marker" id="mapping-286"></span><span class="token mv" id="move-dst-38" data-title="contract_body/state_variable_declaration">address[] allStrategies;</span>

    // Address of the Oracle price provider contract
    <span class="marker" id="mapping-287"></span><span class="token mv" id="move-dst-39" data-title="contract_body/state_variable_declaration">address public priceProvider;</span>
    // Pausing bools
    <span class="marker" id="mapping-288"></span><span class="token mv" id="move-dst-40" data-title="contract_body/state_variable_declaration">bool public rebasePaused = false;</span>
    <span class="marker" id="mapping-289"></span><span class="token mv" id="move-dst-41" data-title="contract_body/state_variable_declaration">bool public depositPaused = true;</span>
    // Redemption fee in basis points
    <span class="marker" id="mapping-290"></span><span class="token mv" id="move-dst-42" data-title="contract_body/state_variable_declaration">uint256 public redeemFeeBps;</span>
    // Buffer of assets to keep in Vault to handle (most) withdrawals
    <span class="marker" id="mapping-291"></span><span class="token mv" id="move-dst-43" data-title="contract_body/state_variable_declaration">uint256 public vaultBuffer;</span>
    // Mints over this amount automatically allocate funds. 18 decimals.
    <span class="marker" id="mapping-292"></span><span class="token mv" id="move-dst-44" data-title="contract_body/state_variable_declaration">uint256 public autoAllocateThreshold;</span>
    // Mints over this amount automatically rebase. 18 decimals.
    <span class="marker" id="mapping-293"></span><span class="token mv" id="move-dst-45" data-title="contract_body/state_variable_declaration">uint256 public rebaseThreshold;</span>

    <span class="marker" id="mapping-294"></span><span class="token mv" id="move-dst-46" data-title="contract_body/state_variable_declaration">OUSD oUSD;</span>

    //keccak256("OUSD.vault.governor.admin.impl");
    <span class="marker" id="mapping-295"></span><span class="token add" data-title="contract_body/state_variable_declaration">bytes32 constant adminImplPosition = 0xa2bd3d3cf188a41358c8b401076eb59066b09dec5775650c0de4c55187d17bd9;</span>

    // Address of the contract responsible for post rebase syncs with AMMs
    <span class="marker" id="mapping-296"></span><span class="token add" data-title="contract_body/state_variable_declaration"><span class="marker" id="mapping-297"></span><span class="token mv" id="move-dst-58" data-title="state_variable_declaration/type_name">address</span> <span class="marker" id="mapping-298"></span><span class="token add" data-title="state_variable_declaration/visibility">public</span> rebaseHooksAddr = <span class="marker" id="mapping-299"></span><span class="token add" data-title="state_variable_declaration/type_cast_expression">address(0)</span>;</span>

    // Address of Uniswap
    <span class="marker" id="mapping-300"></span><span class="token add" data-title="contract_body/state_variable_declaration"><span class="marker" id="mapping-301"></span><span class="token mv" id="move-dst-74" data-title="state_variable_declaration/type_name">address</span> <span class="marker" id="mapping-302"></span><span class="token mv" id="move-dst-75" data-title="state_variable_declaration/visibility">public</span> uniswapAddr = <span class="marker" id="mapping-303"></span><span class="token add" data-title="state_variable_declaration/type_cast_expression">address(0)</span>;</span>

    /**
     * @dev set the implementation for the admin, this needs to be in a base class else we cannot set it
     * @param newImpl address pf the implementation
     */
    <span class="marker" id="mapping-304"></span><span class="token mv" id="move-dst-47" data-title="contract_body/function_definition">function <span class="marker" id="mapping-305"></span><span class="token upd" id="move-dst-48" data-title="function_definition/identifier"><span class="cupd">set</span>AdminImpl</span>(address <span class="marker" id="mapping-306"></span><span class="token upd" id="move-dst-49" data-title="parameter/identifier">newImpl</span>) external onlyGovernor {
        <span class="marker" id="mapping-307"></span><span class="token add" data-title="function_body/variable_declaration_statement">bytes32 position = adminImplPosition;</span>
        <span class="marker" id="mapping-308"></span><span class="token add" data-title="function_body/assembly_statement">assembly {
            sstore(position, newImpl)
        }</span>
    }</span>
}</span></span>

<span class="marker" id="mapping-309"></span><span class="token add" data-title="source_file/comment">// File: contracts/interfaces/IMinMaxOracle.sol</span>

<span class="marker" id="mapping-310"></span><span class="token add" data-title="source_file/pragma_directive">pragma solidity 0.5.11;</span>

<span class="marker" id="mapping-311"></span><span class="token mv" id="move-dst-10" data-title="source_file/interface_declaration">interface IMinMaxOracle {
    //Assuming 8 decimals
    function priceMin(string calldata symbol) external returns (uint256);

    function priceMax(string calldata symbol) external returns (uint256);
}</span>

<span class="marker" id="mapping-312"></span><span class="token mv" id="move-dst-11" data-title="source_file/interface_declaration">interface IViewMinMaxOracle {
    function priceMin(string calldata symbol) external view returns (uint256);

    function priceMax(string calldata symbol) external view returns (uint256);
}</span>

<span class="marker" id="mapping-313"></span><span class="token add" data-title="source_file/comment">// File: contracts/interfaces/IRebaseHooks.sol</span>

<span class="marker" id="mapping-314"></span><span class="token add" data-title="source_file/pragma_directive">pragma solidity 0.5.11;</span>

<span class="marker" id="mapping-315"></span><span class="token add" data-title="source_file/interface_declaration">interface IRebaseHooks <span class="marker" id="mapping-316"></span><span class="token add" data-title="interface_declaration/contract_body">{
    <span class="marker" id="mapping-317"></span><span class="token add" data-title="contract_body/function_definition">function postRebase(<span class="marker" id="mapping-318"></span><span class="token add" data-title="function_definition/parameter">bool sync</span>) <span class="marker" id="mapping-319"></span><span class="token mv" id="move-dst-50" data-title="function_definition/visibility">external</span>;</span>
}</span></span>

<span class="marker" id="mapping-320"></span><span class="token add" data-title="source_file/comment">// File: contracts/vault/VaultCore.sol</span>

<span class="marker" id="mapping-321"></span><span class="token add" data-title="source_file/pragma_directive">pragma solidity 0.5.11;</span>

<span class="marker" id="mapping-322"></span><span class="token mv" id="move-dst-2" data-title="source_file/comment">/**
 * @title OUSD Vault Contract
 * @notice The Vault contract stores assets. On a deposit, OUSD will be minted
           and sent to the depositor. On a withdrawal, OUSD will be burned and
           assets will be sent to the withdrawer. The Vault accepts deposits of
           interest form yield bearing strategies which will modify the supply
           of OUSD.
 * @author Origin Protocol Inc
 */</span>




contract <span class="marker" id="mapping-323"></span><span class="token upd" id="move-dst-14" data-title="contract_declaration/identifier"><span class="cupd">Vault</span>Core</span> is <span class="marker" id="mapping-324"></span><span class="token add" data-title="contract_declaration/inheritance_specifier">VaultStorage</span> {
    /**
     * @dev Verifies that the rebasing is not paused.
     */
    modifier whenNotRebasePaused() {
        require(!rebasePaused, "Rebasing paused");
        _;
    }

    <span class="marker" id="mapping-325"></span><span class="token mv" id="move-dst-30" data-title="contract_body/comment"><span class="marker" id="mapping-326"></span><span class="token upd" id="move-dst-30" data-title="contract_body/comment"><span class="cupd">/</span>**<span class="cupd"></span>
     * @<span class="cupd">d</span>e<span class="cupd">v</span> V<span class="cupd">e</span>rif<span class="cupd">i</span>e<span class="cupd">s</span> tha<span class="cupd">t the</span> depos<span class="cupd">i</span>t<span class="cupd">s</span> a<span class="cupd">r</span><span class="cupd">e</span> n<span class="cupd">o</span>t <span class="cupd">p</span>aused.
     */</span></span>
    <span class="marker" id="mapping-327"></span><span class="token add" data-title="contract_body/modifier_definition">modifier whenNotDepositPaused() <span class="marker" id="mapping-328"></span><span class="token add" data-title="modifier_definition/function_body">{
        <span class="marker" id="mapping-329"></span><span class="token mv" id="move-dst-64" data-title="function_body/expression_statement">require(!depositPaused, "Deposits paused");</span>
        <span class="marker" id="mapping-330"></span><span class="token add" data-title="function_body/expression_statement">_;</span>
    }</span></span>

    /**
     * @dev Deposit a supported asset and mint OUSD.
     * @param _asset Address of the asset being deposited
     * @param _amount Amount of the asset being deposited
     */
    function mint(address _asset, uint256 _amount)
        external
        <span class="marker" id="mapping-331"></span><span class="token add" data-title="function_definition/modifier_invocation">whenNotDepositPaused</span>
    {
        require(assets[_asset].isSupported, "Asset is not supported");
        require(_amount &gt; 0, "Amount must be greater than 0");

        uint256[] memory assetPrices;
        // For now we have to live with the +1 oracle call because we need to
        // know the priceAdjustedDeposit before we decide wether or not to grab
        // assets. This will not effect small non-rebase/allocate mints
        uint256 priceAdjustedDeposit = _amount.mulTruncateScale(
            IMinMaxOracle(priceProvider)
                .priceMin(Helpers.getSymbol(_asset))
                .scaleBy(int8(10)), // 18-8 because oracles have 8 decimals precision
            10**Helpers.getDecimals(_asset)
        );
        if (
            (priceAdjustedDeposit &gt; rebaseThreshold &amp;&amp; !rebasePaused) ||
            (priceAdjustedDeposit &gt;= autoAllocateThreshold)
        ) {
            assetPrices = _getAssetPrices(false);
        }

        // Rebase must happen before any transfers occur.
        if (priceAdjustedDeposit &gt; rebaseThreshold &amp;&amp; !rebasePaused) {
            rebase(<span class="marker" id="mapping-332"></span><span class="token mv" id="move-dst-68" data-title="call_expression/call_argument">assetPrices</span><span class="marker" id="mapping-333"></span><span class="token add" data-title="call_expression/,">,</span> <span class="marker" id="mapping-334"></span><span class="token add" data-title="call_expression/call_argument"><span class="marker" id="mapping-335"></span><span class="token mv" id="move-dst-72" data-title="call_argument/boolean_literal">true</span></span>);
        }

        // Transfer the deposited coins to the vault
        IERC20 asset = IERC20(_asset);
        asset.safeTransferFrom(msg.sender, address(this), _amount);

        // Mint matching OUSD
        oUSD.mint(msg.sender, priceAdjustedDeposit);
        emit Mint(msg.sender, priceAdjustedDeposit);

        if (priceAdjustedDeposit &gt;= autoAllocateThreshold) {
            allocate(assetPrices);
        }
    }

    /**
     * @dev Mint for multiple assets in the same call.
     * @param _assets Addresses of assets being deposited
     * @param _amounts Amount of each asset at the same index in the _assets
     *                 to deposit.
     */
    function mintMultiple(
        address[] calldata _assets,
        uint256[] calldata _amounts
    ) external <span class="marker" id="mapping-336"></span><span class="token add" data-title="function_definition/modifier_invocation">whenNotDepositPaused</span> {
        require(_assets.length == _amounts.length, "Parameter length mismatch");

        uint256 priceAdjustedTotal = 0;
        uint256[] memory assetPrices = _getAssetPrices(false);
        for (uint256 i = 0; i &lt; allAssets.length; i++) {
            for (uint256 j = 0; j &lt; _assets.length; j++) {
                if (_assets[j] == allAssets[i]) {
                    if (_amounts[j] &gt; 0) {
                        uint256 assetDecimals = Helpers.getDecimals(
                            allAssets[i]
                        );
                        priceAdjustedTotal += _amounts[j].mulTruncateScale(
                            assetPrices[i],
                            10**assetDecimals
                        );
                    }
                }
            }
        }
        // Rebase must happen before any transfers occur.
        if (priceAdjustedTotal &gt; rebaseThreshold &amp;&amp; !rebasePaused) {
            rebase(<span class="marker" id="mapping-337"></span><span class="token mv" id="move-dst-67" data-title="call_expression/call_argument">assetPrices</span><span class="marker" id="mapping-338"></span><span class="token add" data-title="call_expression/,">,</span> <span class="marker" id="mapping-339"></span><span class="token add" data-title="call_expression/call_argument"><span class="marker" id="mapping-340"></span><span class="token mv" id="move-dst-70" data-title="call_argument/boolean_literal">true</span></span>);
        }

        for (uint256 i = 0; i &lt; _assets.length; i++) {
            IERC20 asset = IERC20(_assets[i]);
            asset.safeTransferFrom(msg.sender, address(this), _amounts[i]);
        }

        oUSD.mint(msg.sender, priceAdjustedTotal);
        emit Mint(msg.sender, priceAdjustedTotal);

        if (priceAdjustedTotal &gt;= autoAllocateThreshold) {
            allocate(assetPrices);
        }
    }

    /**
     * @dev Withdraw a supported asset and burn OUSD.
     * @param _amount Amount of OUSD to burn
     */
    function redeem(uint256 _amount) public {
        uint256[] memory assetPrices = _getAssetPrices(false);
        if (_amount &gt; rebaseThreshold &amp;&amp; !rebasePaused) {
            rebase(assetPrices<span class="marker" id="mapping-341"></span><span class="token add" data-title="call_expression/,">,</span> <span class="marker" id="mapping-342"></span><span class="token add" data-title="call_expression/call_argument"><span class="marker" id="mapping-343"></span><span class="token mv" id="move-dst-71" data-title="call_argument/boolean_literal">false</span></span>);
        }
        _redeem(_amount, assetPrices);
    }

    function _redeem(uint256 _amount, uint256[] memory assetPrices) internal {
        require(_amount &gt; 0, "Amount must be greater than 0");

        uint256 feeAdjustedAmount;
        if (redeemFeeBps &gt; 0) {
            uint256 redeemFee = _amount.mul(redeemFeeBps).div(10000);
            feeAdjustedAmount = _amount.sub(redeemFee);
        } else {
            feeAdjustedAmount = _amount;
        }

        // Calculate redemption outputs
        uint256[] memory outputs = _calculateRedeemOutputs(feeAdjustedAmount);
        // Send outputs
        for (uint256 i = 0; i &lt; allAssets.length; i++) {
            if (outputs[i] == 0) continue;

            IERC20 asset = IERC20(allAssets[i]);

            if (asset.balanceOf(address(this)) &gt;= outputs[i]) {
                // Use Vault funds first if sufficient
                asset.safeTransfer(msg.sender, outputs[i]);
            } else {
                address strategyAddr = _selectWithdrawStrategyAddr(
                    allAssets[i],
                    outputs[i],
                    assetPrices
                );

                if (strategyAddr != address(0)) {
                    // Nothing in Vault, but something in Strategy, send from there
                    IStrategy strategy = IStrategy(strategyAddr);
                    strategy.withdraw(msg.sender, allAssets[i], outputs[i]);
                } else {
                    // Cant find funds anywhere
                    revert("Liquidity error");
                }
            }
        }

        oUSD.burn(msg.sender, _amount);

        // Until we can prove that we won't affect the prices of our assets
        // by withdrawing them, this should be here.
        // It's possible that a strategy was off on its asset total, perhaps
        // a reward token sold for more or for less than anticipated.
        if (_amount &gt; rebaseThreshold &amp;&amp; !rebasePaused) {
            <span class="marker" id="mapping-344"></span><span class="token mv" id="move-dst-51" data-title="block_statement/expression_statement"><span class="marker" id="mapping-345"></span><span class="token mv" id="move-dst-52" data-title="expression_statement/call_expression"><span class="marker" id="mapping-346"></span><span class="token upd" id="move-dst-53" data-title="call_expression/identifier">reba<span class="cupd">s</span>e</span>(<span class="marker" id="mapping-347"></span><span class="token mv" id="move-dst-66" data-title="call_expression/call_argument">assetPrices</span><span class="marker" id="mapping-348"></span><span class="token add" data-title="call_expression/,">,</span> <span class="marker" id="mapping-349"></span><span class="token mv" id="move-dst-54" data-title="call_argument/boolean_literal">true</span>)</span>;</span>
        }

        emit Redeem(msg.sender, _amount);
    }

    /**
     * @notice Withdraw a supported asset and burn all OUSD.
     */
    function redeemAll() external {
        uint256[] memory assetPrices = _getAssetPrices(false);
        //unfortunately we have to do balanceOf twice
        if (oUSD.balanceOf(msg.sender) &gt; rebaseThreshold &amp;&amp; !rebasePaused) {
            rebase(<span class="marker" id="mapping-350"></span><span class="token mv" id="move-dst-65" data-title="call_expression/call_argument">assetPrices</span><span class="marker" id="mapping-351"></span><span class="token add" data-title="call_expression/,">,</span> <span class="marker" id="mapping-352"></span><span class="token add" data-title="call_expression/call_argument"><span class="marker" id="mapping-353"></span><span class="token mv" id="move-dst-73" data-title="call_argument/boolean_literal">false</span></span>);
        }

        _redeem(oUSD.balanceOf(msg.sender), assetPrices);
    }

    /**
     * @notice Allocate unallocated funds on Vault to strategies.
     * @dev Allocate unallocated funds on Vault to strategies.
     **/
    function allocate() public {
        uint256[] memory assetPrices = _getAssetPrices(false);
        allocate(assetPrices);
    }

    /**
     * @notice Allocate unallocated funds on Vault to strategies.
     * @dev Allocate unallocated funds on Vault to strategies.
     **/
    function allocate(uint256[] memory assetPrices) internal {
        uint256 vaultValue = _totalValueInVault(assetPrices);
        // Nothing in vault to allocate
        if (vaultValue == 0) return;
        uint256 strategiesValue = _totalValueInStrategies(assetPrices);
        // We have a method that does the same as this, gas optimisation
        uint256 totalValue = vaultValue + strategiesValue;

        // We want to maintain a buffer on the Vault so calculate a percentage
        // modifier to multiply each amount being allocated by to enforce the
        // vault buffer
        uint256 vaultBufferModifier;
        if (strategiesValue == 0) {
            // Nothing in Strategies, allocate 100% minus the vault buffer to
            // strategies
            vaultBufferModifier = 1e18 - vaultBuffer;
        } else {
            vaultBufferModifier = vaultBuffer.mul(totalValue).div(vaultValue);
            if (1e18 &gt; vaultBufferModifier) {
                // E.g. 1e18 - (1e17 * 10e18)/5e18 = 8e17
                // (5e18 * 8e17) / 1e18 = 4e18 allocated from Vault
                vaultBufferModifier = 1e18 - vaultBufferModifier;
            } else {
                // We need to let the buffer fill
                return;
            }
        }

        if (vaultBufferModifier == 0) return;

        // Iterate over all assets in the Vault and allocate the the appropriate
        // strategy
        for (uint256 i = 0; i &lt; allAssets.length; i++) {
            IERC20 asset = IERC20(allAssets[i]);
            uint256 assetBalance = asset.balanceOf(address(this));
            // No balance, nothing to do here
            if (assetBalance == 0) continue;

            // Multiply the balance by the vault buffer modifier and truncate
            // to the scale of the asset decimals
            uint256 allocateAmount = assetBalance.mulTruncate(
                vaultBufferModifier
            );

            // Get the target Strategy to maintain weightings
            address depositStrategyAddr = _selectDepositStrategyAddr(
                address(asset),
                assetPrices
            );

            if (depositStrategyAddr != address(0) &amp;&amp; allocateAmount &gt; 0) {
                IStrategy strategy = IStrategy(depositStrategyAddr);
                // Transfer asset to Strategy and call deposit method to
                // mint or take required action
                asset.safeTransfer(address(strategy), allocateAmount);
                strategy.deposit(address(asset), allocateAmount);
            }
        }
    }

    /**
     * @dev Calculate the total value of assets held by the Vault and all
     *         strategies and update the supply of oUSD
     */
    function rebase() public whenNotRebasePaused returns (uint256) {
        uint256[] memory assetPrices = _getAssetPrices(false);
        rebase(assetPrices<span class="marker" id="mapping-354"></span><span class="token add" data-title="call_expression/,">,</span> <span class="marker" id="mapping-355"></span><span class="token add" data-title="call_expression/call_argument"><span class="marker" id="mapping-356"></span><span class="token mv" id="move-dst-57" data-title="call_argument/boolean_literal">true</span></span>);
    }

    /**
     * @dev Calculate the total value of assets held by the Vault and all
     *         strategies and update the supply of oUSD
     */
    function rebase(uint256[] memory assetPrices<span class="marker" id="mapping-357"></span><span class="token add" data-title="function_definition/,">,</span> <span class="marker" id="mapping-358"></span><span class="token add" data-title="function_definition/parameter">bool sync</span>)
        internal
        whenNotRebasePaused
        returns (uint256)
    {
        if (oUSD.totalSupply() == 0) return 0;
        <span class="marker" id="mapping-359"></span><span class="token mv" id="move-dst-61" data-title="function_body/variable_declaration_statement">uint256 <span class="marker" id="mapping-360"></span><span class="token upd" id="move-dst-62" data-title="variable_declaration/identifier">oldTotalSupply</span> = <span class="marker" id="mapping-361"></span><span class="token add" data-title="variable_declaration_statement/call_expression">oUSD.totalSupply()</span>;</span>
        <span class="marker" id="mapping-362"></span><span class="token mv" id="move-dst-59" data-title="function_body/variable_declaration_statement">uint256 <span class="marker" id="mapping-363"></span><span class="token upd" id="move-dst-60" data-title="variable_declaration/identifier">newTo<span class="cupd">t</span><span class="cupd">a</span>lSupply</span> = <span class="marker" id="mapping-364"></span><span class="token mv" id="move-dst-69" data-title="variable_declaration_statement/call_expression">oUSD.changeSupply(_totalValue(assetPrices))</span>;</span>
        <span class="marker" id="mapping-365"></span><span class="token add" data-title="function_body/if_statement">if (oldTotalSupply != newTotalSupply &amp;&amp; rebaseHooksAddr != address(0)) {
            IRebaseHooks(rebaseHooksAddr).postRebase(sync);
        }</span>
    }

    /**
     * @dev Determine the total value of assets held by the vault and its
     *         strategies.
     * @return uint256 value Total value in USD (1e18)
     */
    function totalValue() external returns (uint256 value) {
        uint256[] memory assetPrices = _getAssetPrices(false);
        value = _totalValue(assetPrices);
    }

    /**
     * @dev Internal Calculate the total value of the assets held by the
     *         vault and its strategies.
     * @return uint256 value Total value in USD (1e18)
     */
    function _totalValue(uint256[] memory assetPrices)
        internal
        view
        returns (uint256 value)
    {
        return
            _totalValueInVault(assetPrices) +
            _totalValueInStrategies(assetPrices);
    }

    /**
     * @dev Internal to calculate total value of all assets held in Vault.
     * @return uint256 Total value in ETH (1e18)
     */
    function _totalValueInVault(uint256[] memory assetPrices)
        internal
        view
        returns (uint256 value)
    {
        value = 0;
        for (uint256 y = 0; y &lt; allAssets.length; y++) {
            IERC20 asset = IERC20(allAssets[y]);
            uint256 assetDecimals = Helpers.getDecimals(allAssets[y]);
            uint256 balance = asset.balanceOf(address(this));
            if (balance &gt; 0) {
                value += balance.mulTruncateScale(
                    assetPrices[y],
                    10**assetDecimals
                );
            }
        }
    }

    /**
     * @dev Internal to calculate total value of all assets held in Strategies.
     * @return uint256 Total value in ETH (1e18)
     */
    function _totalValueInStrategies(uint256[] memory assetPrices)
        internal
        view
        returns (uint256 value)
    {
        value = 0;
        for (uint256 i = 0; i &lt; allStrategies.length; i++) {
            value += _totalValueInStrategy(allStrategies[i], assetPrices);
        }
    }

    /**
     * @dev Internal to calculate total value of all assets held by strategy.
     * @param _strategyAddr Address of the strategy
     * @return uint256 Total value in ETH (1e18)
     */
    function _totalValueInStrategy(
        address _strategyAddr,
        uint256[] memory assetPrices
    ) internal view returns (uint256 value) {
        value = 0;
        IStrategy strategy = IStrategy(_strategyAddr);
        for (uint256 y = 0; y &lt; allAssets.length; y++) {
            uint256 assetDecimals = Helpers.getDecimals(allAssets[y]);
            if (strategy.supportsAsset(allAssets[y])) {
                uint256 balance = strategy.checkBalance(allAssets[y]);
                if (balance &gt; 0) {
                    value += balance.mulTruncateScale(
                        assetPrices[y],
                        10**assetDecimals
                    );
                }
            }
        }
    }

    /**
     * @dev Calculate difference in percent of asset allocation for a
               strategy.
     * @param _strategyAddr Address of the strategy
     * @return int256 Difference between current and target. 18 decimals. For ex. 10%=1e17.
     */
    function _strategyWeightDifference(
        address _strategyAddr,
        uint256[] memory assetPrices
    ) internal view returns (int256 difference) {
        difference =
            int256(strategies[_strategyAddr].targetWeight) -
            int256(
                _totalValueInStrategy(_strategyAddr, assetPrices).divPrecisely(
                    _totalValue(assetPrices)
                )
            );
    }

    /**
     * @dev Select a strategy for allocating an asset to.
     * @param _asset Address of asset
     * @return address Address of the target strategy
     */
    function _selectDepositStrategyAddr(
        address _asset,
        uint256[] memory assetPrices
    ) internal view returns (address depositStrategyAddr) {
        depositStrategyAddr = address(0);
        int256 maxDifference = 0;

        for (uint256 i = 0; i &lt; allStrategies.length; i++) {
            IStrategy strategy = IStrategy(allStrategies[i]);
            if (strategy.supportsAsset(_asset)) {
                int256 diff = _strategyWeightDifference(
                    allStrategies[i],
                    assetPrices
                );
                if (diff &gt;= maxDifference) {
                    maxDifference = diff;
                    depositStrategyAddr = allStrategies[i];
                }
            }
        }
    }

    /**
     * @dev Select a strategy for withdrawing an asset from.
     * @param _asset Address of asset
     * @return address Address of the target strategy for withdrawal
     */
    function _selectWithdrawStrategyAddr(
        address _asset,
        uint256 _amount,
        uint256[] memory assetPrices
    ) internal view returns (address withdrawStrategyAddr) {
        withdrawStrategyAddr = address(0);
        int256 minDifference = 1e18;

        for (uint256 i = 0; i &lt; allStrategies.length; i++) {
            IStrategy strategy = IStrategy(allStrategies[i]);
            if (
                strategy.supportsAsset(_asset) &amp;&amp;
                strategy.checkBalance(_asset) &gt; _amount
            ) {
                int256 diff = _strategyWeightDifference(
                    allStrategies[i],
                    assetPrices
                );
                if (diff &lt;= minDifference) {
                    minDifference = diff;
                    withdrawStrategyAddr = allStrategies[i];
                }
            }
        }
    }

    /**
     * @notice Get the balance of an asset held in Vault and all strategies.
     * @param _asset Address of asset
     * @return uint256 Balance of asset in decimals of asset
     */
    function checkBalance(address _asset) external view returns (uint256) {
        return _checkBalance(_asset);
    }

    /**
     * @notice Get the balance of an asset held in Vault and all strategies.
     * @param _asset Address of asset
     * @return uint256 Balance of asset in decimals of asset
     */
    function _checkBalance(address _asset)
        internal
        view
        returns (uint256 balance)
    {
        IERC20 asset = IERC20(_asset);
        balance = asset.balanceOf(address(this));
        for (uint256 i = 0; i &lt; allStrategies.length; i++) {
            IStrategy strategy = IStrategy(allStrategies[i]);
            if (strategy.supportsAsset(_asset)) {
                balance += strategy.checkBalance(_asset);
            }
        }
    }

    /**
     * @notice Get the balance of all assets held in Vault and all strategies.
     * @return uint256 Balance of all assets (1e18)
     */
    function _checkBalance() internal view returns (uint256 balance) {
        balance = 0;
        for (uint256 i = 0; i &lt; allAssets.length; i++) {
            uint256 assetDecimals = Helpers.getDecimals(allAssets[i]);
            balance += _checkBalance(allAssets[i]).scaleBy(
                int8(18 - assetDecimals)
            );
        }
    }

    /**
     * @notice Calculate the outputs for a redeem function, i.e. the mix of
     * coins that will be returned
     */
    function calculateRedeemOutputs(uint256 _amount)
        external
        returns (uint256[] memory)
    {
        return _calculateRedeemOutputs(_amount);
    }

    /**
     * @notice Calculate the outputs for a redeem function, i.e. the mix of
     * coins that will be returned.
     * @return Array of amounts respective to the supported assets
     */
    function _calculateRedeemOutputs(uint256 _amount)
        internal
        returns (uint256[] memory outputs)
    {
        uint256[] memory assetPrices = _getAssetPrices(true);

        uint256 totalBalance = _checkBalance();
        uint256 totalOutputValue = 0; // Running total of USD value of assets
        uint256 assetCount = getAssetCount();

        // Initialise arrays
        // Price of each asset in USD in 1e18
        outputs = new uint256[](assetCount);

        for (uint256 i = 0; i &lt; allAssets.length; i++) {
            uint256 assetDecimals = Helpers.getDecimals(allAssets[i]);

            // Get the proportional amount of this token for the redeem in 1e18
            uint256 proportionalAmount = _checkBalance(allAssets[i])
                .scaleBy(int8(18 - assetDecimals))
                .mul(_amount)
                .div(totalBalance);

            if (proportionalAmount &gt; 0) {
                // Running USD total of all coins in the redeem outputs in 1e18
                totalOutputValue += proportionalAmount.mulTruncate(
                    assetPrices[i]
                );
                // Save the output amount in the decimals of the asset
                outputs[i] = proportionalAmount.scaleBy(
                    int8(assetDecimals - 18)
                );
            }
        }

        // USD difference in amount of coins calculated due to variations in
        // price in 1e18
        int256 outputValueDiff = int256(_amount - totalOutputValue);
        // Make up the difference by adding/removing an equal proportion of
        // each coin according to its USD value
        for (uint256 i = 0; i &lt; outputs.length; i++) {
            if (outputs[i] == 0) continue;
            if (outputValueDiff &lt; 0) {
                outputs[i] -= uint256(-outputValueDiff).mul(outputs[i]).div(
                    totalOutputValue
                );
            } else if (outputValueDiff &gt; 0) {
                outputs[i] += uint256(outputValueDiff).mul(outputs[i]).div(
                    totalOutputValue
                );
            }
        }
    }

    /**
     * @notice Get an array of the supported asset prices in USD.
     * @return uint256[] Array of asset prices in USD (1e18)
     */
    function _getAssetPrices(bool useMax)
        internal
        returns (uint256[] memory assetPrices)
    {
        assetPrices = new uint256[](getAssetCount());

        IMinMaxOracle oracle = IMinMaxOracle(priceProvider);
        // Price from Oracle is returned with 8 decimals
        // _amount is in assetDecimals

        for (uint256 i = 0; i &lt; allAssets.length; i++) {
            string memory symbol = Helpers.getSymbol(allAssets[i]);
            // Get all the USD prices of the asset in 1e18
            if (useMax) {
                assetPrices[i] = oracle.priceMax(symbol).scaleBy(int8(18 - 8));
            } else {
                assetPrices[i] = oracle.priceMin(symbol).scaleBy(int8(18 - 8));
            }
        }
    }

    /***************************************
                    Utils
    ****************************************/

    /**
     * @dev Return the number of assets suppported by the Vault.
     */
    function getAssetCount() public view returns (uint256) {
        return allAssets.length;
    }

    /**
     * @dev Return all asset addresses in order
     */
    function getAllAssets() external view returns (address[] memory) {
        return allAssets;
    }

    /**
     * @dev Return the number of strategies active on the Vault.
     */
    function getStrategyCount() public view returns (uint256) {
        return allStrategies.length;
    }

    /**
     * @dev Get the total APR of the Vault and all Strategies.
     */
    function getAPR() external returns (uint256) {
        if (getStrategyCount() == 0) return 0;

        uint256[] memory assetPrices = _getAssetPrices(true);

        uint256 totalAPR = 0;
        // Get the value from strategies
        for (uint256 i = 0; i &lt; allStrategies.length; i++) {
            IStrategy strategy = IStrategy(allStrategies[i]);
            if (strategy.getAPR() &gt; 0) {
                totalAPR += _totalValueInStrategy(allStrategies[i], assetPrices)
                    .divPrecisely(_totalValue(assetPrices))
                    .mulTruncate(strategy.getAPR());
            }
        }
        return totalAPR;
    }

    function isSupportedAsset(address _asset) external view returns (bool) {
        return assets[_asset].isSupported;
    }

    <span class="marker" id="mapping-366"></span><span class="token mv" id="move-dst-35" data-title="contract_body/comment"><span class="marker" id="mapping-367"></span><span class="token upd" id="move-dst-35" data-title="contract_body/comment"><span class="cupd">/</span>**<span class="cupd"></span>
     * @dev Falldown<span class="cupd"> </span>to the<span class="cupd"> </span>admin impleme<span class="cupd">n</span>tation
     * @not<span class="cupd">i</span>ce <span class="cupd">T</span><span class="cupd">hi</span>s<span class="cupd"> </span>is a catch all<span class="cupd"> f</span>or all fu<span class="cupd">n</span>ctions not<span class="cupd"> </span>decla<span class="cupd">re</span>d <span class="cupd">i</span>n c<span class="cupd">or</span>e
     */</span></span>
    <span class="marker" id="mapping-368"></span><span class="token add" data-title="contract_body/fallback_receive_definition">function() <span class="marker" id="mapping-369"></span><span class="token mv" id="move-dst-63" data-title="fallback_receive_definition/visibility">external</span> <span class="marker" id="mapping-370"></span><span class="token add" data-title="fallback_receive_definition/state_mutability">payable</span> <span class="marker" id="mapping-371"></span><span class="token add" data-title="fallback_receive_definition/function_body">{
        bytes32 slot = adminImplPosition;
        assembly {
            // Copy msg.data. We take full control of memory in this inline assembly
            // block because it will not return to Solidity code. We overwrite the
            // Solidity scratch pad at memory position 0.
            calldatacopy(0, 0, calldatasize)

            // Call the implementation.
            // out and outsize are 0 because we don't know the size yet.
            let result := delegatecall(gas, sload(slot), 0, calldatasize, 0, 0)

            // Copy the returned data.
            returndatacopy(0, 0, returndatasize)

            switch result
                // delegatecall returns 0 on error.
                case 0 {
                    revert(0, returndatasize)
                }
                default {
                    return(0, returndatasize)
                }
        }
    }</span></span>
}</pre></div></div></div></body></html>