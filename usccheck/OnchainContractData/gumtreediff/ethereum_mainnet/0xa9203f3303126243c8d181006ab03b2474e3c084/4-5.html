<html lang="en"><head><meta charset="utf8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>GumTree</title><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css"><style type="text/css">/*
 * This file is part of GumTree.
 *
 * GumTree is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * GumTree is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with GumTree.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Copyright 2011-2015 Jean-Rémy Falleri <jr.falleri@gmail.com>
 * Copyright 2011-2015 Floréal Morandat <florealm@gmail.com>
 */

.add {
	border: 1px solid black;
	background-color: MediumSeaGreen;
}

.del {
	border: 1px solid black;
	background-color: IndianRed;
}

.mv {
	border: 1px solid black;
	background-color: Plum;
}

.upd {
	border: 1px solid black;
	background-color: DarkOrange;
	font-weight: bold;
}

.cupd {
	font-weight: normal;
	color: DimGray;
}

.selected {
	background-color: Gold;
}

.marker {
	margin: 0;
	padding: 0;
}

div {
	margin: 0px;
	padding: 0px;
}

.pre-scrollable {
	margin: 0px;
	padding: 0px;
	font-size: 10pt;
	color: black;
	max-height: 90vh;
	background-color: white;
	border: 1px solid black;
	font-family: "Hack, Inconsolata", "Consolas", "Liberation Sans Regular", "DejaVu Sans Mono", monospace;
}

.tooltip-inner {
    max-width: none;
}
</style><script type="text/javascript" src="https://code.jquery.com/jquery-3.4.1.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/js/bootstrap.bundle.min.js"></script><script type="text/javascript">/*
 * This file is part of GumTree.
 *
 * GumTree is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * GumTree is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with GumTree.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Copyright 2011-2015 Jean-Rémy Falleri <jr.falleri@gmail.com>
 * Copyright 2011-2015 Floréal Morandat <florealm@gmail.com>
 */

$(function(){
    let popoverTriggerList = [].slice.call(document.querySelectorAll('[data-bs-toggle="popover"]'))
    let popoverList = popoverTriggerList.map(function (popoverTriggerEl) {
      return new bootstrap.Popover(popoverTriggerEl)
    })

    $("body").keypress(function (event) {
        switch (event.which) {
            case 116:
                $('html, body').animate({scrollTop: 0}, 100);
                break;
            case 98:
                $("html, body").animate({ scrollTop: $(document).height() }, 100);
                break;
            case 113:
                window.location = "/quit";
                break;
            case 108:
                window.location = "/list";
                break;
        }
    });
});
</script><script type="text/javascript">/*
 * This file is part of GumTree.
 *
 * GumTree is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * GumTree is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with GumTree.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Copyright 2011-2015 Jean-Rémy Falleri <jr.falleri@gmail.com>
 * Copyright 2011-2015 Floréal Morandat <florealm@gmail.com>
 */

currentMapping = 0;

if (typeof String.prototype.startsWith != 'function') {
  String.prototype.startsWith = function (str){
    return this.slice(0, str.length) == str;
  };
}

function getMappedElement(eltId) {
	if (eltId.startsWith("move-src")) {
		return eltId.replace("src","dst");  	 	
  	}
  	else {
  		return eltId.replace("dst","src");
  	}
}

function nextMapping() {
	if (currentMapping == 0) {
		currentMapping = 1;
		return "#mapping-" + currentMapping.toString();
	} else {
		currentMapping++;
		
		if ($("#mapping-" + currentMapping.toString()).length > 0) {
			return "#mapping-" + currentMapping.toString();
		} else {
			currentMapping = 1;
			return "#mapping-" + currentMapping.toString();		
		}		
	}
}

function isSrc(eltId) {
	return eltId.startsWith("move-src");
}

$(function() {
    $("body").keypress(function (event) {
        switch(event.which) {
            case 110:
                const mapping = $(nextMapping());
                const pre = mapping.closest("pre");
                pre.animate({scrollTop: pre.scrollTop() + mapping.position().top - 200}, 100);
                break;
        }
    });

    // highlight
    $("span.mv.token, span.token.upd").click(function(event) {
        if ($(this).hasClass("selected")) {
            $("span.mv.token, span.token.upd").removeClass("selected");
        } else {
            $("span.mv.token, span.token.upd").removeClass("selected");
            const refElt = $("#" + getMappedElement($(this).attr("id")));
            $(this).addClass("selected");
            refElt.addClass("selected");
            const pre = refElt.closest("pre");
            console.log(pre);
            pre.animate({scrollTop: pre.scrollTop() + refElt.position().top - 200}, 100);
        }
        event.stopPropagation();
    });
    
    $("span.add.token, span.token.del").click(function(event) {
        $("span.mv.token, span.token.upd").removeClass("selected");
        event.stopPropagation();
    });

    // tooltip
    $("span.token").hover(
    	function (event) {
    		$(this).tooltip('show');
    		event.stopPropagation();
    	},
    	function (event) {
    		$(this).tooltip('hide');
    		event.stopPropagation();
    	}
    );
});
</script></head><body><div class="container-fluid"><div class="row"><div class="col"><div class="btn-toolbar justify-content-end"><div class="btn-group mr-2"><button class="btn btn-primary btn-sm" id="legend" data-bs-toggle="popover" data-bs-placement="bottom" data-bs-html="true" data-bs-content="<span class='del'>&nbsp;&nbsp;</span> deleted<br><span class='add'>&nbsp;&nbsp;</span> added<br><span class='mv'>&nbsp;&nbsp;</span> moved<br><span class='upd';>&nbsp;&nbsp;</span> updated<br>">Legend</button><button class="btn btn-primary btn-sm" id="shortcuts" data-bs-toggle="popover" data-bs-placement="bottom" data-bs-html="true" data-bs-content="<b>q</b> quit<br><b>l</b> list<br><b>n</b> next<br><b>t</b> top<br><b>b</b> bottom">Shortcuts</button></div><div class="btn-group"><a href="/list" class="btn btn-default btn-sm btn-primary">Back</a><a href="/quit" class="btn btn-default btn-sm btn-danger">Quit</a></div></div></div></div><div class="row"><div class="col-6"><h5>0x1e0d6ba9d7ddd3f9bc121c51fa051e7826f12b9f.etherscan.io-LandResourceV5.sol</h5><pre class="pre-scrollable"><span class="marker" id="mapping-1"></span><span class="token upd" id="move-src-1" data-title="source_file/comment"><span class="cupd">/</span>/<span class="cupd"> </span>D<span class="cupd">e</span>pen<span class="cupd">d</span>ency<span class="cupd"> f</span>ile:<span class="cupd"> </span>op<span class="cupd">e</span>nzeppel<span class="cupd">i</span>n-sol<span class="cupd">i</span>d<span class="cupd">i</span>ty/c<span class="cupd">on</span>tr<span class="cupd">a</span>c<span class="cupd">t</span>s/mat<span class="cupd">h</span>/Sa<span class="cupd">f</span>eMath<span class="cupd">.</span>sol</span>

<span class="marker" id="mapping-2"></span><span class="token upd" id="move-src-2" data-title="source_file/comment"><span class="cupd">// </span>p<span class="cupd">r</span><span class="cupd">a</span>gm<span class="cupd">a </span>solidity ^0.4.24;</span>


<span class="marker" id="mapping-3"></span><span class="token mv" id="move-src-3" data-title="source_file/comment">/**
 * @title SafeMath
 * @dev Math operations with safety checks that throw on error
 */</span>
<span class="marker" id="mapping-4"></span><span class="token mv" id="move-src-4" data-title="source_file/library_declaration">library SafeMath {

  /**
  * @dev Multiplies two numbers, throws on overflow.
  */
  function mul(uint256 _a, uint256 _b) internal pure returns (uint256 c) {
    // Gas optimization: this is cheaper than asserting 'a' not being zero, but the
    // benefit is lost if 'b' is also tested.
    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522
    if (_a == 0) {
      return 0;
    }

    c = _a * _b;
    assert(c / _a == _b);
    return c;
  }

  /**
  * @dev Integer division of two numbers, truncating the quotient.
  */
  function div(uint256 _a, uint256 _b) internal pure returns (uint256) {
    // assert(_b &gt; 0); // Solidity automatically throws when dividing by 0
    // uint256 c = _a / _b;
    // assert(_a == _b * c + _a % _b); // There is no case in which this doesn't hold
    return _a / _b;
  }

  /**
  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).
  */
  function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {
    assert(_b &lt;= _a);
    return _a - _b;
  }

  /**
  * @dev Adds two numbers, throws on overflow.
  */
  function add(uint256 _a, uint256 _b) internal pure returns (uint256 c) {
    c = _a + _b;
    assert(c &gt;= _a);
    return c;
  }
}</span>


<span class="marker" id="mapping-5"></span><span class="token upd" id="move-src-5" data-title="source_file/comment"><span class="cupd">// </span>D<span class="cupd">e</span>pendency<span class="cupd"> f</span>i<span class="cupd">l</span><span class="cupd">e</span>:<span class="cupd"> </span><span class="cupd">o</span>p<span class="cupd">e</span>nzeppelin-<span class="cupd">s</span><span class="cupd">o</span>lidity/<span class="cupd">contracts/</span>i<span class="cupd">n</span>t<span class="cupd">r</span>osp<span class="cupd">e</span>ction/ERC1<span class="cupd">6</span>5<span class="cupd">.sol</span></span>

<span class="marker" id="mapping-6"></span><span class="token upd" id="move-src-6" data-title="source_file/comment"><span class="cupd">//</span><span class="cupd"> </span>p<span class="cupd">ra</span>gm<span class="cupd">a</span> <span class="cupd">s</span><span class="cupd">ol</span>idity ^0.4.24;</span>


<span class="marker" id="mapping-7"></span><span class="token upd" id="move-src-7" data-title="source_file/comment"><span class="cupd">/*</span>*<span class="cupd"></span>
 * @title ERC165
 * @dev h<span class="cupd">t</span>tps:<span class="cupd">/</span>/github.<span class="cupd">c</span>om/ethereum/E<span class="cupd">I</span>Ps<span class="cupd">/</span>blob/master/EIPS<span class="cupd">/</span>eip-165<span class="cupd">.</span><span class="cupd">m</span><span class="cupd">d
</span> */</span>
<span class="marker" id="mapping-8"></span><span class="token mv" id="move-src-8" data-title="source_file/interface_declaration">interface ERC165 {

  /**
   * @notice Query if a contract implements an interface
   * @param _interfaceId The interface identifier, as specified in ERC-165
   * @dev Interface identification is specified in ERC-165. This function
   * uses less than 30,000 gas.
   */
  function supportsInterface(bytes4 _interfaceId)
    external
    view
    returns (bool);
}</span>


<span class="marker" id="mapping-9"></span><span class="token upd" id="move-src-9" data-title="source_file/comment"><span class="cupd">//</span><span class="cupd"> </span>Dependen<span class="cupd">c</span>y file: <span class="cupd">o</span>pe<span class="cupd">n</span>zeppelin-<span class="cupd">s</span>ol<span class="cupd">i</span>dity/co<span class="cupd">nt</span><span class="cupd">r</span><span class="cupd">ac</span>t<span class="cupd">s/</span>toke<span class="cupd">n</span>/ERC721/ERC721<span class="cupd">Bas</span>ic<span class="cupd">.sol</span></span>

<span class="marker" id="mapping-10"></span><span class="token upd" id="move-src-10" data-title="source_file/comment"><span class="cupd">/</span>/<span class="cupd"> pragma solidity ^0.4.24;</span></span>

<span class="marker" id="mapping-11"></span><span class="token upd" id="move-src-11" data-title="source_file/comment"><span class="cupd">//</span><span class="cupd"> </span>import "openzeppelin-solidity/<span class="cupd">contracts/int</span><span class="cupd">r</span>o<span class="cupd">s</span>p<span class="cupd">e</span>c<span class="cupd">t</span>ion/ERC165<span class="cupd">.sol</span>";</span>


<span class="marker" id="mapping-12"></span><span class="token mv" id="move-src-12" data-title="source_file/comment">/**
 * @title ERC721 Non-Fungible Token Standard basic interface
 * @dev see https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md
 */</span>
<span class="marker" id="mapping-13"></span><span class="token mv" id="move-src-13" data-title="source_file/contract_declaration">contract ERC721Basic is ERC165 {

  bytes4 internal constant InterfaceId_ERC721 = 0x80ac58cd;
  /*
   * 0x80ac58cd ===
   *   bytes4(keccak256('balanceOf(address)')) ^
   *   bytes4(keccak256('ownerOf(uint256)')) ^
   *   bytes4(keccak256('approve(address,uint256)')) ^
   *   bytes4(keccak256('getApproved(uint256)')) ^
   *   bytes4(keccak256('setApprovalForAll(address,bool)')) ^
   *   bytes4(keccak256('isApprovedForAll(address,address)')) ^
   *   bytes4(keccak256('transferFrom(address,address,uint256)')) ^
   *   bytes4(keccak256('safeTransferFrom(address,address,uint256)')) ^
   *   bytes4(keccak256('safeTransferFrom(address,address,uint256,bytes)'))
   */

  bytes4 internal constant InterfaceId_ERC721Exists = 0x4f558e79;
  /*
   * 0x4f558e79 ===
   *   bytes4(keccak256('exists(uint256)'))
   */

  bytes4 internal constant InterfaceId_ERC721Enumerable = 0x780e9d63;
  /**
   * 0x780e9d63 ===
   *   bytes4(keccak256('totalSupply()')) ^
   *   bytes4(keccak256('tokenOfOwnerByIndex(address,uint256)')) ^
   *   bytes4(keccak256('tokenByIndex(uint256)'))
   */

  bytes4 internal constant InterfaceId_ERC721Metadata = 0x5b5e139f;
  /**
   * 0x5b5e139f ===
   *   bytes4(keccak256('name()')) ^
   *   bytes4(keccak256('symbol()')) ^
   *   bytes4(keccak256('tokenURI(uint256)'))
   */

  event Transfer(
    address indexed _from,
    address indexed _to,
    uint256 indexed _tokenId
  );
  event Approval(
    address indexed _owner,
    address indexed _approved,
    uint256 indexed _tokenId
  );
  event ApprovalForAll(
    address indexed _owner,
    address indexed _operator,
    bool _approved
  );

  function balanceOf(address _owner) public view returns (uint256 _balance);
  function ownerOf(uint256 _tokenId) public view returns (address _owner);
  function exists(uint256 _tokenId) public view returns (bool _exists);

  function approve(address _to, uint256 _tokenId) public;
  function getApproved(uint256 _tokenId)
    public view returns (address _operator);

  function setApprovalForAll(address _operator, bool _approved) public;
  function isApprovedForAll(address _owner, address _operator)
    public view returns (bool);

  function transferFrom(address _from, address _to, uint256 _tokenId) public;
  function safeTransferFrom(address _from, address _to, uint256 _tokenId)
    public;

  function safeTransferFrom(
    address _from,
    address _to,
    uint256 _tokenId,
    bytes _data
  )
    public;
}</span>


<span class="marker" id="mapping-14"></span><span class="token upd" id="move-src-14" data-title="source_file/comment"><span class="cupd">/</span>/<span class="cupd"> </span>De<span class="cupd">p</span>endency<span class="cupd"> </span>file: openzeppelin-<span class="cupd">solidity</span>/contracts/token/ERC7<span class="cupd">2</span>1/ERC721.sol</span>

<span class="marker" id="mapping-15"></span><span class="token upd" id="move-src-15" data-title="source_file/comment"><span class="cupd">//</span><span class="cupd"> </span>p<span class="cupd">ra</span>gm<span class="cupd">a</span> <span class="cupd">s</span><span class="cupd">o</span>l<span class="cupd">i</span>di<span class="cupd">ty</span> ^0.4.24;</span>

<span class="marker" id="mapping-16"></span><span class="token upd" id="move-src-16" data-title="source_file/comment"><span class="cupd">/</span>/<span class="cupd"> </span>im<span class="cupd">p</span>o<span class="cupd">r</span>t<span class="cupd"> </span>"openzeppelin-<span class="cupd">solidity</span>/contracts/token/ERC7<span class="cupd">2</span>1/ERC721Basic.sol";</span>


<span class="marker" id="mapping-17"></span><span class="token mv" id="move-src-17" data-title="source_file/comment">/**
 * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension
 * @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md
 */</span>
<span class="marker" id="mapping-18"></span><span class="token mv" id="move-src-18" data-title="source_file/contract_declaration">contract ERC721Enumerable is ERC721Basic {
  function totalSupply() public view returns (uint256);
  function tokenOfOwnerByIndex(
    address _owner,
    uint256 _index
  )
    public
    view
    returns (uint256 _tokenId);

  function tokenByIndex(uint256 _index) public view returns (uint256);
}</span>


<span class="marker" id="mapping-19"></span><span class="token mv" id="move-src-19" data-title="source_file/comment">/**
 * @title ERC-721 Non-Fungible Token Standard, optional metadata extension
 * @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md
 */</span>
<span class="marker" id="mapping-20"></span><span class="token mv" id="move-src-20" data-title="source_file/contract_declaration">contract ERC721Metadata is ERC721Basic {
  function name() external view returns (string _name);
  function symbol() external view returns (string _symbol);
  function tokenURI(uint256 _tokenId) public view returns (string);
}</span>


<span class="marker" id="mapping-21"></span><span class="token mv" id="move-src-21" data-title="source_file/comment">/**
 * @title ERC-721 Non-Fungible Token Standard, full implementation interface
 * @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md
 */</span>
<span class="marker" id="mapping-22"></span><span class="token mv" id="move-src-22" data-title="source_file/contract_declaration">contract ERC721 is ERC721Basic, ERC721Enumerable, ERC721Metadata {
}</span>


<span class="marker" id="mapping-23"></span><span class="token upd" id="move-src-23" data-title="source_file/comment"><span class="cupd">//</span><span class="cupd"> </span>Dependen<span class="cupd">c</span>y file: <span class="cupd">o</span>pe<span class="cupd">n</span>zeppelin<span class="cupd">-</span>solidity/<span class="cupd">contracts/</span>i<span class="cupd">ntr</span>ospe<span class="cupd">ct</span>ion<span class="cupd">/</span><span class="cupd">S</span><span class="cupd">u</span>ppor<span class="cupd">t</span>sInterfaceWit<span class="cupd">h</span>Lookup<span class="cupd">.sol</span></span>

<span class="marker" id="mapping-24"></span><span class="token upd" id="move-src-24" data-title="source_file/comment"><span class="cupd">/</span>/<span class="cupd"> pragma solidity ^0.4.24;</span></span>

<span class="marker" id="mapping-25"></span><span class="token upd" id="move-src-25" data-title="source_file/comment"><span class="cupd">/</span>/<span class="cupd"> import </span>"openzeppel<span class="cupd">in</span>-solidi<span class="cupd">t</span>y/cont<span class="cupd">r</span><span class="cupd">ac</span>t<span class="cupd">s/</span>in<span class="cupd">t</span><span class="cupd">r</span>ospec<span class="cupd">t</span>ion/ERC165<span class="cupd">.sol</span>";</span>


<span class="marker" id="mapping-26"></span><span class="token upd" id="move-src-26" data-title="source_file/comment"><span class="cupd">/**
 * @title</span><span class="cupd"> </span><span class="cupd">S</span>up<span class="cupd">p</span><span class="cupd">o</span><span class="cupd">r</span><span class="cupd">t</span>sIn<span class="cupd">t</span><span class="cupd">e</span>rf<span class="cupd">ac</span>e<span class="cupd">W</span><span class="cupd">i</span><span class="cupd">t</span>h<span class="cupd">L</span>oo<span class="cupd">k</span>u<span class="cupd">p
 </span>* <span class="cupd">@a</span><span class="cupd">u</span><span class="cupd">th</span><span class="cupd">o</span>r <span class="cupd">M</span><span class="cupd">a</span><span class="cupd">t</span>t<span class="cupd"> </span>C<span class="cupd">o</span>ndo<span class="cupd">n</span> (<span class="cupd">@</span>shr<span class="cupd">ugs</span><span class="cupd">)</span>
 *<span class="cupd"> </span><span class="cupd">@</span>dev I<span class="cupd">m</span>pleme<span class="cupd">n</span>ts ERC<span class="cupd">1</span>6<span class="cupd">5</span> usi<span class="cupd">n</span><span class="cupd">g</span> <span class="cupd">a</span> lookup t<span class="cupd">a</span><span class="cupd">ble.</span>
 */</span>
<span class="marker" id="mapping-27"></span><span class="token mv" id="move-src-27" data-title="source_file/contract_declaration">contract SupportsInterfaceWithLookup is ERC165 {

  bytes4 public constant InterfaceId_ERC165 = 0x01ffc9a7;
  /**
   * 0x01ffc9a7 ===
   *   bytes4(keccak256('supportsInterface(bytes4)'))
   */

  /**
   * @dev a mapping of interface id to whether or not it's supported
   */
  mapping(bytes4 =&gt; bool) internal supportedInterfaces;

  /**
   * @dev A contract implementing SupportsInterfaceWithLookup
   * implement ERC165 itself
   */
  constructor()
    public
  {
    _registerInterface(InterfaceId_ERC165);
  }

  /**
   * @dev implement supportsInterface(bytes4) using a lookup table
   */
  function supportsInterface(bytes4 _interfaceId)
    external
    view
    returns (bool)
  {
    return supportedInterfaces[_interfaceId];
  }

  /**
   * @dev private method for registering an interface
   */
  function _registerInterface(bytes4 _interfaceId)
    internal
  {
    require(_interfaceId != 0xffffffff);
    supportedInterfaces[_interfaceId] = true;
  }
}</span>


<span class="marker" id="mapping-28"></span><span class="token upd" id="move-src-28" data-title="source_file/comment"><span class="cupd">//</span><span class="cupd"> </span>D<span class="cupd">ep</span><span class="cupd">e</span><span class="cupd">n</span>dency file: @ev<span class="cupd">ol</span>ut<span class="cupd">i</span>onlan<span class="cupd">d</span><span class="cupd">/co</span>mmo<span class="cupd">n</span>/con<span class="cupd">tracts/int</span><span class="cupd">e</span>rfa<span class="cupd">c</span>es/IM<span class="cupd">i</span><span class="cupd">n</span>table<span class="cupd">ERC</span>20<span class="cupd">.sol</span></span>

<span class="marker" id="mapping-29"></span><span class="token upd" id="move-src-29" data-title="source_file/comment"><span class="cupd">/</span>/<span class="cupd"> pragma solidity ^0.4.2</span>3;</span>

<span class="marker" id="mapping-30"></span><span class="token mv" id="move-src-30" data-title="source_file/contract_declaration">contract IMintableERC20 {

    function mint(address _to, uint256 _value) public;
}</span>

<span class="marker" id="mapping-31"></span><span class="token upd" id="move-src-31" data-title="source_file/comment"><span class="cupd">/</span>/<span class="cupd"> </span>Dependency<span class="cupd"> </span>f<span class="cupd">i</span><span class="cupd">le</span>:<span class="cupd"> </span><span class="cupd">@</span><span class="cupd">ev</span>olu<span class="cupd">t</span><span class="cupd">i</span>onland/<span class="cupd">com</span><span class="cupd">m</span><span class="cupd">o</span>n<span class="cupd">/</span>contr<span class="cupd">a</span>ct<span class="cupd">s</span>/in<span class="cupd">ter</span>faces<span class="cupd">/</span><span class="cupd">I</span><span class="cupd">S</span><span class="cupd">e</span>tt<span class="cupd">i</span>ngsRegistry.sol</span>

<span class="marker" id="mapping-32"></span><span class="token upd" id="move-src-32" data-title="source_file/comment"><span class="cupd">//</span><span class="cupd"> </span>p<span class="cupd">ra</span>gm<span class="cupd">a</span> <span class="cupd">s</span>ol<span class="cupd">i</span>d<span class="cupd">i</span><span class="cupd">ty</span> ^0.4.24;</span>

<span class="marker" id="mapping-33"></span><span class="token mv" id="move-src-33" data-title="source_file/contract_declaration">contract ISettingsRegistry {
    enum SettingsValueTypes { NONE, UINT, STRING, ADDRESS, BYTES, BOOL, INT }

    function uintOf(bytes32 _propertyName) public view returns (uint256);

    function stringOf(bytes32 _propertyName) public view returns (string);

    function addressOf(bytes32 _propertyName) public view returns (address);

    function bytesOf(bytes32 _propertyName) public view returns (bytes);

    function boolOf(bytes32 _propertyName) public view returns (bool);

    function intOf(bytes32 _propertyName) public view returns (int);

    function setUintProperty(bytes32 _propertyName, uint _value) public;

    function setStringProperty(bytes32 _propertyName, string _value) public;

    function setAddressProperty(bytes32 _propertyName, address _value) public;

    function setBytesProperty(bytes32 _propertyName, bytes _value) public;

    function setBoolProperty(bytes32 _propertyName, bool _value) public;

    function setIntProperty(bytes32 _propertyName, int _value) public;

    function getValueTypeOf(bytes32 _propertyName) public view returns (uint /* SettingsValueTypes */ );

    event ChangeProperty(bytes32 indexed _propertyName, uint256 _type);
}</span>

<span class="marker" id="mapping-34"></span><span class="token upd" id="move-src-34" data-title="source_file/comment"><span class="cupd">/</span>/<span class="cupd"> </span>De<span class="cupd">p</span>endency<span class="cupd"> </span>file: @ev<span class="cupd">ol</span>ut<span class="cupd">i</span>onlan<span class="cupd">d</span>/common/contracts/<span class="cupd">i</span>n<span class="cupd">t</span>erfaces/IAuthorit<span class="cupd">y</span>.sol</span>

<span class="marker" id="mapping-35"></span><span class="token upd" id="move-src-35" data-title="source_file/comment"><span class="cupd">/</span>/<span class="cupd"> </span><span class="cupd">p</span><span class="cupd">r</span>agma<span class="cupd"> </span><span class="cupd">solidity</span> ^0<span class="cupd">.</span>4.24;</span>

<span class="marker" id="mapping-36"></span><span class="token mv" id="move-src-36" data-title="source_file/contract_declaration">contract IAuthority {
    function canCall(
        address src, address dst, bytes4 sig
    ) public view returns (bool);
}</span>

<span class="marker" id="mapping-37"></span><span class="token upd" id="move-src-37" data-title="source_file/comment"><span class="cupd">//</span><span class="cupd"> </span>Dependency fi<span class="cupd">l</span>e: @evolut<span class="cupd">i</span>onland<span class="cupd">/common</span><span class="cupd">/contracts/</span>DSAu<span class="cupd">t</span>h<span class="cupd">.sol</span></span>

<span class="marker" id="mapping-38"></span><span class="token upd" id="move-src-38" data-title="source_file/comment"><span class="cupd">/</span>/<span class="cupd"> pragma solidity ^0.4.24;</span></span>

<span class="marker" id="mapping-39"></span><span class="token upd" id="move-src-39" data-title="source_file/comment"><span class="cupd">//</span><span class="cupd"> </span><span class="cupd">i</span>mport '<span class="cupd">/</span>Users/e<span class="cupd">c</span>h<span class="cupd">o</span>/w<span class="cupd">o</span>rkspa<span class="cupd">c</span>e/c<span class="cupd">ontract</span>/evolutionlandorg/land/node_module<span class="cupd">s/</span>@evolutionland/<span class="cupd">co</span>mmo<span class="cupd">n</span>/con<span class="cupd">tracts/interfaces/I</span>Autho<span class="cupd">r</span>i<span class="cupd">t</span>y<span class="cupd">.sol</span>';</span>

<span class="marker" id="mapping-40"></span><span class="token mv" id="move-src-40" data-title="source_file/contract_declaration">contract DSAuthEvents {
    event LogSetAuthority (address indexed authority);
    event LogSetOwner     (address indexed owner);
}</span>

<span class="marker" id="mapping-41"></span><span class="token upd" id="move-src-41" data-title="source_file/comment"><span class="cupd">/*</span>*<span class="cupd"></span>
 * @title DSAuth
 * @dev The DSAuth co<span class="cupd">nt</span>ract is reference implement of https:<span class="cupd">/</span>/github.<span class="cupd">c</span>om<span class="cupd">/</span>dapphub/ds-au<span class="cupd">t</span>h
 * But in th<span class="cupd">e</span> isA<span class="cupd">u</span>t<span class="cupd">h</span>or<span class="cupd">i</span>zed method, the src from address<span class="cupd">(</span>this) is remove for <span class="cupd">saf</span>ty conc<span class="cupd">e</span><span class="cupd">r</span>n<span class="cupd">.</span>
 */</span>
<span class="marker" id="mapping-42"></span><span class="token mv" id="move-src-42" data-title="source_file/contract_declaration">contract DSAuth is DSAuthEvents {
    IAuthority   public  authority;
    address      public  owner;

    constructor() public {
        owner = msg.sender;
        emit LogSetOwner(msg.sender);
    }

    function setOwner(address owner_)
        public
        auth
    {
        owner = owner_;
        emit LogSetOwner(owner);
    }

    function setAuthority(IAuthority authority_)
        public
        auth
    {
        authority = authority_;
        emit LogSetAuthority(authority);
    }

    modifier auth {
        require(isAuthorized(msg.sender, msg.sig));
        _;
    }

    modifier onlyOwner() {
        require(msg.sender == owner);
        _;
    }

    function isAuthorized(address src, bytes4 sig) internal view returns (bool) {
        if (src == owner) {
            return true;
        } else if (authority == IAuthority(0)) {
            return false;
        } else {
            return authority.canCall(src, this, sig);
        }
    }
}</span>


<span class="marker" id="mapping-43"></span><span class="token upd" id="move-src-43" data-title="source_file/comment"><span class="cupd">/</span>/<span class="cupd"> </span>De<span class="cupd">p</span><span class="cupd">en</span>d<span class="cupd">e</span>ncy fil<span class="cupd">e</span>: @evo<span class="cupd">l</span>ut<span class="cupd">i</span><span class="cupd">o</span>n<span class="cupd">l</span>an<span class="cupd">d</span><span class="cupd">/co</span>mmo<span class="cupd">n</span>/con<span class="cupd">tracts/int</span>e<span class="cupd">r</span>face<span class="cupd">s</span>/IInt<span class="cupd">e</span>rs<span class="cupd">t</span>ellar<span class="cupd">E</span>ncoder<span class="cupd">.sol</span></span>

<span class="marker" id="mapping-44"></span><span class="token upd" id="move-src-44" data-title="source_file/comment"><span class="cupd">//</span><span class="cupd"> </span>p<span class="cupd">ra</span>gm<span class="cupd">a</span> <span class="cupd">s</span>ol<span class="cupd">i</span>d<span class="cupd">i</span><span class="cupd">t</span>y ^<span class="cupd">0.</span>4.24;</span>

<span class="marker" id="mapping-45"></span><span class="token mv" id="move-src-45" data-title="source_file/contract_declaration">contract IInterstellarEncoder {
    uint256 constant CLEAR_HIGH =  0x00000000000000000000000000000000ffffffffffffffffffffffffffffffff;

    uint256 public constant MAGIC_NUMBER = 42;    // Interstellar Encoding Magic Number.
    uint256 public constant CHAIN_ID = 1; // Ethereum mainet.
    uint256 public constant CURRENT_LAND = 1; // 1 is Atlantis, 0 is NaN.

    enum ObjectClass { 
        NaN,
        LAND,
        APOSTLE,
        OBJECT_CLASS_COUNT
    }

    function registerNewObjectClass(address _objectContract, uint8 objectClass) public;

    function registerNewTokenContract(address _tokenAddress) public;

    function encodeTokenId(address _tokenAddress, uint8 _objectClass, uint128 _objectIndex) public view returns (uint256 _tokenId);

    function encodeTokenIdForObjectContract(
        address _tokenAddress, address _objectContract, uint128 _objectId) public view returns (uint256 _tokenId);

    function getContractAddress(uint256 _tokenId) public view returns (address);

    function getObjectId(uint256 _tokenId) public view returns (uint128 _objectId);

    function getObjectClass(uint256 _tokenId) public view returns (uint8);

    function getObjectAddress(uint256 _tokenId) public view returns (address);
}</span>

<span class="marker" id="mapping-46"></span><span class="token upd" id="move-src-46" data-title="source_file/comment"><span class="cupd">/</span>/<span class="cupd"> </span>De<span class="cupd">p</span>endency<span class="cupd"> </span>file: @ev<span class="cupd">ol</span>ut<span class="cupd">i</span>onlan<span class="cupd">d</span>/common/contracts/<span class="cupd">i</span>n<span class="cupd">t</span>erfaces/ITokenUse.sol</span>

<span class="marker" id="mapping-47"></span><span class="token upd" id="move-src-47" data-title="source_file/comment"><span class="cupd">//</span><span class="cupd"> </span>p<span class="cupd">ra</span>gm<span class="cupd">a</span> <span class="cupd">s</span>ol<span class="cupd">i</span>d<span class="cupd">i</span><span class="cupd">t</span><span class="cupd">y</span> ^0.4.24;</span>

<span class="marker" id="mapping-48"></span><span class="token mv" id="move-src-48" data-title="source_file/contract_declaration">contract ITokenUse {
    uint48 public constant MAX_UINT48_TIME = 281474976710655;

    function isObjectInHireStage(uint256 _tokenId) public view returns (bool);

    function isObjectReadyToUse(uint256 _tokenId) public view returns (bool);

    function getTokenUser(uint256 _tokenId) public view returns (address);

    function createTokenUseOffer(uint256 _tokenId, uint256 _duration, uint256 _price, address _acceptedActivity) public;

    function cancelTokenUseOffer(uint256 _tokenId) public;

    function takeTokenUseOffer(uint256 _tokenId) public;

    function addActivity(uint256 _tokenId, address _user, uint256 _endTime) public;

    function removeActivity(uint256 _tokenId, address _user) public;
}</span>

<span class="marker" id="mapping-49"></span><span class="token upd" id="move-src-49" data-title="source_file/comment"><span class="cupd">/</span>/<span class="cupd"> </span>De<span class="cupd">p</span>endency<span class="cupd"> </span>file: @ev<span class="cupd">ol</span>ut<span class="cupd">i</span>onlan<span class="cupd">d</span>/common/contracts/<span class="cupd">i</span>n<span class="cupd">t</span>erfaces/IActivit<span class="cupd">y</span>.sol</span>

<span class="marker" id="mapping-50"></span><span class="token upd" id="move-src-50" data-title="source_file/comment"><span class="cupd">//</span><span class="cupd"> </span>p<span class="cupd">ra</span>gm<span class="cupd">a</span> <span class="cupd">s</span>ol<span class="cupd">i</span>di<span class="cupd">t</span>y ^0.4.24;</span>

<span class="marker" id="mapping-51"></span><span class="token upd" id="move-src-51" data-title="source_file/comment"><span class="cupd">/</span>/<span class="cupd"> </span>im<span class="cupd">p</span>o<span class="cupd">r</span>t<span class="cupd"> </span>"openzeppelin-<span class="cupd">solidity</span>/contracts/introspection/ERC165<span class="cupd">.</span>sol";</span>

<span class="marker" id="mapping-52"></span><span class="token mv" id="move-src-52" data-title="source_file/contract_declaration">contract IActivity is ERC165 {
    bytes4 internal constant InterfaceId_IActivity = 0x6086e7f8; 
    /*
     * 0x6086e7f8 ===
     *   bytes4(keccak256('activityStopped(uint256)'))
     */

    function activityStopped(uint256 _tokenId) public;
}</span>

<span class="marker" id="mapping-53"></span><span class="token upd" id="move-src-53" data-title="source_file/comment"><span class="cupd">//</span><span class="cupd"> </span>D<span class="cupd">ep</span><span class="cupd">e</span><span class="cupd">n</span>dency file: @ev<span class="cupd">ol</span>ut<span class="cupd">i</span>onlan<span class="cupd">d</span><span class="cupd">/co</span>mmo<span class="cupd">n</span>/con<span class="cupd">tracts/int</span><span class="cupd">e</span><span class="cupd">r</span>face<span class="cupd">s</span>/<span class="cupd">I</span>Mi<span class="cupd">n</span><span class="cupd">er</span>Obj<span class="cupd">e</span>c<span class="cupd">t</span><span class="cupd">.sol</span></span>

<span class="marker" id="mapping-54"></span><span class="token upd" id="move-src-54" data-title="source_file/comment"><span class="cupd">/</span>/<span class="cupd"> pragma solidity ^0.4.24;</span></span>

<span class="marker" id="mapping-55"></span><span class="token upd" id="move-src-55" data-title="source_file/comment"><span class="cupd">/</span>/<span class="cupd"> import "</span>openzeppelin-solidity<span class="cupd">/</span>contracts/introspection/<span class="cupd">ERC165.sol";</span></span>

<span class="marker" id="mapping-56"></span><span class="token mv" id="move-src-56" data-title="source_file/contract_declaration">contract IMinerObject is ERC165  {
    bytes4 internal constant InterfaceId_IMinerObject = 0x64272b75;
    
    /*
     * 0x64272b752 ===
     *   bytes4(keccak256('strengthOf(uint256,address)'))
     */

    function strengthOf(uint256 _tokenId, address _resourceToken, uint256 _landTokenId) public view returns (uint256);

}</span>

<span class="marker" id="mapping-57"></span><span class="token upd" id="move-src-57" data-title="source_file/comment"><span class="cupd">/</span>/<span class="cupd"> </span>Dependency<span class="cupd"> </span>f<span class="cupd">i</span><span class="cupd">le</span>:<span class="cupd"> </span>c<span class="cupd">o</span>nt<span class="cupd">r</span>ac<span class="cupd">ts</span>/i<span class="cupd">nterface</span>s/I<span class="cupd">L</span><span class="cupd">a</span><span class="cupd">nd</span>Ba<span class="cupd">s</span><span class="cupd">e</span>.<span class="cupd">s</span><span class="cupd">o</span>l</span>

<span class="marker" id="mapping-58"></span><span class="token upd" id="move-src-58" data-title="source_file/comment"><span class="cupd">//</span><span class="cupd"> </span><span class="cupd">p</span>ragma <span class="cupd">solidity</span> ^0.4.24;</span>

<span class="marker" id="mapping-59"></span><span class="token mv" id="move-src-59" data-title="source_file/contract_declaration">contract ILandBase {

    /*
     *  Event
     */
    event ModifiedResourceRate(uint indexed tokenId, address resourceToken, uint16 newResourceRate);
    event HasboxSetted(uint indexed tokenId, bool hasBox);

    event ChangedReourceRateAttr(uint indexed tokenId, uint256 attr);

    event ChangedFlagMask(uint indexed tokenId, uint256 newFlagMask);

    event CreatedNewLand(uint indexed tokenId, int x, int y, address beneficiary, uint256 resourceRateAttr, uint256 mask);

    function defineResouceTokenRateAttrId(address _resourceToken, uint8 _attrId) public;

    function setHasBox(uint _landTokenID, bool isHasBox) public;
    function isReserved(uint256 _tokenId) public view returns (bool);
    function isSpecial(uint256 _tokenId) public view returns (bool);
    function isHasBox(uint256 _tokenId) public view returns (bool);

    function getResourceRateAttr(uint _landTokenId) public view returns (uint256);
    function setResourceRateAttr(uint _landTokenId, uint256 _newResourceRateAttr) public;

    function getResourceRate(uint _landTokenId, address _resouceToken) public view returns (uint16);
    function setResourceRate(uint _landTokenID, address _resourceToken, uint16 _newResouceRate) public;

    function getFlagMask(uint _landTokenId) public view returns (uint256);

    function setFlagMask(uint _landTokenId, uint256 _newFlagMask) public;

    <span class="marker" id="mapping-60"></span><span class="token mv" id="move-src-60" data-title="contract_body/function_definition">function resourceToken2RateAttrId(address _resourceToken) external view returns (uint256);</span>
}</span>


<span class="marker" id="mapping-61"></span><span class="token upd" id="move-src-61" data-title="source_file/comment"><span class="cupd">/</span>/<span class="cupd"> </span>De<span class="cupd">p</span>endency file: cont<span class="cupd">ra</span>ct<span class="cupd">s</span>/<span class="cupd">i</span>n<span class="cupd">t</span>erfaces/IMetaDataTeller.sol</span>

<span class="marker" id="mapping-62"></span><span class="token upd" id="move-src-62" data-title="source_file/comment"><span class="cupd">//</span><span class="cupd"> </span><span class="cupd">p</span>ragma <span class="cupd">solidity</span> ^0.4.24;</span>

<span class="marker" id="mapping-63"></span><span class="token mv" id="move-src-63" data-title="source_file/interface_declaration">interface IMetaDataTeller {
	function addTokenMeta(
		address _token,
		uint16 _grade,
		uint112 _strengthRate
	) external;

	//0xf666196d
	function getMetaData(address _token, uint256 _id)
		external
		view
		returns (
			uint16,
			uint16,
			uint16
		);

	//0x7999a5cf
	function getPrefer(address _token) external view returns (uint256);

	//0x33281815
	function getRate(
		address _token,
		uint256 _id,
		uint256 _index
	) external view returns (uint256);
}</span>


<span class="marker" id="mapping-64"></span><span class="token upd" id="move-src-64" data-title="source_file/comment"><span class="cupd">/</span>/<span class="cupd"> </span>Root file: cont<span class="cupd">ra</span>cts/L<span class="cupd">a</span>ndRe<span class="cupd">so</span>urceV5.sol</span>

<span class="marker" id="mapping-65"></span><span class="token mv" id="move-src-65" data-title="source_file/pragma_directive">pragma solidity<span class="marker" id="mapping-66"></span><span class="token del" data-title="solidity_pragma_token/solidity_version_comparison_operator"> ^</span>0.4.24;</span>

<span class="marker" id="mapping-67"></span><span class="token upd" id="move-src-66" data-title="source_file/comment"><span class="cupd">/</span>/<span class="cupd"> import "</span><span class="cupd">o</span><span class="cupd">pe</span>nzeppel<span class="cupd">i</span>n-s<span class="cupd">o</span>lidity/co<span class="cupd">n</span>tracts<span class="cupd">/</span>math/SafeMath<span class="cupd">.sol";</span></span>
<span class="marker" id="mapping-68"></span><span class="token upd" id="move-src-67" data-title="source_file/comment"><span class="cupd">//</span><span class="cupd"> </span><span class="cupd">i</span>mport "open<span class="cupd">zeppelin-solidity/contracts/token/ERC721/ERC721.sol</span>";</span>
<span class="marker" id="mapping-69"></span><span class="token upd" id="move-src-68" data-title="source_file/comment"><span class="cupd">/</span>/<span class="cupd"> </span>im<span class="cupd">p</span>o<span class="cupd">r</span>t<span class="cupd"> </span>"openzeppelin-<span class="cupd">solidity</span>/contracts/introspection/SupportsInterfaceWithLookup<span class="cupd">.</span>sol";</span>
<span class="marker" id="mapping-70"></span><span class="token upd" id="move-src-69" data-title="source_file/comment"><span class="cupd">/</span>/<span class="cupd"> import "</span>@evolutionland<span class="cupd">/</span>common/contr<span class="cupd">a</span>ct<span class="cupd">s</span>/<span class="cupd">i</span>nterfa<span class="cupd">c</span>es/IMintableERC20<span class="cupd">.sol";</span></span>
<span class="marker" id="mapping-71"></span><span class="token upd" id="move-src-70" data-title="source_file/comment"><span class="cupd">//</span> import "@evolutionland<span class="cupd">/</span>common<span class="cupd">/</span><span class="cupd">contracts/</span>interf<span class="cupd">a</span>ces/ISetti<span class="cupd">n</span>gs<span class="cupd">Re</span>gi<span class="cupd">s</span>t<span class="cupd">r</span>y<span class="cupd">.sol</span>";</span>
<span class="marker" id="mapping-72"></span><span class="token upd" id="move-src-71" data-title="source_file/comment"><span class="cupd">/</span>/<span class="cupd"> </span>im<span class="cupd">p</span>o<span class="cupd">r</span>t<span class="cupd"> </span>"@ev<span class="cupd">ol</span>ut<span class="cupd">i</span>onlan<span class="cupd">d</span>/common/con<span class="cupd">t</span>racts/DSAuth<span class="cupd">.</span>sol";</span>
<span class="marker" id="mapping-73"></span><span class="token upd" id="move-src-72" data-title="source_file/comment"><span class="cupd">/</span>/<span class="cupd"> import "</span>@<span class="cupd">e</span>vo<span class="cupd">l</span>ut<span class="cupd">i</span><span class="cupd">o</span>n<span class="cupd">l</span>an<span class="cupd">d</span><span class="cupd">/co</span>mmo<span class="cupd">n</span>/con<span class="cupd">tracts/</span>in<span class="cupd">t</span><span class="cupd">e</span>rf<span class="cupd">a</span>ces/IIn<span class="cupd">t</span>erstellarEncoder<span class="cupd">.sol";</span></span>
<span class="marker" id="mapping-74"></span><span class="token upd" id="move-src-73" data-title="source_file/comment"><span class="cupd">/</span>/<span class="cupd"> import "</span>@<span class="cupd">e</span>vo<span class="cupd">l</span>ut<span class="cupd">i</span><span class="cupd">o</span>n<span class="cupd">l</span>an<span class="cupd">d</span><span class="cupd">/co</span>mmo<span class="cupd">n</span>/con<span class="cupd">tracts/</span>in<span class="cupd">t</span>erfaces/IT<span class="cupd">oken</span>Use<span class="cupd">.sol";</span></span>
<span class="marker" id="mapping-75"></span><span class="token upd" id="move-src-74" data-title="source_file/comment"><span class="cupd">/</span>/<span class="cupd"> import "</span>@<span class="cupd">e</span>vo<span class="cupd">l</span>ut<span class="cupd">i</span><span class="cupd">o</span>n<span class="cupd">l</span>an<span class="cupd">d</span><span class="cupd">/co</span>mmo<span class="cupd">n</span>/con<span class="cupd">tracts/int</span><span class="cupd">e</span><span class="cupd">r</span><span class="cupd">face</span>s/IAct<span class="cupd">i</span>vi<span class="cupd">t</span>y<span class="cupd">.sol";</span></span>
<span class="marker" id="mapping-76"></span><span class="token upd" id="move-src-75" data-title="source_file/comment"><span class="cupd">/</span>/<span class="cupd"> import "@evolutionland/common/contracts/interfaces/IMin</span>erO<span class="cupd">b</span>j<span class="cupd">e</span>ct<span class="cupd">.sol";</span></span>
<span class="marker" id="mapping-77"></span><span class="token upd" id="move-src-76" data-title="source_file/comment"><span class="cupd">/</span>/<span class="cupd"> import "</span><span class="cupd">co</span><span class="cupd">n</span><span class="cupd">tracts/interfaces/I</span>La<span class="cupd">n</span>dBa<span class="cupd">s</span><span class="cupd">e</span><span class="cupd">.sol";</span></span>
<span class="marker" id="mapping-78"></span><span class="token upd" id="move-src-77" data-title="source_file/comment"><span class="cupd">/</span>/<span class="cupd"> import "</span>c<span class="cupd">o</span><span class="cupd">n</span>tr<span class="cupd">a</span><span class="cupd">c</span>ts<span class="cupd">/</span>i<span class="cupd">nt</span>e<span class="cupd">r</span>f<span class="cupd">ac</span>e<span class="cupd">s/</span>IMeta<span class="cupd">D</span>a<span class="cupd">t</span>aTeller<span class="cupd">.sol";</span></span>

contract <span class="marker" id="mapping-79"></span><span class="token upd" id="move-src-78" data-title="contract_declaration/identifier"><span class="cupd">LandResourceV</span>5</span> is SupportsInterfaceWithLookup, DSAuth, IActivity {
	using SafeMath for *;

	// For every seconds, the speed will decrease by current speed multiplying (DENOMINATOR_in_seconds - seconds) / DENOMINATOR_in_seconds
	// resource will decrease 1/10000 every day.
	uint256 public constant DENOMINATOR = 10000;

	uint256 public constant TOTAL_SECONDS = DENOMINATOR * (1 days);

	bool private singletonLock = false;

	ISettingsRegistry public registry;

	uint256 public resourceReleaseStartTime;

	// TODO: move to global settings contract.
	uint256 public attenPerDay = 1;
	uint256 public recoverAttenPerDay = 20;

	// Struct for recording resouces on land which have already been pinged.
	// 金, Evolution Land Gold
	// 木, Evolution Land Wood
	// 水, Evolution Land Water
	// 火, Evolution Land fire
	// 土, Evolution Land Silicon
	struct ResourceMineState {
		mapping(address =&gt; uint256) mintedBalance;
		mapping(address =&gt; uint256[]) miners;
		mapping(address =&gt; uint256) totalMinerStrength;
		uint256 lastUpdateSpeedInSeconds;
		uint256 lastDestoryAttenInSeconds;
		uint256 industryIndex;
		uint128 lastUpdateTime;
		uint64 totalMiners;
		uint64 maxMiners;
	}

	struct MinerStatus {
		uint256 landTokenId;
		address resource;
		uint64 indexInResource;
	}

	mapping(uint256 =&gt; ResourceMineState) public land2ResourceMineState;
	mapping(uint256 =&gt; MinerStatus) public miner2Index;

	/*
	 *  Event
	 */

	event StartMining(
		uint256 minerTokenId,
		uint256 landId,
		address _resource,
		uint256 strength
	);
	event StopMining(
		uint256 minerTokenId,
		uint256 landId,
		address _resource,
		uint256 strength
	);
	event ResourceClaimed(
		address owner,
		uint256 landTokenId,
		uint256 goldBalance,
		uint256 woodBalance,
		uint256 waterBalance,
		uint256 fireBalance,
		uint256 soilBalance
	);
	event UpdateMiningStrengthWhenStop(
		uint256 apostleTokenId,
		uint256 landId,
		uint256 strength
	);
	event UpdateMiningStrengthWhenStart(
		uint256 apostleTokenId,
		uint256 landId,
		uint256 strength
	);

	// v5 add begin
	event StartBarMining(
		uint256 barIndex,
		uint256 landId,
		address resource,
		uint256 rate
	);
	event StopBarMining(uint256 barIndex, uint256 landId, address rate);
	event LandResourceClaimed(
		address owner,
		uint256 landId,
		uint256 goldBalance,
		uint256 woodBalance,
		uint256 waterBalance,
		uint256 fireBalance,
		uint256 soilBalance
	);
	event ItemResourceClaimed(
		address owner,
		address itemToken,
		uint256 itemTokenId,
		uint256 goldBalance,
		uint256 woodBalance,
		uint256 waterBalance,
		uint256 fireBalance,
		uint256 soilBalance
	);

	// land item bar
	event Equip(
		uint256 indexed tokenId,
		address resource,
		uint256 index,
		address staker,
		address token,
		uint256 id
	);
	event Divest(
		uint256 indexed tokenId,
		address resource,
		uint256 index,
		address staker,
		address token,
		uint256 id
	);

	// 0x434f4e54524143545f4c414e445f424153450000000000000000000000000000
	bytes32 public constant CONTRACT_LAND_BASE = "CONTRACT_LAND_BASE";

	// 0x434f4e54524143545f474f4c445f45524332305f544f4b454e00000000000000
	bytes32 public constant CONTRACT_GOLD_ERC20_TOKEN =
		"CONTRACT_GOLD_ERC20_TOKEN";

	// 0x434f4e54524143545f574f4f445f45524332305f544f4b454e00000000000000
	bytes32 public constant CONTRACT_WOOD_ERC20_TOKEN =
		"CONTRACT_WOOD_ERC20_TOKEN";

	// 0x434f4e54524143545f57415445525f45524332305f544f4b454e000000000000
	bytes32 public constant CONTRACT_WATER_ERC20_TOKEN =
		"CONTRACT_WATER_ERC20_TOKEN";

	// 0x434f4e54524143545f464952455f45524332305f544f4b454e00000000000000
	bytes32 public constant CONTRACT_FIRE_ERC20_TOKEN =
		"CONTRACT_FIRE_ERC20_TOKEN";

	// 0x434f4e54524143545f534f494c5f45524332305f544f4b454e00000000000000
	bytes32 public constant CONTRACT_SOIL_ERC20_TOKEN =
		"CONTRACT_SOIL_ERC20_TOKEN";

	// 0x434f4e54524143545f494e5445525354454c4c41525f454e434f444552000000
	bytes32 public constant CONTRACT_INTERSTELLAR_ENCODER =
		"CONTRACT_INTERSTELLAR_ENCODER";

	// 0x434f4e54524143545f4f424a4543545f4f574e45525348495000000000000000
	bytes32 public constant CONTRACT_OBJECT_OWNERSHIP =
		"CONTRACT_OBJECT_OWNERSHIP";

	// 0x434f4e54524143545f544f4b454e5f5553450000000000000000000000000000
	bytes32 public constant CONTRACT_TOKEN_USE = "CONTRACT_TOKEN_USE";

	//0x4655524e4143455f4954454d5f4d494e455f4645450000000000000000000000
	bytes32 public constant FURNACE_ITEM_MINE_FEE = "FURNACE_ITEM_MINE_FEE";

	// 0x434f4e54524143545f4d455441444154415f54454c4c45520000000000000000
	bytes32 public constant CONTRACT_METADATA_TELLER =
		"CONTRACT_METADATA_TELLER";

	// 0x55494e545f4954454d4241525f50524f544543545f504552494f440000000000
	bytes32 public constant UINT_ITEMBAR_PROTECT_PERIOD =
		"UINT_ITEMBAR_PROTECT_PERIOD";

	// rate precision
	uint128 public constant RATE_PRECISION = 10**8;

	<span class="marker" id="mapping-80"></span><span class="token mv" id="move-src-79" data-title="contract_body/comment"><span class="marker" id="mapping-81"></span><span class="token upd" id="move-src-80" data-title="contract_body/comment"><span class="cupd">// </span>max <span class="cupd">land </span>miner amounts</span></span>
	uint256 public maxMiners;

	// (itemTokenAddress =&gt; (itemTokenId =&gt; (resourceAddress =&gt; mined balance)))
	mapping(address =&gt; mapping(uint256 =&gt; mapping(address =&gt; uint256)))
		public itemMinedBalance;

	// (landTokenId =&gt; (resourceAddress =&gt; (landBarIndex =&gt; itemEnhancedRate)))
	mapping(uint256 =&gt; mapping(address =&gt; mapping(uint256 =&gt; uint256)))
		public land2BarRate;

	<span class="marker" id="mapping-82"></span><span class="token mv" id="move-src-81" data-title="contract_body/comment"><span class="marker" id="mapping-83"></span><span class="token upd" id="move-src-82" data-title="contract_body/comment"><span class="cupd">// </span>l<span class="cupd">a</span>nd<span class="cupd"> </span>i<span class="cupd">t</span>em bar</span></span>
	struct Bar {
		address staker;    <span class="marker" id="mapping-84"></span><span class="token del" data-title="struct_declaration/comment">// staker who equip item to the land item bar</span>
		address token;     <span class="marker" id="mapping-85"></span><span class="token del" data-title="struct_declaration/comment">// item token address of the item which equpped in the land item bar</span>
		uint256 id;        <span class="marker" id="mapping-86"></span><span class="token del" data-title="struct_declaration/comment">// item token id</span>
		address resource;  <span class="marker" id="mapping-87"></span><span class="token del" data-title="struct_declaration/comment">// which resource staker want to stake</span>
	}

	<span class="marker" id="mapping-88"></span><span class="token mv" id="move-src-83" data-title="contract_body/comment"><span class="marker" id="mapping-89"></span><span class="token upd" id="move-src-84" data-title="contract_body/comment"><span class="cupd">// </span>la<span class="cupd">n</span>d <span class="cupd">it</span><span class="cupd">e</span>m<span class="cupd"> b</span><span class="cupd">a</span><span class="cupd">r</span><span class="cupd"> </span>s<span class="cupd">t</span><span class="cupd">a</span>tus</span></span>
	struct Status {
		address staker;    <span class="marker" id="mapping-90"></span><span class="token del" data-title="struct_declaration/comment">// staker who equip item to the land item bar</span>
		uint256 <span class="marker" id="mapping-91"></span><span class="token upd" id="move-src-85" data-title="struct_member/identifier">landT<span class="cupd">okenId</span></span>; <span class="marker" id="mapping-92"></span><span class="token del" data-title="struct_declaration/comment">// land token id which the item equipped</span>
		uint256 index;     <span class="marker" id="mapping-93"></span><span class="token del" data-title="struct_declaration/comment">// land item bar slot which the item equipped</span>
	}

	// max land bar amount
	uint256 public maxAmount;
	// (landTokenId =&gt; (landBarIndex =&gt; BAR))
	mapping(uint256 =&gt; mapping(uint256 =&gt; Bar)) public landId2Bars;
	// (itemTokenAddress =&gt; (itemTokenId =&gt; STATUS))
	mapping(address =&gt; mapping(uint256 =&gt; Status)) public itemId2Status;
	// (itemTokenAddress =&gt; (itemTokenId =&gt; itemProtectPeriod))
	mapping(address =&gt; mapping(uint256 =&gt; uint256)) public protectPeriod;
	// v5 add end

	/*
	 *  Modifiers
	 */
	modifier singletonLockCall() {
		require(!singletonLock, "Only can call once");
		_;
		singletonLock = true;
	}

	function initializeContract(
		address _registry,
		uint256 _resourceReleaseStartTime
	) public singletonLockCall {
		// Ownable constructor
		owner = msg.sender;
		emit LogSetOwner(msg.sender);

		registry = ISettingsRegistry(_registry);

		resourceReleaseStartTime = _resourceReleaseStartTime;

		_registerInterface(InterfaceId_IActivity);
	}

	// get amount of speed uint at this moment
	function _getReleaseSpeedInSeconds(uint256 _tokenId, uint256 _time)
		internal
		view
		returns (uint256 currentSpeed)
	{
		require(_time &gt;= resourceReleaseStartTime, "Should after release time");
		require(
			_time &gt;= land2ResourceMineState[_tokenId].lastUpdateTime,
			"Should after release last update time"
		);

		// after 10000 days from start
		// the resource release speed decreases to 0
		if (TOTAL_SECONDS &lt; _time - resourceReleaseStartTime) {
			return 0;
		}

		// max amount of speed unit of _tokenId for now
		// suppose that speed_uint = 1 in this function
		uint256 availableSpeedInSeconds =
			TOTAL_SECONDS.sub(_time - resourceReleaseStartTime);
		return availableSpeedInSeconds;
		// // time from last update
		// uint256 timeBetween =
		// 	_time - land2ResourceMineState[_tokenId].lastUpdateTime;

		// // the recover speed is 20/10000, 20 times.
		// // recoveryRate overall from lasUpdateTime til now + amount of speed uint at lastUpdateTime
		// uint256 nextSpeedInSeconds =
		// 	land2ResourceMineState[_tokenId].lastUpdateSpeedInSeconds +
		// 		timeBetween *
		// 		recoverAttenPerDay;
		// // destroyRate overall from lasUpdateTime til now amount of speed uint at lastUpdateTime
		// uint256 destroyedSpeedInSeconds =
		// 	timeBetween *
		// 		land2ResourceMineState[_tokenId].lastDestoryAttenInSeconds;

		// if (nextSpeedInSeconds &lt; destroyedSpeedInSeconds) {
		// 	nextSpeedInSeconds = 0;
		// } else {
		// 	nextSpeedInSeconds = nextSpeedInSeconds - destroyedSpeedInSeconds;
		// }

		// if (nextSpeedInSeconds &gt; availableSpeedInSeconds) {
		// 	nextSpeedInSeconds = availableSpeedInSeconds;
		// }

		// return nextSpeedInSeconds;
	}

	function getReleaseSpeed(
		uint256 _tokenId,
		address _resource,
		uint256 _time
	) public view returns (uint256 currentSpeed) {
		return
			ILandBase(registry.addressOf(CONTRACT_LAND_BASE))
				.getResourceRate(_tokenId, _resource)
				.mul(_getReleaseSpeedInSeconds(_tokenId, _time))
				.mul(1 ether)
				.div(TOTAL_SECONDS);
	}

	function _getMinableBalance(
		uint256 _tokenId,
		address _resource,
		uint256 _currentTime,
		uint256 _lastUpdateTime
	) public view returns (uint256 minableBalance) {
		uint256 speed_in_current_period =
			ILandBase(registry.addressOf(CONTRACT_LAND_BASE))
				.getResourceRate(_tokenId, _resource)
				.mul(
				_getReleaseSpeedInSeconds(
					_tokenId,
					((_currentTime + _lastUpdateTime) / 2)
				)
			)
				.mul(1 ether)
				.div(1 days)
				.div(TOTAL_SECONDS);

		// calculate the area of trapezoid
		minableBalance = speed_in_current_period.mul(
			_currentTime - _lastUpdateTime
		);
	}

	function _getMaxMineBalance(
		uint256 _tokenId,
		address _resource,
		uint256 _currentTime,
		uint256 _lastUpdateTime
	) internal view returns (uint256) {
		// totalMinerStrength is in wei
		return
			getTotalMiningStrength(_tokenId, _resource)
				.mul(_currentTime - _lastUpdateTime)
				.div(1 days);
	}

	function setMaxMiners(uint256 _maxMiners) public auth {
		require(_maxMiners &gt; maxMiners, "Land: INVALID_MAXMINERS");
		maxMiners = _maxMiners;
	}

	function mine(uint256 _landTokenId) public {
		_mineAllResource(
			_landTokenId,
			registry.addressOf(CONTRACT_GOLD_ERC20_TOKEN),
			registry.addressOf(CONTRACT_WOOD_ERC20_TOKEN),
			registry.addressOf(CONTRACT_WATER_ERC20_TOKEN),
			registry.addressOf(CONTRACT_FIRE_ERC20_TOKEN),
			registry.addressOf(CONTRACT_SOIL_ERC20_TOKEN)
		);
	}

	function _mineAllResource(
		uint256 _landTokenId,
		address _gold,
		address _wood,
		address _water,
		address _fire,
		address _soil
	) internal {
		require(
			IInterstellarEncoder(
				registry.addressOf(CONTRACT_INTERSTELLAR_ENCODER)
			)
				.getObjectClass(_landTokenId) == 1,
			"Token must be land."
		);

		// v5 remove
		// if (land2ResourceMineState[_landTokenId].lastUpdateTime == 0) {
		// 	land2ResourceMineState[_landTokenId].lastUpdateTime = uint128(
		// 		resourceReleaseStartTime
		// 	);
		// 	land2ResourceMineState[_landTokenId]
		// 		.lastUpdateSpeedInSeconds = TOTAL_SECONDS;
		// }

		_mineResource(_landTokenId, _gold);
		_mineResource(_landTokenId, _wood);
		_mineResource(_landTokenId, _water);
		_mineResource(_landTokenId, _fire);
		_mineResource(_landTokenId, _soil);

		// v5 remove
		// land2ResourceMineState[_landTokenId]
		// 	.lastUpdateSpeedInSeconds = _getReleaseSpeedInSeconds(
		// 	_landTokenId,
		// 	now
		// );

		land2ResourceMineState[_landTokenId].lastUpdateTime = uint128(now);
	}

	function _distribution(
		uint256 _landId,
		address _resource,
		uint256 minedBalance,
		uint256 barsRate
	) internal returns (uint256) {
		uint256 landBalance =
			minedBalance.mul(RATE_PRECISION).div(barsRate.add(RATE_PRECISION));
		uint256 barsBalance = minedBalance.sub(landBalance);
		for (uint256 i = 0; i &lt; maxAmount; i++) {
			(address itemToken, uint256 itemId, address resouce) =
				getBarItem(_landId, i);
			if (itemToken != address(0) &amp;&amp; resouce == _resource) {
				uint256 barBalance =
					barsBalance.mul(getBarRate(_landId, _resource, i)).div(
						barsRate
					);
				(barBalance, landBalance) = _payFee(barBalance, landBalance);
				itemMinedBalance[itemToken][itemId][
					_resource
				] = getItemMinedBalance(itemToken, itemId, _resource).add(
					barBalance
				);
			}
		}
		return landBalance;
	}

	function _payFee(uint256 barBalance, uint256 landBalance)
		internal
		view
		returns (uint256, uint256)
	{
		uint256 fee =
			barBalance.mul(registry.uintOf(FURNACE_ITEM_MINE_FEE)).div(
				RATE_PRECISION
			);
		barBalance = barBalance.sub(fee);
		landBalance = landBalance.add(fee);
		return (barBalance, landBalance);
	}

	function _mineResource(uint256 _landId, address _resource) internal {
		// the longest seconds to zero speed.
		if (getLandMiningStrength(_landId, _resource) == 0) {
			return;
		}
		uint256 minedBalance = _calculateMinedBalance(_landId, _resource, now);
		if (minedBalance == 0) {
			return;
		}

		uint256 barsRate = getBarsRate(_landId, _resource);
		uint256 landBalance = minedBalance;
		if (barsRate &gt; 0) {
			// V5 yeild distribution
			landBalance = _distribution(
				_landId,
				_resource,
				minedBalance,
				barsRate
			);
		}
		land2ResourceMineState[_landId].mintedBalance[
			_resource
		] = getLandMinedBalance(_landId, _resource).add(landBalance);
	}

	function _calculateMinedBalance(
		uint256 _landTokenId,
		address _resourceToken,
		uint256 _currentTime
	) internal view returns (uint256) {
		uint256 currentTime = _currentTime;

		uint256 minedBalance;
		uint256 minableBalance;
		if (currentTime &gt; (resourceReleaseStartTime + TOTAL_SECONDS)) {
			currentTime = (resourceReleaseStartTime + TOTAL_SECONDS);
		}

		uint256 lastUpdateTime =
			land2ResourceMineState[_landTokenId].lastUpdateTime;
		require(currentTime &gt;= lastUpdateTime);

		if (lastUpdateTime &gt;= (resourceReleaseStartTime + TOTAL_SECONDS)) {
			minedBalance = 0;
			minableBalance = 0;
		} else {
			minedBalance = _getMaxMineBalance(
				_landTokenId,
				_resourceToken,
				currentTime,
				lastUpdateTime
			);
			minableBalance = _getMinableBalance(
				_landTokenId,
				_resourceToken,
				currentTime,
				lastUpdateTime
			);
		}

		if (minedBalance &gt; minableBalance) {
			minedBalance = minableBalance;
		}

		return minedBalance;
	}

	// v5 remove
	// function claimAllResource(uint256 _landTokenId) public {
	// 	require(
	// 		msg.sender == ownership.ownerOf(_landTokenId),
	// 		"Must be the owner of the land"
	// 	);

	// 	_mineAllResource(_landTokenId, gold, wood, water, fire, soil);

	// 	uint256 goldBalance;
	// 	uint256 woodBalance;
	// 	uint256 waterBalance;
	// 	uint256 fireBalance;
	// 	uint256 soilBalance;

	// 	if (land2ResourceMineState[_landTokenId].mintedBalance[gold] &gt; 0) {
	// 		goldBalance = land2ResourceMineState[_landTokenId].mintedBalance[
	// 			gold
	// 		];
	// 		IMintableERC20(gold).mint(msg.sender, goldBalance);
	// 		land2ResourceMineState[_landTokenId].mintedBalance[gold] = 0;
	// 	}

	// 	if (land2ResourceMineState[_landTokenId].mintedBalance[wood] &gt; 0) {
	// 		woodBalance = land2ResourceMineState[_landTokenId].mintedBalance[
	// 			wood
	// 		];
	// 		IMintableERC20(wood).mint(msg.sender, woodBalance);
	// 		land2ResourceMineState[_landTokenId].mintedBalance[wood] = 0;
	// 	}

	// 	if (land2ResourceMineState[_landTokenId].mintedBalance[water] &gt; 0) {
	// 		waterBalance = land2ResourceMineState[_landTokenId].mintedBalance[
	// 			water
	// 		];
	// 		IMintableERC20(water).mint(msg.sender, waterBalance);
	// 		land2ResourceMineState[_landTokenId].mintedBalance[water] = 0;
	// 	}

	// 	if (land2ResourceMineState[_landTokenId].mintedBalance[fire] &gt; 0) {
	// 		fireBalance = land2ResourceMineState[_landTokenId].mintedBalance[
	// 			fire
	// 		];
	// 		IMintableERC20(fire).mint(msg.sender, fireBalance);
	// 		land2ResourceMineState[_landTokenId].mintedBalance[fire] = 0;
	// 	}

	// 	if (land2ResourceMineState[_landTokenId].mintedBalance[soil] &gt; 0) {
	// 		soilBalance = land2ResourceMineState[_landTokenId].mintedBalance[
	// 			soil
	// 		];
	// 		IMintableERC20(soil).mint(msg.sender, soilBalance);
	// 		land2ResourceMineState[_landTokenId].mintedBalance[soil] = 0;
	// 	}

	// 	emit ResourceClaimed(
	// 		msg.sender,
	// 		_landTokenId,
	// 		goldBalance,
	// 		woodBalance,
	// 		waterBalance,
	// 		fireBalance,
	// 		soilBalance
	// 	);
	// }

	// both for own _tokenId or hired one
	function startMining(
		uint256 _tokenId,
		uint256 _landTokenId,
		address _resource
	) public {
		<span class="marker" id="mapping-94"></span><span class="token mv" id="move-src-86" data-title="function_body/expression_statement">ITokenUse(registry.addressOf(CONTRACT_TOKEN_USE)).addActivity(
			_tokenId,
			msg.sender,
			0
		);</span>

		// require the permission from land owner;
		require(
			msg.sender ==
				ERC721(registry.addressOf(CONTRACT_OBJECT_OWNERSHIP)).ownerOf(
					_landTokenId
				),
			"Must be the owner of the land"
		);

		// make sure that _tokenId won't be used repeatedly
		require(miner2Index[_tokenId].landTokenId == 0);

		// update status!
		mine(_landTokenId);

		uint256 _index =
			land2ResourceMineState[_landTokenId].miners[_resource].length;

		land2ResourceMineState[_landTokenId].totalMiners += 1;

		// v5 remove
		// if (land2ResourceMineState[_landTokenId].maxMiners == 0) {
		// 	land2ResourceMineState[_landTokenId].maxMiners = 5;
		// }

		require(
			land2ResourceMineState[_landTokenId].totalMiners &lt;= maxMiners,
			"Land: EXCEED_MAXAMOUNT"
		);

		address miner =
			IInterstellarEncoder(
				registry.addressOf(CONTRACT_INTERSTELLAR_ENCODER)
			)
				.getObjectAddress(_tokenId);
		uint256 strength =
			IMinerObject(miner).strengthOf(_tokenId, _resource, _landTokenId);

		land2ResourceMineState[_landTokenId].miners[_resource].push(_tokenId);
		<span class="marker" id="mapping-95"></span><span class="token del" data-title="expression_statement/augmented_assignment_expression"><span class="marker" id="mapping-96"></span><span class="token mv" id="move-src-87" data-title="augmented_assignment_expression/array_access">land2ResourceMineState[_landTokenId].totalMinerStrength[
			_resource
		]</span> += strength</span>;

		miner2Index[_tokenId] = MinerStatus({
			landTokenId: _landTokenId,
			resource: _resource,
			indexInResource: uint64(_index)
		});

		emit StartMining(_tokenId, _landTokenId, _resource, strength);
	}

	function batchStartMining(
		uint256[] _tokenIds,
		uint256[] _landTokenIds,
		address[] _resources
	) <span class="marker" id="mapping-97"></span><span class="token del" data-title="visibility/public">public</span> {
		require(
			_tokenIds.length == _landTokenIds.length &amp;&amp;
				_landTokenIds.length == _resources.length,
			"input error"
		);
		uint256 length = _tokenIds.length;

		for (uint256 i = 0; i &lt; length; i++) {
			startMining(_tokenIds[i], _landTokenIds[i], _resources[i]);
		}
	}

	function batchClaimLandResource(uint256[] _landTokenIds) <span class="marker" id="mapping-98"></span><span class="token del" data-title="visibility/public">public</span> {
		uint256 length = _landTokenIds.length;

		for (uint256 i = 0; i &lt; length; i++) {
			claimLandResource(_landTokenIds[i]);
		}
	}

	// Only trigger from Token Activity.
	function activityStopped(uint256 _tokenId) public auth {
		_stopMining(_tokenId);
	}

	function stopMining(uint256 _tokenId) public {
		ITokenUse(registry.addressOf(CONTRACT_TOKEN_USE)).removeActivity(
			_tokenId,
			msg.sender
		);
	}

	function _stopMining(uint256 _tokenId) internal {
		// remove the miner from land2ResourceMineState;
		uint64 minerIndex = miner2Index[_tokenId].indexInResource;
		address resource = miner2Index[_tokenId].resource;
		uint256 landTokenId = miner2Index[_tokenId].landTokenId;

		// update status!
		mine(landTokenId);

		uint64 lastMinerIndex =
			uint64(
				land2ResourceMineState[landTokenId].miners[resource].length.sub(
					1
				)
			);
		uint256 lastMiner =
			land2ResourceMineState[landTokenId].miners[resource][
				lastMinerIndex
			];

		land2ResourceMineState[landTokenId].miners[resource][
			minerIndex
		] = lastMiner;
		land2ResourceMineState[landTokenId].miners[resource][
			lastMinerIndex
		] = 0;

		<span class="marker" id="mapping-99"></span><span class="token del" data-title="expression_statement/augmented_assignment_expression"><span class="marker" id="mapping-100"></span><span class="token mv" id="move-src-88" data-title="augmented_assignment_expression/member_expression">land2ResourceMineState[landTokenId].miners[resource].length</span> -= 1</span>;
		miner2Index[lastMiner].indexInResource = minerIndex;

		land2ResourceMineState[landTokenId].totalMiners -= 1;

		address miner =
			IInterstellarEncoder(
				registry.addressOf(CONTRACT_INTERSTELLAR_ENCODER)
			)
				.getObjectAddress(_tokenId);
		uint256 strength =
			IMinerObject(miner).strengthOf(_tokenId, resource, landTokenId);

		// for backward compatibility
		// if strength can fluctuate some time in the future
		if (
			land2ResourceMineState[landTokenId].totalMinerStrength[resource] !=
			0
		) {
			if (
				land2ResourceMineState[landTokenId].totalMinerStrength[
					resource
				] &gt; strength
			) {
				land2ResourceMineState[landTokenId].totalMinerStrength[
					resource
				] = land2ResourceMineState[landTokenId].totalMinerStrength[
					resource
				]
					.sub(strength);
			} else {
				land2ResourceMineState[landTokenId].totalMinerStrength[
					resource
				] = 0;
			}
		}

		if (land2ResourceMineState[landTokenId].totalMiners == 0) {
			land2ResourceMineState[landTokenId].totalMinerStrength[
				resource
			] = 0;
		}

		delete miner2Index[_tokenId];

		emit StopMining(_tokenId, landTokenId, resource, strength);
	}

	// v5 remove
	// function getMinerOnLand(
	// 	uint256 _landTokenId,
	// 	address _resourceToken,
	// 	uint256 _index
	// ) public view returns (uint256) {
	// 	return
	// 		land2ResourceMineState[_landTokenId].miners[_resourceToken][_index];
	// }

	// function getTotalMiningStrength(
	// 	uint256 _landTokenId,
	// 	address _resourceToken
	// ) public view returns (uint256) {
	// 	return
	// 		land2ResourceMineState[_landTokenId].totalMinerStrength[
	// 			_resourceToken
	// 		];
	// }

	// function availableResources(
	// 	uint256 _landTokenId,
	// 	address[5] _resourceTokens
	// )
	// 	public
	// 	view
	// 	returns (
	// 		uint256,
	// 		uint256,
	// 		uint256,
	// 		uint256,
	// 		uint256
	// 	)
	// {
	// 	uint256 availableGold =
	// 		_calculateMinedBalance(_landTokenId, _resourceTokens[0], now) +
	// 			land2ResourceMineState[_landTokenId].mintedBalance[
	// 				_resourceTokens[0]
	// 			];
	// 	uint256 availableWood =
	// 		_calculateMinedBalance(_landTokenId, _resourceTokens[1], now) +
	// 			land2ResourceMineState[_landTokenId].mintedBalance[
	// 				_resourceTokens[1]
	// 			];
	// 	uint256 availableWater =
	// 		_calculateMinedBalance(_landTokenId, _resourceTokens[2], now) +
	// 			land2ResourceMineState[_landTokenId].mintedBalance[
	// 				_resourceTokens[2]
	// 			];
	// 	uint256 availableFire =
	// 		_calculateMinedBalance(_landTokenId, _resourceTokens[3], now) +
	// 			land2ResourceMineState[_landTokenId].mintedBalance[
	// 				_resourceTokens[3]
	// 			];
	// 	uint256 availableSoil =
	// 		_calculateMinedBalance(_landTokenId, _resourceTokens[4], now) +
	// 			land2ResourceMineState[_landTokenId].mintedBalance[
	// 				_resourceTokens[4]
	// 			];

	// 	return (
	// 		availableGold,
	// 		availableWood,
	// 		availableWater,
	// 		availableFire,
	// 		availableSoil
	// 	);
	// }

	// V5 remove
	// function mintedBalanceOnLand(uint256 _landTokenId, address _resourceToken) public view returns (uint256) {
	//     return land2ResourceMineState[_landTokenId].mintedBalance[_resourceToken];
	// }

	// function landWorkingOn(uint256 _apostleTokenId) public view returns (uint256 landTokenId) {
	//     landTokenId = miner2Index[_apostleTokenId].landTokenId;
	// }

	function _updateMinerStrength(uint256 _apostleTokenId, bool _isStop)
		internal
		returns (uint256, uint256)
	{
		// require that this apostle
		uint256 landTokenId = landWorkingOn(_apostleTokenId);
		require(landTokenId != 0, "this apostle is not mining.");

		address resource = miner2Index[_apostleTokenId].resource;

		address miner =
			IInterstellarEncoder(
				registry.addressOf(CONTRACT_INTERSTELLAR_ENCODER)
			)
				.getObjectAddress(_apostleTokenId);
		uint256 strength =
			IMinerObject(miner).strengthOf(
				_apostleTokenId,
				resource,
				landTokenId
			);

		mine(landTokenId);

		if (_isStop) {
			land2ResourceMineState[landTokenId].totalMinerStrength[
				resource
			] = land2ResourceMineState[landTokenId].totalMinerStrength[resource]
				.sub(strength);
		} else {
			<span class="marker" id="mapping-101"></span><span class="token del" data-title="expression_statement/augmented_assignment_expression"><span class="marker" id="mapping-102"></span><span class="token mv" id="move-src-89" data-title="augmented_assignment_expression/array_access">land2ResourceMineState[landTokenId].totalMinerStrength[
				resource
			]</span> += strength</span>;
		}

		return (landTokenId, strength);
	}

	// when a mirrorToken or a pet has tied to apostle
	// we need to update status and remove this apostle from mining list first
	// open authority to PetBase
	// can only be called by PetBase
	function updateMinerStrengthWhenStop(uint256 _apostleTokenId) public auth {
		uint256 landTokenId;
		uint256 strength;
		(landTokenId, strength) = _updateMinerStrength(_apostleTokenId, true);
		// _isStop == true - minus strength
		// _isStop == false - add strength
		emit UpdateMiningStrengthWhenStop(
			_apostleTokenId,
			landTokenId,
			strength
		);
	}

	function updateMinerStrengthWhenStart(uint256 _apostleTokenId) public auth {
		uint256 landTokenId;
		uint256 strength;
		(landTokenId, strength) = _updateMinerStrength(_apostleTokenId, false);
		// _isStop == true - minus strength
		// _isStop == false - add strength
		emit UpdateMiningStrengthWhenStart(
			_apostleTokenId,
			landTokenId,
			strength
		);
	}

	// V5 add
	function getLandMinedBalance(uint256 _landId, address _resource)
		public
		view
		returns (uint256)
	{
		return land2ResourceMineState[_landId].mintedBalance[_resource];
	}

	function getItemMinedBalance(
		address _itemToken,
		uint256 _itemId,
		address _resource
	) public view returns (uint256) {
		return itemMinedBalance[_itemToken][_itemId][_resource];
	}

	function getLandMiningStrength(uint256 _landId, address _resource)
		public
		view
		returns (uint256)
	{
		return land2ResourceMineState[_landId].totalMinerStrength[_resource];
	}

	function getBarMiningStrength(
		uint256 _landId,
		address _resource,
		uint256 _index
	) public view returns (uint256) {
		return
			getLandMiningStrength(_landId, _resource)
				.mul(getBarRate(_landId, _resource, _index))
				.div(RATE_PRECISION);
	}

	function getBarRate(
		uint256 _landId,
		address _resource,
		uint256 _index
	) public view returns (uint256) {
		return land2BarRate[_landId][_resource][_index];
	}

	function getBarsRate(uint256 _landId, address _resource)
		public
		view
		returns (uint256 barsRate)
	{
		for (uint256 i = 0; i &lt; maxAmount; i++) {
			barsRate = barsRate.add(getBarRate(_landId, _resource, i));
		}
	}

	function getBarsMiningStrength(uint256 _landId, address _resource)
		public
		view
		returns (uint256 barsMiningStrength)
	{
		return
			getLandMiningStrength(_landId, _resource)
				.mul(getBarsRate(_landId, _resource))
				.div(RATE_PRECISION);
	}

	function getTotalMiningStrength(uint256 _landId, address _resource)
		public
		view
		returns (uint256)
	{
		return
			getLandMiningStrength(_landId, _resource).add(
				getBarsMiningStrength(_landId, _resource)
			);
	}

	function getMinerOnLand(
		uint256 _landId,
		address _resource,
		uint256 _index
	) public view returns (uint256) {
		return land2ResourceMineState[_landId].miners[_resource][_index];
	}

	function landWorkingOn(uint256 _apostleTokenId)
		public
		view
		returns (uint256 landId)
	{
		landId = miner2Index[_apostleTokenId].landTokenId;
	}

	function _getBarRateByIndex(
		uint256 _landId,
		address _resource,
		uint256 _index
	) internal view returns (uint256) {
		return enhanceStrengthRateByIndex(_resource, _landId, _index);
	}

	function _startBarMining(
		uint256 _index,
		uint256 _landId,
		address _resource
	) internal {
		uint256 rate = _getBarRateByIndex(_landId, _resource, _index);
		land2BarRate[_landId][_resource][_index] = rate;
		emit StartBarMining(_index, _landId, _resource, rate);
	}

	function _stopBarMinig(
		uint256 _index,
		uint256 _landId,
		address _resource
	) internal {
		delete land2BarRate[_landId][_resource][_index];
		emit StopBarMining(_index, _landId, _resource);
	}

	function _claimItemResource(
		address _itemToken,
		uint256 _itemId,
		address _resource
	) internal returns (uint256) {
		uint256 balance = getItemMinedBalance(_itemToken, _itemId, _resource);
		if (balance &gt; 0) {
			IMintableERC20(_resource).mint(msg.sender, balance);
			itemMinedBalance[_itemToken][_itemId][_resource] = 0;
			return balance;
		} else {
			return 0;
		}
	}

	function claimItemResource(address _itemToken, uint256 _itemId) public {
		(address staker, uint256 landId) = getLandIdByItem(_itemToken, _itemId);
		if (staker == address(0) &amp;&amp; landId == 0) {
			require(
				ERC721(_itemToken).ownerOf(_itemId) == msg.sender,
				"Land: ONLY_ITEM_ONWER"
			);
		} else {
			require(staker == msg.sender, "Land: ONLY_ITEM_STAKER");
			mine(landId);
		}

		address gold = registry.addressOf(CONTRACT_GOLD_ERC20_TOKEN);
		address wood = registry.addressOf(CONTRACT_WOOD_ERC20_TOKEN);
		address water = registry.addressOf(CONTRACT_WATER_ERC20_TOKEN);
		address fire = registry.addressOf(CONTRACT_FIRE_ERC20_TOKEN);
		address soil = registry.addressOf(CONTRACT_SOIL_ERC20_TOKEN);
		uint256 goldBalance = _claimItemResource(_itemToken, _itemId, gold);
		uint256 woodBalance = _claimItemResource(_itemToken, _itemId, wood);
		uint256 waterBalance = _claimItemResource(_itemToken, _itemId, water);
		uint256 fireBalance = _claimItemResource(_itemToken, _itemId, fire);
		uint256 soilBalance = _claimItemResource(_itemToken, _itemId, soil);

		emit ItemResourceClaimed(
			msg.sender,
			_itemToken,
			_itemId,
			goldBalance,
			woodBalance,
			waterBalance,
			fireBalance,
			soilBalance
		);
	}

	function _claimLandResource(uint256 _landId, address _resource)
		internal
		returns (uint256)
	{
		uint256 balance = getLandMinedBalance(_landId, _resource);
		if (balance &gt; 0) {
			IMintableERC20(_resource).mint(msg.sender, balance);
			land2ResourceMineState[_landId].mintedBalance[_resource] = 0;
			return balance;
		} else {
			return 0;
		}
	}

	function claimLandResource(uint256 _landId) public {
		require(
			msg.sender ==
				ERC721(registry.addressOf(CONTRACT_OBJECT_OWNERSHIP)).ownerOf(
					_landId
				),
			"Land: ONLY_LANDER"
		);

		address gold = registry.addressOf(CONTRACT_GOLD_ERC20_TOKEN);
		address wood = registry.addressOf(CONTRACT_WOOD_ERC20_TOKEN);
		address water = registry.addressOf(CONTRACT_WATER_ERC20_TOKEN);
		address fire = registry.addressOf(CONTRACT_FIRE_ERC20_TOKEN);
		address soil = registry.addressOf(CONTRACT_SOIL_ERC20_TOKEN);
		_mineAllResource(_landId, gold, wood, water, fire, soil);

		uint256 goldBalance = _claimLandResource(_landId, gold);
		uint256 woodBalance = _claimLandResource(_landId, wood);
		uint256 waterBalance = _claimLandResource(_landId, water);
		uint256 fireBalance = _claimLandResource(_landId, fire);
		uint256 soilBalance = _claimLandResource(_landId, soil);

		emit LandResourceClaimed(
			msg.sender,
			_landId,
			goldBalance,
			woodBalance,
			waterBalance,
			fireBalance,
			soilBalance
		);
	}

	function _calculateResources(
		address _itemToken,
		uint256 _itemId,
		uint256 _landId,
		address _resource,
		uint256 _minedBalance
	) internal view returns (uint256 landBalance, uint256 barResource) {
		uint256 barsRate = getBarsRate(_landId, _resource);
		// V5 yeild distribution
		landBalance = _minedBalance.mul(RATE_PRECISION).div(
			barsRate.add(RATE_PRECISION)
		);
		<span class="marker" id="mapping-103"></span><span class="token del" data-title="function_body/if_statement">if (<span class="marker" id="mapping-104"></span><span class="token mv" id="move-src-90" data-title="if_statement/binary_expression">barsRate &gt; 0</span>) <span class="marker" id="mapping-105"></span><span class="token del" data-title="if_statement/block_statement">{
			<span class="marker" id="mapping-106"></span><span class="token mv" id="move-src-91" data-title="block_statement/variable_declaration_statement">uint256 barsBalance = _minedBalance.sub(landBalance);</span>
			<span class="marker" id="mapping-107"></span><span class="token mv" id="move-src-92" data-title="block_statement/for_statement">for (uint256 i = 0; i &lt; maxAmount; i++) <span class="marker" id="mapping-108"></span><span class="token mv" id="move-src-93" data-title="for_statement/block_statement">{
				<span class="marker" id="mapping-109"></span><span class="token mv" id="move-src-94" data-title="block_statement/variable_declaration_statement">(address itemToken, uint256 itemId, <span class="marker" id="mapping-110"></span><span class="token del" data-title="variable_declaration_tuple/variable_declaration">address resource</span>) = getBarItem(_landId, i);</span>
				<span class="marker" id="mapping-111"></span><span class="token mv" id="move-src-95" data-title="block_statement/if_statement">if (<span class="marker" id="mapping-112"></span><span class="token del" data-title="if_statement/binary_expression"><span class="marker" id="mapping-113"></span><span class="token mv" id="move-src-96" data-title="binary_expression/binary_expression">_itemId == itemId &amp;&amp; _itemToken == itemToken</span> &amp;&amp; <span class="marker" id="mapping-114"></span><span class="token del" data-title="binary_expression/binary_expression">_resource == resource</span></span>) <span class="marker" id="mapping-115"></span><span class="token mv" id="move-src-97" data-title="if_statement/block_statement">{
					uint256 barBalance =
						barsBalance.mul(getBarRate(_landId, _resource, i)).div(
							barsRate
						);
					(barBalance, landBalance) = _payFee(barBalance, landBalance);
					<span class="marker" id="mapping-116"></span><span class="token mv" id="move-src-98" data-title="block_statement/expression_statement">barResource = barResource.add(barBalance);</span>
				}</span></span>
			}</span></span>
		}</span></span>
	}

	function availableLandResources(
		uint256 _landId,
		<span class="marker" id="mapping-117"></span><span class="token mv" id="move-src-99" data-title="type_name/primitive_type">address</span>[] <span class="marker" id="mapping-118"></span><span class="token del" data-title="parameter/memory">memory</span> _resources
	) <span class="marker" id="mapping-119"></span><span class="token del" data-title="visibility/public">public</span> view returns (uint256[] memory) {
		uint256[] memory availables = new uint256[](_resources.length);
		for (uint256 i = 0; i &lt; _resources.length; i++) <span class="marker" id="mapping-120"></span><span class="token del" data-title="for_statement/block_statement">{
			<span class="marker" id="mapping-121"></span><span class="token del" data-title="block_statement/if_statement">if (<span class="marker" id="mapping-122"></span><span class="token del" data-title="if_statement/binary_expression">getLandMiningStrength(_landId, _resources[i]) &gt; 0</span>) <span class="marker" id="mapping-123"></span><span class="token mv" id="move-src-100" data-title="if_statement/block_statement">{
				uint256 mined = _calculateMinedBalance(_landId, _resources[i], now);
				(uint256 available, ) =
					_calculateResources(
						address(0),
						0,
						_landId,
						_resources[i],
						mined
					);
				availables[i] = available.add(
					getLandMinedBalance(_landId, _resources[i])
				);
			}</span></span>
		}</span>
		return availables;
	}

	function availableItemResources(
		address _itemToken,
		uint256 _itemId,
		address[] <span class="marker" id="mapping-124"></span><span class="token del" data-title="parameter/memory">memory</span> _resources
	) <span class="marker" id="mapping-125"></span><span class="token mv" id="move-src-101" data-title="function_definition/visibility">public</span> view returns (uint256[] memory) {
		uint256[] memory availables = new uint256[](_resources.length);
		for (uint256 i = 0; i &lt; _resources.length; i++) <span class="marker" id="mapping-126"></span><span class="token del" data-title="for_statement/block_statement">{
			<span class="marker" id="mapping-127"></span><span class="token mv" id="move-src-102" data-title="block_statement/variable_declaration_statement">(address staker, uint256 landId) =
				getLandIdByItem(_itemToken, _itemId);</span>
			<span class="marker" id="mapping-128"></span><span class="token del" data-title="block_statement/if_statement">if (<span class="marker" id="mapping-129"></span><span class="token del" data-title="if_statement/binary_expression">getLandMiningStrength(landId, _resources[i]) &gt; 0</span>) <span class="marker" id="mapping-130"></span><span class="token mv" id="move-src-103" data-title="if_statement/block_statement">{
				uint256 available = 0;
				if (staker != address(0) &amp;&amp; landId != 0) {
					uint256 mined =
						_calculateMinedBalance(landId, _resources[i], now);
					(, uint256 availableItem) =
						_calculateResources(
							_itemToken,
							_itemId,
							landId,
							_resources[i],
							mined
						);
					available = available.add(availableItem);
				}
				available = available.add(
					getItemMinedBalance(_itemToken, _itemId, _resources[i])
				);
				availables[i] = available;
			}</span></span>
		}</span>
		return availables;
	}

	function isNotProtect(address _token, uint256 _id)
		public
		view
		returns (bool)
	{
		return protectPeriod[_token][_id] &lt; now;
	}

	function getBarItem(uint256 _tokenId, uint256 _index)
		public
		view
		returns (
			address,
			uint256,
			address
		)
	{
		require(_index &lt; maxAmount, "Furnace: INDEX_FORBIDDEN.");
		return (
			landId2Bars[_tokenId][_index].token,
			landId2Bars[_tokenId][_index].id,
			landId2Bars[_tokenId][_index].resource
		);
	}

	function getLandIdByItem(address _item, uint256 _itemId)
		public
		view
		returns (address, uint256)
	{
		return (
			itemId2Status[_item][_itemId].staker,
			itemId2Status[_item][_itemId].<span class="marker" id="mapping-131"></span><span class="token upd" id="move-src-104" data-title="member_expression/identifier">landT<span class="cupd">okenId</span></span>
		);
	}

	<span class="marker" id="mapping-132"></span><span class="token mv" id="move-src-105" data-title="contract_body/comment"><span class="marker" id="mapping-133"></span><span class="token upd" id="move-src-106" data-title="contract_body/comment"><span class="cupd">/</span>**<span class="cupd"></span>
        @<span class="cupd">d</span>ev Equip function, A NFT can<span class="cupd"> </span>equi<span class="cupd">p</span><span class="cupd"> </span>to EVO Bar (LandBar or <span class="cupd">A</span>p<span class="cupd">o</span>s<span class="cupd">t</span>leBar<span class="cupd">)</span>.
       <span class="cupd"> </span>@param _t<span class="cupd">ok</span>enId  T<span class="cupd">o</span>ken Id which to be q<span class="cupd">u</span>iped.
      <span class="cupd"> </span> @param<span class="cupd"> </span>_resource<span class="cupd"> </span><span class="cupd">W</span><span class="cupd">h</span>ic<span class="cupd">h</span> resouce appp<span class="cupd">l</span>y to.
       <span class="cupd"> @</span>para<span class="cupd">m</span> _index    Index of the Bar.
    <span class="cupd">   </span> @param<span class="cupd"> _</span>token    Toke<span class="cupd">n</span> address wh<span class="cupd">i</span>ch t<span class="cupd">o</span> quip.
    <span class="cupd"> </span><span class="cupd"> </span>  @param _id     <span class="cupd"> </span> Token Id which to quip.
    */</span></span>
	function equip(
		uint256 _tokenId,
		address _resource,
		uint256 _index,
		address _token,
		uint256 _id
	) public {
		_equip(_tokenId, _resource, _index, _token, _id);
	}

	<span class="marker" id="mapping-134"></span><span class="token mv" id="move-src-107" data-title="contract_body/comment"><span class="marker" id="mapping-135"></span><span class="token upd" id="move-src-108" data-title="contract_body/comment"><span class="cupd">//</span>/<span class="cupd"> </span><span class="cupd">e</span>qui<span class="cupd">p</span><span class="cupd"> </span><span class="cupd">r</span><span class="cupd">u</span><span class="cupd">l</span><span class="cupd">e</span>s:</span></span>
	<span class="marker" id="mapping-136"></span><span class="token mv" id="move-src-109" data-title="contract_body/comment"><span class="marker" id="mapping-137"></span><span class="token upd" id="move-src-110" data-title="contract_body/comment"><span class="cupd">//</span>/<span class="cupd"> </span>1. land own<span class="cupd">e</span>r c<span class="cupd">ou</span>ld <span class="cupd">r</span>epla<span class="cupd">ce </span><span class="cupd">i</span>t<span class="cupd">e</span>m whi<span class="cupd">c</span>h i<span class="cupd">s</span><span class="cupd"> </span>not<span class="cupd"> </span>in prot<span class="cupd">e</span>ct<span class="cupd">e</span>d<span class="cupd"> </span>perio<span class="cupd">d</span>.</span></span>
	<span class="marker" id="mapping-138"></span><span class="token mv" id="move-src-111" data-title="contract_body/comment"><span class="marker" id="mapping-139"></span><span class="token upd" id="move-src-112" data-title="contract_body/comment"><span class="cupd">//</span>/<span class="cupd"> </span>2. <span class="cupd">a</span><span class="cupd">l</span><span class="cupd">l</span><span class="cupd"> </span>u<span class="cupd">s</span>er<span class="cupd"> </span>could<span class="cupd"> </span><span class="cupd">re</span>pl<span class="cupd">a</span>ce<span class="cupd"> </span>l<span class="cupd">o</span>w-cl<span class="cupd">a</span>ss<span class="cupd"> </span>i<span class="cupd">t</span><span class="cupd">e</span>ms w<span class="cupd">i</span>th high-class item. </span></span>
	<span class="marker" id="mapping-140"></span><span class="token mv" id="move-src-113" data-title="contract_body/comment"><span class="marker" id="mapping-141"></span><span class="token upd" id="move-src-114" data-title="contract_body/comment"><span class="cupd">//</span>/<span class="cupd"> </span><span class="cupd"> </span><span class="cupd"> </span><span class="cupd"> </span><span class="cupd">i</span>f<span class="cupd"> </span><span class="cupd">t</span><span class="cupd">h</span><span class="cupd">e </span><span class="cupd">c</span>l<span class="cupd">a</span>ss<span class="cupd">e</span>s<span class="cupd"> is the </span>sa<span class="cupd">m</span><span class="cupd">e</span>,<span class="cupd"> </span>h<span class="cupd">i</span>g<span class="cupd">h</span>-gr<span class="cupd">a</span>de<span class="cupd"> can </span>r<span class="cupd">e</span><span class="cupd">p</span>lac<span class="cupd">e</span><span class="cupd"> </span>low-gr<span class="cupd">a</span>de items.</span></span>
	function _equip(
		uint256 _tokenId,
		address _resource,
		uint256 _index,
		address _token,
		uint256 _id
	) internal {
		beforeEquip(_tokenId, _resource);
		IMetaDataTeller teller =
			IMetaDataTeller(registry.addressOf(CONTRACT_METADATA_TELLER));
		uint256 resourceId =
			<span class="marker" id="mapping-142"></span><span class="token upd" id="move-src-115" data-title="call_expression/identifier"><span class="cupd">ILandBase</span></span>(registry.addressOf(CONTRACT_LAND_BASE))
				.resourceToken2RateAttrId(_resource);
		require(resourceId &gt; 0 &amp;&amp; resourceId &lt; 6, "Furnace: INVALID_RESOURCE");
		require(
			IInterstellarEncoder(
				registry.addressOf(CONTRACT_INTERSTELLAR_ENCODER)
			)
				.getObjectClass(_tokenId) == 1,
			"Funace: ONLY_LAND"
		);
		(uint16 objClassExt, uint16 class, uint16 grade) =
			teller.getMetaData(_token, _id);
		require(objClassExt &gt; 0, "Furnace: PERMISSION");
		require(_index &lt; maxAmount, "Furnace: INDEX_FORBIDDEN");
		Bar storage bar = landId2Bars[_tokenId][_index];
		if (bar.token != address(0)) {
			require(isNotProtect(bar.token, bar.id), "Furnace: PROTECT_PERIOD");
			(, uint16 originClass, uint16 originGrade) =
				teller.getMetaData(bar.token, bar.id);
			require(
				class &gt; originClass ||
					(class == originClass &amp;&amp; grade &gt; originGrade) ||
					ERC721(registry.addressOf(CONTRACT_OBJECT_OWNERSHIP))
						.ownerOf(_tokenId) ==
					msg.sender,
				"Furnace: FORBIDDEN"
			);
			//TODO:: safe transfer
			ERC721(bar.token).transferFrom(address(this), bar.staker, bar.id);
			<span class="marker" id="mapping-143"></span><span class="token del" data-title="block_statement/emit_statement">emit Divest(
				<span class="marker" id="mapping-144"></span><span class="token mv" id="move-src-116" data-title="emit_statement/call_argument">_tokenId</span>,
				<span class="marker" id="mapping-145"></span><span class="token del" data-title="emit_statement/call_argument">bar.resource</span>,
				<span class="marker" id="mapping-146"></span><span class="token mv" id="move-src-117" data-title="emit_statement/call_argument">_index</span>,
				<span class="marker" id="mapping-147"></span><span class="token del" data-title="emit_statement/call_argument">bar.staker</span>,
				<span class="marker" id="mapping-148"></span><span class="token del" data-title="emit_statement/call_argument">bar.token</span>,
				<span class="marker" id="mapping-149"></span><span class="token del" data-title="emit_statement/call_argument">bar.id</span>
			);</span>
		}
		ERC721(_token).transferFrom(msg.sender, address(this), _id);
		bar.staker = msg.sender;
		bar.token = _token;
		bar.id = _id;
		bar.resource = _resource;
		itemId2Status[bar.token][bar.id] = Status({
			staker: bar.staker,
			<span class="marker" id="mapping-150"></span><span class="token upd" id="move-src-118" data-title="call_struct_argument/identifier">landT<span class="cupd">okenId</span></span>: _tokenId,
			index: _index
		});
		if (isNotProtect(bar.token, bar.id)) {
			protectPeriod[bar.token][bar.id] = _calculateProtectPeriod(class).add(now);
		}
		afterEquiped(_index, _tokenId, _resource);
		emit Equip(_tokenId, _resource, _index, bar.staker, bar.token, bar.id);
	}

	function _calculateProtectPeriod(
		uint16 _class
	) internal view returns (uint256) {
		uint256 baseProtectPeriod =
			registry.uintOf(UINT_ITEMBAR_PROTECT_PERIOD);
		return <span class="marker" id="mapping-151"></span><span class="token del" data-title="return_statement/call_expression"><span class="marker" id="mapping-152"></span><span class="token del" data-title="call_expression/member_expression">baseProtectPeriod.add</span>(<span class="marker" id="mapping-153"></span><span class="token del" data-title="call_expression/call_argument"><span class="marker" id="mapping-154"></span><span class="token mv" id="move-src-119" data-title="call_argument/call_expression">uint256(_class).mul(baseProtectPeriod)</span></span>)</span>;
	}

	function beforeEquip(uint256 _landTokenId, address _resource) internal {
		if (getLandMiningStrength(_landTokenId, _resource) &gt; 0) {
			mine(_landTokenId);
		}
	}

	function afterEquiped(
		uint256 _index,
		uint256 _landTokenId,
		address _resource
	) internal {
		_startBarMining(_index, _landTokenId, _resource);
	}

	function afterDivested(
		uint256 _index,
		uint256 _landTokenId,
		address _resource
	) internal {
		if (getLandMiningStrength(_landTokenId, _resource) &gt; 0) {
			mine(_landTokenId);
		}
		_stopBarMinig(_index, _landTokenId, _resource);
	}

	<span class="marker" id="mapping-155"></span><span class="token mv" id="move-src-120" data-title="contract_body/comment"><span class="marker" id="mapping-156"></span><span class="token upd" id="move-src-121" data-title="contract_body/comment"><span class="cupd">/**
        @dev</span> <span class="cupd">D</span>ives<span class="cupd">t function, A NFT can</span> <span class="cupd">D</span>ive<span class="cupd">s</span>t f<span class="cupd">r</span>o<span class="cupd">m EVO Bar (LandBar or ApostleBar).
        @param _tokenI</span><span class="cupd">d Token Id which to b</span>e <span class="cupd">unquiped.
        @para</span><span class="cupd">m</span><span class="cupd"> _index</span><span class="cupd">   Index of the Bar.
</span><span class="cupd">  </span>  */</span></span>
	function divest(uint256 _tokenId, uint256 _index) public {
		_divest(_tokenId, _index);
	}

	function _divest(uint256 _tokenId, uint256 _index) internal {
		Bar memory bar = landId2Bars[_tokenId][_index];
		require(bar.token != address(0), "Furnace: EMPTY");
		require(bar.staker == msg.sender, "Furnace: FORBIDDEN");
		ERC721(bar.token).transferFrom(address(this), bar.staker, bar.id);
		afterDivested(_index, _tokenId, bar.resource);
		//clean
		delete itemId2Status[bar.token][bar.id];
		delete landId2Bars[_tokenId][_index];
		emit Divest(
			_tokenId,
			bar.resource,
			_index,
			bar.staker,
			bar.token,
			bar.id
		);
	}

	function setMaxAmount(uint256 _maxAmount) public auth {
		require(_maxAmount &gt; maxAmount, "Furnace: INVALID_MAXAMOUNT");
		maxAmount = _maxAmount;
	}

	function enhanceStrengthRateByIndex(
		address _resource,
		uint256 _tokenId,
		uint256 _index
	) public view returns (uint256) {
		Bar storage bar = landId2Bars[_tokenId][_index];
		if (bar.token == address(0)) {
			return 0;
		}
		IMetaDataTeller teller =
			IMetaDataTeller(registry.addressOf(CONTRACT_METADATA_TELLER));
		uint256 resourceId =
			<span class="marker" id="mapping-157"></span><span class="token upd" id="move-src-122" data-title="call_expression/identifier"><span class="cupd">ILandBase</span></span>(registry.addressOf(CONTRACT_LAND_BASE))
				.resourceToken2RateAttrId(_resource);
		return teller.getRate(bar.token, bar.id, resourceId);
	}

	function enhanceStrengthRateOf(address _resource, uint256 _tokenId)
		external
		view
		returns (uint256)
	{
		uint256 rate;
		for (uint256 i = 0; i &lt; maxAmount; i++) {
			rate = rate.add(enhanceStrengthRateByIndex(_resource, _tokenId, i));
		}
		return rate;
	}
}</pre></div><div class="col-6"><h5>0xe97c7f83ec91e29569f1a08de95ad3bb0e8b6b3a.etherscan.io-LandResourceV6.sol</h5><pre class="pre-scrollable"><span class="marker" id="mapping-158"></span><span class="token upd" id="move-dst-1" data-title="source_file/comment"><span class="cupd">/</span>**<span class="cupd"></span>
 *Submit<span class="cupd">t</span><span class="cupd">e</span><span class="cupd">d </span>fo<span class="cupd">r</span> <span class="cupd">v</span>e<span class="cupd">r</span>i<span class="cupd">f</span>ica<span class="cupd">t</span><span class="cupd">io</span>n<span class="cupd"> </span><span class="cupd">a</span>t<span class="cupd"> </span>hecoi<span class="cupd">n</span>f<span class="cupd">o</span>.com on 2021-07-02
*/</span>

<span class="marker" id="mapping-159"></span><span class="token upd" id="move-dst-2" data-title="source_file/comment"><span class="cupd">// </span>Ve<span class="cupd">r</span>ified by D<span class="cupd">a</span>rwini<span class="cupd">a </span>Network</span>

<span class="marker" id="mapping-160"></span><span class="token upd" id="move-dst-5" data-title="source_file/comment"><span class="cupd">// </span>h<span class="cupd">e</span>vm:<span class="cupd"> f</span><span class="cupd">l</span>att<span class="cupd">e</span>ned<span class="cupd"> </span>s<span class="cupd">o</span>urc<span class="cupd">e</span><span class="cupd">s</span> <span class="cupd">o</span>f <span class="cupd">contracts/</span>La<span class="cupd">n</span>dResou<span class="cupd">r</span>c<span class="cupd">e</span>V<span class="cupd">6</span><span class="cupd">.sol</span></span>

<span class="marker" id="mapping-161"></span><span class="token mv" id="move-dst-65" data-title="source_file/pragma_directive">pragma solidity<span class="marker" id="mapping-162"></span><span class="token add" data-title="solidity_pragma_token/solidity_version_comparison_operator"> &gt;=</span><span class="marker" id="mapping-163"></span><span class="token add" data-title="solidity_pragma_token/solidity_version">0.4.23</span><span class="marker" id="mapping-164"></span><span class="token add" data-title="solidity_pragma_token/solidity_version_comparison_operator"> &lt;</span><span class="marker" id="mapping-165"></span><span class="token add" data-title="solidity_pragma_token/solidity_version">0.5.0</span><span class="marker" id="mapping-166"></span><span class="token add" data-title="solidity_pragma_token/solidity_version_comparison_operator"> &gt;=</span>0.4.24<span class="marker" id="mapping-167"></span><span class="token add" data-title="solidity_pragma_token/solidity_version_comparison_operator"> &lt;</span><span class="marker" id="mapping-168"></span><span class="token add" data-title="solidity_pragma_token/solidity_version">0.5.0</span>;</span>

<span class="marker" id="mapping-169"></span><span class="token upd" id="move-dst-6" data-title="source_file/comment"><span class="cupd">//</span>////<span class="cupd"> </span>cont<span class="cupd">ra</span>cts/interf<span class="cupd">a</span>ce<span class="cupd">s</span>/ILandBase.s<span class="cupd">ol</span></span>
<span class="marker" id="mapping-170"></span><span class="token upd" id="move-dst-7" data-title="source_file/comment"><span class="cupd">/*</span><span class="cupd"> </span><span class="cupd">p</span>ra<span class="cupd">g</span><span class="cupd">m</span>a <span class="cupd">s</span>o<span class="cupd">l</span><span class="cupd">i</span><span class="cupd">d</span>ity<span class="cupd"> </span>^0.4.24;<span class="cupd"> */</span></span>

<span class="marker" id="mapping-171"></span><span class="token mv" id="move-dst-59" data-title="source_file/contract_declaration">contract ILandBase {

    /*
     *  Event
     */
    event ModifiedResourceRate(uint indexed tokenId, address resourceToken, uint16 newResourceRate);
    event HasboxSetted(uint indexed tokenId, bool hasBox);

    event ChangedReourceRateAttr(uint indexed tokenId, uint256 attr);

    event ChangedFlagMask(uint indexed tokenId, uint256 newFlagMask);

    event CreatedNewLand(uint indexed tokenId, int x, int y, address beneficiary, uint256 resourceRateAttr, uint256 mask);

    function defineResouceTokenRateAttrId(address _resourceToken, uint8 _attrId) public;

    function setHasBox(uint _landTokenID, bool isHasBox) public;
    function isReserved(uint256 _tokenId) public view returns (bool);
    function isSpecial(uint256 _tokenId) public view returns (bool);
    function isHasBox(uint256 _tokenId) public view returns (bool);

    function getResourceRateAttr(uint _landTokenId) public view returns (uint256);
    function setResourceRateAttr(uint _landTokenId, uint256 _newResourceRateAttr) public;

    function getResourceRate(uint _landTokenId, address _resouceToken) public view returns (uint16);
    function setResourceRate(uint _landTokenID, address _resourceToken, uint16 _newResouceRate) public;

    function getFlagMask(uint _landTokenId) public view returns (uint256);

    function setFlagMask(uint _landTokenId, uint256 _newFlagMask) public;

}</span>

<span class="marker" id="mapping-172"></span><span class="token upd" id="move-dst-9" data-title="source_file/comment"><span class="cupd">//</span>////<span class="cupd"> </span><span class="cupd">c</span><span class="cupd">o</span><span class="cupd">n</span>tract<span class="cupd">s</span>/<span class="cupd">i</span><span class="cupd">nt</span>e<span class="cupd">r</span>f<span class="cupd">ac</span>e<span class="cupd">s/</span>ILa<span class="cupd">n</span>d<span class="cupd">Bas</span>eExt<span class="cupd">.sol</span></span>
<span class="marker" id="mapping-173"></span><span class="token upd" id="move-dst-10" data-title="source_file/comment"><span class="cupd">/</span>*<span class="cupd"> pragma solidity ^0.4.24;</span> */</span>

<span class="marker" id="mapping-174"></span><span class="token add" data-title="source_file/contract_declaration">contract ILandBaseExt <span class="marker" id="mapping-175"></span><span class="token add" data-title="contract_declaration/contract_body">{
    <span class="marker" id="mapping-176"></span><span class="token mv" id="move-dst-60" data-title="contract_body/function_definition">function resourceToken2RateAttrId(address _resourceToken) external view returns (uint256);</span>
}</span></span>

<span class="marker" id="mapping-177"></span><span class="token upd" id="move-dst-11" data-title="source_file/comment"><span class="cupd">//</span>////<span class="cupd"> </span><span class="cupd">contracts/int</span>e<span class="cupd">r</span>face<span class="cupd">s</span>/IM<span class="cupd">e</span><span class="cupd">t</span>aDataTeller<span class="cupd">.sol</span></span>
<span class="marker" id="mapping-178"></span><span class="token upd" id="move-dst-14" data-title="source_file/comment"><span class="cupd">/</span>*<span class="cupd"> </span><span class="cupd">p</span>ragma<span class="cupd"> </span><span class="cupd">solidity</span> ^0.4.<span class="cupd">2</span>4; */</span>

<span class="marker" id="mapping-179"></span><span class="token mv" id="move-dst-63" data-title="source_file/interface_declaration">interface IMetaDataTeller {
	function addTokenMeta(
		address _token,
		uint16 _grade,
		uint112 _strengthRate
	) external;

	//0xf666196d
	function getMetaData(address _token, uint256 _id)
		external
		view
		returns (
			uint16,
			uint16,
			uint16
		);

	//0x7999a5cf
	function getPrefer(address _token) external view returns (uint256);

	//0x33281815
	function getRate(
		address _token,
		uint256 _id,
		uint256 _index
	) external view returns (uint256);
}</span>

<span class="marker" id="mapping-180"></span><span class="token upd" id="move-dst-15" data-title="source_file/comment"><span class="cupd">//</span>////<span class="cupd"> </span>lib/common-cont<span class="cupd">ra</span>cts/contr<span class="cupd">a</span>ct<span class="cupd">s</span>/interfaces/IAuth<span class="cupd">o</span>r<span class="cupd">i</span><span class="cupd">ty</span>.sol</span>
<span class="marker" id="mapping-181"></span><span class="token upd" id="move-dst-16" data-title="source_file/comment"><span class="cupd">/</span>*<span class="cupd"> </span><span class="cupd">p</span><span class="cupd">r</span>agma<span class="cupd"> </span><span class="cupd">solidity</span> ^0.4.<span class="cupd">2</span>4; */</span>

<span class="marker" id="mapping-182"></span><span class="token mv" id="move-dst-36" data-title="source_file/contract_declaration">contract IAuthority {
    function canCall(
        address src, address dst, bytes4 sig
    ) public view returns (bool);
}</span>

<span class="marker" id="mapping-183"></span><span class="token upd" id="move-dst-23" data-title="source_file/comment"><span class="cupd">//</span>////<span class="cupd"> </span>lib/<span class="cupd">c</span><span class="cupd">o</span>mmo<span class="cupd">n</span><span class="cupd">-</span><span class="cupd">contracts/</span>co<span class="cupd">ntr</span>a<span class="cupd">ct</span>s<span class="cupd">/</span>D<span class="cupd">S</span>A<span class="cupd">u</span><span class="cupd">t</span><span class="cupd">h</span><span class="cupd">.sol</span></span>
<span class="marker" id="mapping-184"></span><span class="token upd" id="move-dst-24" data-title="source_file/comment"><span class="cupd">/</span>*<span class="cupd"> pragma solidity ^0.4.24;</span> */</span>

<span class="marker" id="mapping-185"></span><span class="token upd" id="move-dst-25" data-title="source_file/comment"><span class="cupd">/</span>*<span class="cupd"> import </span>'./<span class="cupd">in</span><span class="cupd">t</span>e<span class="cupd">r</span>f<span class="cupd">ac</span>e<span class="cupd">s/</span>IAu<span class="cupd">t</span>ho<span class="cupd">r</span>i<span class="cupd">t</span>y<span class="cupd">.sol</span>'; */</span>

<span class="marker" id="mapping-186"></span><span class="token mv" id="move-dst-40" data-title="source_file/contract_declaration">contract DSAuthEvents {
    event LogSetAuthority (address indexed authority);
    event LogSetOwner     (address indexed owner);
}</span>

<span class="marker" id="mapping-187"></span><span class="token upd" id="move-dst-26" data-title="source_file/comment"><span class="cupd">/**
 * @title</span> <span class="cupd">D</span>S<span class="cupd">A</span>uth
 * @dev The DSAuth<span class="cupd"> </span>co<span class="cupd">n</span>tr<span class="cupd">a</span>ct<span class="cupd"> </span>is<span class="cupd"> </span>re<span class="cupd">f</span>er<span class="cupd">en</span>c<span class="cupd">e</span> implem<span class="cupd">e</span>nt o<span class="cupd">f</span> https://github<span class="cupd">.</span>com/dap<span class="cupd">p</span>hub/ds-au<span class="cupd">th
</span> <span class="cupd">* </span>But i<span class="cupd">n</span> the isA<span class="cupd">ut</span>hori<span class="cupd">z</span>ed<span class="cupd"> </span>metho<span class="cupd">d</span>, <span class="cupd">t</span>he src<span class="cupd"> </span>fro<span class="cupd">m</span> addr<span class="cupd">e</span>s<span class="cupd">s</span>(<span class="cupd">thi</span>s)<span class="cupd"> </span>i<span class="cupd">s</span> r<span class="cupd">e</span><span class="cupd">m</span><span class="cupd">o</span>ve <span class="cupd">f</span><span class="cupd">o</span><span class="cupd">r</span> sa<span class="cupd">f</span>t<span class="cupd">y</span> c<span class="cupd">o</span>nc<span class="cupd">ern.</span>
 */</span>
<span class="marker" id="mapping-188"></span><span class="token mv" id="move-dst-42" data-title="source_file/contract_declaration">contract DSAuth is DSAuthEvents {
    IAuthority   public  authority;
    address      public  owner;

    constructor() public {
        owner = msg.sender;
        emit LogSetOwner(msg.sender);
    }

    function setOwner(address owner_)
        public
        auth
    {
        owner = owner_;
        emit LogSetOwner(owner);
    }

    function setAuthority(IAuthority authority_)
        public
        auth
    {
        authority = authority_;
        emit LogSetAuthority(authority);
    }

    modifier auth {
        require(isAuthorized(msg.sender, msg.sig));
        _;
    }

    modifier onlyOwner() {
        require(msg.sender == owner);
        _;
    }

    function isAuthorized(address src, bytes4 sig) internal view returns (bool) {
        if (src == owner) {
            return true;
        } else if (authority == IAuthority(0)) {
            return false;
        } else {
            return authority.canCall(src, this, sig);
        }
    }
}</span>

<span class="marker" id="mapping-189"></span><span class="token upd" id="move-dst-28" data-title="source_file/comment"><span class="cupd">//</span>////<span class="cupd"> </span>lib/z<span class="cupd">ep</span>p<span class="cupd">e</span>li<span class="cupd">n</span>-s<span class="cupd">ol</span><span class="cupd">i</span><span class="cupd">d</span>ity<span class="cupd">/co</span><span class="cupd">n</span><span class="cupd">tracts/int</span>rosp<span class="cupd">e</span><span class="cupd">c</span>t<span class="cupd">i</span>o<span class="cupd">n</span>/<span class="cupd">ERC</span>165<span class="cupd">.sol</span></span>
<span class="marker" id="mapping-190"></span><span class="token upd" id="move-dst-29" data-title="source_file/comment"><span class="cupd">/</span>*<span class="cupd"> pragma solidity ^0.4.2</span>4; */</span>


<span class="marker" id="mapping-191"></span><span class="token upd" id="move-dst-31" data-title="source_file/comment"><span class="cupd">/</span>**<span class="cupd"></span><span class="cupd">
</span> * @<span class="cupd">t</span>i<span class="cupd">tl</span><span class="cupd">e</span> ERC165
 <span class="cupd">*</span> <span class="cupd">@d</span>ev<span class="cupd"> </span>https:/<span class="cupd">/</span>githu<span class="cupd">b.c</span>om/ether<span class="cupd">e</span>um/EIPs/<span class="cupd">b</span>l<span class="cupd">o</span>b<span class="cupd">/</span><span class="cupd">m</span><span class="cupd">ast</span><span class="cupd">e</span>r<span class="cupd">/</span>E<span class="cupd">I</span>P<span class="cupd">S</span><span class="cupd">/</span>eip-165.md
 */</span>
<span class="marker" id="mapping-192"></span><span class="token mv" id="move-dst-8" data-title="source_file/interface_declaration">interface ERC165 {

  /**
   * @notice Query if a contract implements an interface
   * @param _interfaceId The interface identifier, as specified in ERC-165
   * @dev Interface identification is specified in ERC-165. This function
   * uses less than 30,000 gas.
   */
  function supportsInterface(bytes4 _interfaceId)
    external
    view
    returns (bool);
}</span>

<span class="marker" id="mapping-193"></span><span class="token upd" id="move-dst-32" data-title="source_file/comment"><span class="cupd">//</span>////<span class="cupd"> </span>lib/common-cont<span class="cupd">ra</span>cts/contr<span class="cupd">a</span>ct<span class="cupd">s</span>/<span class="cupd">i</span>nterfaces/IAct<span class="cupd">i</span>vi<span class="cupd">ty</span>.sol</span>
<span class="marker" id="mapping-194"></span><span class="token upd" id="move-dst-34" data-title="source_file/comment"><span class="cupd">/</span>*<span class="cupd"> </span><span class="cupd">p</span>ragma<span class="cupd"> </span>s<span class="cupd">ol</span><span class="cupd">i</span><span class="cupd">d</span><span class="cupd">i</span><span class="cupd">t</span><span class="cupd">y</span> ^0.4.24; */</span>

<span class="marker" id="mapping-195"></span><span class="token upd" id="move-dst-35" data-title="source_file/comment"><span class="cupd">/</span>*<span class="cupd"> </span>im<span class="cupd">p</span>o<span class="cupd">r</span>t<span class="cupd"> </span>"openzeppelin-<span class="cupd">solidity</span>/contracts/introspection/ERC165<span class="cupd">.</span>sol"; */</span>

<span class="marker" id="mapping-196"></span><span class="token mv" id="move-dst-52" data-title="source_file/contract_declaration">contract IActivity is ERC165 {
    bytes4 internal constant InterfaceId_IActivity = 0x6086e7f8; 
    /*
     * 0x6086e7f8 ===
     *   bytes4(keccak256('activityStopped(uint256)'))
     */

    function activityStopped(uint256 _tokenId) public;
}</span>

<span class="marker" id="mapping-197"></span><span class="token upd" id="move-dst-37" data-title="source_file/comment"><span class="cupd">//</span>////<span class="cupd"> </span><span class="cupd">l</span><span class="cupd">i</span>b<span class="cupd">/common</span>-contracts<span class="cupd">/contracts/</span>in<span class="cupd">t</span>erfaces/IInterstellarEncoder<span class="cupd">.sol</span></span>
<span class="marker" id="mapping-198"></span><span class="token upd" id="move-dst-38" data-title="source_file/comment"><span class="cupd">/</span>*<span class="cupd"> pragma solidity ^0.4.24;</span> */</span>

<span class="marker" id="mapping-199"></span><span class="token mv" id="move-dst-45" data-title="source_file/contract_declaration">contract IInterstellarEncoder {
    uint256 constant CLEAR_HIGH =  0x00000000000000000000000000000000ffffffffffffffffffffffffffffffff;

    uint256 public constant MAGIC_NUMBER = 42;    // Interstellar Encoding Magic Number.
    uint256 public constant CHAIN_ID = 1; // Ethereum mainet.
    uint256 public constant CURRENT_LAND = 1; // 1 is Atlantis, 0 is NaN.

    enum ObjectClass { 
        NaN,
        LAND,
        APOSTLE,
        OBJECT_CLASS_COUNT
    }

    function registerNewObjectClass(address _objectContract, uint8 objectClass) public;

    function registerNewTokenContract(address _tokenAddress) public;

    function encodeTokenId(address _tokenAddress, uint8 _objectClass, uint128 _objectIndex) public view returns (uint256 _tokenId);

    function encodeTokenIdForObjectContract(
        address _tokenAddress, address _objectContract, uint128 _objectId) public view returns (uint256 _tokenId);

    function getContractAddress(uint256 _tokenId) public view returns (address);

    function getObjectId(uint256 _tokenId) public view returns (uint128 _objectId);

    function getObjectClass(uint256 _tokenId) public view returns (uint8);

    function getObjectAddress(uint256 _tokenId) public view returns (address);
}</span>

<span class="marker" id="mapping-200"></span><span class="token upd" id="move-dst-39" data-title="source_file/comment"><span class="cupd">//</span>////<span class="cupd"> </span>l<span class="cupd">i</span>b<span class="cupd">/</span><span class="cupd">c</span><span class="cupd">o</span>mm<span class="cupd">o</span>n-<span class="cupd">c</span><span class="cupd">ontract</span><span class="cupd">s/</span><span class="cupd">co</span><span class="cupd">n</span><span class="cupd">tracts/interfaces/I</span>Mine<span class="cupd">r</span>Objec<span class="cupd">t</span><span class="cupd">.sol</span></span>
<span class="marker" id="mapping-201"></span><span class="token upd" id="move-dst-41" data-title="source_file/comment"><span class="cupd">/*</span><span class="cupd"> </span>p<span class="cupd">ra</span><span class="cupd">g</span><span class="cupd">m</span><span class="cupd">a</span><span class="cupd"> </span><span class="cupd">s</span><span class="cupd">o</span>l<span class="cupd">i</span><span class="cupd">d</span><span class="cupd">i</span><span class="cupd">ty </span>^0<span class="cupd">.</span>4.24;<span class="cupd"> </span><span class="cupd">*/</span></span>

<span class="marker" id="mapping-202"></span><span class="token upd" id="move-dst-43" data-title="source_file/comment"><span class="cupd">/</span>*<span class="cupd"> </span>im<span class="cupd">p</span>ort "op<span class="cupd">en</span>z<span class="cupd">e</span>pp<span class="cupd">e</span><span class="cupd">l</span><span class="cupd">i</span>n-s<span class="cupd">o</span><span class="cupd">l</span>i<span class="cupd">d</span>ity<span class="cupd">/co</span><span class="cupd">n</span><span class="cupd">tracts/int</span><span class="cupd">r</span>o<span class="cupd">s</span>p<span class="cupd">e</span>c<span class="cupd">t</span>ion/<span class="cupd">E</span>RC165<span class="cupd">.sol</span>"; */</span>

<span class="marker" id="mapping-203"></span><span class="token mv" id="move-dst-56" data-title="source_file/contract_declaration">contract IMinerObject is ERC165  {
    bytes4 internal constant InterfaceId_IMinerObject = 0x64272b75;
    
    /*
     * 0x64272b752 ===
     *   bytes4(keccak256('strengthOf(uint256,address)'))
     */

    function strengthOf(uint256 _tokenId, address _resourceToken, uint256 _landTokenId) public view returns (uint256);

}</span>

<span class="marker" id="mapping-204"></span><span class="token upd" id="move-dst-44" data-title="source_file/comment"><span class="cupd">//</span>////<span class="cupd"> </span>lib/common-cont<span class="cupd">ra</span>cts/contr<span class="cupd">a</span>ct<span class="cupd">s</span>/<span class="cupd">i</span>nterfaces/IM<span class="cupd">i</span>n<span class="cupd">t</span>ableERC2<span class="cupd">0.</span>sol</span>
<span class="marker" id="mapping-205"></span><span class="token upd" id="move-dst-46" data-title="source_file/comment"><span class="cupd">/</span>*<span class="cupd"> </span><span class="cupd">p</span>ragma<span class="cupd"> </span>s<span class="cupd">ol</span><span class="cupd">i</span><span class="cupd">d</span><span class="cupd">i</span><span class="cupd">t</span>y ^0.4.23; */</span>

<span class="marker" id="mapping-206"></span><span class="token mv" id="move-dst-30" data-title="source_file/contract_declaration">contract IMintableERC20 {

    function mint(address _to, uint256 _value) public;
}</span>

<span class="marker" id="mapping-207"></span><span class="token upd" id="move-dst-47" data-title="source_file/comment"><span class="cupd">//</span>////<span class="cupd"> </span>lib/common-cont<span class="cupd">ra</span>cts/contr<span class="cupd">a</span>ct<span class="cupd">s</span>/<span class="cupd">i</span>nterfaces/ISett<span class="cupd">i</span>ngsRegis<span class="cupd">t</span>r<span class="cupd">y</span>.sol</span>
<span class="marker" id="mapping-208"></span><span class="token upd" id="move-dst-49" data-title="source_file/comment"><span class="cupd">/</span>*<span class="cupd"> </span><span class="cupd">p</span>ragma<span class="cupd"> </span>s<span class="cupd">ol</span><span class="cupd">i</span><span class="cupd">d</span><span class="cupd">i</span><span class="cupd">t</span><span class="cupd">y</span> ^0.4.24; */</span>

<span class="marker" id="mapping-209"></span><span class="token mv" id="move-dst-33" data-title="source_file/contract_declaration">contract ISettingsRegistry {
    enum SettingsValueTypes { NONE, UINT, STRING, ADDRESS, BYTES, BOOL, INT }

    function uintOf(bytes32 _propertyName) public view returns (uint256);

    function stringOf(bytes32 _propertyName) public view returns (string);

    function addressOf(bytes32 _propertyName) public view returns (address);

    function bytesOf(bytes32 _propertyName) public view returns (bytes);

    function boolOf(bytes32 _propertyName) public view returns (bool);

    function intOf(bytes32 _propertyName) public view returns (int);

    function setUintProperty(bytes32 _propertyName, uint _value) public;

    function setStringProperty(bytes32 _propertyName, string _value) public;

    function setAddressProperty(bytes32 _propertyName, address _value) public;

    function setBytesProperty(bytes32 _propertyName, bytes _value) public;

    function setBoolProperty(bytes32 _propertyName, bool _value) public;

    function setIntProperty(bytes32 _propertyName, int _value) public;

    function getValueTypeOf(bytes32 _propertyName) public view returns (uint /* SettingsValueTypes */ );

    event ChangeProperty(bytes32 indexed _propertyName, uint256 _type);
}</span>

<span class="marker" id="mapping-210"></span><span class="token upd" id="move-dst-50" data-title="source_file/comment"><span class="cupd">//</span>////<span class="cupd"> </span>lib/common-cont<span class="cupd">ra</span>cts/contr<span class="cupd">a</span>ct<span class="cupd">s</span>/<span class="cupd">i</span>n<span class="cupd">t</span>erfaces/ITokenUse.sol</span>
<span class="marker" id="mapping-211"></span><span class="token upd" id="move-dst-51" data-title="source_file/comment"><span class="cupd">/</span>*<span class="cupd"> </span><span class="cupd">p</span><span class="cupd">r</span>agma<span class="cupd"> </span><span class="cupd">solidity</span> ^0<span class="cupd">.</span>4.24; */</span>

<span class="marker" id="mapping-212"></span><span class="token mv" id="move-dst-48" data-title="source_file/contract_declaration">contract ITokenUse {
    uint48 public constant MAX_UINT48_TIME = 281474976710655;

    function isObjectInHireStage(uint256 _tokenId) public view returns (bool);

    function isObjectReadyToUse(uint256 _tokenId) public view returns (bool);

    function getTokenUser(uint256 _tokenId) public view returns (address);

    function createTokenUseOffer(uint256 _tokenId, uint256 _duration, uint256 _price, address _acceptedActivity) public;

    function cancelTokenUseOffer(uint256 _tokenId) public;

    function takeTokenUseOffer(uint256 _tokenId) public;

    function addActivity(uint256 _tokenId, address _user, uint256 _endTime) public;

    function removeActivity(uint256 _tokenId, address _user) public;
}</span>

<span class="marker" id="mapping-213"></span><span class="token upd" id="move-dst-53" data-title="source_file/comment"><span class="cupd">//</span>////<span class="cupd"> </span>lib/z<span class="cupd">ep</span>p<span class="cupd">e</span>li<span class="cupd">n</span>-s<span class="cupd">ol</span><span class="cupd">i</span><span class="cupd">d</span>ity<span class="cupd">/co</span><span class="cupd">n</span><span class="cupd">tracts/int</span>rosp<span class="cupd">e</span>ction/Suppo<span class="cupd">r</span>t<span class="cupd">s</span><span class="cupd">I</span><span class="cupd">n</span>t<span class="cupd">er</span>fac<span class="cupd">e</span>Wi<span class="cupd">t</span>hLookup<span class="cupd">.sol</span></span>
<span class="marker" id="mapping-214"></span><span class="token upd" id="move-dst-54" data-title="source_file/comment"><span class="cupd">/</span>*<span class="cupd"> pragma solidity ^0.4.24;</span> */</span>

<span class="marker" id="mapping-215"></span><span class="token upd" id="move-dst-55" data-title="source_file/comment"><span class="cupd">/</span>*<span class="cupd"> import "</span>.<span class="cupd">/</span><span class="cupd">ERC165.sol";</span> */</span>


<span class="marker" id="mapping-216"></span><span class="token upd" id="move-dst-57" data-title="source_file/comment"><span class="cupd">/</span>**<span class="cupd"></span><span class="cupd">
</span> * @<span class="cupd">t</span>i<span class="cupd">tl</span><span class="cupd">e</span> Sup<span class="cupd">p</span><span class="cupd">o</span><span class="cupd">rt</span>s<span class="cupd">Interfac</span>eWit<span class="cupd">h</span>Lookup
 *<span class="cupd"> </span>@author Matt <span class="cupd">Co</span>ndon <span class="cupd">(</span>@shrugs)
 *<span class="cupd"> </span>@dev Implem<span class="cupd">e</span>nts ERC165 using <span class="cupd">a</span> lookup table.
 */</span>
<span class="marker" id="mapping-217"></span><span class="token mv" id="move-dst-27" data-title="source_file/contract_declaration">contract SupportsInterfaceWithLookup is ERC165 {

  bytes4 public constant InterfaceId_ERC165 = 0x01ffc9a7;
  /**
   * 0x01ffc9a7 ===
   *   bytes4(keccak256('supportsInterface(bytes4)'))
   */

  /**
   * @dev a mapping of interface id to whether or not it's supported
   */
  mapping(bytes4 =&gt; bool) internal supportedInterfaces;

  /**
   * @dev A contract implementing SupportsInterfaceWithLookup
   * implement ERC165 itself
   */
  constructor()
    public
  {
    _registerInterface(InterfaceId_ERC165);
  }

  /**
   * @dev implement supportsInterface(bytes4) using a lookup table
   */
  function supportsInterface(bytes4 _interfaceId)
    external
    view
    returns (bool)
  {
    return supportedInterfaces[_interfaceId];
  }

  /**
   * @dev private method for registering an interface
   */
  function _registerInterface(bytes4 _interfaceId)
    internal
  {
    require(_interfaceId != 0xffffffff);
    supportedInterfaces[_interfaceId] = true;
  }
}</span>

<span class="marker" id="mapping-218"></span><span class="token upd" id="move-dst-58" data-title="source_file/comment"><span class="cupd">//</span>////<span class="cupd"> </span>lib/ze<span class="cupd">p</span>pelin-<span class="cupd">solidity</span>/contracts/math/SafeMath.sol</span>
<span class="marker" id="mapping-219"></span><span class="token upd" id="move-dst-61" data-title="source_file/comment"><span class="cupd">/</span>*<span class="cupd"> </span><span class="cupd">p</span><span class="cupd">ra</span>gma <span class="cupd">s</span>ol<span class="cupd">i</span>di<span class="cupd">t</span>y ^0.4.24; */</span>


<span class="marker" id="mapping-220"></span><span class="token mv" id="move-dst-3" data-title="source_file/comment">/**
 * @title SafeMath
 * @dev Math operations with safety checks that throw on error
 */</span>
<span class="marker" id="mapping-221"></span><span class="token mv" id="move-dst-4" data-title="source_file/library_declaration">library SafeMath {

  /**
  * @dev Multiplies two numbers, throws on overflow.
  */
  function mul(uint256 _a, uint256 _b) internal pure returns (uint256 c) {
    // Gas optimization: this is cheaper than asserting 'a' not being zero, but the
    // benefit is lost if 'b' is also tested.
    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522
    if (_a == 0) {
      return 0;
    }

    c = _a * _b;
    assert(c / _a == _b);
    return c;
  }

  /**
  * @dev Integer division of two numbers, truncating the quotient.
  */
  function div(uint256 _a, uint256 _b) internal pure returns (uint256) {
    // assert(_b &gt; 0); // Solidity automatically throws when dividing by 0
    // uint256 c = _a / _b;
    // assert(_a == _b * c + _a % _b); // There is no case in which this doesn't hold
    return _a / _b;
  }

  /**
  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).
  */
  function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {
    assert(_b &lt;= _a);
    return _a - _b;
  }

  /**
  * @dev Adds two numbers, throws on overflow.
  */
  function add(uint256 _a, uint256 _b) internal pure returns (uint256 c) {
    c = _a + _b;
    assert(c &gt;= _a);
    return c;
  }
}</span>

<span class="marker" id="mapping-222"></span><span class="token upd" id="move-dst-62" data-title="source_file/comment"><span class="cupd">//</span>////<span class="cupd"> </span>lib/ze<span class="cupd">p</span>pelin-<span class="cupd">solidity</span>/contracts/token/ERC721/ERC721Basic.sol</span>
<span class="marker" id="mapping-223"></span><span class="token upd" id="move-dst-64" data-title="source_file/comment"><span class="cupd">/</span>*<span class="cupd"> </span>p<span class="cupd">ra</span>gm<span class="cupd">a</span> <span class="cupd">so</span>lidity ^0.4.24; */</span>

<span class="marker" id="mapping-224"></span><span class="token upd" id="move-dst-66" data-title="source_file/comment"><span class="cupd">/</span>*<span class="cupd"> import "</span>../../intr<span class="cupd">o</span>s<span class="cupd">pe</span>ct<span class="cupd">i</span><span class="cupd">o</span><span class="cupd">n</span><span class="cupd">/</span>ERC165<span class="cupd">.sol";</span> */</span>


<span class="marker" id="mapping-225"></span><span class="token mv" id="move-dst-12" data-title="source_file/comment">/**
 * @title ERC721 Non-Fungible Token Standard basic interface
 * @dev see https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md
 */</span>
<span class="marker" id="mapping-226"></span><span class="token mv" id="move-dst-13" data-title="source_file/contract_declaration">contract ERC721Basic is ERC165 {

  bytes4 internal constant InterfaceId_ERC721 = 0x80ac58cd;
  /*
   * 0x80ac58cd ===
   *   bytes4(keccak256('balanceOf(address)')) ^
   *   bytes4(keccak256('ownerOf(uint256)')) ^
   *   bytes4(keccak256('approve(address,uint256)')) ^
   *   bytes4(keccak256('getApproved(uint256)')) ^
   *   bytes4(keccak256('setApprovalForAll(address,bool)')) ^
   *   bytes4(keccak256('isApprovedForAll(address,address)')) ^
   *   bytes4(keccak256('transferFrom(address,address,uint256)')) ^
   *   bytes4(keccak256('safeTransferFrom(address,address,uint256)')) ^
   *   bytes4(keccak256('safeTransferFrom(address,address,uint256,bytes)'))
   */

  bytes4 internal constant InterfaceId_ERC721Exists = 0x4f558e79;
  /*
   * 0x4f558e79 ===
   *   bytes4(keccak256('exists(uint256)'))
   */

  bytes4 internal constant InterfaceId_ERC721Enumerable = 0x780e9d63;
  /**
   * 0x780e9d63 ===
   *   bytes4(keccak256('totalSupply()')) ^
   *   bytes4(keccak256('tokenOfOwnerByIndex(address,uint256)')) ^
   *   bytes4(keccak256('tokenByIndex(uint256)'))
   */

  bytes4 internal constant InterfaceId_ERC721Metadata = 0x5b5e139f;
  /**
   * 0x5b5e139f ===
   *   bytes4(keccak256('name()')) ^
   *   bytes4(keccak256('symbol()')) ^
   *   bytes4(keccak256('tokenURI(uint256)'))
   */

  event Transfer(
    address indexed _from,
    address indexed _to,
    uint256 indexed _tokenId
  );
  event Approval(
    address indexed _owner,
    address indexed _approved,
    uint256 indexed _tokenId
  );
  event ApprovalForAll(
    address indexed _owner,
    address indexed _operator,
    bool _approved
  );

  function balanceOf(address _owner) public view returns (uint256 _balance);
  function ownerOf(uint256 _tokenId) public view returns (address _owner);
  function exists(uint256 _tokenId) public view returns (bool _exists);

  function approve(address _to, uint256 _tokenId) public;
  function getApproved(uint256 _tokenId)
    public view returns (address _operator);

  function setApprovalForAll(address _operator, bool _approved) public;
  function isApprovedForAll(address _owner, address _operator)
    public view returns (bool);

  function transferFrom(address _from, address _to, uint256 _tokenId) public;
  function safeTransferFrom(address _from, address _to, uint256 _tokenId)
    public;

  function safeTransferFrom(
    address _from,
    address _to,
    uint256 _tokenId,
    bytes _data
  )
    public;
}</span>

<span class="marker" id="mapping-227"></span><span class="token upd" id="move-dst-67" data-title="source_file/comment"><span class="cupd">//</span>////<span class="cupd"> </span>l<span class="cupd">i</span>b/<span class="cupd">zeppelin-solidity/contracts/token/ERC721/ERC721.sol</span></span>
<span class="marker" id="mapping-228"></span><span class="token upd" id="move-dst-68" data-title="source_file/comment"><span class="cupd">/</span>*<span class="cupd"> </span><span class="cupd">p</span><span class="cupd">r</span>agma<span class="cupd"> </span><span class="cupd">solidity</span> ^0<span class="cupd">.</span>4.24; */</span>

<span class="marker" id="mapping-229"></span><span class="token upd" id="move-dst-69" data-title="source_file/comment"><span class="cupd">/</span>*<span class="cupd"> import "</span>.<span class="cupd">/</span>ERC721B<span class="cupd">a</span><span class="cupd">s</span><span class="cupd">i</span><span class="cupd">c</span><span class="cupd">.sol";</span> */</span>


<span class="marker" id="mapping-230"></span><span class="token mv" id="move-dst-17" data-title="source_file/comment">/**
 * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension
 * @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md
 */</span>
<span class="marker" id="mapping-231"></span><span class="token mv" id="move-dst-18" data-title="source_file/contract_declaration">contract ERC721Enumerable is ERC721Basic {
  function totalSupply() public view returns (uint256);
  function tokenOfOwnerByIndex(
    address _owner,
    uint256 _index
  )
    public
    view
    returns (uint256 _tokenId);

  function tokenByIndex(uint256 _index) public view returns (uint256);
}</span>


<span class="marker" id="mapping-232"></span><span class="token mv" id="move-dst-19" data-title="source_file/comment">/**
 * @title ERC-721 Non-Fungible Token Standard, optional metadata extension
 * @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md
 */</span>
<span class="marker" id="mapping-233"></span><span class="token mv" id="move-dst-20" data-title="source_file/contract_declaration">contract ERC721Metadata is ERC721Basic {
  function name() external view returns (string _name);
  function symbol() external view returns (string _symbol);
  function tokenURI(uint256 _tokenId) public view returns (string);
}</span>


<span class="marker" id="mapping-234"></span><span class="token mv" id="move-dst-21" data-title="source_file/comment">/**
 * @title ERC-721 Non-Fungible Token Standard, full implementation interface
 * @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md
 */</span>
<span class="marker" id="mapping-235"></span><span class="token mv" id="move-dst-22" data-title="source_file/contract_declaration">contract ERC721 is ERC721Basic, ERC721Enumerable, ERC721Metadata {
}</span>

<span class="marker" id="mapping-236"></span><span class="token upd" id="move-dst-70" data-title="source_file/comment"><span class="cupd">//</span><span class="cupd">/</span><span class="cupd">/</span>// <span class="cupd">contracts/</span>L<span class="cupd">a</span><span class="cupd">n</span>d<span class="cupd">Re</span><span class="cupd">s</span>ou<span class="cupd">r</span>ceV6<span class="cupd">.sol</span></span>
<span class="marker" id="mapping-237"></span><span class="token upd" id="move-dst-71" data-title="source_file/comment"><span class="cupd">/</span>*<span class="cupd"> </span><span class="cupd">p</span><span class="cupd">r</span>agma<span class="cupd"> </span>s<span class="cupd">ol</span><span class="cupd">i</span><span class="cupd">d</span>i<span class="cupd">t</span>y ^0<span class="cupd">.</span>4.24; */</span>

<span class="marker" id="mapping-238"></span><span class="token upd" id="move-dst-72" data-title="source_file/comment"><span class="cupd">/</span>*<span class="cupd"> import "</span>op<span class="cupd">e</span>nzeppe<span class="cupd">l</span><span class="cupd">i</span>n-s<span class="cupd">o</span><span class="cupd">l</span>i<span class="cupd">d</span>ity<span class="cupd">/co</span><span class="cupd">n</span><span class="cupd">tracts/</span>ma<span class="cupd">t</span>h/Saf<span class="cupd">e</span>M<span class="cupd">a</span><span class="cupd">t</span>h<span class="cupd">.sol";</span> */</span>
<span class="marker" id="mapping-239"></span><span class="token upd" id="move-dst-73" data-title="source_file/comment"><span class="cupd">/</span>*<span class="cupd"> import "</span>op<span class="cupd">e</span>nzeppe<span class="cupd">l</span><span class="cupd">i</span>n-s<span class="cupd">o</span><span class="cupd">l</span>i<span class="cupd">d</span>ity<span class="cupd">/co</span><span class="cupd">n</span><span class="cupd">tracts/</span><span class="cupd">t</span><span class="cupd">oken</span>/ERC721/ERC721<span class="cupd">.sol";</span> */</span>
<span class="marker" id="mapping-240"></span><span class="token upd" id="move-dst-74" data-title="source_file/comment"><span class="cupd">/</span>*<span class="cupd"> import "</span>op<span class="cupd">e</span>nzeppe<span class="cupd">l</span><span class="cupd">i</span>n-s<span class="cupd">o</span><span class="cupd">l</span>i<span class="cupd">d</span>ity<span class="cupd">/co</span><span class="cupd">n</span><span class="cupd">tracts/int</span>rosp<span class="cupd">e</span>ction/Suppo<span class="cupd">r</span>tsInter<span class="cupd">face</span>W<span class="cupd">i</span><span class="cupd">t</span>hLookup<span class="cupd">.sol";</span> */</span>
<span class="marker" id="mapping-241"></span><span class="token upd" id="move-dst-75" data-title="source_file/comment"><span class="cupd">/</span>*<span class="cupd"> import "@evolutionland/common/contracts/interfaces/IMin</span>ta<span class="cupd">b</span>l<span class="cupd">e</span>ERC20<span class="cupd">.sol";</span> */</span>
<span class="marker" id="mapping-242"></span><span class="token upd" id="move-dst-76" data-title="source_file/comment"><span class="cupd">/</span>*<span class="cupd"> import "</span>@evolutionland/<span class="cupd">co</span>mmo<span class="cupd">n</span>/con<span class="cupd">tracts/interfaces/I</span>Setti<span class="cupd">n</span>g<span class="cupd">s</span>R<span class="cupd">e</span>gistry<span class="cupd">.sol";</span> */</span>
<span class="marker" id="mapping-243"></span><span class="token upd" id="move-dst-77" data-title="source_file/comment"><span class="cupd">/</span>*<span class="cupd"> import "</span>@ev<span class="cupd">o</span>lutio<span class="cupd">n</span>l<span class="cupd">a</span>nd/<span class="cupd">c</span>ommon<span class="cupd">/</span>co<span class="cupd">nt</span><span class="cupd">r</span><span class="cupd">ac</span>t<span class="cupd">s/</span><span class="cupd">D</span>SAu<span class="cupd">t</span>h<span class="cupd">.sol";</span> */</span>
<span class="marker" id="mapping-244"></span><span class="token add" data-title="source_file/comment">/* import "@evolutionland/common/contracts/interfaces/IInterstellarEncoder.sol"; */</span>
<span class="marker" id="mapping-245"></span><span class="token add" data-title="source_file/comment">/* import "@evolutionland/common/contracts/interfaces/ITokenUse.sol"; */</span>
<span class="marker" id="mapping-246"></span><span class="token add" data-title="source_file/comment">/* import "@evolutionland/common/contracts/interfaces/IActivity.sol"; */</span>
<span class="marker" id="mapping-247"></span><span class="token add" data-title="source_file/comment">/* import "@evolutionland/common/contracts/interfaces/IMinerObject.sol"; */</span>
<span class="marker" id="mapping-248"></span><span class="token add" data-title="source_file/comment">/* import "./interfaces/ILandBase.sol"; */</span>
<span class="marker" id="mapping-249"></span><span class="token add" data-title="source_file/comment">/* import "./interfaces/ILandBaseExt.sol"; */</span>
<span class="marker" id="mapping-250"></span><span class="token add" data-title="source_file/comment">/* import "./interfaces/IMetaDataTeller.sol"; */</span>

<span class="marker" id="mapping-251"></span><span class="token add" data-title="source_file/comment">// DSAuth see https://github.com/evolutionlandorg/common-contracts/blob/2873a4f8f970bd442ffcf9c6ae63b3dc79e743db/contracts/DSAuth.sol#L40</span>
contract <span class="marker" id="mapping-252"></span><span class="token upd" id="move-dst-78" data-title="contract_declaration/identifier"><span class="cupd">LandResourceV</span>6</span> is SupportsInterfaceWithLookup, DSAuth, IActivity {
	using SafeMath for *;

	// For every seconds, the speed will decrease by current speed multiplying (DENOMINATOR_in_seconds - seconds) / DENOMINATOR_in_seconds
	// resource will decrease 1/10000 every day.
	uint256 public constant DENOMINATOR = 10000;

	uint256 public constant TOTAL_SECONDS = DENOMINATOR * (1 days);

	bool private singletonLock = false;

	ISettingsRegistry public registry;

	uint256 public resourceReleaseStartTime;

	// TODO: move to global settings contract.
	uint256 public attenPerDay = 1;
	uint256 public recoverAttenPerDay = 20;

	// Struct for recording resouces on land which have already been pinged.
	// 金, Evolution Land Gold
	// 木, Evolution Land Wood
	// 水, Evolution Land Water
	// 火, Evolution Land fire
	// 土, Evolution Land Silicon
	struct ResourceMineState {
		mapping(address =&gt; uint256) mintedBalance;
		mapping(address =&gt; uint256[]) miners;
		mapping(address =&gt; uint256) totalMinerStrength;
		uint256 lastUpdateSpeedInSeconds;
		uint256 lastDestoryAttenInSeconds;
		uint256 industryIndex;
		uint128 lastUpdateTime;
		uint64 totalMiners;
		uint64 maxMiners;
	}

	struct MinerStatus {
		uint256 landTokenId;
		address resource;
		uint64 indexInResource;
	}

	mapping(uint256 =&gt; ResourceMineState) public land2ResourceMineState;
	mapping(uint256 =&gt; MinerStatus) public miner2Index;

	/*
	 *  Event
	 */

	event StartMining(
		uint256 minerTokenId,
		uint256 landId,
		address _resource,
		uint256 strength
	);
	event StopMining(
		uint256 minerTokenId,
		uint256 landId,
		address _resource,
		uint256 strength
	);
	event ResourceClaimed(
		address owner,
		uint256 landTokenId,
		uint256 goldBalance,
		uint256 woodBalance,
		uint256 waterBalance,
		uint256 fireBalance,
		uint256 soilBalance
	);
	event UpdateMiningStrengthWhenStop(
		uint256 apostleTokenId,
		uint256 landId,
		uint256 strength
	);
	event UpdateMiningStrengthWhenStart(
		uint256 apostleTokenId,
		uint256 landId,
		uint256 strength
	);

	// v5 add begin
	event StartBarMining(
		uint256 barIndex,
		uint256 landId,
		address resource,
		uint256 rate
	);
	event StopBarMining(uint256 barIndex, uint256 landId, address rate);
	event LandResourceClaimed(
		address owner,
		uint256 landId,
		uint256 goldBalance,
		uint256 woodBalance,
		uint256 waterBalance,
		uint256 fireBalance,
		uint256 soilBalance
	);
	event ItemResourceClaimed(
		address owner,
		address itemToken,
		uint256 itemTokenId,
		uint256 goldBalance,
		uint256 woodBalance,
		uint256 waterBalance,
		uint256 fireBalance,
		uint256 soilBalance
	);

	// land item bar
	event Equip(
		uint256 indexed tokenId,
		address resource,
		uint256 index,
		address staker,
		address token,
		uint256 id
	);
	event Divest(
		uint256 indexed tokenId,
		address resource,
		uint256 index,
		address staker,
		address token,
		uint256 id
	);

    	<span class="marker" id="mapping-253"></span><span class="token add" data-title="contract_body/event_definition">event SetMaxLandBar(uint256 maxAmount);</span>
    	<span class="marker" id="mapping-254"></span><span class="token add" data-title="contract_body/event_definition">event SetMaxMiner(uint256 maxMiners);</span>

	// 0x434f4e54524143545f4c414e445f424153450000000000000000000000000000
	bytes32 public constant CONTRACT_LAND_BASE = "CONTRACT_LAND_BASE";

	// 0x434f4e54524143545f474f4c445f45524332305f544f4b454e00000000000000
	bytes32 public constant CONTRACT_GOLD_ERC20_TOKEN =
		"CONTRACT_GOLD_ERC20_TOKEN";

	// 0x434f4e54524143545f574f4f445f45524332305f544f4b454e00000000000000
	bytes32 public constant CONTRACT_WOOD_ERC20_TOKEN =
		"CONTRACT_WOOD_ERC20_TOKEN";

	// 0x434f4e54524143545f57415445525f45524332305f544f4b454e000000000000
	bytes32 public constant CONTRACT_WATER_ERC20_TOKEN =
		"CONTRACT_WATER_ERC20_TOKEN";

	// 0x434f4e54524143545f464952455f45524332305f544f4b454e00000000000000
	bytes32 public constant CONTRACT_FIRE_ERC20_TOKEN =
		"CONTRACT_FIRE_ERC20_TOKEN";

	// 0x434f4e54524143545f534f494c5f45524332305f544f4b454e00000000000000
	bytes32 public constant CONTRACT_SOIL_ERC20_TOKEN =
		"CONTRACT_SOIL_ERC20_TOKEN";

	// 0x434f4e54524143545f494e5445525354454c4c41525f454e434f444552000000
	bytes32 public constant CONTRACT_INTERSTELLAR_ENCODER =
		"CONTRACT_INTERSTELLAR_ENCODER";

	// 0x434f4e54524143545f4f424a4543545f4f574e45525348495000000000000000
	bytes32 public constant CONTRACT_OBJECT_OWNERSHIP =
		"CONTRACT_OBJECT_OWNERSHIP";

	// 0x434f4e54524143545f544f4b454e5f5553450000000000000000000000000000
	bytes32 public constant CONTRACT_TOKEN_USE = "CONTRACT_TOKEN_USE";

	//0x4655524e4143455f4954454d5f4d494e455f4645450000000000000000000000
	bytes32 public constant FURNACE_ITEM_MINE_FEE = "FURNACE_ITEM_MINE_FEE";

	// 0x434f4e54524143545f4d455441444154415f54454c4c45520000000000000000
	bytes32 public constant CONTRACT_METADATA_TELLER =
		"CONTRACT_METADATA_TELLER";

	// 0x55494e545f4954454d4241525f50524f544543545f504552494f440000000000
	bytes32 public constant UINT_ITEMBAR_PROTECT_PERIOD =
		"UINT_ITEMBAR_PROTECT_PERIOD";

	// rate precision
	uint128 public constant RATE_PRECISION = 10**8;

	uint256 public maxMiners;

	// (itemTokenAddress =&gt; (itemTokenId =&gt; (resourceAddress =&gt; mined balance)))
	mapping(address =&gt; mapping(uint256 =&gt; mapping(address =&gt; uint256)))
		public itemMinedBalance;

	// (landTokenId =&gt; (resourceAddress =&gt; (landBarIndex =&gt; itemEnhancedRate)))
	mapping(uint256 =&gt; mapping(address =&gt; mapping(uint256 =&gt; uint256)))
		public land2BarRate;

	<span class="marker" id="mapping-255"></span><span class="token mv" id="move-dst-80" data-title="contract_body/comment"><span class="marker" id="mapping-256"></span><span class="token upd" id="move-dst-80" data-title="contract_body/comment"><span class="cupd">// </span><span class="cupd">land </span>bar</span></span>
	struct Bar {
		address staker;
		address token;
		uint256 id;
		address resource;
	}

	<span class="marker" id="mapping-257"></span><span class="token mv" id="move-dst-82" data-title="contract_body/comment"><span class="marker" id="mapping-258"></span><span class="token upd" id="move-dst-82" data-title="contract_body/comment"><span class="cupd">// </span>b<span class="cupd">a</span>r<span class="cupd"> </span>s<span class="cupd">t</span>atus</span></span>
	struct Status {
		address staker;
		uint256 <span class="marker" id="mapping-259"></span><span class="token upd" id="move-dst-85" data-title="struct_member/identifier">t<span class="cupd">okenId</span></span>;
		uint256 index;
	}

	// max land bar amount
	uint256 public maxAmount;
	// (landTokenId =&gt; (landBarIndex =&gt; BAR))
	mapping(uint256 =&gt; mapping(uint256 =&gt; Bar)) public landId2Bars;
	// (itemTokenAddress =&gt; (itemTokenId =&gt; STATUS))
	mapping(address =&gt; mapping(uint256 =&gt; Status)) public itemId2Status;
	// (itemTokenAddress =&gt; (itemTokenId =&gt; itemProtectPeriod))
	mapping(address =&gt; mapping(uint256 =&gt; uint256)) public protectPeriod;
	// v5 add end

	/*
	 *  Modifiers
	 */
	modifier singletonLockCall() {
		require(!singletonLock, "Only can call once");
		_;
		singletonLock = true;
	}

    	<span class="marker" id="mapping-260"></span><span class="token mv" id="move-dst-84" data-title="contract_body/comment"><span class="marker" id="mapping-261"></span><span class="token upd" id="move-dst-84" data-title="contract_body/comment"><span class="cupd">// </span>i<span class="cupd">n</span><span class="cupd">it</span>ializ<span class="cupd">e</span>Contract<span class="cupd"> b</span>e c<span class="cupd">a</span>lled by p<span class="cupd">r</span>oxy<span class="cupd"> </span>con<span class="cupd">t</span>r<span class="cupd">a</span>ct</span></span>
    	<span class="marker" id="mapping-262"></span><span class="token mv" id="move-dst-106" data-title="contract_body/comment"><span class="marker" id="mapping-263"></span><span class="token upd" id="move-dst-106" data-title="contract_body/comment"><span class="cupd">/</span>/<span class="cupd"> </span>s<span class="cupd">e</span><span class="cupd">e</span><span class="cupd"> </span>h<span class="cupd">t</span>t<span class="cupd">p</span><span class="cupd">s</span>://b<span class="cupd">l</span>og<span class="cupd">.</span>o<span class="cupd">p</span><span class="cupd">en</span>z<span class="cupd">e</span><span class="cupd">p</span><span class="cupd">p</span><span class="cupd">e</span>l<span class="cupd">i</span>n.<span class="cupd">c</span>om/t<span class="cupd">h</span><span class="cupd">e</span>-<span class="cupd">t</span><span class="cupd">ra</span><span class="cupd">n</span>s<span class="cupd">par</span><span class="cupd">en</span>t-p<span class="cupd">r</span><span class="cupd">o</span>xy-<span class="cupd">p</span><span class="cupd">a</span>tte<span class="cupd">r</span><span class="cupd">n</span>/</span></span>
	function initializeContract(
		address _registry,
		uint256 _resourceReleaseStartTime
	) public singletonLockCall {
        <span class="marker" id="mapping-264"></span><span class="token add" data-title="function_body/expression_statement"><span class="marker" id="mapping-265"></span><span class="token add" data-title="expression_statement/call_expression">require(<span class="marker" id="mapping-266"></span><span class="token add" data-title="call_expression/call_argument"><span class="marker" id="mapping-267"></span><span class="token add" data-title="call_argument/binary_expression">_registry!= <span class="marker" id="mapping-268"></span><span class="token add" data-title="binary_expression/type_cast_expression"><span class="marker" id="mapping-269"></span><span class="token mv" id="move-dst-99" data-title="type_cast_expression/primitive_type">address</span>(<span class="marker" id="mapping-270"></span><span class="token add" data-title="type_cast_expression/call_argument">0</span>)</span></span></span>, <span class="marker" id="mapping-271"></span><span class="token add" data-title="call_expression/call_argument">"_registry is a zero value"</span>)</span>;</span>
		// Ownable constructor
		owner = msg.sender;
		emit LogSetOwner(msg.sender);

		registry = ISettingsRegistry(_registry);

		resourceReleaseStartTime = _resourceReleaseStartTime;

        	<span class="marker" id="mapping-272"></span><span class="token add" data-title="function_body/comment">//see https://github.com/evolutionlandorg/common-contracts/blob/2873a4f8f970bd442ffcf9c6ae63b3dc79e743db/contracts/interfaces/IActivity.sol#L6</span>
		_registerInterface(InterfaceId_IActivity);

        	<span class="marker" id="mapping-273"></span><span class="token add" data-title="function_body/expression_statement">maxMiners = 5;</span>
        	<span class="marker" id="mapping-274"></span><span class="token add" data-title="function_body/expression_statement">maxAmount = 5;</span>
	}

	// get amount of speed uint at this moment
	function _getReleaseSpeedInSeconds(uint256 _tokenId, uint256 _time)
		internal
		view
		returns (uint256 currentSpeed)
	{
		require(_time &gt;= resourceReleaseStartTime, "Should after release time");
		require(
			_time &gt;= land2ResourceMineState[_tokenId].lastUpdateTime,
			"Should after release last update time"
		);

		// after 10000 days from start
		// the resource release speed decreases to 0
		if (TOTAL_SECONDS &lt; _time - resourceReleaseStartTime) {
			return 0;
		}

		// max amount of speed unit of _tokenId for now
		// suppose that speed_uint = 1 in this function
		uint256 availableSpeedInSeconds =
			TOTAL_SECONDS.sub(_time - resourceReleaseStartTime);
		return availableSpeedInSeconds;
		// // time from last update
		// uint256 timeBetween =
		// 	_time - land2ResourceMineState[_tokenId].lastUpdateTime;

		// // the recover speed is 20/10000, 20 times.
		// // recoveryRate overall from lasUpdateTime til now + amount of speed uint at lastUpdateTime
		// uint256 nextSpeedInSeconds =
		// 	land2ResourceMineState[_tokenId].lastUpdateSpeedInSeconds +
		// 		timeBetween *
		// 		recoverAttenPerDay;
		// // destroyRate overall from lasUpdateTime til now amount of speed uint at lastUpdateTime
		// uint256 destroyedSpeedInSeconds =
		// 	timeBetween *
		// 		land2ResourceMineState[_tokenId].lastDestoryAttenInSeconds;

		// if (nextSpeedInSeconds &lt; destroyedSpeedInSeconds) {
		// 	nextSpeedInSeconds = 0;
		// } else {
		// 	nextSpeedInSeconds = nextSpeedInSeconds - destroyedSpeedInSeconds;
		// }

		// if (nextSpeedInSeconds &gt; availableSpeedInSeconds) {
		// 	nextSpeedInSeconds = availableSpeedInSeconds;
		// }

		// return nextSpeedInSeconds;
	}

	function getReleaseSpeed(
		uint256 _tokenId,
		address _resource,
		uint256 _time
	) public view returns (uint256 currentSpeed) {
		return
			ILandBase(registry.addressOf(CONTRACT_LAND_BASE))
				.getResourceRate(_tokenId, _resource)
				.mul(_getReleaseSpeedInSeconds(_tokenId, _time))
				.mul(1 ether)
				.div(TOTAL_SECONDS);
	}

	<span class="marker" id="mapping-275"></span><span class="token mv" id="move-dst-108" data-title="contract_body/comment"><span class="marker" id="mapping-276"></span><span class="token upd" id="move-dst-108" data-title="contract_body/comment"><span class="cupd">//</span><span class="cupd"> </span>For <span class="cupd">e</span>very seconds, the s<span class="cupd">p</span>eed<span class="cupd"> </span>will dec<span class="cupd">r</span>ease by c<span class="cupd">u</span>rrent speed mu<span class="cupd">l</span>tiplying (DENOMINATOR_in_s<span class="cupd">e</span>conds - seconds) / DENOMINATOR_in_seconds.</span></span>
	<span class="marker" id="mapping-277"></span><span class="token mv" id="move-dst-110" data-title="contract_body/comment"><span class="marker" id="mapping-278"></span><span class="token upd" id="move-dst-110" data-title="contract_body/comment"><span class="cupd">//</span><span class="cupd"> </span>r<span class="cupd">e</span>s<span class="cupd">ou</span><span class="cupd">r</span><span class="cupd">ce </span>w<span class="cupd">i</span>ll d<span class="cupd">e</span><span class="cupd">c</span>rea<span class="cupd">s</span>e<span class="cupd"> </span>1/10000<span class="cupd"> </span><span class="cupd">e</span>v<span class="cupd">e</span>ry<span class="cupd"> </span><span class="cupd">d</span>ay.</span></span>
    	<span class="marker" id="mapping-279"></span><span class="token mv" id="move-dst-112" data-title="contract_body/comment"><span class="marker" id="mapping-280"></span><span class="token upd" id="move-dst-112" data-title="contract_body/comment"><span class="cupd">//</span><span class="cupd"> </span>`min<span class="cupd">a</span>b<span class="cupd">l</span>eBa<span class="cupd">l</span>ance`<span class="cupd"> </span>i<span class="cupd">s</span><span class="cupd"> </span>an<span class="cupd"> </span>a<span class="cupd">re</span><span class="cupd">a</span><span class="cupd"> </span><span class="cupd">o</span>f <span class="cupd">a</span><span class="cupd"> </span><span class="cupd">t</span>rap<span class="cupd">e</span>zo<span class="cupd">i</span>d.</span></span>
    	<span class="marker" id="mapping-281"></span><span class="token mv" id="move-dst-114" data-title="contract_body/comment"><span class="marker" id="mapping-282"></span><span class="token upd" id="move-dst-114" data-title="contract_body/comment"><span class="cupd">//</span><span class="cupd"> </span>The<span class="cupd"> </span>reason<span class="cupd"> </span>for<span class="cupd"> </span>d<span class="cupd">i</span>viding<span class="cupd"> </span>by `1 days` <span class="cupd">t</span>wice is t<span class="cupd">h</span>at th<span class="cupd">e </span>definition of `getResour<span class="cupd">c</span>eR<span class="cupd">a</span>t<span class="cupd">e</span>`<span class="cupd"> is the </span>nu<span class="cupd">m</span>b<span class="cupd">e</span>r<span class="cupd"> </span>of m<span class="cupd">i</span>nes t<span class="cupd">h</span><span class="cupd">a</span>t<span class="cupd"> can </span>b<span class="cupd">e</span> mined <span class="cupd">p</span><span class="cupd">e</span>r<span class="cupd"> </span>d<span class="cupd">a</span>y.</span></span>
	function _getMinableBalance(
		uint256 _tokenId,
		address _resource,
		uint256 _currentTime,
		uint256 _lastUpdateTime
	) public view returns (uint256 minableBalance) {
		uint256 speed_in_current_period =
			ILandBase(registry.addressOf(CONTRACT_LAND_BASE))
				.getResourceRate(_tokenId, _resource)
				.mul(
				_getReleaseSpeedInSeconds(
					_tokenId,
					((_currentTime + _lastUpdateTime) / 2)
				)
			)
				.mul(1 ether)
				.div(1 days)
				.div(TOTAL_SECONDS);

		// calculate the area of trapezoid
		minableBalance = speed_in_current_period.mul(
			_currentTime - _lastUpdateTime
		);
	}

	function _getMaxMineBalance(
		uint256 _tokenId,
		address _resource,
		uint256 _currentTime,
		uint256 _lastUpdateTime
	) internal view returns (uint256) {
		// totalMinerStrength is in wei
		return
			getTotalMiningStrength(_tokenId, _resource)
				.mul(_currentTime - _lastUpdateTime)
				.div(1 days);
	}

	function setMaxMiners(uint256 _maxMiners) public auth {
		require(_maxMiners &gt; maxMiners, "Land: INVALID_MAXMINERS");
		maxMiners = _maxMiners;
        <span class="marker" id="mapping-283"></span><span class="token add" data-title="function_body/emit_statement">emit SetMaxMiner(maxMiners);</span>
	}

	function mine(uint256 _landTokenId) public {
		_mineAllResource(
			_landTokenId,
			registry.addressOf(CONTRACT_GOLD_ERC20_TOKEN),
			registry.addressOf(CONTRACT_WOOD_ERC20_TOKEN),
			registry.addressOf(CONTRACT_WATER_ERC20_TOKEN),
			registry.addressOf(CONTRACT_FIRE_ERC20_TOKEN),
			registry.addressOf(CONTRACT_SOIL_ERC20_TOKEN)
		);
	}

	function _mineAllResource(
		uint256 _landTokenId,
		address _gold,
		address _wood,
		address _water,
		address _fire,
		address _soil
	) internal {
		require(
			IInterstellarEncoder(
				registry.addressOf(CONTRACT_INTERSTELLAR_ENCODER)
			)
				.getObjectClass(_landTokenId) == 1,
			"Token must be land."
		);

		// v5 remove
		// if (land2ResourceMineState[_landTokenId].lastUpdateTime == 0) {
		// 	land2ResourceMineState[_landTokenId].lastUpdateTime = uint128(
		// 		resourceReleaseStartTime
		// 	);
		// 	land2ResourceMineState[_landTokenId]
		// 		.lastUpdateSpeedInSeconds = TOTAL_SECONDS;
		// }

		_mineResource(_landTokenId, _gold);
		_mineResource(_landTokenId, _wood);
		_mineResource(_landTokenId, _water);
		_mineResource(_landTokenId, _fire);
		_mineResource(_landTokenId, _soil);

		// v5 remove
		// land2ResourceMineState[_landTokenId]
		// 	.lastUpdateSpeedInSeconds = _getReleaseSpeedInSeconds(
		// 	_landTokenId,
		// 	now
		// );

		land2ResourceMineState[_landTokenId].lastUpdateTime = uint128(now);
	}

	function _distribution(
		uint256 _landId,
		address _resource,
		uint256 minedBalance,
		uint256 barsRate
	) internal returns (uint256) {
		uint256 landBalance =
			minedBalance.mul(RATE_PRECISION).div(barsRate.add(RATE_PRECISION));
		uint256 barsBalance = minedBalance.sub(landBalance);
		for (uint256 i = 0; i &lt; maxAmount; i++) {
			(address itemToken, uint256 itemId, address resouce) =
				getBarItem(_landId, i);
			if (itemToken != address(0) &amp;&amp; resouce == _resource) {
				uint256 barBalance =
					barsBalance.mul(getBarRate(_landId, _resource, i)).div(
						barsRate
					);
				(barBalance, landBalance) = _payFee(barBalance, landBalance);
				itemMinedBalance[itemToken][itemId][
					_resource
				] = getItemMinedBalance(itemToken, itemId, _resource).add(
					barBalance
				);
			}
		}
		return landBalance;
	}

	function _payFee(uint256 barBalance, uint256 landBalance)
		internal
		view
		returns (uint256, uint256)
	{
		uint256 fee =
			barBalance.mul(registry.uintOf(FURNACE_ITEM_MINE_FEE)).div(
				RATE_PRECISION
			);
		barBalance = barBalance.sub(fee);
		landBalance = landBalance.add(fee);
		return (barBalance, landBalance);
	}

	function _mineResource(uint256 _landId, address _resource) internal {
		// the longest seconds to zero speed.
		if (getLandMiningStrength(_landId, _resource) == 0) {
			return;
		}
		uint256 minedBalance = _calculateMinedBalance(_landId, _resource, now);
		if (minedBalance == 0) {
			return;
		}

		uint256 barsRate = getBarsRate(_landId, _resource);
		uint256 landBalance = minedBalance;
		if (barsRate &gt; 0) {
			// V5 yeild distribution
			landBalance = _distribution(
				_landId,
				_resource,
				minedBalance,
				barsRate
			);
		}
		land2ResourceMineState[_landId].mintedBalance[
			_resource
		] = getLandMinedBalance(_landId, _resource).add(landBalance);
	}

	function _calculateMinedBalance(
		uint256 _landTokenId,
		address _resourceToken,
		uint256 _currentTime
	) internal view returns (uint256) {
		uint256 currentTime = _currentTime;

		uint256 minedBalance;
		uint256 minableBalance;
		if (currentTime &gt; (resourceReleaseStartTime + TOTAL_SECONDS)) {
			currentTime = (resourceReleaseStartTime + TOTAL_SECONDS);
		}

		uint256 lastUpdateTime =
			land2ResourceMineState[_landTokenId].lastUpdateTime;
		require(currentTime &gt;= lastUpdateTime<span class="marker" id="mapping-284"></span><span class="token add" data-title="call_expression/,">,</span> <span class="marker" id="mapping-285"></span><span class="token add" data-title="call_expression/call_argument">"Land: INVALID_TIMESTAMP"</span>);

		if (lastUpdateTime &gt;= (resourceReleaseStartTime + TOTAL_SECONDS)) {
			minedBalance = 0;
			minableBalance = 0;
		} else {
			minedBalance = _getMaxMineBalance(
				_landTokenId,
				_resourceToken,
				currentTime,
				lastUpdateTime
			);
			minableBalance = _getMinableBalance(
				_landTokenId,
				_resourceToken,
				currentTime,
				lastUpdateTime
			);
		}

		if (minedBalance &gt; minableBalance) {
			minedBalance = minableBalance;
		} 

		return minedBalance;
	}

	// v5 remove
	// function claimAllResource(uint256 _landTokenId) public {
	// 	require(
	// 		msg.sender == ownership.ownerOf(_landTokenId),
	// 		"Must be the owner of the land"
	// 	);

	// 	_mineAllResource(_landTokenId, gold, wood, water, fire, soil);

	// 	uint256 goldBalance;
	// 	uint256 woodBalance;
	// 	uint256 waterBalance;
	// 	uint256 fireBalance;
	// 	uint256 soilBalance;

	// 	if (land2ResourceMineState[_landTokenId].mintedBalance[gold] &gt; 0) {
	// 		goldBalance = land2ResourceMineState[_landTokenId].mintedBalance[
	// 			gold
	// 		];
	// 		IMintableERC20(gold).mint(msg.sender, goldBalance);
	// 		land2ResourceMineState[_landTokenId].mintedBalance[gold] = 0;
	// 	}

	// 	if (land2ResourceMineState[_landTokenId].mintedBalance[wood] &gt; 0) {
	// 		woodBalance = land2ResourceMineState[_landTokenId].mintedBalance[
	// 			wood
	// 		];
	// 		IMintableERC20(wood).mint(msg.sender, woodBalance);
	// 		land2ResourceMineState[_landTokenId].mintedBalance[wood] = 0;
	// 	}

	// 	if (land2ResourceMineState[_landTokenId].mintedBalance[water] &gt; 0) {
	// 		waterBalance = land2ResourceMineState[_landTokenId].mintedBalance[
	// 			water
	// 		];
	// 		IMintableERC20(water).mint(msg.sender, waterBalance);
	// 		land2ResourceMineState[_landTokenId].mintedBalance[water] = 0;
	// 	}

	// 	if (land2ResourceMineState[_landTokenId].mintedBalance[fire] &gt; 0) {
	// 		fireBalance = land2ResourceMineState[_landTokenId].mintedBalance[
	// 			fire
	// 		];
	// 		IMintableERC20(fire).mint(msg.sender, fireBalance);
	// 		land2ResourceMineState[_landTokenId].mintedBalance[fire] = 0;
	// 	}

	// 	if (land2ResourceMineState[_landTokenId].mintedBalance[soil] &gt; 0) {
	// 		soilBalance = land2ResourceMineState[_landTokenId].mintedBalance[
	// 			soil
	// 		];
	// 		IMintableERC20(soil).mint(msg.sender, soilBalance);
	// 		land2ResourceMineState[_landTokenId].mintedBalance[soil] = 0;
	// 	}

	// 	emit ResourceClaimed(
	// 		msg.sender,
	// 		_landTokenId,
	// 		goldBalance,
	// 		woodBalance,
	// 		waterBalance,
	// 		fireBalance,
	// 		soilBalance
	// 	);
	// }

	// both for own _tokenId or hired one
	function startMining(
		uint256 _tokenId,
		uint256 _landTokenId,
		address _resource
	) public {
		// require the permission from land owner;
		require(
			msg.sender ==
				ERC721(registry.addressOf(CONTRACT_OBJECT_OWNERSHIP)).ownerOf(
					_landTokenId
				),
			"Must be the owner of the land"
		);

		// make sure that _tokenId won't be used repeatedly
		require(miner2Index[_tokenId].landTokenId == 0);

		<span class="marker" id="mapping-286"></span><span class="token mv" id="move-dst-86" data-title="function_body/expression_statement">ITokenUse(registry.addressOf(CONTRACT_TOKEN_USE)).addActivity(
			_tokenId,
			msg.sender,
			0
		);</span>

		// update status!
		mine(_landTokenId);

		uint256 _index =
			land2ResourceMineState[_landTokenId].miners[_resource].length;

		land2ResourceMineState[_landTokenId].totalMiners += 1;

		// v5 remove
		// if (land2ResourceMineState[_landTokenId].maxMiners == 0) {
		// 	land2ResourceMineState[_landTokenId].maxMiners = 5;
		// }

		require(
			land2ResourceMineState[_landTokenId].totalMiners &lt;= maxMiners,
			"Land: EXCEED_MAXAMOUNT"
		);

		address miner =
			IInterstellarEncoder(
				registry.addressOf(CONTRACT_INTERSTELLAR_ENCODER)
			)
				.getObjectAddress(_tokenId);
		uint256 strength =
			IMinerObject(miner).strengthOf(_tokenId, _resource, _landTokenId);

		land2ResourceMineState[_landTokenId].miners[_resource].push(_tokenId);
		<span class="marker" id="mapping-287"></span><span class="token add" data-title="expression_statement/assignment_expression"><span class="marker" id="mapping-288"></span><span class="token mv" id="move-dst-87" data-title="assignment_expression/array_access">land2ResourceMineState[_landTokenId].totalMinerStrength[_resource]</span> = <span class="marker" id="mapping-289"></span><span class="token add" data-title="assignment_expression/call_expression">land2ResourceMineState[_landTokenId].totalMinerStrength[_resource].add(strength)</span></span>;

		miner2Index[_tokenId] = MinerStatus({
			landTokenId: _landTokenId,
			resource: _resource,
			indexInResource: uint64(_index)
		});

		emit StartMining(_tokenId, _landTokenId, _resource, strength);
	}

	function batchStartMining(
		uint256[] _tokenIds,
		uint256[] _landTokenIds,
		address[] _resources
	) <span class="marker" id="mapping-290"></span><span class="token add" data-title="visibility/external">external</span> {
		require(
			_tokenIds.length == _landTokenIds.length &amp;&amp;
				_landTokenIds.length == _resources.length,
			"input error"
		);
		uint256 length = _tokenIds.length;

		for (uint256 i = 0; i &lt; length; i++) {
			startMining(_tokenIds[i], _landTokenIds[i], _resources[i]);
		}
	}

	function batchClaimLandResource(uint256[] _landTokenIds) <span class="marker" id="mapping-291"></span><span class="token add" data-title="visibility/external">external</span> {
		uint256 length = _landTokenIds.length;

		for (uint256 i = 0; i &lt; length; i++) {
			claimLandResource(_landTokenIds[i]);
		}
	}

	// Only trigger from Token Activity.
	function activityStopped(uint256 _tokenId) public auth {
		_stopMining(_tokenId);
	}

	function stopMining(uint256 _tokenId) public {
		ITokenUse(registry.addressOf(CONTRACT_TOKEN_USE)).removeActivity(
			_tokenId,
			msg.sender
		);
	}

	function _stopMining(uint256 _tokenId) internal {
		// remove the miner from land2ResourceMineState;
		uint64 minerIndex = miner2Index[_tokenId].indexInResource;
		address resource = miner2Index[_tokenId].resource;
		uint256 landTokenId = miner2Index[_tokenId].landTokenId;

		// update status!
		mine(landTokenId);

		uint64 lastMinerIndex =
			uint64(
				land2ResourceMineState[landTokenId].miners[resource].length.sub(
					1
				)
			);
		uint256 lastMiner =
			land2ResourceMineState[landTokenId].miners[resource][
				lastMinerIndex
			];

		land2ResourceMineState[landTokenId].miners[resource][
			minerIndex
		] = lastMiner;
		land2ResourceMineState[landTokenId].miners[resource][
			lastMinerIndex
		] = 0;

		<span class="marker" id="mapping-292"></span><span class="token add" data-title="expression_statement/assignment_expression"><span class="marker" id="mapping-293"></span><span class="token mv" id="move-dst-88" data-title="assignment_expression/member_expression">land2ResourceMineState[landTokenId].miners[resource].length</span> = <span class="marker" id="mapping-294"></span><span class="token add" data-title="assignment_expression/call_expression">land2ResourceMineState[landTokenId].miners[resource].length.sub(1)</span></span>;
		miner2Index[lastMiner].indexInResource = minerIndex;

		land2ResourceMineState[landTokenId].totalMiners -= 1;

		address miner =
			IInterstellarEncoder(
				registry.addressOf(CONTRACT_INTERSTELLAR_ENCODER)
			)
				.getObjectAddress(_tokenId);
		uint256 strength =
			IMinerObject(miner).strengthOf(_tokenId, resource, landTokenId);

		// for backward compatibility
		// if strength can fluctuate some time in the future
		if (
			land2ResourceMineState[landTokenId].totalMinerStrength[resource] !=
			0
		) {
			if (
				land2ResourceMineState[landTokenId].totalMinerStrength[
					resource
				] &gt; strength
			) {
				land2ResourceMineState[landTokenId].totalMinerStrength[
					resource
				] = land2ResourceMineState[landTokenId].totalMinerStrength[
					resource
				]
					.sub(strength);
			} else {
				land2ResourceMineState[landTokenId].totalMinerStrength[
					resource
				] = 0;
			}
		}

		if (land2ResourceMineState[landTokenId].totalMiners == 0) {
			land2ResourceMineState[landTokenId].totalMinerStrength[
				resource
			] = 0;
		}

		delete miner2Index[_tokenId];

		emit StopMining(_tokenId, landTokenId, resource, strength);
	}

	// v5 remove
	// function getMinerOnLand(
	// 	uint256 _landTokenId,
	// 	address _resourceToken,
	// 	uint256 _index
	// ) public view returns (uint256) {
	// 	return
	// 		land2ResourceMineState[_landTokenId].miners[_resourceToken][_index];
	// }

	// function getTotalMiningStrength(
	// 	uint256 _landTokenId,
	// 	address _resourceToken
	// ) public view returns (uint256) {
	// 	return
	// 		land2ResourceMineState[_landTokenId].totalMinerStrength[
	// 			_resourceToken
	// 		];
	// }

	// function availableResources(
	// 	uint256 _landTokenId,
	// 	address[5] _resourceTokens
	// )
	// 	public
	// 	view
	// 	returns (
	// 		uint256,
	// 		uint256,
	// 		uint256,
	// 		uint256,
	// 		uint256
	// 	)
	// {
	// 	uint256 availableGold =
	// 		_calculateMinedBalance(_landTokenId, _resourceTokens[0], now) +
	// 			land2ResourceMineState[_landTokenId].mintedBalance[
	// 				_resourceTokens[0]
	// 			];
	// 	uint256 availableWood =
	// 		_calculateMinedBalance(_landTokenId, _resourceTokens[1], now) +
	// 			land2ResourceMineState[_landTokenId].mintedBalance[
	// 				_resourceTokens[1]
	// 			];
	// 	uint256 availableWater =
	// 		_calculateMinedBalance(_landTokenId, _resourceTokens[2], now) +
	// 			land2ResourceMineState[_landTokenId].mintedBalance[
	// 				_resourceTokens[2]
	// 			];
	// 	uint256 availableFire =
	// 		_calculateMinedBalance(_landTokenId, _resourceTokens[3], now) +
	// 			land2ResourceMineState[_landTokenId].mintedBalance[
	// 				_resourceTokens[3]
	// 			];
	// 	uint256 availableSoil =
	// 		_calculateMinedBalance(_landTokenId, _resourceTokens[4], now) +
	// 			land2ResourceMineState[_landTokenId].mintedBalance[
	// 				_resourceTokens[4]
	// 			];

	// 	return (
	// 		availableGold,
	// 		availableWood,
	// 		availableWater,
	// 		availableFire,
	// 		availableSoil
	// 	);
	// }

	// V5 remove
	// function mintedBalanceOnLand(uint256 _landTokenId, address _resourceToken) public view returns (uint256) {
	//     return land2ResourceMineState[_landTokenId].mintedBalance[_resourceToken];
	// }

	// function landWorkingOn(uint256 _apostleTokenId) public view returns (uint256 landTokenId) {
	//     landTokenId = miner2Index[_apostleTokenId].landTokenId;
	// }

	function _updateMinerStrength(uint256 _apostleTokenId, bool _isStop)
		internal
		returns (uint256, uint256)
	{
		// require that this apostle
		uint256 landTokenId = landWorkingOn(_apostleTokenId);
		require(landTokenId != 0, "this apostle is not mining.");

		address resource = miner2Index[_apostleTokenId].resource;

		address miner =
			IInterstellarEncoder(
				registry.addressOf(CONTRACT_INTERSTELLAR_ENCODER)
			)
				.getObjectAddress(_apostleTokenId);
		uint256 strength =
			IMinerObject(miner).strengthOf(
				_apostleTokenId,
				resource,
				landTokenId
			);

		mine(landTokenId);

		if (_isStop) {
			land2ResourceMineState[landTokenId].totalMinerStrength[
				resource
			] = land2ResourceMineState[landTokenId].totalMinerStrength[resource]
				.sub(strength);
		} else {
			<span class="marker" id="mapping-295"></span><span class="token add" data-title="expression_statement/assignment_expression"><span class="marker" id="mapping-296"></span><span class="token mv" id="move-dst-89" data-title="assignment_expression/array_access">land2ResourceMineState[landTokenId].totalMinerStrength[resource]</span> = <span class="marker" id="mapping-297"></span><span class="token add" data-title="assignment_expression/call_expression">land2ResourceMineState[landTokenId].totalMinerStrength[resource].add(strength)</span></span>;
		}

		return (landTokenId, strength);
	}

	// when a mirrorToken or a pet has tied to apostle
	// we need to update status and remove this apostle from mining list first
	// open authority to PetBase
	// can only be called by PetBase
	function updateMinerStrengthWhenStop(uint256 _apostleTokenId) public auth {
		uint256 landTokenId;
		uint256 strength;
		(landTokenId, strength) = _updateMinerStrength(_apostleTokenId, true);
		// _isStop == true - minus strength
		// _isStop == false - add strength
		emit UpdateMiningStrengthWhenStop(
			_apostleTokenId,
			landTokenId,
			strength
		);
	}

	function updateMinerStrengthWhenStart(uint256 _apostleTokenId) public auth {
		uint256 landTokenId;
		uint256 strength;
		(landTokenId, strength) = _updateMinerStrength(_apostleTokenId, false);
		// _isStop == true - minus strength
		// _isStop == false - add strength
		emit UpdateMiningStrengthWhenStart(
			_apostleTokenId,
			landTokenId,
			strength
		);
	}

	// V5 add
	function getLandMinedBalance(uint256 _landId, address _resource)
		public
		view
		returns (uint256)
	{
		return land2ResourceMineState[_landId].mintedBalance[_resource];
	}

	function getItemMinedBalance(
		address _itemToken,
		uint256 _itemId,
		address _resource
	) public view returns (uint256) {
		return itemMinedBalance[_itemToken][_itemId][_resource];
	}

	function getLandMiningStrength(uint256 _landId, address _resource)
		public
		view
		returns (uint256)
	{
		return land2ResourceMineState[_landId].totalMinerStrength[_resource];
	}

	function getBarMiningStrength(
		uint256 _landId,
		address _resource,
		uint256 _index
	) public view returns (uint256) {
		return
			getLandMiningStrength(_landId, _resource)
				.mul(getBarRate(_landId, _resource, _index))
				.div(RATE_PRECISION);
	}

	function getBarRate(
		uint256 _landId,
		address _resource,
		uint256 _index
	) public view returns (uint256) {
		return land2BarRate[_landId][_resource][_index];
	}

	function getBarsRate(uint256 _landId, address _resource)
		public
		view
		returns (uint256 barsRate)
	{
		for (uint256 i = 0; i &lt; maxAmount; i++) {
			barsRate = barsRate.add(getBarRate(_landId, _resource, i));
		}
	}

	function getBarsMiningStrength(uint256 _landId, address _resource)
		public
		view
		returns (uint256 barsMiningStrength)
	{
		return
			getLandMiningStrength(_landId, _resource)
				.mul(getBarsRate(_landId, _resource))
				.div(RATE_PRECISION);
	}

	function getTotalMiningStrength(uint256 _landId, address _resource)
		public
		view
		returns (uint256)
	{
		return
			getLandMiningStrength(_landId, _resource).add(
				getBarsMiningStrength(_landId, _resource)
			);
	}

	function getMinerOnLand(
		uint256 _landId,
		address _resource,
		uint256 _index
	) public view returns (uint256) {
		return land2ResourceMineState[_landId].miners[_resource][_index];
	}

	function landWorkingOn(uint256 _apostleTokenId)
		public
		view
		returns (uint256 landId)
	{
		landId = miner2Index[_apostleTokenId].landTokenId;
	}

	function _getBarRateByIndex(
		uint256 _landId,
		address _resource,
		uint256 _index
	) internal view returns (uint256) {
		return enhanceStrengthRateByIndex(_resource, _landId, _index);
	}

	function _startBarMining(
		uint256 _index,
		uint256 _landId,
		address _resource
	) internal {
		uint256 rate = _getBarRateByIndex(_landId, _resource, _index);
		land2BarRate[_landId][_resource][_index] = rate;
		emit StartBarMining(_index, _landId, _resource, rate);
	}

	function _stopBarMinig(
		uint256 _index,
		uint256 _landId,
		address _resource
	) internal {
		delete land2BarRate[_landId][_resource][_index];
		emit StopBarMining(_index, _landId, _resource);
	}

	function _claimItemResource(
		address _itemToken,
		uint256 _itemId,
		address _resource
	) internal returns (uint256) {
		uint256 balance = getItemMinedBalance(_itemToken, _itemId, _resource);
		if (balance &gt; 0) {
			IMintableERC20(_resource).mint(msg.sender, balance);
			itemMinedBalance[_itemToken][_itemId][_resource] = 0;
			return balance;
		} else {
			return 0;
		}
	}

	function claimItemResource(address _itemToken, uint256 _itemId) public {
		(address staker, uint256 landId) = getLandIdByItem(_itemToken, _itemId);
		if (staker == address(0) &amp;&amp; landId == 0) {
			require(
				ERC721(_itemToken).ownerOf(_itemId) == msg.sender,
				"Land: ONLY_ITEM_OWNER"
			);
		} else {
			require(staker == msg.sender, "Land: ONLY_ITEM_STAKER");
			mine(landId);
		}

		address gold = registry.addressOf(CONTRACT_GOLD_ERC20_TOKEN);
		address wood = registry.addressOf(CONTRACT_WOOD_ERC20_TOKEN);
		address water = registry.addressOf(CONTRACT_WATER_ERC20_TOKEN);
		address fire = registry.addressOf(CONTRACT_FIRE_ERC20_TOKEN);
		address soil = registry.addressOf(CONTRACT_SOIL_ERC20_TOKEN);
		uint256 goldBalance = _claimItemResource(_itemToken, _itemId, gold);
		uint256 woodBalance = _claimItemResource(_itemToken, _itemId, wood);
		uint256 waterBalance = _claimItemResource(_itemToken, _itemId, water);
		uint256 fireBalance = _claimItemResource(_itemToken, _itemId, fire);
		uint256 soilBalance = _claimItemResource(_itemToken, _itemId, soil);

		emit ItemResourceClaimed(
			msg.sender,
			_itemToken,
			_itemId,
			goldBalance,
			woodBalance,
			waterBalance,
			fireBalance,
			soilBalance
		);
	}

	function _claimLandResource(uint256 _landId, address _resource)
		internal
		returns (uint256)
	{
		uint256 balance = getLandMinedBalance(_landId, _resource);
		if (balance &gt; 0) {
			IMintableERC20(_resource).mint(msg.sender, balance);
			land2ResourceMineState[_landId].mintedBalance[_resource] = 0;
			return balance;
		} else {
			return 0;
		}
	}

	function claimLandResource(uint256 _landId) public {
		require(
			msg.sender ==
				ERC721(registry.addressOf(CONTRACT_OBJECT_OWNERSHIP)).ownerOf(
					_landId
				),
			"Land: ONLY_LANDER"
		);

		address gold = registry.addressOf(CONTRACT_GOLD_ERC20_TOKEN);
		address wood = registry.addressOf(CONTRACT_WOOD_ERC20_TOKEN);
		address water = registry.addressOf(CONTRACT_WATER_ERC20_TOKEN);
		address fire = registry.addressOf(CONTRACT_FIRE_ERC20_TOKEN);
		address soil = registry.addressOf(CONTRACT_SOIL_ERC20_TOKEN);
		_mineAllResource(_landId, gold, wood, water, fire, soil);

		uint256 goldBalance = _claimLandResource(_landId, gold);
		uint256 woodBalance = _claimLandResource(_landId, wood);
		uint256 waterBalance = _claimLandResource(_landId, water);
		uint256 fireBalance = _claimLandResource(_landId, fire);
		uint256 soilBalance = _claimLandResource(_landId, soil);

		emit LandResourceClaimed(
			msg.sender,
			_landId,
			goldBalance,
			woodBalance,
			waterBalance,
			fireBalance,
			soilBalance
		);
	}

	function _calculateResources(
		address _itemToken,
		uint256 _itemId,
		uint256 _landId,
		address _resource,
		uint256 _minedBalance
	) internal view returns (uint256 landBalance, uint256 barResource) {
		uint256 barsRate = getBarsRate(_landId, _resource);
		// V5 yeild distribution
		landBalance = _minedBalance.mul(RATE_PRECISION).div(
			barsRate.add(RATE_PRECISION)
		);
		<span class="marker" id="mapping-298"></span><span class="token mv" id="move-dst-95" data-title="function_body/if_statement">if (<span class="marker" id="mapping-299"></span><span class="token mv" id="move-dst-90" data-title="if_statement/binary_expression">barsRate &gt; 0</span>) <span class="marker" id="mapping-300"></span><span class="token mv" id="move-dst-93" data-title="if_statement/block_statement">{
			<span class="marker" id="mapping-301"></span><span class="token mv" id="move-dst-91" data-title="block_statement/variable_declaration_statement">uint256 barsBalance = _minedBalance.sub(landBalance);</span>
			<span class="marker" id="mapping-302"></span><span class="token mv" id="move-dst-92" data-title="block_statement/for_statement">for (uint256 i = 0; i &lt; maxAmount; i++) <span class="marker" id="mapping-303"></span><span class="token mv" id="move-dst-97" data-title="for_statement/block_statement">{
				uint256 barBalance =
					barsBalance.mul(getBarRate(_landId, _resource, i)).div(
						barsRate
					);
				(barBalance, landBalance) = _payFee(barBalance, landBalance);
				<span class="marker" id="mapping-304"></span><span class="token mv" id="move-dst-94" data-title="block_statement/variable_declaration_statement">(address itemToken, uint256 itemId, ) = getBarItem(_landId, i);</span>
				<span class="marker" id="mapping-305"></span><span class="token add" data-title="block_statement/if_statement">if (<span class="marker" id="mapping-306"></span><span class="token mv" id="move-dst-96" data-title="if_statement/binary_expression">_itemId == itemId &amp;&amp; _itemToken == itemToken</span>) <span class="marker" id="mapping-307"></span><span class="token add" data-title="if_statement/block_statement">{
					<span class="marker" id="mapping-308"></span><span class="token mv" id="move-dst-98" data-title="block_statement/expression_statement">barResource = barResource.add(barBalance);</span>
				}</span></span>
			}</span></span>
		}</span></span>
	}

	function availableLandResources(
		uint256 _landId,
		<span class="marker" id="mapping-309"></span><span class="token add" data-title="type_name/primitive_type">address</span>[] _resources
	) <span class="marker" id="mapping-310"></span><span class="token add" data-title="visibility/external">external</span> view returns (uint256[] memory) {
		uint256[] memory availables = new uint256[](_resources.length);
		for (uint256 i = 0; i &lt; _resources.length; i++) <span class="marker" id="mapping-311"></span><span class="token mv" id="move-dst-100" data-title="for_statement/block_statement">{
			uint256 mined = _calculateMinedBalance(_landId, _resources[i], now);
			(uint256 available, ) =
				_calculateResources(
					address(0),
					0,
					_landId,
					_resources[i],
					mined
				);
			availables[i] = available.add(
				getLandMinedBalance(_landId, _resources[i])
			);
		}</span>
		return availables;
	}

	function availableItemResources(
		address _itemToken,
		uint256 _itemId,
		address[] _resources
	) <span class="marker" id="mapping-312"></span><span class="token add" data-title="function_definition/visibility">external</span> view returns (uint256[] memory) {
		uint256[] memory availables = new uint256[](_resources.length);
		for (uint256 i = 0; i &lt; _resources.length; i++) <span class="marker" id="mapping-313"></span><span class="token mv" id="move-dst-103" data-title="for_statement/block_statement">{
			<span class="marker" id="mapping-314"></span><span class="token mv" id="move-dst-102" data-title="block_statement/variable_declaration_statement">(address staker, uint256 landId) =
				getLandIdByItem(_itemToken, _itemId);</span>
			uint256 available = 0;
			if (staker != address(0) &amp;&amp; landId != 0) {
				uint256 mined =
					_calculateMinedBalance(landId, _resources[i], now);
				(, uint256 availableItem) =
					_calculateResources(
						_itemToken,
						_itemId,
						landId,
						_resources[i],
						mined
					);
				available = available.add(availableItem);
			}
			available = available.add(
				getItemMinedBalance(_itemToken, _itemId, _resources[i])
			);
			availables[i] = available;
		}</span>
		return availables;
	}

	function isNotProtect(address _token, uint256 _id)
		public
		view
		returns (bool)
	{
		return protectPeriod[_token][_id] &lt; now;
	}

	function getBarItem(uint256 _tokenId, uint256 _index)
		public
		view
		returns (
			address,
			uint256,
			address
		)
	{
		require(_index &lt; maxAmount, "Furnace: INDEX_FORBIDDEN.");
		return (
			landId2Bars[_tokenId][_index].token,
			landId2Bars[_tokenId][_index].id,
			landId2Bars[_tokenId][_index].resource
		);
	}

	function getLandIdByItem(address _item, uint256 _itemId)
		public
		view
		returns (address, uint256)
	{
		return (
			itemId2Status[_item][_itemId].staker,
			itemId2Status[_item][_itemId].<span class="marker" id="mapping-315"></span><span class="token upd" id="move-dst-104" data-title="member_expression/identifier">t<span class="cupd">okenId</span></span>
		);
	}

	<span class="marker" id="mapping-316"></span><span class="token mv" id="move-dst-121" data-title="contract_body/comment"><span class="marker" id="mapping-317"></span><span class="token upd" id="move-dst-121" data-title="contract_body/comment"><span class="cupd">/**
        @dev</span> Eq<span class="cupd">u</span>i<span class="cupd">p function, A NFT can</span> eq<span class="cupd">u</span>ip<span class="cupd"> </span><span class="cupd">t</span><span class="cupd">o EVO Bar (LandBar or ApostleBar).
        @param _tokenI</span>d<span class="cupd">  Token Id which to b</span><span class="cupd">e quiped.
        @para</span>m _resource<span class="cupd"> </span>Which resouce appply to.
        @para<span class="cupd">m _inde</span>x<span class="cupd">    Index of the Bar.</span>
        @param _token    Token address which to quip.
        @param _id       Token Id which to quip.<span class="cupd">
</span>    	*/</span></span>
	function equip(
		uint256 _tokenId,
		address _resource,
		uint256 _index,
		address _token,
		uint256 _id
	) public {
		_equip(_tokenId, _resource, _index, _token, _id);
	}

	function _equip(
		uint256 _tokenId,
		address _resource,
		uint256 _index,
		address _token,
		uint256 _id
	) internal {
		beforeEquip(_tokenId, _resource);
		IMetaDataTeller teller =
			IMetaDataTeller(registry.addressOf(CONTRACT_METADATA_TELLER));
		uint256 resourceId =
			<span class="marker" id="mapping-318"></span><span class="token upd" id="move-dst-115" data-title="call_expression/identifier"><span class="cupd">ILandBase</span>Ext</span>(registry.addressOf(CONTRACT_LAND_BASE))
				.resourceToken2RateAttrId(_resource);
		require(resourceId &gt; 0 &amp;&amp; resourceId &lt; 6, "Furnace: INVALID_RESOURCE");
		require(
			IInterstellarEncoder(
				registry.addressOf(CONTRACT_INTERSTELLAR_ENCODER)
			)
				.getObjectClass(_tokenId) == 1,
			"Funace: ONLY_LAND"
		);
		(uint16 objClassExt, uint16 class, uint16 grade) =
			teller.getMetaData(_token, _id);
		require(objClassExt &gt; 0, "Furnace: PERMISSION");
		require(_index &lt; maxAmount, "Furnace: INDEX_FORBIDDEN");
		Bar storage bar = landId2Bars[_tokenId][_index];
		if (bar.token != address(0)) {
			require(isNotProtect(bar.token, bar.id), "Furnace: PROTECT_PERIOD");
			(, uint16 originClass, uint16 originGrade) =
				teller.getMetaData(bar.token, bar.id);
			require(
				class &gt; originClass ||
					(class == originClass &amp;&amp; grade &gt; originGrade) ||
					ERC721(registry.addressOf(CONTRACT_OBJECT_OWNERSHIP))
						.ownerOf(_tokenId) ==
					msg.sender,
				"Furnace: FORBIDDEN"
			);
			//TODO:: safe transfer
			ERC721(bar.token).transferFrom(address(this), bar.staker, bar.id);
		}
		ERC721(_token).transferFrom(msg.sender, address(this), _id);
		bar.staker = msg.sender;
		bar.token = _token;
		bar.id = _id;
		bar.resource = _resource;
		itemId2Status[bar.token][bar.id] = Status({
			staker: bar.staker,
			<span class="marker" id="mapping-319"></span><span class="token upd" id="move-dst-118" data-title="call_struct_argument/identifier">t<span class="cupd">okenId</span></span>: _tokenId,
			index: _index
		});
		if (isNotProtect(bar.token, bar.id)) {
			protectPeriod[bar.token][bar.id] = _calculateProtectPeriod(class)
				.add(now);
		}
		afterEquiped(_index, _tokenId, _resource);
		emit Equip(_tokenId, _resource, _index, bar.staker, bar.token, bar.id);
	}

	function _calculateProtectPeriod(
		uint16 _class
	) internal view returns (uint256) {
		uint256 baseProtectPeriod =
			registry.uintOf(UINT_ITEMBAR_PROTECT_PERIOD);
		return <span class="marker" id="mapping-320"></span><span class="token mv" id="move-dst-119" data-title="return_statement/call_expression">uint256(_class).mul(baseProtectPeriod)</span>;
	}

	function beforeEquip(uint256 _landTokenId, address _resource) internal {
		if (getLandMiningStrength(_landTokenId, _resource) &gt; 0) {
			mine(_landTokenId);
		}
	}

	function afterEquiped(
		uint256 _index,
		uint256 _landTokenId,
		address _resource
	) internal {
		_startBarMining(_index, _landTokenId, _resource);
	}

	function afterDivested(
		uint256 _index,
		uint256 _landTokenId,
		address _resource
	) internal {
		if (getLandMiningStrength(_landTokenId, _resource) &gt; 0) {
			mine(_landTokenId);
		}
		_stopBarMinig(_index, _landTokenId, _resource);
	}

    	<span class="marker" id="mapping-321"></span><span class="token add" data-title="contract_body/function_definition">function devestAndClaim(<span class="marker" id="mapping-322"></span><span class="token add" data-title="function_definition/parameter">address _itemToken</span>, <span class="marker" id="mapping-323"></span><span class="token add" data-title="function_definition/parameter">uint256 _tokenId</span>, <span class="marker" id="mapping-324"></span><span class="token add" data-title="function_definition/parameter">uint256 _index</span>) <span class="marker" id="mapping-325"></span><span class="token mv" id="move-dst-101" data-title="function_definition/visibility">public</span> <span class="marker" id="mapping-326"></span><span class="token add" data-title="function_definition/function_body">{
		<span class="marker" id="mapping-327"></span><span class="token add" data-title="function_body/expression_statement"><span class="marker" id="mapping-328"></span><span class="token add" data-title="expression_statement/call_expression">divest(<span class="marker" id="mapping-329"></span><span class="token mv" id="move-dst-116" data-title="call_expression/call_argument">_tokenId</span>, <span class="marker" id="mapping-330"></span><span class="token mv" id="move-dst-117" data-title="call_expression/call_argument">_index</span>)</span>;</span>
		<span class="marker" id="mapping-331"></span><span class="token add" data-title="function_body/expression_statement">claimItemResource(_itemToken, _tokenId);</span>
    	}</span></span>

	<span class="marker" id="mapping-332"></span><span class="token add" data-title="contract_body/comment">/**
        @dev Divest function, A NFT can Divest from EVO Bar (LandBar or ApostleBar).
        @param _tokenId Token Id which to be unquiped.
        @param _index   Index of the Bar.
    	*/</span>
	function divest(uint256 _tokenId, uint256 _index) public {
		_divest(_tokenId, _index);
	}

	function _divest(uint256 _tokenId, uint256 _index) internal {
		Bar memory bar = landId2Bars[_tokenId][_index];
		require(bar.token != address(0), "Furnace: EMPTY");
		require(bar.staker == msg.sender, "Furnace: FORBIDDEN");
		ERC721(bar.token).transferFrom(address(this), bar.staker, bar.id);
		afterDivested(_index, _tokenId, bar.resource);
		//clean
		delete itemId2Status[bar.token][bar.id];
		delete landId2Bars[_tokenId][_index];
		emit Divest(
			_tokenId,
			bar.resource,
			_index,
			bar.staker,
			bar.token,
			bar.id
		);
	}

	function setMaxAmount(uint256 _maxAmount) public auth {
        require(_maxAmount &gt; maxAmount, "Furnace: INVALID_MAXAMOUNT");
        maxAmount = _maxAmount;
        <span class="marker" id="mapping-333"></span><span class="token add" data-title="function_body/emit_statement">emit SetMaxLandBar(maxAmount);</span>
	}

	function enhanceStrengthRateByIndex(
		address _resource,
		uint256 _tokenId,
		uint256 _index
	) public view returns (uint256) {
		Bar storage bar = landId2Bars[_tokenId][_index];
		if (bar.token == address(0)) {
			return 0;
		}
		IMetaDataTeller teller =
			IMetaDataTeller(registry.addressOf(CONTRACT_METADATA_TELLER));
		uint256 resourceId =
			<span class="marker" id="mapping-334"></span><span class="token upd" id="move-dst-122" data-title="call_expression/identifier"><span class="cupd">ILandBase</span>Ext</span>(registry.addressOf(CONTRACT_LAND_BASE))
				.resourceToken2RateAttrId(_resource);
		return teller.getRate(bar.token, bar.id, resourceId);
	}

	function enhanceStrengthRateOf(address _resource, uint256 _tokenId)
		external
		view
		returns (uint256)
	{
		uint256 rate;
		for (uint256 i = 0; i &lt; maxAmount; i++) {
			rate = rate.add(enhanceStrengthRateByIndex(_resource, _tokenId, i));
		}
		return rate;
	}
}</pre></div></div></div></body></html>