<html lang="en"><head><meta charset="utf8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>GumTree</title><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css"><style type="text/css">/*
 * This file is part of GumTree.
 *
 * GumTree is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * GumTree is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with GumTree.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Copyright 2011-2015 Jean-Rémy Falleri <jr.falleri@gmail.com>
 * Copyright 2011-2015 Floréal Morandat <florealm@gmail.com>
 */

.add {
	border: 1px solid black;
	background-color: MediumSeaGreen;
}

.del {
	border: 1px solid black;
	background-color: IndianRed;
}

.mv {
	border: 1px solid black;
	background-color: Plum;
}

.upd {
	border: 1px solid black;
	background-color: DarkOrange;
	font-weight: bold;
}

.cupd {
	font-weight: normal;
	color: DimGray;
}

.selected {
	background-color: Gold;
}

.marker {
	margin: 0;
	padding: 0;
}

div {
	margin: 0px;
	padding: 0px;
}

.pre-scrollable {
	margin: 0px;
	padding: 0px;
	font-size: 10pt;
	color: black;
	max-height: 90vh;
	background-color: white;
	border: 1px solid black;
	font-family: "Hack, Inconsolata", "Consolas", "Liberation Sans Regular", "DejaVu Sans Mono", monospace;
}

.tooltip-inner {
    max-width: none;
}
</style><script type="text/javascript" src="https://code.jquery.com/jquery-3.4.1.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/js/bootstrap.bundle.min.js"></script><script type="text/javascript">/*
 * This file is part of GumTree.
 *
 * GumTree is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * GumTree is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with GumTree.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Copyright 2011-2015 Jean-Rémy Falleri <jr.falleri@gmail.com>
 * Copyright 2011-2015 Floréal Morandat <florealm@gmail.com>
 */

$(function(){
    let popoverTriggerList = [].slice.call(document.querySelectorAll('[data-bs-toggle="popover"]'))
    let popoverList = popoverTriggerList.map(function (popoverTriggerEl) {
      return new bootstrap.Popover(popoverTriggerEl)
    })

    $("body").keypress(function (event) {
        switch (event.which) {
            case 116:
                $('html, body').animate({scrollTop: 0}, 100);
                break;
            case 98:
                $("html, body").animate({ scrollTop: $(document).height() }, 100);
                break;
            case 113:
                window.location = "/quit";
                break;
            case 108:
                window.location = "/list";
                break;
        }
    });
});
</script><script type="text/javascript">/*
 * This file is part of GumTree.
 *
 * GumTree is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * GumTree is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with GumTree.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Copyright 2011-2015 Jean-Rémy Falleri <jr.falleri@gmail.com>
 * Copyright 2011-2015 Floréal Morandat <florealm@gmail.com>
 */

currentMapping = 0;

if (typeof String.prototype.startsWith != 'function') {
  String.prototype.startsWith = function (str){
    return this.slice(0, str.length) == str;
  };
}

function getMappedElement(eltId) {
	if (eltId.startsWith("move-src")) {
		return eltId.replace("src","dst");  	 	
  	}
  	else {
  		return eltId.replace("dst","src");
  	}
}

function nextMapping() {
	if (currentMapping == 0) {
		currentMapping = 1;
		return "#mapping-" + currentMapping.toString();
	} else {
		currentMapping++;
		
		if ($("#mapping-" + currentMapping.toString()).length > 0) {
			return "#mapping-" + currentMapping.toString();
		} else {
			currentMapping = 1;
			return "#mapping-" + currentMapping.toString();		
		}		
	}
}

function isSrc(eltId) {
	return eltId.startsWith("move-src");
}

$(function() {
    $("body").keypress(function (event) {
        switch(event.which) {
            case 110:
                const mapping = $(nextMapping());
                const pre = mapping.closest("pre");
                pre.animate({scrollTop: pre.scrollTop() + mapping.position().top - 200}, 100);
                break;
        }
    });

    // highlight
    $("span.mv.token, span.token.upd").click(function(event) {
        if ($(this).hasClass("selected")) {
            $("span.mv.token, span.token.upd").removeClass("selected");
        } else {
            $("span.mv.token, span.token.upd").removeClass("selected");
            const refElt = $("#" + getMappedElement($(this).attr("id")));
            $(this).addClass("selected");
            refElt.addClass("selected");
            const pre = refElt.closest("pre");
            console.log(pre);
            pre.animate({scrollTop: pre.scrollTop() + refElt.position().top - 200}, 100);
        }
        event.stopPropagation();
    });
    
    $("span.add.token, span.token.del").click(function(event) {
        $("span.mv.token, span.token.upd").removeClass("selected");
        event.stopPropagation();
    });

    // tooltip
    $("span.token").hover(
    	function (event) {
    		$(this).tooltip('show');
    		event.stopPropagation();
    	},
    	function (event) {
    		$(this).tooltip('hide');
    		event.stopPropagation();
    	}
    );
});
</script></head><body><div class="container-fluid"><div class="row"><div class="col"><div class="btn-toolbar justify-content-end"><div class="btn-group mr-2"><button class="btn btn-primary btn-sm" id="legend" data-bs-toggle="popover" data-bs-placement="bottom" data-bs-html="true" data-bs-content="<span class='del'>&nbsp;&nbsp;</span> deleted<br><span class='add'>&nbsp;&nbsp;</span> added<br><span class='mv'>&nbsp;&nbsp;</span> moved<br><span class='upd';>&nbsp;&nbsp;</span> updated<br>">Legend</button><button class="btn btn-primary btn-sm" id="shortcuts" data-bs-toggle="popover" data-bs-placement="bottom" data-bs-html="true" data-bs-content="<b>q</b> quit<br><b>l</b> list<br><b>n</b> next<br><b>t</b> top<br><b>b</b> bottom">Shortcuts</button></div><div class="btn-group"><a href="/list" class="btn btn-default btn-sm btn-primary">Back</a><a href="/quit" class="btn btn-default btn-sm btn-danger">Quit</a></div></div></div></div><div class="row"><div class="col-6"><h5>CallProxy.sol</h5><pre class="pre-scrollable">/*
  Copyright 2019-2021 StarkWare Industries Ltd.

  Licensed under the Apache License, Version 2.0 (the "License").
  You may not use this file except in compliance with the License.
  You may obtain a copy of the License at

  https://www.starkware.co/open-source-license/

  Unless required by applicable law or agreed to in writing,
  software distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions
  and limitations under the License.
*/
// SPDX-License-Identifier: Apache-2.0.
pragma solidity ^0.6.11;

import "IFactRegistry.sol";
import "StorageSlots.sol";
import "BlockDirectCall.sol";
import "Common.sol";

/**
  CallProxy is a 'call' based proxy.
  It is a facade to a real implementation,
  only that unlike the Proxy pattern, it uses call and not delegatecall,
  so that the state is recorded on the called contract.

  This contract is expected to be placed behind the regular proxy,
  thus:
  1. Implementation address is stored in a hashed slot (other than proxy's one...).
  2. No state variable is allowed in low address ranges.
  3. Setting of implementation is done in initialize.
  4. isFrozen and initialize are implemented, to be compliant with Proxy.

  This implementation is intentionally minimal,
  and has no management or governance.
  The assumption is that if a different implementation is needed, it will be performed
  in an upgradeTo a new deployed CallProxy, pointing to a new implementation.
*/
contract CallProxy is BlockDirectCall, StorageSlots {

    using Addresses for address;

    string public constant CALL_PROXY_VERSION = "3.0.0";

    // Proxy client - initialize &amp; isFrozen.
    function isFrozen() public pure returns(bool) {
        return false;
    }

    function initialize(bytes calldata data) external notCalledDirectly {
        require(<span class="marker" id="mapping-1"></span><span class="token mv" id="move-src-1" data-title="call_argument/binary_expression">data.length == 32</span>, "INCORRECT_DATA_SIZE");
        address impl = abi.decode(data, (address));
        require(impl.isContract(), "ADDRESS_NOT_CONTRACT");
        setCallProxyImplementation(impl);
    }

    /*
      Returns the call proxy implementation address.
    */
    function callProxyImplementation() public view returns (address _implementation) {
        bytes32 slot = CALL_PROXY_IMPL_SLOT;
        assembly {
            _implementation := sload(slot)
        }
    }

    /*
      Sets the call proxy implementation address.
    */
    function setCallProxyImplementation(address newImplementation) private {
        bytes32 slot = CALL_PROXY_IMPL_SLOT;
        assembly {
            sstore(slot, newImplementation)
        }
    }

    /*
      An explicit isValid entry point, used to make isValid a part of the ABI and visible
      on Etherscan (and alike).
    */
    function isValid(bytes32 fact)
        external view
        returns(bool)
    {
        return IFactRegistry(callProxyImplementation()).isValid(fact);
    }

    /*
      This entry point serves only transactions with empty calldata. (i.e. pure value transfer tx).
      We don't expect to receive such, thus block them.
    */
    receive() external payable {
        revert("CONTRACT_NOT_EXPECTED_TO_RECEIVE");
    }

    /*
      Contract's default function. Pass execution to the implementation contract (using call).
      It returns back to the external caller whatever the implementation called code returns.
    */
    fallback() external payable { 
        address _implementation = callProxyImplementation();
        require(_implementation != address(0x0), "MISSING_IMPLEMENTATION");
        uint256 value = msg.value;
        assembly {
            // Copy msg.data. We take full control of memory in this inline assembly
            // block because it will not return to Solidity code. We overwrite the
            // Solidity scratch pad at memory position 0.
            calldatacopy(0, 0, calldatasize())

            // Call the implementation.
            // out and outsize are 0 for now, as we don't know the out size yet.
            let result := call(gas(), _implementation, value, 0, calldatasize(), 0, 0)

            // Copy the returned data.
            returndatacopy(0, 0, returndatasize())

            switch result
                // delegatecall returns 0 on error.
                case 0 {
                    revert(0, returndatasize())
                }
                default {
                    return(0, returndatasize())
                }
        }
    }
}
</pre></div><div class="col-6"><h5>CallProxy.sol</h5><pre class="pre-scrollable">/*
  Copyright 2019-2021 StarkWare Industries Ltd.

  Licensed under the Apache License, Version 2.0 (the "License").
  You may not use this file except in compliance with the License.
  You may obtain a copy of the License at

  https://www.starkware.co/open-source-license/

  Unless required by applicable law or agreed to in writing,
  software distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions
  and limitations under the License.
*/
// SPDX-License-Identifier: Apache-2.0.
pragma solidity ^0.6.11;

import "IFactRegistry.sol";
import "StorageSlots.sol";
import "BlockDirectCall.sol";
import "Common.sol";

/**
  CallProxy is a 'call' based proxy.
  It is a facade to a real implementation,
  only that unlike the Proxy pattern, it uses call and not delegatecall,
  so that the state is recorded on the called contract.

  This contract is expected to be placed behind the regular proxy,
  thus:
  1. Implementation address is stored in a hashed slot (other than proxy's one...).
  2. No state variable is allowed in low address ranges.
  3. Setting of implementation is done in initialize.
  4. isFrozen and initialize are implemented, to be compliant with Proxy.

  This implementation is intentionally minimal,
  and has no management or governance.
  The assumption is that if a different implementation is needed, it will be performed
  in an upgradeTo a new deployed CallProxy, pointing to a new implementation.
*/
<span class="marker" id="mapping-2"></span><span class="token add" data-title="source_file/comment">// NOLINTNEXTLINE locked-ether.</span>
contract CallProxy is BlockDirectCall, StorageSlots {
    using Addresses for address;

    string public constant CALL_PROXY_VERSION = "3.1.0";

    // Proxy client - initialize &amp; isFrozen.
    <span class="marker" id="mapping-3"></span><span class="token add" data-title="contract_body/comment">// NOLINTNEXTLINE: external-function.</span>
    function isFrozen() public pure returns (bool) {
        return false;
    }

    <span class="marker" id="mapping-4"></span><span class="token add" data-title="contract_body/comment">/*
      Proxy calls the function initialize upon activating an implementation.
      In the context of the CallProxy contract, the mainstream operation of
      initialize is to extract the real implementation from the passed call data,
      and to save it in the CallProxyImplementation slot.

      However, in a case of EIC flow,
      The implementation address is set, as in the normal flow, and then the
      EIC initialize() function is called with the remaining data.

      Case I (no EIC):
        [0 .. 31] implementation address

      Case II (EIC):
        data length &gt;= 64
        [0  .. 31] implementation address
        [32 .. 63] EIC address
        [64 -    ] EIC init data.
    */</span>
    function initialize(bytes calldata data) external notCalledDirectly {
        require(<span class="marker" id="mapping-5"></span><span class="token add" data-title="call_argument/binary_expression"><span class="marker" id="mapping-6"></span><span class="token add" data-title="binary_expression/member_expression"><span class="marker" id="mapping-7"></span><span class="token add" data-title="member_expression/binary_expression"><span class="marker" id="mapping-8"></span><span class="token mv" id="move-dst-1" data-title="binary_expression/binary_expression">data.length == 32</span> || data</span>.length</span> &gt;= 64</span>, "INCORRECT_DATA_SIZE");
        address impl = abi.decode(data, (address));
        require(impl.isContract(), "ADDRESS_NOT_CONTRACT");
        setCallProxyImplementation(impl);
        <span class="marker" id="mapping-9"></span><span class="token add" data-title="function_body/if_statement">if (data.length &gt;= 64) {
            address eic = abi.decode(data[32:64], (address));
            if (eic != address(0x0)) {
                callExternalInitializer(eic, data[64:]);
            }
        }</span>
    }

    <span class="marker" id="mapping-10"></span><span class="token add" data-title="contract_body/function_definition">function callExternalInitializer(address externalInitializerAddr, bytes calldata eicData)
        private
    {
        require(externalInitializerAddr.isContract(), "EIC_NOT_A_CONTRACT");

        // NOLINTNEXTLINE: low-level-calls, controlled-delegatecall.
        (bool success, bytes memory returndata) = externalInitializerAddr.delegatecall(
            abi.encodeWithSelector(this.initialize.selector, eicData)
        );
        require(success, string(returndata));
        require(returndata.length == 0, string(returndata));
    }</span>

    /*
      Returns the call proxy implementation address.
    */
    function callProxyImplementation() public view returns (address _implementation) {
        bytes32 slot = CALL_PROXY_IMPL_SLOT;
        assembly {
            _implementation := sload(slot)
        }
    }

    /*
      Sets the call proxy implementation address.
    */
    function setCallProxyImplementation(address newImplementation) private {
        bytes32 slot = CALL_PROXY_IMPL_SLOT;
        assembly {
            sstore(slot, newImplementation)
        }
    }

    /*
      An explicit isValid entry point, used to make isValid a part of the ABI and visible
      on Etherscan (and alike).
    */
    function isValid(bytes32 fact) external view returns (bool) {
        return IFactRegistry(callProxyImplementation()).isValid(fact);
    }

    /*
      This entry point serves only transactions with empty calldata. (i.e. pure value transfer tx).
      We don't expect to receive such, thus block them.
    */
    receive() external payable {
        revert("CONTRACT_NOT_EXPECTED_TO_RECEIVE");
    }

    /*
      Contract's default function. Pass execution to the implementation contract (using call).
      It returns back to the external caller whatever the implementation called code returns.
    */
    fallback() external payable {
        <span class="marker" id="mapping-11"></span><span class="token add" data-title="function_body/comment">// NOLINT locked-ether.</span>
        address _implementation = callProxyImplementation();
        require(_implementation != address(0x0), "MISSING_IMPLEMENTATION");
        uint256 value = msg.value;
        assembly {
            // Copy msg.data. We take full control of memory in this inline assembly
            // block because it will not return to Solidity code. We overwrite the
            // Solidity scratch pad at memory position 0.
            calldatacopy(0, 0, calldatasize())

            // Call the implementation.
            // out and outsize are 0 for now, as we don't know the out size yet.
            let result := call(gas(), _implementation, value, 0, calldatasize(), 0, 0)

            // Copy the returned data.
            returndatacopy(0, 0, returndatasize())

            switch result
            // delegatecall returns 0 on error.
            case 0 {
                revert(0, returndatasize())
            }
            default {
                return(0, returndatasize())
            }
        }
    }
}
</pre></div></div></div></body></html>